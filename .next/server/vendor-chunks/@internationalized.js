"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@internationalized";
exports.ids = ["vendor-chunks/@internationalized"];
exports.modules = {

/***/ "(ssr)/./node_modules/@internationalized/date/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@internationalized/date/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BuddhistCalendar: () => (/* binding */ $8d73d47422ca7302$export$42d20a78301dee44),\n/* harmony export */   CalendarDate: () => (/* binding */ $35ea8db9cb2ccb90$export$99faa760c7908e4f),\n/* harmony export */   CalendarDateTime: () => (/* binding */ $35ea8db9cb2ccb90$export$ca871e8dbb80966f),\n/* harmony export */   CopticCalendar: () => (/* binding */ $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1),\n/* harmony export */   DateFormatter: () => (/* binding */ $fb18d541ea1ad717$export$ad991b66133851cf),\n/* harmony export */   EthiopicAmeteAlemCalendar: () => (/* binding */ $b956b2d7a6cf451f$export$d72e0c37005a4914),\n/* harmony export */   EthiopicCalendar: () => (/* binding */ $b956b2d7a6cf451f$export$26ba6eab5e20cd7d),\n/* harmony export */   GregorianCalendar: () => (/* binding */ $3b62074eb05584b2$export$80ee6245ec4f29ec),\n/* harmony export */   HebrewCalendar: () => (/* binding */ $7c5f6fbf42389787$export$ca405048b8fb5af),\n/* harmony export */   IndianCalendar: () => (/* binding */ $82c358003bdda0a8$export$39f31c639fa15726),\n/* harmony export */   IslamicCivilCalendar: () => (/* binding */ $f2f3e0e3a817edbd$export$2066795aadd37bfc),\n/* harmony export */   IslamicTabularCalendar: () => (/* binding */ $f2f3e0e3a817edbd$export$37f0887f2f9d22f7),\n/* harmony export */   IslamicUmalquraCalendar: () => (/* binding */ $f2f3e0e3a817edbd$export$5baab4758c231076),\n/* harmony export */   JapaneseCalendar: () => (/* binding */ $62225008020f0a13$export$b746ab2b60cdffbf),\n/* harmony export */   PersianCalendar: () => (/* binding */ $f3ed2e4472ae7e25$export$37fccdbfd14c5939),\n/* harmony export */   TaiwanCalendar: () => (/* binding */ $5f31bd6f0c8940b2$export$65e01080afcb0799),\n/* harmony export */   Time: () => (/* binding */ $35ea8db9cb2ccb90$export$680ea196effce5f),\n/* harmony export */   ZonedDateTime: () => (/* binding */ $35ea8db9cb2ccb90$export$d3b7288e7994edea),\n/* harmony export */   createCalendar: () => (/* binding */ $64244302c3013299$export$dd0bbc9b26defe37),\n/* harmony export */   endOfMonth: () => (/* binding */ $14e0f24ef4ac5c92$export$a2258d9c4118825c),\n/* harmony export */   endOfWeek: () => (/* binding */ $14e0f24ef4ac5c92$export$ef8b6d9133084f4e),\n/* harmony export */   endOfYear: () => (/* binding */ $14e0f24ef4ac5c92$export$8b7aa55c66d5569e),\n/* harmony export */   fromAbsolute: () => (/* binding */ $11d87f3f76e88657$export$1b96692a1ba042ac),\n/* harmony export */   fromDate: () => (/* binding */ $11d87f3f76e88657$export$e57ff100d91bd4b9),\n/* harmony export */   getDayOfWeek: () => (/* binding */ $14e0f24ef4ac5c92$export$2061056d06d7cdf7),\n/* harmony export */   getHoursInDay: () => (/* binding */ $14e0f24ef4ac5c92$export$126c91c941de7e),\n/* harmony export */   getLocalTimeZone: () => (/* binding */ $14e0f24ef4ac5c92$export$aa8b41735afcabd2),\n/* harmony export */   getMinimumDayInMonth: () => (/* binding */ $14e0f24ef4ac5c92$export$b2f4953d301981d5),\n/* harmony export */   getMinimumMonthInYear: () => (/* binding */ $14e0f24ef4ac5c92$export$5412ac11713b72ad),\n/* harmony export */   getWeeksInMonth: () => (/* binding */ $14e0f24ef4ac5c92$export$ccc1b2479e7dd654),\n/* harmony export */   isEqualDay: () => (/* binding */ $14e0f24ef4ac5c92$export$91b62ebf2ba703ee),\n/* harmony export */   isEqualMonth: () => (/* binding */ $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2),\n/* harmony export */   isEqualYear: () => (/* binding */ $14e0f24ef4ac5c92$export$ea840f5a6dda8147),\n/* harmony export */   isSameDay: () => (/* binding */ $14e0f24ef4ac5c92$export$ea39ec197993aef0),\n/* harmony export */   isSameMonth: () => (/* binding */ $14e0f24ef4ac5c92$export$a18c89cbd24170ff),\n/* harmony export */   isSameYear: () => (/* binding */ $14e0f24ef4ac5c92$export$5841f9eb9773f25f),\n/* harmony export */   isToday: () => (/* binding */ $14e0f24ef4ac5c92$export$629b0a497aa65267),\n/* harmony export */   isWeekday: () => (/* binding */ $14e0f24ef4ac5c92$export$ee9d87258e1d19ed),\n/* harmony export */   isWeekend: () => (/* binding */ $14e0f24ef4ac5c92$export$618d60ea299da42),\n/* harmony export */   maxDate: () => (/* binding */ $14e0f24ef4ac5c92$export$a75f2bff57811055),\n/* harmony export */   minDate: () => (/* binding */ $14e0f24ef4ac5c92$export$5c333a116e949cdd),\n/* harmony export */   now: () => (/* binding */ $14e0f24ef4ac5c92$export$461939dd4422153),\n/* harmony export */   parseAbsolute: () => (/* binding */ $fae977aafc393c5c$export$5adfdab05168c219),\n/* harmony export */   parseAbsoluteToLocal: () => (/* binding */ $fae977aafc393c5c$export$8e384432362ed0f0),\n/* harmony export */   parseDate: () => (/* binding */ $fae977aafc393c5c$export$6b862160d295c8e),\n/* harmony export */   parseDateTime: () => (/* binding */ $fae977aafc393c5c$export$588937bcd60ade55),\n/* harmony export */   parseDuration: () => (/* binding */ $fae977aafc393c5c$export$ecae829bb3747ea6),\n/* harmony export */   parseTime: () => (/* binding */ $fae977aafc393c5c$export$c9698ec7f05a07e1),\n/* harmony export */   parseZonedDateTime: () => (/* binding */ $fae977aafc393c5c$export$fd7893f06e92a6a4),\n/* harmony export */   startOfMonth: () => (/* binding */ $14e0f24ef4ac5c92$export$a5a3b454ada2268e),\n/* harmony export */   startOfWeek: () => (/* binding */ $14e0f24ef4ac5c92$export$42c81a444fbfb5d4),\n/* harmony export */   startOfYear: () => (/* binding */ $14e0f24ef4ac5c92$export$f91e89d3d0406102),\n/* harmony export */   toCalendar: () => (/* binding */ $11d87f3f76e88657$export$b4a036af3fc0b032),\n/* harmony export */   toCalendarDate: () => (/* binding */ $11d87f3f76e88657$export$93522d1a439f3617),\n/* harmony export */   toCalendarDateTime: () => (/* binding */ $11d87f3f76e88657$export$b21e0b124e224484),\n/* harmony export */   toLocalTimeZone: () => (/* binding */ $11d87f3f76e88657$export$d9b67bc93c097491),\n/* harmony export */   toTime: () => (/* binding */ $11d87f3f76e88657$export$d33f79e3ffc3dc83),\n/* harmony export */   toTimeZone: () => (/* binding */ $11d87f3f76e88657$export$538b00033cc11c75),\n/* harmony export */   toZoned: () => (/* binding */ $11d87f3f76e88657$export$84c95a83c799e074),\n/* harmony export */   today: () => (/* binding */ $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(ssr)/./node_modules/next/node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from ICU.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $2b4dce13dd5a17fa$export$842a2cf37af977e1(amount, numerator) {\n    return amount - numerator * Math.floor(amount / numerator);\n}\nfunction $2b4dce13dd5a17fa$export$784d13d8ee351f07(date) {\n    if (date.era) return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(date.calendar, date.era, date.year, date.month, date.day);\n    else return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(date.calendar, date.year, date.month, date.day);\n}\nfunction $2b4dce13dd5a17fa$export$27fa0172ae2644b3(date) {\n    if (date.era) return new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);\n    else return new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.year, date.month, date.day, date.hour, date.minute, date.second);\n}\n\n\nconst $3b62074eb05584b2$var$EPOCH = 1721426; // 001/01/03 Julian C.E.\nfunction $3b62074eb05584b2$export$f297eb839006d339(era, year, month, day) {\n    year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year);\n    let y1 = year - 1;\n    let monthOffset = -2;\n    if (month <= 2) monthOffset = 0;\n    else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) monthOffset = -1;\n    return $3b62074eb05584b2$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);\n}\nfunction $3b62074eb05584b2$export$553d7fa8e3805fc0(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\nfunction $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year) {\n    return era === \"BC\" ? 1 - year : year;\n}\nfunction $3b62074eb05584b2$export$4475b7e617eb123c(year) {\n    let era = \"AD\";\n    if (year <= 0) {\n        era = \"BC\";\n        year = 1 - year;\n    }\n    return [\n        era,\n        year\n    ];\n}\nconst $3b62074eb05584b2$var$daysInMonth = {\n    standard: [\n        31,\n        28,\n        31,\n        30,\n        31,\n        30,\n        31,\n        31,\n        30,\n        31,\n        30,\n        31\n    ],\n    leapyear: [\n        31,\n        29,\n        31,\n        30,\n        31,\n        30,\n        31,\n        31,\n        30,\n        31,\n        30,\n        31\n    ]\n};\nclass $3b62074eb05584b2$export$80ee6245ec4f29ec {\n    fromJulianDay(jd) {\n        let jd0 = jd;\n        let depoch = jd0 - $3b62074eb05584b2$var$EPOCH;\n        let quadricent = Math.floor(depoch / 146097);\n        let dqc = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(depoch, 146097);\n        let cent = Math.floor(dqc / 36524);\n        let dcent = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dqc, 36524);\n        let quad = Math.floor(dcent / 1461);\n        let dquad = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dcent, 1461);\n        let yindex = Math.floor(dquad / 365);\n        let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);\n        let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(extendedYear);\n        let yearDay = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, 1, 1);\n        let leapAdj = 2;\n        if (jd0 < $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 1)) leapAdj = 0;\n        else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) leapAdj = 1;\n        let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);\n        let day = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, month, 1) + 1;\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, month, day);\n    }\n    toJulianDay(date) {\n        return $3b62074eb05584b2$export$f297eb839006d339(date.era, date.year, date.month, date.day);\n    }\n    getDaysInMonth(date) {\n        return $3b62074eb05584b2$var$daysInMonth[$3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? \"leapyear\" : \"standard\"][date.month - 1];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getMonthsInYear(date) {\n        return 12;\n    }\n    getDaysInYear(date) {\n        return $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? 366 : 365;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getYearsInEra(date) {\n        return 9999;\n    }\n    getEras() {\n        return [\n            \"BC\",\n            \"AD\"\n        ];\n    }\n    isInverseEra(date) {\n        return date.era === \"BC\";\n    }\n    balanceDate(date) {\n        if (date.year <= 0) {\n            date.era = date.era === \"BC\" ? \"AD\" : \"BC\";\n            date.year = 1 - date.year;\n        }\n    }\n    constructor(){\n        this.identifier = \"gregory\";\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Data from https://github.com/unicode-cldr/cldr-core/blob/master/supplemental/weekData.json\n// Locales starting on Sunday have been removed for compression.\nconst $2fe286d2fb449abb$export$7a5acbd77d414bd9 = {\n    \"001\": 1,\n    AD: 1,\n    AE: 6,\n    AF: 6,\n    AI: 1,\n    AL: 1,\n    AM: 1,\n    AN: 1,\n    AR: 1,\n    AT: 1,\n    AU: 1,\n    AX: 1,\n    AZ: 1,\n    BA: 1,\n    BE: 1,\n    BG: 1,\n    BH: 6,\n    BM: 1,\n    BN: 1,\n    BY: 1,\n    CH: 1,\n    CL: 1,\n    CM: 1,\n    CN: 1,\n    CR: 1,\n    CY: 1,\n    CZ: 1,\n    DE: 1,\n    DJ: 6,\n    DK: 1,\n    DZ: 6,\n    EC: 1,\n    EE: 1,\n    EG: 6,\n    ES: 1,\n    FI: 1,\n    FJ: 1,\n    FO: 1,\n    FR: 1,\n    GB: 1,\n    GE: 1,\n    GF: 1,\n    GP: 1,\n    GR: 1,\n    HR: 1,\n    HU: 1,\n    IE: 1,\n    IQ: 6,\n    IR: 6,\n    IS: 1,\n    IT: 1,\n    JO: 6,\n    KG: 1,\n    KW: 6,\n    KZ: 1,\n    LB: 1,\n    LI: 1,\n    LK: 1,\n    LT: 1,\n    LU: 1,\n    LV: 1,\n    LY: 6,\n    MC: 1,\n    MD: 1,\n    ME: 1,\n    MK: 1,\n    MN: 1,\n    MQ: 1,\n    MV: 5,\n    MY: 1,\n    NL: 1,\n    NO: 1,\n    NZ: 1,\n    OM: 6,\n    PL: 1,\n    QA: 6,\n    RE: 1,\n    RO: 1,\n    RS: 1,\n    RU: 1,\n    SD: 6,\n    SE: 1,\n    SI: 1,\n    SK: 1,\n    SM: 1,\n    SY: 6,\n    TJ: 1,\n    TM: 1,\n    TR: 1,\n    UA: 1,\n    UY: 1,\n    UZ: 1,\n    VA: 1,\n    VN: 1,\n    XK: 1\n};\n\n\nfunction $14e0f24ef4ac5c92$export$ea39ec197993aef0(a, b) {\n    b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);\n    return a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;\n}\nfunction $14e0f24ef4ac5c92$export$a18c89cbd24170ff(a, b) {\n    b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);\n    // In the Japanese calendar, months can span multiple eras/years, so only compare the first of the month.\n    a = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(a);\n    b = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(b);\n    return a.era === b.era && a.year === b.year && a.month === b.month;\n}\nfunction $14e0f24ef4ac5c92$export$5841f9eb9773f25f(a, b) {\n    b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);\n    a = $14e0f24ef4ac5c92$export$f91e89d3d0406102(a);\n    b = $14e0f24ef4ac5c92$export$f91e89d3d0406102(b);\n    return a.era === b.era && a.year === b.year;\n}\nfunction $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(a, b) {\n    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;\n}\nfunction $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(a, b) {\n    a = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(a);\n    b = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(b);\n    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year && a.month === b.month;\n}\nfunction $14e0f24ef4ac5c92$export$ea840f5a6dda8147(a, b) {\n    a = $14e0f24ef4ac5c92$export$f91e89d3d0406102(a);\n    b = $14e0f24ef4ac5c92$export$f91e89d3d0406102(b);\n    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year;\n}\nfunction $14e0f24ef4ac5c92$export$629b0a497aa65267(date, timeZone) {\n    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));\n}\nfunction $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale) {\n    let julian = date.calendar.toJulianDay(date);\n    // If julian is negative, then julian % 7 will be negative, so we adjust\n    // accordingly.  Julian day 0 is Monday.\n    let dayOfWeek = Math.ceil(julian + 1 - $14e0f24ef4ac5c92$var$getWeekStart(locale)) % 7;\n    if (dayOfWeek < 0) dayOfWeek += 7;\n    return dayOfWeek;\n}\nfunction $14e0f24ef4ac5c92$export$461939dd4422153(timeZone) {\n    return (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(Date.now(), timeZone);\n}\nfunction $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone) {\n    return (0, $11d87f3f76e88657$export$93522d1a439f3617)($14e0f24ef4ac5c92$export$461939dd4422153(timeZone));\n}\nfunction $14e0f24ef4ac5c92$export$68781ddf31c0090f(a, b) {\n    return a.calendar.toJulianDay(a) - b.calendar.toJulianDay(b);\n}\nfunction $14e0f24ef4ac5c92$export$c19a80a9721b80f6(a, b) {\n    return $14e0f24ef4ac5c92$var$timeToMs(a) - $14e0f24ef4ac5c92$var$timeToMs(b);\n}\nfunction $14e0f24ef4ac5c92$var$timeToMs(a) {\n    return a.hour * 3600000 + a.minute * 60000 + a.second * 1000 + a.millisecond;\n}\nfunction $14e0f24ef4ac5c92$export$126c91c941de7e(a, timeZone) {\n    let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(a, timeZone);\n    let tomorrow = a.add({\n        days: 1\n    });\n    let tomorrowMs = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(tomorrow, timeZone);\n    return (tomorrowMs - ms) / 3600000;\n}\nlet $14e0f24ef4ac5c92$var$localTimeZone = null;\nfunction $14e0f24ef4ac5c92$export$aa8b41735afcabd2() {\n    // TODO: invalidate this somehow?\n    if ($14e0f24ef4ac5c92$var$localTimeZone == null) $14e0f24ef4ac5c92$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;\n    return $14e0f24ef4ac5c92$var$localTimeZone;\n}\nfunction $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date) {\n    // Use `subtract` instead of `set` so we don't get constrained in an era.\n    return date.subtract({\n        days: date.day - 1\n    });\n}\nfunction $14e0f24ef4ac5c92$export$a2258d9c4118825c(date) {\n    return date.add({\n        days: date.calendar.getDaysInMonth(date) - date.day\n    });\n}\nfunction $14e0f24ef4ac5c92$export$f91e89d3d0406102(date) {\n    return $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date.subtract({\n        months: date.month - 1\n    }));\n}\nfunction $14e0f24ef4ac5c92$export$8b7aa55c66d5569e(date) {\n    return $14e0f24ef4ac5c92$export$a2258d9c4118825c(date.add({\n        months: date.calendar.getMonthsInYear(date) - date.month\n    }));\n}\nfunction $14e0f24ef4ac5c92$export$5412ac11713b72ad(date) {\n    if (date.calendar.getMinimumMonthInYear) return date.calendar.getMinimumMonthInYear(date);\n    return 1;\n}\nfunction $14e0f24ef4ac5c92$export$b2f4953d301981d5(date) {\n    if (date.calendar.getMinimumDayInMonth) return date.calendar.getMinimumDayInMonth(date);\n    return 1;\n}\nfunction $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale) {\n    let dayOfWeek = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);\n    return date.subtract({\n        days: dayOfWeek\n    });\n}\nfunction $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(date, locale) {\n    return $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale).add({\n        days: 6\n    });\n}\nconst $14e0f24ef4ac5c92$var$cachedRegions = new Map();\nfunction $14e0f24ef4ac5c92$var$getRegion(locale) {\n    // If the Intl.Locale API is available, use it to get the region for the locale.\n    // @ts-ignore\n    if (Intl.Locale) {\n        // Constructing an Intl.Locale is expensive, so cache the result.\n        let region = $14e0f24ef4ac5c92$var$cachedRegions.get(locale);\n        if (!region) {\n            // @ts-ignore\n            region = new Intl.Locale(locale).maximize().region;\n            if (region) $14e0f24ef4ac5c92$var$cachedRegions.set(locale, region);\n        }\n        return region;\n    }\n    // If not, just try splitting the string.\n    // If the second part of the locale string is 'u',\n    // then this is a unicode extension, so ignore it.\n    // Otherwise, it should be the region.\n    let part = locale.split(\"-\")[1];\n    return part === \"u\" ? undefined : part;\n}\nfunction $14e0f24ef4ac5c92$var$getWeekStart(locale) {\n    // TODO: use Intl.Locale for this once browsers support the weekInfo property\n    // https://github.com/tc39/proposal-intl-locale-info\n    let region = $14e0f24ef4ac5c92$var$getRegion(locale);\n    return region ? (0, $2fe286d2fb449abb$export$7a5acbd77d414bd9)[region] || 0 : 0;\n}\nfunction $14e0f24ef4ac5c92$export$ccc1b2479e7dd654(date, locale) {\n    let days = date.calendar.getDaysInMonth(date);\n    return Math.ceil(($14e0f24ef4ac5c92$export$2061056d06d7cdf7($14e0f24ef4ac5c92$export$a5a3b454ada2268e(date), locale) + days) / 7);\n}\nfunction $14e0f24ef4ac5c92$export$5c333a116e949cdd(a, b) {\n    if (a && b) return a.compare(b) <= 0 ? a : b;\n    return a || b;\n}\nfunction $14e0f24ef4ac5c92$export$a75f2bff57811055(a, b) {\n    if (a && b) return a.compare(b) >= 0 ? a : b;\n    return a || b;\n}\nconst $14e0f24ef4ac5c92$var$WEEKEND_DATA = {\n    AF: [\n        4,\n        5\n    ],\n    AE: [\n        5,\n        6\n    ],\n    BH: [\n        5,\n        6\n    ],\n    DZ: [\n        5,\n        6\n    ],\n    EG: [\n        5,\n        6\n    ],\n    IL: [\n        5,\n        6\n    ],\n    IQ: [\n        5,\n        6\n    ],\n    IR: [\n        5,\n        5\n    ],\n    JO: [\n        5,\n        6\n    ],\n    KW: [\n        5,\n        6\n    ],\n    LY: [\n        5,\n        6\n    ],\n    OM: [\n        5,\n        6\n    ],\n    QA: [\n        5,\n        6\n    ],\n    SA: [\n        5,\n        6\n    ],\n    SD: [\n        5,\n        6\n    ],\n    SY: [\n        5,\n        6\n    ],\n    YE: [\n        5,\n        6\n    ]\n};\nfunction $14e0f24ef4ac5c92$export$618d60ea299da42(date, locale) {\n    let julian = date.calendar.toJulianDay(date);\n    // If julian is negative, then julian % 7 will be negative, so we adjust\n    // accordingly.  Julian day 0 is Monday.\n    let dayOfWeek = Math.ceil(julian + 1) % 7;\n    if (dayOfWeek < 0) dayOfWeek += 7;\n    let region = $14e0f24ef4ac5c92$var$getRegion(locale);\n    // Use Intl.Locale for this once weekInfo is supported.\n    // https://github.com/tc39/proposal-intl-locale-info\n    let [start, end] = $14e0f24ef4ac5c92$var$WEEKEND_DATA[region] || [\n        6,\n        0\n    ];\n    return dayOfWeek === start || dayOfWeek === end;\n}\nfunction $14e0f24ef4ac5c92$export$ee9d87258e1d19ed(date, locale) {\n    return !$14e0f24ef4ac5c92$export$618d60ea299da42(date, locale);\n}\n\n\nfunction $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) {\n    date = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\n    let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);\n    return $11d87f3f76e88657$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);\n}\nfunction $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {\n    // Note: Date.UTC() interprets one and two-digit years as being in the\n    // 20th century, so don't use it\n    let date = new Date();\n    date.setUTCHours(hour, minute, second, millisecond);\n    date.setUTCFullYear(year, month - 1, day);\n    return date.getTime();\n}\nfunction $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone) {\n    // Fast path for UTC.\n    if (timeZone === \"UTC\") return 0;\n    // Fast path: for local timezone after 1970, use native Date.\n    if (ms > 0 && timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)()) return new Date(ms).getTimezoneOffset() * -60000;\n    let { year: year, month: month, day: day, hour: hour, minute: minute, second: second } = $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone);\n    let utc = $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, 0);\n    return utc - Math.floor(ms / 1000) * 1000;\n}\nconst $11d87f3f76e88657$var$formattersByTimeZone = new Map();\nfunction $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone) {\n    let formatter = $11d87f3f76e88657$var$formattersByTimeZone.get(timeZone);\n    if (!formatter) {\n        formatter = new Intl.DateTimeFormat(\"en-US\", {\n            timeZone: timeZone,\n            hour12: false,\n            era: \"short\",\n            year: \"numeric\",\n            month: \"numeric\",\n            day: \"numeric\",\n            hour: \"numeric\",\n            minute: \"numeric\",\n            second: \"numeric\"\n        });\n        $11d87f3f76e88657$var$formattersByTimeZone.set(timeZone, formatter);\n    }\n    let parts = formatter.formatToParts(new Date(ms));\n    let namedParts = {};\n    for (let part of parts)if (part.type !== \"literal\") namedParts[part.type] = part.value;\n    return {\n        // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\n        year: namedParts.era === \"BC\" || namedParts.era === \"B\" ? -namedParts.year + 1 : +namedParts.year,\n        month: +namedParts.month,\n        day: +namedParts.day,\n        hour: namedParts.hour === \"24\" ? 0 : +namedParts.hour,\n        minute: +namedParts.minute,\n        second: +namedParts.second\n    };\n}\nconst $11d87f3f76e88657$var$DAYMILLIS = 86400000;\nfunction $11d87f3f76e88657$export$136f38efe7caf549(date, timeZone) {\n    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date);\n    let earlier = ms - $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);\n    let later = ms - $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);\n    return $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later);\n}\nfunction $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later) {\n    let found = earlier === later ? [\n        earlier\n    ] : [\n        earlier,\n        later\n    ];\n    return found.filter((absolute)=>$11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute));\n}\nfunction $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute) {\n    let parts = $11d87f3f76e88657$var$getTimeZoneParts(absolute, timeZone);\n    return date.year === parts.year && date.month === parts.month && date.day === parts.day && date.hour === parts.hour && date.minute === parts.minute && date.second === parts.second;\n}\nfunction $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation = \"compatible\") {\n    let dateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);\n    // Fast path: if the time zone is UTC, use native Date.\n    if (timeZone === \"UTC\") return $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);\n    // Fast path: if the time zone is the local timezone and disambiguation is compatible, use native Date.\n    if (timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)() && disambiguation === \"compatible\") {\n        dateTime = $11d87f3f76e88657$export$b4a036af3fc0b032(dateTime, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\n        // Don't use Date constructor here because two-digit years are interpreted in the 20th century.\n        let date = new Date();\n        let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(dateTime.era, dateTime.year);\n        date.setFullYear(year, dateTime.month - 1, dateTime.day);\n        date.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);\n        return date.getTime();\n    }\n    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);\n    let offsetBefore = $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);\n    let offsetAfter = $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);\n    let valid = $11d87f3f76e88657$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);\n    if (valid.length === 1) return valid[0];\n    if (valid.length > 1) switch(disambiguation){\n        // 'compatible' means 'earlier' for \"fall back\" transitions\n        case \"compatible\":\n        case \"earlier\":\n            return valid[0];\n        case \"later\":\n            return valid[valid.length - 1];\n        case \"reject\":\n            throw new RangeError(\"Multiple possible absolute times found\");\n    }\n    switch(disambiguation){\n        case \"earlier\":\n            return Math.min(ms - offsetBefore, ms - offsetAfter);\n        // 'compatible' means 'later' for \"spring forward\" transitions\n        case \"compatible\":\n        case \"later\":\n            return Math.max(ms - offsetBefore, ms - offsetAfter);\n        case \"reject\":\n            throw new RangeError(\"No such absolute time found\");\n    }\n}\nfunction $11d87f3f76e88657$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = \"compatible\") {\n    return new Date($11d87f3f76e88657$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));\n}\nfunction $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone) {\n    let offset = $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone);\n    let date = new Date(ms + offset);\n    let year = date.getUTCFullYear();\n    let month = date.getUTCMonth() + 1;\n    let day = date.getUTCDate();\n    let hour = date.getUTCHours();\n    let minute = date.getUTCMinutes();\n    let second = date.getUTCSeconds();\n    let millisecond = date.getUTCMilliseconds();\n    return new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)(year, month, day, timeZone, offset, hour, minute, second, millisecond);\n}\nfunction $11d87f3f76e88657$export$e57ff100d91bd4b9(date, timeZone) {\n    return $11d87f3f76e88657$export$1b96692a1ba042ac(date.getTime(), timeZone);\n}\nfunction $11d87f3f76e88657$export$d7f92bcd3596b086(date) {\n    return $11d87f3f76e88657$export$e57ff100d91bd4b9(date, (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)());\n}\nfunction $11d87f3f76e88657$export$93522d1a439f3617(dateTime) {\n    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);\n}\nfunction $11d87f3f76e88657$export$6f4d78149f3f53ac(date) {\n    return {\n        era: date.era,\n        year: date.year,\n        month: date.month,\n        day: date.day\n    };\n}\nfunction $11d87f3f76e88657$export$4d0393e732857be5(date) {\n    return {\n        hour: date.hour,\n        minute: date.minute,\n        second: date.second,\n        millisecond: date.millisecond\n    };\n}\nfunction $11d87f3f76e88657$export$b21e0b124e224484(date, time) {\n    let hour = 0, minute = 0, second = 0, millisecond = 0;\n    if (\"timeZone\" in date) ({ hour: hour, minute: minute, second: second, millisecond: millisecond } = date);\n    else if (\"hour\" in date && !time) return date;\n    if (time) ({ hour: hour, minute: minute, second: second, millisecond: millisecond } = time);\n    return new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);\n}\nfunction $11d87f3f76e88657$export$d33f79e3ffc3dc83(dateTime) {\n    return new (0, $35ea8db9cb2ccb90$export$680ea196effce5f)(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);\n}\nfunction $11d87f3f76e88657$export$b4a036af3fc0b032(date, calendar) {\n    if (date.calendar.identifier === calendar.identifier) return date;\n    let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));\n    let copy = date.copy();\n    copy.calendar = calendar;\n    copy.era = calendarDate.era;\n    copy.year = calendarDate.year;\n    copy.month = calendarDate.month;\n    copy.day = calendarDate.day;\n    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(copy);\n    return copy;\n}\nfunction $11d87f3f76e88657$export$84c95a83c799e074(date, timeZone, disambiguation) {\n    if (date instanceof (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)) {\n        if (date.timeZone === timeZone) return date;\n        return $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone);\n    }\n    let ms = $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation);\n    return $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone);\n}\nfunction $11d87f3f76e88657$export$83aac07b4c37b25(date) {\n    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;\n    return new Date(ms);\n}\nfunction $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone) {\n    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;\n    return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone), date.calendar);\n}\nfunction $11d87f3f76e88657$export$d9b67bc93c097491(date) {\n    return $11d87f3f76e88657$export$538b00033cc11c75(date, (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)());\n}\n\n\n\nconst $735220c2d4774dd3$var$ONE_HOUR = 3600000;\nfunction $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {\n    let mutableDate = date.copy();\n    let days = \"hour\" in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;\n    $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);\n    if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);\n    mutableDate.month += duration.months || 0;\n    $735220c2d4774dd3$var$balanceYearMonth(mutableDate);\n    $735220c2d4774dd3$var$constrainMonthDay(mutableDate);\n    mutableDate.day += (duration.weeks || 0) * 7;\n    mutableDate.day += duration.days || 0;\n    mutableDate.day += days;\n    $735220c2d4774dd3$var$balanceDay(mutableDate);\n    if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);\n    // Constrain in case adding ended up with a date outside the valid range for the calendar system.\n    // The behavior here is slightly different than when constraining in the `set` function in that\n    // we adjust smaller fields to their minimum/maximum values rather than constraining each field\n    // individually. This matches the general behavior of `add` vs `set` regarding how fields are balanced.\n    if (mutableDate.year < 1) {\n        mutableDate.year = 1;\n        mutableDate.month = 1;\n        mutableDate.day = 1;\n    }\n    let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);\n    if (mutableDate.year > maxYear) {\n        var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;\n        let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);\n        mutableDate.year = maxYear;\n        mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);\n        mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);\n    }\n    if (mutableDate.month < 1) {\n        mutableDate.month = 1;\n        mutableDate.day = 1;\n    }\n    let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);\n    if (mutableDate.month > maxMonth) {\n        mutableDate.month = maxMonth;\n        mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);\n    }\n    mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));\n    return mutableDate;\n}\nfunction $735220c2d4774dd3$var$addYears(date, years) {\n    var _date_calendar_isInverseEra, _date_calendar;\n    if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;\n    date.year += years;\n}\nfunction $735220c2d4774dd3$var$balanceYearMonth(date) {\n    while(date.month < 1){\n        $735220c2d4774dd3$var$addYears(date, -1);\n        date.month += date.calendar.getMonthsInYear(date);\n    }\n    let monthsInYear = 0;\n    while(date.month > (monthsInYear = date.calendar.getMonthsInYear(date))){\n        date.month -= monthsInYear;\n        $735220c2d4774dd3$var$addYears(date, 1);\n    }\n}\nfunction $735220c2d4774dd3$var$balanceDay(date) {\n    while(date.day < 1){\n        date.month--;\n        $735220c2d4774dd3$var$balanceYearMonth(date);\n        date.day += date.calendar.getDaysInMonth(date);\n    }\n    while(date.day > date.calendar.getDaysInMonth(date)){\n        date.day -= date.calendar.getDaysInMonth(date);\n        date.month++;\n        $735220c2d4774dd3$var$balanceYearMonth(date);\n    }\n}\nfunction $735220c2d4774dd3$var$constrainMonthDay(date) {\n    date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));\n    date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));\n}\nfunction $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {\n    if (date.calendar.constrainDate) date.calendar.constrainDate(date);\n    date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));\n    $735220c2d4774dd3$var$constrainMonthDay(date);\n}\nfunction $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {\n    let inverseDuration = {};\n    for(let key in duration)if (typeof duration[key] === \"number\") inverseDuration[key] = -duration[key];\n    return inverseDuration;\n}\nfunction $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {\n    return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));\n}\nfunction $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {\n    let mutableDate = date.copy();\n    if (fields.era != null) mutableDate.era = fields.era;\n    if (fields.year != null) mutableDate.year = fields.year;\n    if (fields.month != null) mutableDate.month = fields.month;\n    if (fields.day != null) mutableDate.day = fields.day;\n    $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);\n    return mutableDate;\n}\nfunction $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {\n    let mutableValue = value.copy();\n    if (fields.hour != null) mutableValue.hour = fields.hour;\n    if (fields.minute != null) mutableValue.minute = fields.minute;\n    if (fields.second != null) mutableValue.second = fields.second;\n    if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;\n    $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);\n    return mutableValue;\n}\nfunction $735220c2d4774dd3$var$balanceTime(time) {\n    time.second += Math.floor(time.millisecond / 1000);\n    time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1000);\n    time.minute += Math.floor(time.second / 60);\n    time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);\n    time.hour += Math.floor(time.minute / 60);\n    time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);\n    let days = Math.floor(time.hour / 24);\n    time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);\n    return days;\n}\nfunction $735220c2d4774dd3$export$7555de1e070510cb(time) {\n    time.millisecond = Math.max(0, Math.min(time.millisecond, 1000));\n    time.second = Math.max(0, Math.min(time.second, 59));\n    time.minute = Math.max(0, Math.min(time.minute, 59));\n    time.hour = Math.max(0, Math.min(time.hour, 23));\n}\nfunction $735220c2d4774dd3$var$nonNegativeMod(a, b) {\n    let result = a % b;\n    if (result < 0) result += b;\n    return result;\n}\nfunction $735220c2d4774dd3$var$addTimeFields(time, duration) {\n    time.hour += duration.hours || 0;\n    time.minute += duration.minutes || 0;\n    time.second += duration.seconds || 0;\n    time.millisecond += duration.milliseconds || 0;\n    return $735220c2d4774dd3$var$balanceTime(time);\n}\nfunction $735220c2d4774dd3$export$7ed87b6bc2506470(time, duration) {\n    let res = time.copy();\n    $735220c2d4774dd3$var$addTimeFields(res, duration);\n    return res;\n}\nfunction $735220c2d4774dd3$export$fe34d3a381cd7501(time, duration) {\n    return $735220c2d4774dd3$export$7ed87b6bc2506470(time, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));\n}\nfunction $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {\n    let mutable = value.copy();\n    switch(field){\n        case \"era\":\n            {\n                let eras = value.calendar.getEras();\n                let eraIndex = eras.indexOf(value.era);\n                if (eraIndex < 0) throw new Error(\"Invalid era: \" + value.era);\n                eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);\n                mutable.era = eras[eraIndex];\n                // Constrain the year and other fields within the era, so the era doesn't change when we balance below.\n                $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);\n                break;\n            }\n        case \"year\":\n            var _mutable_calendar_isInverseEra, _mutable_calendar;\n            if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;\n            // The year field should not cycle within the era as that can cause weird behavior affecting other fields.\n            // We need to also allow values < 1 so that decrementing goes to the previous era. If we get -Infinity back\n            // we know we wrapped around after reaching 9999 (the maximum), so set the year back to 1.\n            mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);\n            if (mutable.year === -Infinity) mutable.year = 1;\n            if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);\n            break;\n        case \"month\":\n            mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);\n            break;\n        case \"day\":\n            mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);\n            break;\n        default:\n            throw new Error(\"Unsupported field \" + field);\n    }\n    if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);\n    $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);\n    return mutable;\n}\nfunction $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {\n    let mutable = value.copy();\n    switch(field){\n        case \"hour\":\n            {\n                let hours = value.hour;\n                let min = 0;\n                let max = 23;\n                if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {\n                    let isPM = hours >= 12;\n                    min = isPM ? 12 : 0;\n                    max = isPM ? 23 : 11;\n                }\n                mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min, max, options === null || options === void 0 ? void 0 : options.round);\n                break;\n            }\n        case \"minute\":\n            mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);\n            break;\n        case \"second\":\n            mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);\n            break;\n        case \"millisecond\":\n            mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);\n            break;\n        default:\n            throw new Error(\"Unsupported field \" + field);\n    }\n    return mutable;\n}\nfunction $735220c2d4774dd3$var$cycleValue(value, amount, min, max, round = false) {\n    if (round) {\n        value += Math.sign(amount);\n        if (value < min) value = max;\n        let div = Math.abs(amount);\n        if (amount > 0) value = Math.ceil(value / div) * div;\n        else value = Math.floor(value / div) * div;\n        if (value > max) value = min;\n    } else {\n        value += amount;\n        if (value < min) value = max - (min - value - 1);\n        else if (value > max) value = min + (value - max - 1);\n    }\n    return value;\n}\nfunction $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {\n    let ms;\n    if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {\n        let res = $735220c2d4774dd3$export$e16d8520af44a096((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), {\n            years: duration.years,\n            months: duration.months,\n            weeks: duration.weeks,\n            days: duration.days\n        });\n        // Changing the date may change the timezone offset, so we need to recompute\n        // using the 'compatible' disambiguation.\n        ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);\n    } else // Otherwise, preserve the offset of the original date.\n    ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;\n    // Perform time manipulation in milliseconds rather than on the original time fields to account for DST.\n    // For example, adding one hour during a DST transition may result in the hour field staying the same or\n    // skipping an hour. This results in the offset field changing value instead of the specified field.\n    ms += duration.milliseconds || 0;\n    ms += (duration.seconds || 0) * 1000;\n    ms += (duration.minutes || 0) * 60000;\n    ms += (duration.hours || 0) * 3600000;\n    let res = (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone);\n    return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(res, dateTime.calendar);\n}\nfunction $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {\n    return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));\n}\nfunction $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {\n    // For date fields, we want the time to remain consistent and the UTC offset to potentially change to account for DST changes.\n    // For time fields, we want the time to change by the amount given. This may result in the hour field staying the same, but the UTC\n    // offset changing in the case of a backward DST transition, or skipping an hour in the case of a forward DST transition.\n    switch(field){\n        case \"hour\":\n            {\n                let min = 0;\n                let max = 23;\n                if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {\n                    let isPM = dateTime.hour >= 12;\n                    min = isPM ? 12 : 0;\n                    max = isPM ? 23 : 11;\n                }\n                // The minimum and maximum hour may be affected by daylight saving time.\n                // For example, it might jump forward at midnight, and skip 1am.\n                // Or it might end at midnight and repeat the 11pm hour. To handle this, we get\n                // the possible absolute times for the min and max, and find the maximum range\n                // that is within the current day.\n                let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);\n                let minDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {\n                    hour: min\n                }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\n                let minAbsolute = [\n                    (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, \"earlier\"),\n                    (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, \"later\")\n                ].filter((ms)=>(0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === minDate.day)[0];\n                let maxDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {\n                    hour: max\n                }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\n                let maxAbsolute = [\n                    (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, \"earlier\"),\n                    (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, \"later\")\n                ].filter((ms)=>(0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === maxDate.day).pop();\n                // Since hours may repeat, we need to operate on the absolute time in milliseconds.\n                // This is done in hours from the Unix epoch so that cycleValue works correctly,\n                // and then converted back to milliseconds.\n                let ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;\n                let hours = Math.floor(ms / $735220c2d4774dd3$var$ONE_HOUR);\n                let remainder = ms % $735220c2d4774dd3$var$ONE_HOUR;\n                ms = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;\n                // Now compute the new timezone offset, and convert the absolute time back to local time.\n                return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);\n            }\n        case \"minute\":\n        case \"second\":\n        case \"millisecond\":\n            // @ts-ignore\n            return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);\n        case \"era\":\n        case \"year\":\n        case \"month\":\n        case \"day\":\n            {\n                let res = $735220c2d4774dd3$export$d52ced6badfb9a4c((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), field, amount, options);\n                let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);\n                return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);\n            }\n        default:\n            throw new Error(\"Unsupported field \" + field);\n    }\n}\nfunction $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {\n    // Set the date/time fields, and recompute the UTC offset to account for DST changes.\n    // We also need to validate by converting back to a local time in case hours are skipped during forward DST transitions.\n    let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);\n    let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);\n    // If the resulting plain date time values are equal, return the original time.\n    // We don't want to change the offset when setting the time to the same value.\n    if (res.compare(plainDateTime) === 0) return dateTime;\n    let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);\n    return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);\n}\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\nconst $fae977aafc393c5c$var$TIME_RE = /^(\\d{2})(?::(\\d{2}))?(?::(\\d{2}))?(\\.\\d+)?$/;\nconst $fae977aafc393c5c$var$DATE_RE = /^(\\d{4})-(\\d{2})-(\\d{2})$/;\nconst $fae977aafc393c5c$var$DATE_TIME_RE = /^(\\d{4})-(\\d{2})-(\\d{2})(?:T(\\d{2}))?(?::(\\d{2}))?(?::(\\d{2}))?(\\.\\d+)?$/;\nconst $fae977aafc393c5c$var$ZONED_DATE_TIME_RE = /^(\\d{4})-(\\d{2})-(\\d{2})(?:T(\\d{2}))?(?::(\\d{2}))?(?::(\\d{2}))?(\\.\\d+)?(?:([+-]\\d{2})(?::?(\\d{2}))?)?\\[(.*?)\\]$/;\nconst $fae977aafc393c5c$var$ABSOLUTE_RE = /^(\\d{4})-(\\d{2})-(\\d{2})(?:T(\\d{2}))?(?::(\\d{2}))?(?::(\\d{2}))?(\\.\\d+)?(?:(?:([+-]\\d{2})(?::?(\\d{2}))?)|Z)$/;\nconst $fae977aafc393c5c$var$DATE_TIME_DURATION_RE = /^((?<negative>-)|\\+)?P((?<years>\\d*)Y)?((?<months>\\d*)M)?((?<weeks>\\d*)W)?((?<days>\\d*)D)?((?<time>T)((?<hours>\\d*[.,]?\\d{1,9})H)?((?<minutes>\\d*[.,]?\\d{1,9})M)?((?<seconds>\\d*[.,]?\\d{1,9})S)?)?$/;\nconst $fae977aafc393c5c$var$requiredDurationTimeGroups = [\n    \"hours\",\n    \"minutes\",\n    \"seconds\"\n];\nconst $fae977aafc393c5c$var$requiredDurationGroups = [\n    \"years\",\n    \"months\",\n    \"weeks\",\n    \"days\",\n    ...$fae977aafc393c5c$var$requiredDurationTimeGroups\n];\nfunction $fae977aafc393c5c$export$c9698ec7f05a07e1(value) {\n    let m = value.match($fae977aafc393c5c$var$TIME_RE);\n    if (!m) throw new Error(\"Invalid ISO 8601 time string: \" + value);\n    return new (0, $35ea8db9cb2ccb90$export$680ea196effce5f)($fae977aafc393c5c$var$parseNumber(m[1], 0, 23), m[2] ? $fae977aafc393c5c$var$parseNumber(m[2], 0, 59) : 0, m[3] ? $fae977aafc393c5c$var$parseNumber(m[3], 0, 59) : 0, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, Infinity) * 1000 : 0);\n}\nfunction $fae977aafc393c5c$export$6b862160d295c8e(value) {\n    let m = value.match($fae977aafc393c5c$var$DATE_RE);\n    if (!m) throw new Error(\"Invalid ISO 8601 date string: \" + value);\n    let date = new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)($fae977aafc393c5c$var$parseNumber(m[1], 0, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1);\n    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));\n    return date;\n}\nfunction $fae977aafc393c5c$export$588937bcd60ade55(value) {\n    let m = value.match($fae977aafc393c5c$var$DATE_TIME_RE);\n    if (!m) throw new Error(\"Invalid ISO 8601 date time string: \" + value);\n    let date = new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)($fae977aafc393c5c$var$parseNumber(m[1], 1, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $fae977aafc393c5c$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $fae977aafc393c5c$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $fae977aafc393c5c$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);\n    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));\n    return date;\n}\nfunction $fae977aafc393c5c$export$fd7893f06e92a6a4(value, disambiguation) {\n    let m = value.match($fae977aafc393c5c$var$ZONED_DATE_TIME_RE);\n    if (!m) throw new Error(\"Invalid ISO 8601 date time string: \" + value);\n    let date = new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)($fae977aafc393c5c$var$parseNumber(m[1], 1, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1, m[10], 0, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $fae977aafc393c5c$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $fae977aafc393c5c$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $fae977aafc393c5c$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);\n    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));\n    let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(date);\n    let ms;\n    if (m[8]) {\n        var _m_;\n        date.offset = $fae977aafc393c5c$var$parseNumber(m[8], -23, 23) * 3600000 + $fae977aafc393c5c$var$parseNumber((_m_ = m[9]) !== null && _m_ !== void 0 ? _m_ : \"0\", 0, 59) * 60000;\n        ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(date) - date.offset;\n        // Validate offset against parsed date.\n        let absolutes = (0, $11d87f3f76e88657$export$136f38efe7caf549)(plainDateTime, date.timeZone);\n        if (!absolutes.includes(ms)) throw new Error(`Offset ${$fae977aafc393c5c$var$offsetToString(date.offset)} is invalid for ${$fae977aafc393c5c$export$4223de14708adc63(date)} in ${date.timeZone}`);\n    } else // Convert to absolute and back to fix invalid times due to DST.\n    ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)((0, $11d87f3f76e88657$export$b21e0b124e224484)(plainDateTime), date.timeZone, disambiguation);\n    return (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, date.timeZone);\n}\nfunction $fae977aafc393c5c$export$5adfdab05168c219(value, timeZone) {\n    let m = value.match($fae977aafc393c5c$var$ABSOLUTE_RE);\n    if (!m) throw new Error(\"Invalid ISO 8601 date time string: \" + value);\n    let date = new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)($fae977aafc393c5c$var$parseNumber(m[1], 1, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1, timeZone, 0, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $fae977aafc393c5c$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $fae977aafc393c5c$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $fae977aafc393c5c$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);\n    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));\n    var _m_;\n    if (m[8]) date.offset = $fae977aafc393c5c$var$parseNumber(m[8], -23, 23) * 3600000 + $fae977aafc393c5c$var$parseNumber((_m_ = m[9]) !== null && _m_ !== void 0 ? _m_ : \"0\", 0, 59) * 60000;\n    return (0, $11d87f3f76e88657$export$538b00033cc11c75)(date, timeZone);\n}\nfunction $fae977aafc393c5c$export$8e384432362ed0f0(value) {\n    return $fae977aafc393c5c$export$5adfdab05168c219(value, (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)());\n}\nfunction $fae977aafc393c5c$var$parseNumber(value, min, max) {\n    let val = Number(value);\n    if (val < min || val > max) throw new RangeError(`Value out of range: ${min} <= ${val} <= ${max}`);\n    return val;\n}\nfunction $fae977aafc393c5c$export$f59dee82248f5ad4(time) {\n    return `${String(time.hour).padStart(2, \"0\")}:${String(time.minute).padStart(2, \"0\")}:${String(time.second).padStart(2, \"0\")}${time.millisecond ? String(time.millisecond / 1000).slice(1) : \"\"}`;\n}\nfunction $fae977aafc393c5c$export$60dfd74aa96791bd(date) {\n    let gregorianDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\n    return `${String(gregorianDate.year).padStart(4, \"0\")}-${String(gregorianDate.month).padStart(2, \"0\")}-${String(gregorianDate.day).padStart(2, \"0\")}`;\n}\nfunction $fae977aafc393c5c$export$4223de14708adc63(date) {\n    // @ts-ignore\n    return `${$fae977aafc393c5c$export$60dfd74aa96791bd(date)}T${$fae977aafc393c5c$export$f59dee82248f5ad4(date)}`;\n}\nfunction $fae977aafc393c5c$var$offsetToString(offset) {\n    let sign = Math.sign(offset) < 0 ? \"-\" : \"+\";\n    offset = Math.abs(offset);\n    let offsetHours = Math.floor(offset / 3600000);\n    let offsetMinutes = offset % 3600000 / 60000;\n    return `${sign}${String(offsetHours).padStart(2, \"0\")}:${String(offsetMinutes).padStart(2, \"0\")}`;\n}\nfunction $fae977aafc393c5c$export$bf79f1ebf4b18792(date) {\n    return `${$fae977aafc393c5c$export$4223de14708adc63(date)}${$fae977aafc393c5c$var$offsetToString(date.offset)}[${date.timeZone}]`;\n}\nfunction $fae977aafc393c5c$export$ecae829bb3747ea6(value) {\n    var _match_groups, _match_groups1, _match_groups2, _match_groups3, _match_groups4, _match_groups5, _match_groups6, _match_groups7, _match_groups8;\n    const match = value.match($fae977aafc393c5c$var$DATE_TIME_DURATION_RE);\n    if (!match) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);\n    const parseDurationGroup = (group, isNegative, min, max)=>{\n        if (!group) return 0;\n        try {\n            const sign = isNegative ? -1 : 1;\n            return sign * $fae977aafc393c5c$var$parseNumber(group.replace(\",\", \".\"), min, max);\n        } catch  {\n            throw new Error(`Invalid ISO 8601 Duration string: ${value}`);\n        }\n    };\n    const isNegative = !!((_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups.negative);\n    const hasRequiredGroups = $fae977aafc393c5c$var$requiredDurationGroups.some((group)=>{\n        var _match_groups;\n        return (_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups[group];\n    });\n    if (!hasRequiredGroups) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);\n    const durationStringIncludesTime = (_match_groups1 = match.groups) === null || _match_groups1 === void 0 ? void 0 : _match_groups1.time;\n    if (durationStringIncludesTime) {\n        const hasRequiredDurationTimeGroups = $fae977aafc393c5c$var$requiredDurationTimeGroups.some((group)=>{\n            var _match_groups;\n            return (_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups[group];\n        });\n        if (!hasRequiredDurationTimeGroups) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);\n    }\n    const duration = {\n        years: parseDurationGroup((_match_groups2 = match.groups) === null || _match_groups2 === void 0 ? void 0 : _match_groups2.years, isNegative, 0, 9999),\n        months: parseDurationGroup((_match_groups3 = match.groups) === null || _match_groups3 === void 0 ? void 0 : _match_groups3.months, isNegative, 0, 12),\n        weeks: parseDurationGroup((_match_groups4 = match.groups) === null || _match_groups4 === void 0 ? void 0 : _match_groups4.weeks, isNegative, 0, Infinity),\n        days: parseDurationGroup((_match_groups5 = match.groups) === null || _match_groups5 === void 0 ? void 0 : _match_groups5.days, isNegative, 0, 31),\n        hours: parseDurationGroup((_match_groups6 = match.groups) === null || _match_groups6 === void 0 ? void 0 : _match_groups6.hours, isNegative, 0, 23),\n        minutes: parseDurationGroup((_match_groups7 = match.groups) === null || _match_groups7 === void 0 ? void 0 : _match_groups7.minutes, isNegative, 0, 59),\n        seconds: parseDurationGroup((_match_groups8 = match.groups) === null || _match_groups8 === void 0 ? void 0 : _match_groups8.seconds, isNegative, 0, 59)\n    };\n    if (duration.hours !== undefined && duration.hours % 1 !== 0 && (duration.minutes || duration.seconds)) throw new Error(`Invalid ISO 8601 Duration string: ${value} - only the smallest unit can be fractional`);\n    if (duration.minutes !== undefined && duration.minutes % 1 !== 0 && duration.seconds) throw new Error(`Invalid ISO 8601 Duration string: ${value} - only the smallest unit can be fractional`);\n    return duration;\n}\n\n\n\n\nfunction $35ea8db9cb2ccb90$var$shiftArgs(args) {\n    let calendar = typeof args[0] === \"object\" ? args.shift() : new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();\n    let era;\n    if (typeof args[0] === \"string\") era = args.shift();\n    else {\n        let eras = calendar.getEras();\n        era = eras[eras.length - 1];\n    }\n    let year = args.shift();\n    let month = args.shift();\n    let day = args.shift();\n    return [\n        calendar,\n        era,\n        year,\n        month,\n        day\n    ];\n}\nvar // This prevents TypeScript from allowing other types with the same fields to match.\n// i.e. a ZonedDateTime should not be be passable to a parameter that expects CalendarDate.\n// If that behavior is desired, use the AnyCalendarDate interface instead.\n// @ts-ignore\n$35ea8db9cb2ccb90$var$_type = /*#__PURE__*/ new WeakMap();\nclass $35ea8db9cb2ccb90$export$99faa760c7908e4f {\n    /** Returns a copy of this date. */ copy() {\n        if (this.era) return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);\n        else return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);\n    }\n    /** Returns a new `CalendarDate` with the given duration added to it. */ add(duration) {\n        return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);\n    }\n    /** Returns a new `CalendarDate` with the given duration subtracted from it. */ subtract(duration) {\n        return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);\n    }\n    /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {\n        return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)(this, fields);\n    }\n    /**\n   * Returns a new `CalendarDate` with the given field adjusted by a specified amount.\n   * When the resulting value reaches the limits of the field, it wraps around.\n   */ cycle(field, amount, options) {\n        return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);\n    }\n    /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */ toDate(timeZone) {\n        return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone);\n    }\n    /** Converts the date to an ISO 8601 formatted string. */ toString() {\n        return (0, $fae977aafc393c5c$export$60dfd74aa96791bd)(this);\n    }\n    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {\n        return (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);\n    }\n    constructor(...args){\n        (0, _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_0__._)(this, $35ea8db9cb2ccb90$var$_type, {\n            writable: true,\n            value: void 0\n        });\n        let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);\n        this.calendar = calendar;\n        this.era = era;\n        this.year = year;\n        this.month = month;\n        this.day = day;\n        (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);\n    }\n}\nvar // This prevents TypeScript from allowing other types with the same fields to match.\n// @ts-ignore\n$35ea8db9cb2ccb90$var$_type1 = /*#__PURE__*/ new WeakMap();\nclass $35ea8db9cb2ccb90$export$680ea196effce5f {\n    /** Returns a copy of this time. */ copy() {\n        return new $35ea8db9cb2ccb90$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);\n    }\n    /** Returns a new `Time` with the given duration added to it. */ add(duration) {\n        return (0, $735220c2d4774dd3$export$7ed87b6bc2506470)(this, duration);\n    }\n    /** Returns a new `Time` with the given duration subtracted from it. */ subtract(duration) {\n        return (0, $735220c2d4774dd3$export$fe34d3a381cd7501)(this, duration);\n    }\n    /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {\n        return (0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields);\n    }\n    /**\n   * Returns a new `Time` with the given field adjusted by a specified amount.\n   * When the resulting value reaches the limits of the field, it wraps around.\n   */ cycle(field, amount, options) {\n        return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);\n    }\n    /** Converts the time to an ISO 8601 formatted string. */ toString() {\n        return (0, $fae977aafc393c5c$export$f59dee82248f5ad4)(this);\n    }\n    /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */ compare(b) {\n        return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, b);\n    }\n    constructor(hour = 0, minute = 0, second = 0, millisecond = 0){\n        (0, _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_0__._)(this, $35ea8db9cb2ccb90$var$_type1, {\n            writable: true,\n            value: void 0\n        });\n        this.hour = hour;\n        this.minute = minute;\n        this.second = second;\n        this.millisecond = millisecond;\n        (0, $735220c2d4774dd3$export$7555de1e070510cb)(this);\n    }\n}\nvar // This prevents TypeScript from allowing other types with the same fields to match.\n// @ts-ignore\n$35ea8db9cb2ccb90$var$_type2 = /*#__PURE__*/ new WeakMap();\nclass $35ea8db9cb2ccb90$export$ca871e8dbb80966f {\n    /** Returns a copy of this date. */ copy() {\n        if (this.era) return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n        else return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n    }\n    /** Returns a new `CalendarDateTime` with the given duration added to it. */ add(duration) {\n        return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);\n    }\n    /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */ subtract(duration) {\n        return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);\n    }\n    /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {\n        return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)((0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields), fields);\n    }\n    /**\n   * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.\n   * When the resulting value reaches the limits of the field, it wraps around.\n   */ cycle(field, amount, options) {\n        switch(field){\n            case \"era\":\n            case \"year\":\n            case \"month\":\n            case \"day\":\n                return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);\n            default:\n                return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);\n        }\n    }\n    /** Converts the date to a native JavaScript Date object in the given time zone. */ toDate(timeZone, disambiguation) {\n        return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone, disambiguation);\n    }\n    /** Converts the date to an ISO 8601 formatted string. */ toString() {\n        return (0, $fae977aafc393c5c$export$4223de14708adc63)(this);\n    }\n    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {\n        let res = (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);\n        if (res === 0) return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, (0, $11d87f3f76e88657$export$b21e0b124e224484)(b));\n        return res;\n    }\n    constructor(...args){\n        (0, _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_0__._)(this, $35ea8db9cb2ccb90$var$_type2, {\n            writable: true,\n            value: void 0\n        });\n        let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);\n        this.calendar = calendar;\n        this.era = era;\n        this.year = year;\n        this.month = month;\n        this.day = day;\n        this.hour = args.shift() || 0;\n        this.minute = args.shift() || 0;\n        this.second = args.shift() || 0;\n        this.millisecond = args.shift() || 0;\n        (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);\n    }\n}\nvar // This prevents TypeScript from allowing other types with the same fields to match.\n// @ts-ignore\n$35ea8db9cb2ccb90$var$_type3 = /*#__PURE__*/ new WeakMap();\nclass $35ea8db9cb2ccb90$export$d3b7288e7994edea {\n    /** Returns a copy of this date. */ copy() {\n        if (this.era) return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);\n        else return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);\n    }\n    /** Returns a new `ZonedDateTime` with the given duration added to it. */ add(duration) {\n        return (0, $735220c2d4774dd3$export$96b1d28349274637)(this, duration);\n    }\n    /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */ subtract(duration) {\n        return (0, $735220c2d4774dd3$export$6814caac34ca03c7)(this, duration);\n    }\n    /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields, disambiguation) {\n        return (0, $735220c2d4774dd3$export$31b5430eb18be4f8)(this, fields, disambiguation);\n    }\n    /**\n   * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.\n   * When the resulting value reaches the limits of the field, it wraps around.\n   */ cycle(field, amount, options) {\n        return (0, $735220c2d4774dd3$export$9a297d111fc86b79)(this, field, amount, options);\n    }\n    /** Converts the date to a native JavaScript Date object. */ toDate() {\n        return (0, $11d87f3f76e88657$export$83aac07b4c37b25)(this);\n    }\n    /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */ toString() {\n        return (0, $fae977aafc393c5c$export$bf79f1ebf4b18792)(this);\n    }\n    /** Converts the date to an ISO 8601 formatted string in UTC. */ toAbsoluteString() {\n        return this.toDate().toISOString();\n    }\n    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {\n        // TODO: Is this a bad idea??\n        return this.toDate().getTime() - (0, $11d87f3f76e88657$export$84c95a83c799e074)(b, this.timeZone).toDate().getTime();\n    }\n    constructor(...args){\n        (0, _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_0__._)(this, $35ea8db9cb2ccb90$var$_type3, {\n            writable: true,\n            value: void 0\n        });\n        let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);\n        let timeZone = args.shift();\n        let offset = args.shift();\n        this.calendar = calendar;\n        this.era = era;\n        this.year = year;\n        this.month = month;\n        this.day = day;\n        this.timeZone = timeZone;\n        this.offset = offset;\n        this.hour = args.shift() || 0;\n        this.minute = args.shift() || 0;\n        this.second = args.shift() || 0;\n        this.millisecond = args.shift() || 0;\n        (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);\n    }\n}\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\n\nconst $62225008020f0a13$var$ERA_START_DATES = [\n    [\n        1868,\n        9,\n        8\n    ],\n    [\n        1912,\n        7,\n        30\n    ],\n    [\n        1926,\n        12,\n        25\n    ],\n    [\n        1989,\n        1,\n        8\n    ],\n    [\n        2019,\n        5,\n        1\n    ]\n];\nconst $62225008020f0a13$var$ERA_END_DATES = [\n    [\n        1912,\n        7,\n        29\n    ],\n    [\n        1926,\n        12,\n        24\n    ],\n    [\n        1989,\n        1,\n        7\n    ],\n    [\n        2019,\n        4,\n        30\n    ]\n];\nconst $62225008020f0a13$var$ERA_ADDENDS = [\n    1867,\n    1911,\n    1925,\n    1988,\n    2018\n];\nconst $62225008020f0a13$var$ERA_NAMES = [\n    \"meiji\",\n    \"taisho\",\n    \"showa\",\n    \"heisei\",\n    \"reiwa\"\n];\nfunction $62225008020f0a13$var$findEraFromGregorianDate(date) {\n    const idx = $62225008020f0a13$var$ERA_START_DATES.findIndex(([year, month, day])=>{\n        if (date.year < year) return true;\n        if (date.year === year && date.month < month) return true;\n        if (date.year === year && date.month === month && date.day < day) return true;\n        return false;\n    });\n    if (idx === -1) return $62225008020f0a13$var$ERA_START_DATES.length - 1;\n    if (idx === 0) return 0;\n    return idx - 1;\n}\nfunction $62225008020f0a13$var$toGregorian(date) {\n    let eraAddend = $62225008020f0a13$var$ERA_ADDENDS[$62225008020f0a13$var$ERA_NAMES.indexOf(date.era)];\n    if (!eraAddend) throw new Error(\"Unknown era: \" + date.era);\n    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(date.year + eraAddend, date.month, date.day);\n}\nclass $62225008020f0a13$export$b746ab2b60cdffbf extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {\n    fromJulianDay(jd) {\n        let date = super.fromJulianDay(jd);\n        let era = $62225008020f0a13$var$findEraFromGregorianDate(date);\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, $62225008020f0a13$var$ERA_NAMES[era], date.year - $62225008020f0a13$var$ERA_ADDENDS[era], date.month, date.day);\n    }\n    toJulianDay(date) {\n        return super.toJulianDay($62225008020f0a13$var$toGregorian(date));\n    }\n    balanceDate(date) {\n        let gregorianDate = $62225008020f0a13$var$toGregorian(date);\n        let era = $62225008020f0a13$var$findEraFromGregorianDate(gregorianDate);\n        if ($62225008020f0a13$var$ERA_NAMES[era] !== date.era) {\n            date.era = $62225008020f0a13$var$ERA_NAMES[era];\n            date.year = gregorianDate.year - $62225008020f0a13$var$ERA_ADDENDS[era];\n        }\n        // Constrain in case we went before the first supported era.\n        this.constrainDate(date);\n    }\n    constrainDate(date) {\n        let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\n        let end = $62225008020f0a13$var$ERA_END_DATES[idx];\n        if (end != null) {\n            let [endYear, endMonth, endDay] = end;\n            // Constrain the year to the maximum possible value in the era.\n            // Then constrain the month and day fields within that.\n            let maxYear = endYear - $62225008020f0a13$var$ERA_ADDENDS[idx];\n            date.year = Math.max(1, Math.min(maxYear, date.year));\n            if (date.year === maxYear) {\n                date.month = Math.min(endMonth, date.month);\n                if (date.month === endMonth) date.day = Math.min(endDay, date.day);\n            }\n        }\n        if (date.year === 1 && idx >= 0) {\n            let [, startMonth, startDay] = $62225008020f0a13$var$ERA_START_DATES[idx];\n            date.month = Math.max(startMonth, date.month);\n            if (date.month === startMonth) date.day = Math.max(startDay, date.day);\n        }\n    }\n    getEras() {\n        return $62225008020f0a13$var$ERA_NAMES;\n    }\n    getYearsInEra(date) {\n        // Get the number of years in the era, taking into account the date's month and day fields.\n        let era = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\n        let cur = $62225008020f0a13$var$ERA_START_DATES[era];\n        let next = $62225008020f0a13$var$ERA_START_DATES[era + 1];\n        if (next == null) // 9999 gregorian is the maximum year allowed.\n        return 9999 - cur[0] + 1;\n        let years = next[0] - cur[0];\n        if (date.month < next[1] || date.month === next[1] && date.day < next[2]) years++;\n        return years;\n    }\n    getDaysInMonth(date) {\n        return super.getDaysInMonth($62225008020f0a13$var$toGregorian(date));\n    }\n    getMinimumMonthInYear(date) {\n        let start = $62225008020f0a13$var$getMinimums(date);\n        return start ? start[1] : 1;\n    }\n    getMinimumDayInMonth(date) {\n        let start = $62225008020f0a13$var$getMinimums(date);\n        return start && date.month === start[1] ? start[2] : 1;\n    }\n    constructor(...args){\n        super(...args);\n        this.identifier = \"japanese\";\n    }\n}\nfunction $62225008020f0a13$var$getMinimums(date) {\n    if (date.year === 1) {\n        let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\n        return $62225008020f0a13$var$ERA_START_DATES[idx];\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from ICU.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\n\nconst $8d73d47422ca7302$var$BUDDHIST_ERA_START = -543;\nclass $8d73d47422ca7302$export$42d20a78301dee44 extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {\n    fromJulianDay(jd) {\n        let gregorianDate = super.fromJulianDay(jd);\n        let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(gregorianDate.era, gregorianDate.year);\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, year - $8d73d47422ca7302$var$BUDDHIST_ERA_START, gregorianDate.month, gregorianDate.day);\n    }\n    toJulianDay(date) {\n        return super.toJulianDay($8d73d47422ca7302$var$toGregorian(date));\n    }\n    getEras() {\n        return [\n            \"BE\"\n        ];\n    }\n    getDaysInMonth(date) {\n        return super.getDaysInMonth($8d73d47422ca7302$var$toGregorian(date));\n    }\n    balanceDate() {}\n    constructor(...args){\n        super(...args);\n        this.identifier = \"buddhist\";\n    }\n}\nfunction $8d73d47422ca7302$var$toGregorian(date) {\n    let [era, year] = (0, $3b62074eb05584b2$export$4475b7e617eb123c)(date.year + $8d73d47422ca7302$var$BUDDHIST_ERA_START);\n    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, date.month, date.day);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from ICU.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\n\nconst $5f31bd6f0c8940b2$var$TAIWAN_ERA_START = 1911;\nfunction $5f31bd6f0c8940b2$var$gregorianYear(date) {\n    return date.era === \"minguo\" ? date.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START : 1 - date.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;\n}\nfunction $5f31bd6f0c8940b2$var$gregorianToTaiwan(year) {\n    let y = year - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;\n    if (y > 0) return [\n        \"minguo\",\n        y\n    ];\n    else return [\n        \"before_minguo\",\n        1 - y\n    ];\n}\nclass $5f31bd6f0c8940b2$export$65e01080afcb0799 extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {\n    fromJulianDay(jd) {\n        let date = super.fromJulianDay(jd);\n        let extendedYear = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);\n        let [era, year] = $5f31bd6f0c8940b2$var$gregorianToTaiwan(extendedYear);\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, era, year, date.month, date.day);\n    }\n    toJulianDay(date) {\n        return super.toJulianDay($5f31bd6f0c8940b2$var$toGregorian(date));\n    }\n    getEras() {\n        return [\n            \"before_minguo\",\n            \"minguo\"\n        ];\n    }\n    balanceDate(date) {\n        let [era, year] = $5f31bd6f0c8940b2$var$gregorianToTaiwan($5f31bd6f0c8940b2$var$gregorianYear(date));\n        date.era = era;\n        date.year = year;\n    }\n    isInverseEra(date) {\n        return date.era === \"before_minguo\";\n    }\n    getDaysInMonth(date) {\n        return super.getDaysInMonth($5f31bd6f0c8940b2$var$toGregorian(date));\n    }\n    getYearsInEra(date) {\n        return date.era === \"before_minguo\" ? 9999 : 9999 - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;\n    }\n    constructor(...args){\n        super(...args);\n        this.identifier = \"roc\" // Republic of China\n        ;\n    }\n}\nfunction $5f31bd6f0c8940b2$var$toGregorian(date) {\n    let [era, year] = (0, $3b62074eb05584b2$export$4475b7e617eb123c)($5f31bd6f0c8940b2$var$gregorianYear(date));\n    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, date.month, date.day);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from ICU.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\n\nconst $f3ed2e4472ae7e25$var$PERSIAN_EPOCH = 1948321; // 622/03/19 Julian C.E.\nfunction $f3ed2e4472ae7e25$var$isLeapYear(year) {\n    let y0 = year > 0 ? year - 474 : year - 473;\n    let y1 = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(y0, 2820) + 474;\n    return (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)((y1 + 38) * 31, 128) < 31;\n}\nfunction $f3ed2e4472ae7e25$var$persianToJulianDay(year, month, day) {\n    let y0 = year > 0 ? year - 474 : year - 473;\n    let y1 = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(y0, 2820) + 474;\n    let offset = month <= 7 ? 31 * (month - 1) : 30 * (month - 1) + 6;\n    return $f3ed2e4472ae7e25$var$PERSIAN_EPOCH - 1 + 1029983 * Math.floor(y0 / 2820) + 365 * (y1 - 1) + Math.floor((31 * y1 - 5) / 128) + offset + day;\n}\nclass $f3ed2e4472ae7e25$export$37fccdbfd14c5939 {\n    fromJulianDay(jd) {\n        let d0 = jd - $f3ed2e4472ae7e25$var$persianToJulianDay(475, 1, 1);\n        let n2820 = Math.floor(d0 / 1029983);\n        let d1 = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(d0, 1029983);\n        let y2820 = d1 === 1029982 ? 2820 : Math.floor((128 * d1 + 46878) / 46751);\n        let year = 474 + 2820 * n2820 + y2820;\n        if (year <= 0) year--;\n        let yDay = jd - $f3ed2e4472ae7e25$var$persianToJulianDay(year, 1, 1) + 1;\n        let month = yDay <= 186 ? Math.ceil(yDay / 31) : Math.ceil((yDay - 6) / 31);\n        let day = jd - $f3ed2e4472ae7e25$var$persianToJulianDay(year, month, 1) + 1;\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, year, month, day);\n    }\n    toJulianDay(date) {\n        return $f3ed2e4472ae7e25$var$persianToJulianDay(date.year, date.month, date.day);\n    }\n    getMonthsInYear() {\n        return 12;\n    }\n    getDaysInMonth(date) {\n        if (date.month <= 6) return 31;\n        if (date.month <= 11) return 30;\n        return $f3ed2e4472ae7e25$var$isLeapYear(date.year) ? 30 : 29;\n    }\n    getEras() {\n        return [\n            \"AP\"\n        ];\n    }\n    getYearsInEra() {\n        // 9378-10-10 persian is 9999-12-31 gregorian.\n        // Round down to 9377 to set the maximum full year.\n        return 9377;\n    }\n    constructor(){\n        this.identifier = \"persian\";\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from ICU.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\n\n// Starts in 78 AD,\nconst $82c358003bdda0a8$var$INDIAN_ERA_START = 78;\n// The Indian year starts 80 days later than the Gregorian year.\nconst $82c358003bdda0a8$var$INDIAN_YEAR_START = 80;\nclass $82c358003bdda0a8$export$39f31c639fa15726 extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {\n    fromJulianDay(jd) {\n        // Gregorian date for Julian day\n        let date = super.fromJulianDay(jd);\n        // Year in Saka era\n        let indianYear = date.year - $82c358003bdda0a8$var$INDIAN_ERA_START;\n        // Day number in Gregorian year (starting from 0)\n        let yDay = jd - (0, $3b62074eb05584b2$export$f297eb839006d339)(date.era, date.year, 1, 1);\n        let leapMonth;\n        if (yDay < $82c358003bdda0a8$var$INDIAN_YEAR_START) {\n            //  Day is at the end of the preceding Saka year\n            indianYear--;\n            // Days in leapMonth this year, previous Gregorian year\n            leapMonth = (0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(date.year - 1) ? 31 : 30;\n            yDay += leapMonth + 155 + 90 + 10;\n        } else {\n            // Days in leapMonth this year\n            leapMonth = (0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(date.year) ? 31 : 30;\n            yDay -= $82c358003bdda0a8$var$INDIAN_YEAR_START;\n        }\n        let indianMonth;\n        let indianDay;\n        if (yDay < leapMonth) {\n            indianMonth = 1;\n            indianDay = yDay + 1;\n        } else {\n            let mDay = yDay - leapMonth;\n            if (mDay < 155) {\n                indianMonth = Math.floor(mDay / 31) + 2;\n                indianDay = mDay % 31 + 1;\n            } else {\n                mDay -= 155;\n                indianMonth = Math.floor(mDay / 30) + 7;\n                indianDay = mDay % 30 + 1;\n            }\n        }\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, indianYear, indianMonth, indianDay);\n    }\n    toJulianDay(date) {\n        let extendedYear = date.year + $82c358003bdda0a8$var$INDIAN_ERA_START;\n        let [era, year] = (0, $3b62074eb05584b2$export$4475b7e617eb123c)(extendedYear);\n        let leapMonth;\n        let jd;\n        if ((0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(year)) {\n            leapMonth = 31;\n            jd = (0, $3b62074eb05584b2$export$f297eb839006d339)(era, year, 3, 21);\n        } else {\n            leapMonth = 30;\n            jd = (0, $3b62074eb05584b2$export$f297eb839006d339)(era, year, 3, 22);\n        }\n        if (date.month === 1) return jd + date.day - 1;\n        jd += leapMonth + Math.min(date.month - 2, 5) * 31;\n        if (date.month >= 8) jd += (date.month - 7) * 30;\n        jd += date.day - 1;\n        return jd;\n    }\n    getDaysInMonth(date) {\n        if (date.month === 1 && (0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(date.year + $82c358003bdda0a8$var$INDIAN_ERA_START)) return 31;\n        if (date.month >= 2 && date.month <= 6) return 31;\n        return 30;\n    }\n    getYearsInEra() {\n        // 9999-12-31 gregorian is 9920-10-10 indian.\n        // Round down to 9919 for the last full year.\n        return 9919;\n    }\n    getEras() {\n        return [\n            \"saka\"\n        ];\n    }\n    balanceDate() {}\n    constructor(...args){\n        super(...args);\n        this.identifier = \"indian\";\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from ICU.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\nconst $f2f3e0e3a817edbd$var$CIVIL_EPOC = 1948440; // CE 622 July 16 Friday (Julian calendar) / CE 622 July 19 (Gregorian calendar)\nconst $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC = 1948439; // CE 622 July 15 Thursday (Julian calendar)\nconst $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START = 1300;\nconst $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END = 1600;\nconst $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS = 460322;\nfunction $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, month, day) {\n    return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30) + epoch - 1;\n}\nfunction $f2f3e0e3a817edbd$var$julianDayToIslamic(calendar, epoch, jd) {\n    let year = Math.floor((30 * (jd - epoch) + 10646) / 10631);\n    let month = Math.min(12, Math.ceil((jd - (29 + $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, 1, 1))) / 29.5) + 1);\n    let day = jd - $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, month, 1) + 1;\n    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(calendar, year, month, day);\n}\nfunction $f2f3e0e3a817edbd$var$isLeapYear(year) {\n    return (14 + 11 * year) % 30 < 11;\n}\nclass $f2f3e0e3a817edbd$export$2066795aadd37bfc {\n    fromJulianDay(jd) {\n        return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$CIVIL_EPOC, jd);\n    }\n    toJulianDay(date) {\n        return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$CIVIL_EPOC, date.year, date.month, date.day);\n    }\n    getDaysInMonth(date) {\n        let length = 29 + date.month % 2;\n        if (date.month === 12 && $f2f3e0e3a817edbd$var$isLeapYear(date.year)) length++;\n        return length;\n    }\n    getMonthsInYear() {\n        return 12;\n    }\n    getDaysInYear(date) {\n        return $f2f3e0e3a817edbd$var$isLeapYear(date.year) ? 355 : 354;\n    }\n    getYearsInEra() {\n        // 9999 gregorian\n        return 9665;\n    }\n    getEras() {\n        return [\n            \"AH\"\n        ];\n    }\n    constructor(){\n        this.identifier = \"islamic-civil\";\n    }\n}\nclass $f2f3e0e3a817edbd$export$37f0887f2f9d22f7 extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {\n    fromJulianDay(jd) {\n        return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, jd);\n    }\n    toJulianDay(date) {\n        return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, date.year, date.month, date.day);\n    }\n    constructor(...args){\n        super(...args);\n        this.identifier = \"islamic-tbla\";\n    }\n}\n// Generated by scripts/generate-umalqura.js\nconst $f2f3e0e3a817edbd$var$UMALQURA_DATA = \"qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=\";\nlet $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH;\nlet $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE;\nfunction $f2f3e0e3a817edbd$var$umalquraYearStart(year) {\n    return $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS + $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];\n}\nfunction $f2f3e0e3a817edbd$var$umalquraMonthLength(year, month) {\n    let idx = year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START;\n    let mask = 0x01 << 11 - (month - 1);\n    if (($f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH[idx] & mask) === 0) return 29;\n    else return 30;\n}\nfunction $f2f3e0e3a817edbd$var$umalquraMonthStart(year, month) {\n    let day = $f2f3e0e3a817edbd$var$umalquraYearStart(year);\n    for(let i = 1; i < month; i++)day += $f2f3e0e3a817edbd$var$umalquraMonthLength(year, i);\n    return day;\n}\nfunction $f2f3e0e3a817edbd$var$umalquraYearLength(year) {\n    return $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year + 1 - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];\n}\nclass $f2f3e0e3a817edbd$export$5baab4758c231076 extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {\n    fromJulianDay(jd) {\n        let days = jd - $f2f3e0e3a817edbd$var$CIVIL_EPOC;\n        let startDays = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_START);\n        let endDays = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END);\n        if (days < startDays || days > endDays) return super.fromJulianDay(jd);\n        else {\n            let y = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START - 1;\n            let m = 1;\n            let d = 1;\n            while(d > 0){\n                y++;\n                d = days - $f2f3e0e3a817edbd$var$umalquraYearStart(y) + 1;\n                let yearLength = $f2f3e0e3a817edbd$var$umalquraYearLength(y);\n                if (d === yearLength) {\n                    m = 12;\n                    break;\n                } else if (d < yearLength) {\n                    let monthLength = $f2f3e0e3a817edbd$var$umalquraMonthLength(y, m);\n                    m = 1;\n                    while(d > monthLength){\n                        d -= monthLength;\n                        m++;\n                        monthLength = $f2f3e0e3a817edbd$var$umalquraMonthLength(y, m);\n                    }\n                    break;\n                }\n            }\n            return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, y, m, days - $f2f3e0e3a817edbd$var$umalquraMonthStart(y, m) + 1);\n        }\n    }\n    toJulianDay(date) {\n        if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.toJulianDay(date);\n        return $f2f3e0e3a817edbd$var$CIVIL_EPOC + $f2f3e0e3a817edbd$var$umalquraMonthStart(date.year, date.month) + (date.day - 1);\n    }\n    getDaysInMonth(date) {\n        if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.getDaysInMonth(date);\n        return $f2f3e0e3a817edbd$var$umalquraMonthLength(date.year, date.month);\n    }\n    getDaysInYear(date) {\n        if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.getDaysInYear(date);\n        return $f2f3e0e3a817edbd$var$umalquraYearLength(date.year);\n    }\n    constructor(){\n        super();\n        this.identifier = \"islamic-umalqura\";\n        if (!$f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH) $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH = new Uint16Array(Uint8Array.from(atob($f2f3e0e3a817edbd$var$UMALQURA_DATA), (c)=>c.charCodeAt(0)).buffer);\n        if (!$f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE) {\n            $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE = new Uint32Array($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START + 1);\n            let yearStart = 0;\n            for(let year = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START; year <= $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END; year++){\n                $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] = yearStart;\n                for(let i = 1; i <= 12; i++)yearStart += $f2f3e0e3a817edbd$var$umalquraMonthLength(year, i);\n            }\n        }\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from ICU.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\n\nconst $7c5f6fbf42389787$var$HEBREW_EPOCH = 347997;\n// Hebrew date calculations are performed in terms of days, hours, and\n// \"parts\" (or halakim), which are 1/1080 of an hour, or 3 1/3 seconds.\nconst $7c5f6fbf42389787$var$HOUR_PARTS = 1080;\nconst $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;\n// An approximate value for the length of a lunar month.\n// It is used to calculate the approximate year and month of a given\n// absolute date.\nconst $7c5f6fbf42389787$var$MONTH_DAYS = 29;\nconst $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;\nconst $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;\nfunction $7c5f6fbf42389787$var$isLeapYear(year) {\n    return (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(year * 7 + 1, 19) < 7;\n}\n// Test for delay of start of new year and to avoid\n// Sunday, Wednesday, and Friday as start of the new year.\nfunction $7c5f6fbf42389787$var$hebrewDelay1(year) {\n    let months = Math.floor((235 * year - 234) / 19);\n    let parts = 12084 + 13753 * months;\n    let day = months * 29 + Math.floor(parts / 25920);\n    if ((0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(3 * (day + 1), 7) < 3) day += 1;\n    return day;\n}\n// Check for delay in start of new year due to length of adjacent years\nfunction $7c5f6fbf42389787$var$hebrewDelay2(year) {\n    let last = $7c5f6fbf42389787$var$hebrewDelay1(year - 1);\n    let present = $7c5f6fbf42389787$var$hebrewDelay1(year);\n    let next = $7c5f6fbf42389787$var$hebrewDelay1(year + 1);\n    if (next - present === 356) return 2;\n    if (present - last === 382) return 1;\n    return 0;\n}\nfunction $7c5f6fbf42389787$var$startOfYear(year) {\n    return $7c5f6fbf42389787$var$hebrewDelay1(year) + $7c5f6fbf42389787$var$hebrewDelay2(year);\n}\nfunction $7c5f6fbf42389787$var$getDaysInYear(year) {\n    return $7c5f6fbf42389787$var$startOfYear(year + 1) - $7c5f6fbf42389787$var$startOfYear(year);\n}\nfunction $7c5f6fbf42389787$var$getYearType(year) {\n    let yearLength = $7c5f6fbf42389787$var$getDaysInYear(year);\n    if (yearLength > 380) yearLength -= 30; // Subtract length of leap month.\n    switch(yearLength){\n        case 353:\n            return 0; // deficient\n        case 354:\n            return 1; // normal\n        case 355:\n            return 2; // complete\n    }\n}\nfunction $7c5f6fbf42389787$var$getDaysInMonth(year, month) {\n    // Normalize month numbers from 1 - 13, even on non-leap years\n    if (month >= 6 && !$7c5f6fbf42389787$var$isLeapYear(year)) month++;\n    // First of all, dispose of fixed-length 29 day months\n    if (month === 4 || month === 7 || month === 9 || month === 11 || month === 13) return 29;\n    let yearType = $7c5f6fbf42389787$var$getYearType(year);\n    // If it's Heshvan, days depend on length of year\n    if (month === 2) return yearType === 2 ? 30 : 29;\n    // Similarly, Kislev varies with the length of year\n    if (month === 3) return yearType === 0 ? 29 : 30;\n    // Adar I only exists in leap years\n    if (month === 6) return $7c5f6fbf42389787$var$isLeapYear(year) ? 30 : 0;\n    return 30;\n}\nclass $7c5f6fbf42389787$export$ca405048b8fb5af {\n    fromJulianDay(jd) {\n        let d = jd - $7c5f6fbf42389787$var$HEBREW_EPOCH;\n        let m = d * $7c5f6fbf42389787$var$DAY_PARTS / $7c5f6fbf42389787$var$MONTH_PARTS; // Months (approx)\n        let year = Math.floor((19 * m + 234) / 235) + 1; // Years (approx)\n        let ys = $7c5f6fbf42389787$var$startOfYear(year); // 1st day of year\n        let dayOfYear = Math.floor(d - ys);\n        // Because of the postponement rules, it's possible to guess wrong.  Fix it.\n        while(dayOfYear < 1){\n            year--;\n            ys = $7c5f6fbf42389787$var$startOfYear(year);\n            dayOfYear = Math.floor(d - ys);\n        }\n        // Now figure out which month we're in, and the date within that month\n        let month = 1;\n        let monthStart = 0;\n        while(monthStart < dayOfYear){\n            monthStart += $7c5f6fbf42389787$var$getDaysInMonth(year, month);\n            month++;\n        }\n        month--;\n        monthStart -= $7c5f6fbf42389787$var$getDaysInMonth(year, month);\n        let day = dayOfYear - monthStart;\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, year, month, day);\n    }\n    toJulianDay(date) {\n        let jd = $7c5f6fbf42389787$var$startOfYear(date.year);\n        for(let month = 1; month < date.month; month++)jd += $7c5f6fbf42389787$var$getDaysInMonth(date.year, month);\n        return jd + date.day + $7c5f6fbf42389787$var$HEBREW_EPOCH;\n    }\n    getDaysInMonth(date) {\n        return $7c5f6fbf42389787$var$getDaysInMonth(date.year, date.month);\n    }\n    getMonthsInYear(date) {\n        return $7c5f6fbf42389787$var$isLeapYear(date.year) ? 13 : 12;\n    }\n    getDaysInYear(date) {\n        return $7c5f6fbf42389787$var$getDaysInYear(date.year);\n    }\n    getYearsInEra() {\n        // 6239 gregorian\n        return 9999;\n    }\n    getEras() {\n        return [\n            \"AM\"\n        ];\n    }\n    balanceYearMonth(date, previousDate) {\n        // Keep date in the same month when switching between leap years and non leap years\n        if (previousDate.year !== date.year) {\n            if ($7c5f6fbf42389787$var$isLeapYear(previousDate.year) && !$7c5f6fbf42389787$var$isLeapYear(date.year) && previousDate.month > 6) date.month--;\n            else if (!$7c5f6fbf42389787$var$isLeapYear(previousDate.year) && $7c5f6fbf42389787$var$isLeapYear(date.year) && previousDate.month > 6) date.month++;\n        }\n    }\n    constructor(){\n        this.identifier = \"hebrew\";\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from ICU.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\nconst $b956b2d7a6cf451f$var$ETHIOPIC_EPOCH = 1723856;\nconst $b956b2d7a6cf451f$var$COPTIC_EPOCH = 1824665;\n// The delta between Amete Alem 1 and Amete Mihret 1\n// AA 5501 = AM 1\nconst $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA = 5500;\nfunction $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, month, day) {\n    return epoch // difference from Julian epoch to 1,1,1\n     + 365 * year // number of days from years\n     + Math.floor(year / 4) // extra day of leap year\n     + 30 * (month - 1 // number of days from months (1 based)\n    ) + day - 1 // number of days for present month (1 based)\n    ;\n}\nfunction $b956b2d7a6cf451f$var$julianDayToCE(epoch, jd) {\n    let year = Math.floor(4 * (jd - epoch) / 1461);\n    let month = 1 + Math.floor((jd - $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, 1, 1)) / 30);\n    let day = jd + 1 - $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, month, 1);\n    return [\n        year,\n        month,\n        day\n    ];\n}\nfunction $b956b2d7a6cf451f$var$getLeapDay(year) {\n    return Math.floor(year % 4 / 3);\n}\nfunction $b956b2d7a6cf451f$var$getDaysInMonth(year, month) {\n    // The Ethiopian and Coptic calendars have 13 months, 12 of 30 days each and\n    // an intercalary month at the end of the year of 5 or 6 days, depending whether\n    // the year is a leap year or not. The Leap Year follows the same rules as the\n    // Julian Calendar so that the extra month always has six days in the year before\n    // a Julian Leap Year.\n    if (month % 13 !== 0) // not intercalary month\n    return 30;\n    else // intercalary month 5 days + possible leap day\n    return $b956b2d7a6cf451f$var$getLeapDay(year) + 5;\n}\nclass $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {\n    fromJulianDay(jd) {\n        let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, jd);\n        let era = \"AM\";\n        if (year <= 0) {\n            era = \"AA\";\n            year += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;\n        }\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, era, year, month, day);\n    }\n    toJulianDay(date) {\n        let year = date.year;\n        if (date.era === \"AA\") year -= $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;\n        return $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, year, date.month, date.day);\n    }\n    getDaysInMonth(date) {\n        return $b956b2d7a6cf451f$var$getDaysInMonth(date.year, date.month);\n    }\n    getMonthsInYear() {\n        return 13;\n    }\n    getDaysInYear(date) {\n        return 365 + $b956b2d7a6cf451f$var$getLeapDay(date.year);\n    }\n    getYearsInEra(date) {\n        // 9999-12-31 gregorian is 9992-20-02 ethiopic.\n        // Round down to 9991 for the last full year.\n        // AA 9999-01-01 ethiopic is 4506-09-30 gregorian.\n        return date.era === \"AA\" ? 9999 : 9991;\n    }\n    getEras() {\n        return [\n            \"AA\",\n            \"AM\"\n        ];\n    }\n    constructor(){\n        this.identifier = \"ethiopic\";\n    }\n}\nclass $b956b2d7a6cf451f$export$d72e0c37005a4914 extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {\n    fromJulianDay(jd) {\n        let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, jd);\n        year += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, \"AA\", year, month, day);\n    }\n    getEras() {\n        return [\n            \"AA\"\n        ];\n    }\n    getYearsInEra() {\n        // 9999-13-04 ethioaa is the maximum date, which is equivalent to 4506-09-29 gregorian.\n        return 9999;\n    }\n    constructor(...args){\n        super(...args);\n        this.identifier = \"ethioaa\" // also known as 'ethiopic-amete-alem' in ICU\n        ;\n    }\n}\nclass $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1 extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {\n    fromJulianDay(jd) {\n        let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$COPTIC_EPOCH, jd);\n        let era = \"CE\";\n        if (year <= 0) {\n            era = \"BCE\";\n            year = 1 - year;\n        }\n        return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, era, year, month, day);\n    }\n    toJulianDay(date) {\n        let year = date.year;\n        if (date.era === \"BCE\") year = 1 - year;\n        return $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$COPTIC_EPOCH, year, date.month, date.day);\n    }\n    getDaysInMonth(date) {\n        let year = date.year;\n        if (date.era === \"BCE\") year = 1 - year;\n        return $b956b2d7a6cf451f$var$getDaysInMonth(year, date.month);\n    }\n    isInverseEra(date) {\n        return date.era === \"BCE\";\n    }\n    balanceDate(date) {\n        if (date.year <= 0) {\n            date.era = date.era === \"BCE\" ? \"CE\" : \"BCE\";\n            date.year = 1 - date.year;\n        }\n    }\n    getEras() {\n        return [\n            \"BCE\",\n            \"CE\"\n        ];\n    }\n    getYearsInEra(date) {\n        // 9999-12-30 gregorian is 9716-02-20 coptic.\n        // Round down to 9715 for the last full year.\n        // BCE 9999-01-01 coptic is BC 9716-06-15 gregorian.\n        return date.era === \"BCE\" ? 9999 : 9715;\n    }\n    constructor(...args){\n        super(...args);\n        this.identifier = \"coptic\";\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\n\n\n\n\nfunction $64244302c3013299$export$dd0bbc9b26defe37(name) {\n    switch(name){\n        case \"buddhist\":\n            return new (0, $8d73d47422ca7302$export$42d20a78301dee44)();\n        case \"ethiopic\":\n            return new (0, $b956b2d7a6cf451f$export$26ba6eab5e20cd7d)();\n        case \"ethioaa\":\n            return new (0, $b956b2d7a6cf451f$export$d72e0c37005a4914)();\n        case \"coptic\":\n            return new (0, $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1)();\n        case \"hebrew\":\n            return new (0, $7c5f6fbf42389787$export$ca405048b8fb5af)();\n        case \"indian\":\n            return new (0, $82c358003bdda0a8$export$39f31c639fa15726)();\n        case \"islamic-civil\":\n            return new (0, $f2f3e0e3a817edbd$export$2066795aadd37bfc)();\n        case \"islamic-tbla\":\n            return new (0, $f2f3e0e3a817edbd$export$37f0887f2f9d22f7)();\n        case \"islamic-umalqura\":\n            return new (0, $f2f3e0e3a817edbd$export$5baab4758c231076)();\n        case \"japanese\":\n            return new (0, $62225008020f0a13$export$b746ab2b60cdffbf)();\n        case \"persian\":\n            return new (0, $f3ed2e4472ae7e25$export$37fccdbfd14c5939)();\n        case \"roc\":\n            return new (0, $5f31bd6f0c8940b2$export$65e01080afcb0799)();\n        case \"gregory\":\n        default:\n            return new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();\n    }\n}\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $fb18d541ea1ad717$var$formatterCache = new Map();\nclass $fb18d541ea1ad717$export$ad991b66133851cf {\n    /** Formats a date as a string according to the locale and format options passed to the constructor. */ format(value) {\n        return this.formatter.format(value);\n    }\n    /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */ formatToParts(value) {\n        return this.formatter.formatToParts(value);\n    }\n    /** Formats a date range as a string. */ formatRange(start, end) {\n        // @ts-ignore\n        if (typeof this.formatter.formatRange === \"function\") // @ts-ignore\n        return this.formatter.formatRange(start, end);\n        if (end < start) throw new RangeError(\"End date must be >= start date\");\n        // Very basic fallback for old browsers.\n        return `${this.formatter.format(start)} \\u{2013} ${this.formatter.format(end)}`;\n    }\n    /** Formats a date range as an array of parts. */ formatRangeToParts(start, end) {\n        // @ts-ignore\n        if (typeof this.formatter.formatRangeToParts === \"function\") // @ts-ignore\n        return this.formatter.formatRangeToParts(start, end);\n        if (end < start) throw new RangeError(\"End date must be >= start date\");\n        let startParts = this.formatter.formatToParts(start);\n        let endParts = this.formatter.formatToParts(end);\n        return [\n            ...startParts.map((p)=>({\n                    ...p,\n                    source: \"startRange\"\n                })),\n            {\n                type: \"literal\",\n                value: \" \\u2013 \",\n                source: \"shared\"\n            },\n            ...endParts.map((p)=>({\n                    ...p,\n                    source: \"endRange\"\n                }))\n        ];\n    }\n    /** Returns the resolved formatting options based on the values passed to the constructor. */ resolvedOptions() {\n        let resolvedOptions = this.formatter.resolvedOptions();\n        if ($fb18d541ea1ad717$var$hasBuggyResolvedHourCycle()) {\n            if (!this.resolvedHourCycle) this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(resolvedOptions.locale, this.options);\n            resolvedOptions.hourCycle = this.resolvedHourCycle;\n            resolvedOptions.hour12 = this.resolvedHourCycle === \"h11\" || this.resolvedHourCycle === \"h12\";\n        }\n        // Safari uses a different name for the Ethiopic (Amete Alem) calendar.\n        // https://bugs.webkit.org/show_bug.cgi?id=241564\n        if (resolvedOptions.calendar === \"ethiopic-amete-alem\") resolvedOptions.calendar = \"ethioaa\";\n        return resolvedOptions;\n    }\n    constructor(locale, options = {}){\n        this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options);\n        this.options = options;\n    }\n}\n// There are multiple bugs involving the hour12 and hourCycle options in various browser engines.\n//   - Chrome [1] (and the ECMA 402 spec [2]) resolve hour12: false in English and other locales to h24 (24:00 - 23:59)\n//     rather than h23 (00:00 - 23:59). Same can happen with hour12: true in French, which Chrome resolves to h11 (00:00 - 11:59)\n//     rather than h12 (12:00 - 11:59).\n//   - WebKit returns an incorrect hourCycle resolved option in the French locale due to incorrect parsing of 'h' literal\n//     in the resolved pattern. It also formats incorrectly when specifying the hourCycle option for the same reason. [3]\n// [1] https://bugs.chromium.org/p/chromium/issues/detail?id=1045791\n// [2] https://github.com/tc39/ecma402/issues/402\n// [3] https://bugs.webkit.org/show_bug.cgi?id=229313\n// https://github.com/unicode-org/cldr/blob/018b55eff7ceb389c7e3fc44e2f657eae3b10b38/common/supplemental/supplementalData.xml#L4774-L4802\nconst $fb18d541ea1ad717$var$hour12Preferences = {\n    true: {\n        // Only Japanese uses the h11 style for 12 hour time. All others use h12.\n        ja: \"h11\"\n    },\n    false: {\n    }\n};\nfunction $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options = {}) {\n    // Work around buggy hour12 behavior in Chrome / ECMA 402 spec by using hourCycle instead.\n    // Only apply the workaround if the issue is detected, because the hourCycle option is buggy in Safari.\n    if (typeof options.hour12 === \"boolean\" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {\n        options = {\n            ...options\n        };\n        let pref = $fb18d541ea1ad717$var$hour12Preferences[String(options.hour12)][locale.split(\"-\")[0]];\n        let defaultHourCycle = options.hour12 ? \"h12\" : \"h23\";\n        options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;\n        delete options.hour12;\n    }\n    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : \"\");\n    if ($fb18d541ea1ad717$var$formatterCache.has(cacheKey)) return $fb18d541ea1ad717$var$formatterCache.get(cacheKey);\n    let numberFormatter = new Intl.DateTimeFormat(locale, options);\n    $fb18d541ea1ad717$var$formatterCache.set(cacheKey, numberFormatter);\n    return numberFormatter;\n}\nlet $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;\nfunction $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {\n    if ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null) $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat(\"en-US\", {\n        hour: \"numeric\",\n        hour12: false\n    }).format(new Date(2020, 2, 3, 0)) === \"24\";\n    return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;\n}\nlet $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;\nfunction $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {\n    if ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null) $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat(\"fr\", {\n        hour: \"numeric\",\n        hour12: false\n    }).resolvedOptions().hourCycle === \"h12\";\n    return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;\n}\nfunction $fb18d541ea1ad717$var$getResolvedHourCycle(locale, options) {\n    if (!options.timeStyle && !options.hour) return undefined;\n    // Work around buggy results in resolved hourCycle and hour12 options in WebKit.\n    // Format the minimum possible hour and maximum possible hour in a day and parse the results.\n    locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, \"\");\n    locale += (locale.includes(\"-u-\") ? \"\" : \"-u\") + \"-nu-latn\";\n    let formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, {\n        ...options,\n        timeZone: undefined // use local timezone\n    });\n    let min = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p)=>p.type === \"hour\").value, 10);\n    let max = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p)=>p.type === \"hour\").value, 10);\n    if (min === 0 && max === 23) return \"h23\";\n    if (min === 24 && max === 23) return \"h24\";\n    if (min === 0 && max === 11) return \"h11\";\n    if (min === 12 && max === 11) return \"h12\";\n    throw new Error(\"Unexpected hour cycle result\");\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGludGVybmF0aW9uYWxpemVkL2RhdGUvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpRkFBaUY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUVBQXVFO0FBQ3RHO0FBQ0EsaUJBQWlCLHVFQUF1RTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsNENBQTRDLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRTtBQUN0RSw0Q0FBNEMsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO0FBQzlELGlEQUFpRCxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUU7QUFDeEcsdURBQXVELEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxzQkFBc0IsRUFBRSxVQUFVLEVBQUU7QUFDbEosZ0RBQWdELEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSx5QkFBeUIsRUFBRSxVQUFVLEVBQUU7QUFDOUksK0tBQStLLElBQUksMkJBQTJCLElBQUksMkJBQTJCLElBQUk7QUFDalA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxtREFBbUQsaUJBQWlCLGlEQUFpRCxLQUFLLGNBQWM7QUFDdk0sTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsS0FBSyxLQUFLLEtBQUssS0FBSyxJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUNBQW1DLEdBQUcscUNBQXFDLEdBQUcscUNBQXFDLEVBQUUsaUVBQWlFO0FBQ3BNO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNENBQTRDLEdBQUcsNkNBQTZDLEdBQUcsMkNBQTJDO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0RBQWdELEdBQUcsZ0RBQWdEO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSyxFQUFFLHFDQUFxQyxHQUFHLHVDQUF1QztBQUNwRztBQUNBO0FBQ0EsY0FBYyxnREFBZ0QsRUFBRSxrREFBa0QsR0FBRyxjQUFjO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpRUFBaUUsTUFBTTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUZBQWlGLE1BQU07QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpR0FBaUcsTUFBTTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlLQUFpSyxPQUFPO0FBQ3hLLCtJQUErSSxPQUFPO0FBQ3RKO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvRUFBUTtBQUNwQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9FQUFRO0FBQ3BCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0VBQVE7QUFDcEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvRUFBUTtBQUNwQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtEO0FBQ2xELHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsaURBQWlEO0FBQ3ZIO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6Rix5REFBeUQ7QUFDekQsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCLEdBQUcsTUFBTSxFQUFFLDJCQUEyQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBSysvRztBQUMvL0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFybnR1YmUtMS4wLy4vbm9kZV9tb2R1bGVzL0BpbnRlcm5hdGlvbmFsaXplZC9kYXRlL2Rpc3QvaW1wb3J0Lm1qcz80ODExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XyBhcyAkY1VWdU4kX30gZnJvbSBcIkBzd2MvaGVscGVycy9fL19jbGFzc19wcml2YXRlX2ZpZWxkX2luaXRcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gdGhlIFRDMzkgVGVtcG9yYWwgcHJvcG9zYWwuXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgY2FuIGJlIGZvdW5kIGluIHRoZSBOT1RJQ0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gSUNVLlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGNhbiBiZSBmb3VuZCBpbiB0aGUgTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQ4NDJhMmNmMzdhZjk3N2UxKGFtb3VudCwgbnVtZXJhdG9yKSB7XG4gICAgcmV0dXJuIGFtb3VudCAtIG51bWVyYXRvciAqIE1hdGguZmxvb3IoYW1vdW50IC8gbnVtZXJhdG9yKTtcbn1cbmZ1bmN0aW9uICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQ3ODRkMTNkOGVlMzUxZjA3KGRhdGUpIHtcbiAgICBpZiAoZGF0ZS5lcmEpIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKShkYXRlLmNhbGVuZGFyLCBkYXRlLmVyYSwgZGF0ZS55ZWFyLCBkYXRlLm1vbnRoLCBkYXRlLmRheSk7XG4gICAgZWxzZSByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikoZGF0ZS5jYWxlbmRhciwgZGF0ZS55ZWFyLCBkYXRlLm1vbnRoLCBkYXRlLmRheSk7XG59XG5mdW5jdGlvbiAkMmI0ZGNlMTNkZDVhMTdmYSRleHBvcnQkMjdmYTAxNzJhZTI2NDRiMyhkYXRlKSB7XG4gICAgaWYgKGRhdGUuZXJhKSByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkY2E4NzFlOGRiYjgwOTY2ZikoZGF0ZS5jYWxlbmRhciwgZGF0ZS5lcmEsIGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXksIGRhdGUuaG91ciwgZGF0ZS5taW51dGUsIGRhdGUuc2Vjb25kLCBkYXRlLm1pbGxpc2Vjb25kKTtcbiAgICBlbHNlIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRjYTg3MWU4ZGJiODA5NjZmKShkYXRlLmNhbGVuZGFyLCBkYXRlLnllYXIsIGRhdGUubW9udGgsIGRhdGUuZGF5LCBkYXRlLmhvdXIsIGRhdGUubWludXRlLCBkYXRlLnNlY29uZCk7XG59XG5cblxuY29uc3QgJDNiNjIwNzRlYjA1NTg0YjIkdmFyJEVQT0NIID0gMTcyMTQyNjsgLy8gMDAxLzAxLzAzIEp1bGlhbiBDLkUuXG5mdW5jdGlvbiAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkZjI5N2ViODM5MDA2ZDMzOShlcmEsIHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICB5ZWFyID0gJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGMzNmUwZWNiMmQ0ZmE2OWQoZXJhLCB5ZWFyKTtcbiAgICBsZXQgeTEgPSB5ZWFyIC0gMTtcbiAgICBsZXQgbW9udGhPZmZzZXQgPSAtMjtcbiAgICBpZiAobW9udGggPD0gMikgbW9udGhPZmZzZXQgPSAwO1xuICAgIGVsc2UgaWYgKCQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ1NTNkN2ZhOGUzODA1ZmMwKHllYXIpKSBtb250aE9mZnNldCA9IC0xO1xuICAgIHJldHVybiAkM2I2MjA3NGViMDU1ODRiMiR2YXIkRVBPQ0ggLSAxICsgMzY1ICogeTEgKyBNYXRoLmZsb29yKHkxIC8gNCkgLSBNYXRoLmZsb29yKHkxIC8gMTAwKSArIE1hdGguZmxvb3IoeTEgLyA0MDApICsgTWF0aC5mbG9vcigoMzY3ICogbW9udGggLSAzNjIpIC8gMTIgKyBtb250aE9mZnNldCArIGRheSk7XG59XG5mdW5jdGlvbiAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkNTUzZDdmYThlMzgwNWZjMCh5ZWFyKSB7XG4gICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuZnVuY3Rpb24gJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGMzNmUwZWNiMmQ0ZmE2OWQoZXJhLCB5ZWFyKSB7XG4gICAgcmV0dXJuIGVyYSA9PT0gXCJCQ1wiID8gMSAtIHllYXIgOiB5ZWFyO1xufVxuZnVuY3Rpb24gJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDQ0NzViN2U2MTdlYjEyM2MoeWVhcikge1xuICAgIGxldCBlcmEgPSBcIkFEXCI7XG4gICAgaWYgKHllYXIgPD0gMCkge1xuICAgICAgICBlcmEgPSBcIkJDXCI7XG4gICAgICAgIHllYXIgPSAxIC0geWVhcjtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZXJhLFxuICAgICAgICB5ZWFyXG4gICAgXTtcbn1cbmNvbnN0ICQzYjYyMDc0ZWIwNTU4NGIyJHZhciRkYXlzSW5Nb250aCA9IHtcbiAgICBzdGFuZGFyZDogW1xuICAgICAgICAzMSxcbiAgICAgICAgMjgsXG4gICAgICAgIDMxLFxuICAgICAgICAzMCxcbiAgICAgICAgMzEsXG4gICAgICAgIDMwLFxuICAgICAgICAzMSxcbiAgICAgICAgMzEsXG4gICAgICAgIDMwLFxuICAgICAgICAzMSxcbiAgICAgICAgMzAsXG4gICAgICAgIDMxXG4gICAgXSxcbiAgICBsZWFweWVhcjogW1xuICAgICAgICAzMSxcbiAgICAgICAgMjksXG4gICAgICAgIDMxLFxuICAgICAgICAzMCxcbiAgICAgICAgMzEsXG4gICAgICAgIDMwLFxuICAgICAgICAzMSxcbiAgICAgICAgMzEsXG4gICAgICAgIDMwLFxuICAgICAgICAzMSxcbiAgICAgICAgMzAsXG4gICAgICAgIDMxXG4gICAgXVxufTtcbmNsYXNzICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjIHtcbiAgICBmcm9tSnVsaWFuRGF5KGpkKSB7XG4gICAgICAgIGxldCBqZDAgPSBqZDtcbiAgICAgICAgbGV0IGRlcG9jaCA9IGpkMCAtICQzYjYyMDc0ZWIwNTU4NGIyJHZhciRFUE9DSDtcbiAgICAgICAgbGV0IHF1YWRyaWNlbnQgPSBNYXRoLmZsb29yKGRlcG9jaCAvIDE0NjA5Nyk7XG4gICAgICAgIGxldCBkcWMgPSAoMCwgJDJiNGRjZTEzZGQ1YTE3ZmEkZXhwb3J0JDg0MmEyY2YzN2FmOTc3ZTEpKGRlcG9jaCwgMTQ2MDk3KTtcbiAgICAgICAgbGV0IGNlbnQgPSBNYXRoLmZsb29yKGRxYyAvIDM2NTI0KTtcbiAgICAgICAgbGV0IGRjZW50ID0gKDAsICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQ4NDJhMmNmMzdhZjk3N2UxKShkcWMsIDM2NTI0KTtcbiAgICAgICAgbGV0IHF1YWQgPSBNYXRoLmZsb29yKGRjZW50IC8gMTQ2MSk7XG4gICAgICAgIGxldCBkcXVhZCA9ICgwLCAkMmI0ZGNlMTNkZDVhMTdmYSRleHBvcnQkODQyYTJjZjM3YWY5NzdlMSkoZGNlbnQsIDE0NjEpO1xuICAgICAgICBsZXQgeWluZGV4ID0gTWF0aC5mbG9vcihkcXVhZCAvIDM2NSk7XG4gICAgICAgIGxldCBleHRlbmRlZFllYXIgPSBxdWFkcmljZW50ICogNDAwICsgY2VudCAqIDEwMCArIHF1YWQgKiA0ICsgeWluZGV4ICsgKGNlbnQgIT09IDQgJiYgeWluZGV4ICE9PSA0ID8gMSA6IDApO1xuICAgICAgICBsZXQgW2VyYSwgeWVhcl0gPSAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkNDQ3NWI3ZTYxN2ViMTIzYyhleHRlbmRlZFllYXIpO1xuICAgICAgICBsZXQgeWVhckRheSA9IGpkMCAtICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCRmMjk3ZWI4MzkwMDZkMzM5KGVyYSwgeWVhciwgMSwgMSk7XG4gICAgICAgIGxldCBsZWFwQWRqID0gMjtcbiAgICAgICAgaWYgKGpkMCA8ICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCRmMjk3ZWI4MzkwMDZkMzM5KGVyYSwgeWVhciwgMywgMSkpIGxlYXBBZGogPSAwO1xuICAgICAgICBlbHNlIGlmICgkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkNTUzZDdmYThlMzgwNWZjMCh5ZWFyKSkgbGVhcEFkaiA9IDE7XG4gICAgICAgIGxldCBtb250aCA9IE1hdGguZmxvb3IoKCh5ZWFyRGF5ICsgbGVhcEFkaikgKiAxMiArIDM3MykgLyAzNjcpO1xuICAgICAgICBsZXQgZGF5ID0gamQwIC0gJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGYyOTdlYjgzOTAwNmQzMzkoZXJhLCB5ZWFyLCBtb250aCwgMSkgKyAxO1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikoZXJhLCB5ZWFyLCBtb250aCwgZGF5KTtcbiAgICB9XG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xuICAgICAgICByZXR1cm4gJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGYyOTdlYjgzOTAwNmQzMzkoZGF0ZS5lcmEsIGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXkpO1xuICAgIH1cbiAgICBnZXREYXlzSW5Nb250aChkYXRlKSB7XG4gICAgICAgIHJldHVybiAkM2I2MjA3NGViMDU1ODRiMiR2YXIkZGF5c0luTW9udGhbJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDU1M2Q3ZmE4ZTM4MDVmYzAoZGF0ZS55ZWFyKSA/IFwibGVhcHllYXJcIiA6IFwic3RhbmRhcmRcIl1bZGF0ZS5tb250aCAtIDFdO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgZ2V0TW9udGhzSW5ZZWFyKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIDEyO1xuICAgIH1cbiAgICBnZXREYXlzSW5ZZWFyKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ1NTNkN2ZhOGUzODA1ZmMwKGRhdGUueWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBnZXRZZWFyc0luRXJhKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIDk5OTk7XG4gICAgfVxuICAgIGdldEVyYXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBcIkJDXCIsXG4gICAgICAgICAgICBcIkFEXCJcbiAgICAgICAgXTtcbiAgICB9XG4gICAgaXNJbnZlcnNlRXJhKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZXJhID09PSBcIkJDXCI7XG4gICAgfVxuICAgIGJhbGFuY2VEYXRlKGRhdGUpIHtcbiAgICAgICAgaWYgKGRhdGUueWVhciA8PSAwKSB7XG4gICAgICAgICAgICBkYXRlLmVyYSA9IGRhdGUuZXJhID09PSBcIkJDXCIgPyBcIkFEXCIgOiBcIkJDXCI7XG4gICAgICAgICAgICBkYXRlLnllYXIgPSAxIC0gZGF0ZS55ZWFyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IFwiZ3JlZ29yeVwiO1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gRGF0YSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS91bmljb2RlLWNsZHIvY2xkci1jb3JlL2Jsb2IvbWFzdGVyL3N1cHBsZW1lbnRhbC93ZWVrRGF0YS5qc29uXG4vLyBMb2NhbGVzIHN0YXJ0aW5nIG9uIFN1bmRheSBoYXZlIGJlZW4gcmVtb3ZlZCBmb3IgY29tcHJlc3Npb24uXG5jb25zdCAkMmZlMjg2ZDJmYjQ0OWFiYiRleHBvcnQkN2E1YWNiZDc3ZDQxNGJkOSA9IHtcbiAgICBcIjAwMVwiOiAxLFxuICAgIEFEOiAxLFxuICAgIEFFOiA2LFxuICAgIEFGOiA2LFxuICAgIEFJOiAxLFxuICAgIEFMOiAxLFxuICAgIEFNOiAxLFxuICAgIEFOOiAxLFxuICAgIEFSOiAxLFxuICAgIEFUOiAxLFxuICAgIEFVOiAxLFxuICAgIEFYOiAxLFxuICAgIEFaOiAxLFxuICAgIEJBOiAxLFxuICAgIEJFOiAxLFxuICAgIEJHOiAxLFxuICAgIEJIOiA2LFxuICAgIEJNOiAxLFxuICAgIEJOOiAxLFxuICAgIEJZOiAxLFxuICAgIENIOiAxLFxuICAgIENMOiAxLFxuICAgIENNOiAxLFxuICAgIENOOiAxLFxuICAgIENSOiAxLFxuICAgIENZOiAxLFxuICAgIENaOiAxLFxuICAgIERFOiAxLFxuICAgIERKOiA2LFxuICAgIERLOiAxLFxuICAgIERaOiA2LFxuICAgIEVDOiAxLFxuICAgIEVFOiAxLFxuICAgIEVHOiA2LFxuICAgIEVTOiAxLFxuICAgIEZJOiAxLFxuICAgIEZKOiAxLFxuICAgIEZPOiAxLFxuICAgIEZSOiAxLFxuICAgIEdCOiAxLFxuICAgIEdFOiAxLFxuICAgIEdGOiAxLFxuICAgIEdQOiAxLFxuICAgIEdSOiAxLFxuICAgIEhSOiAxLFxuICAgIEhVOiAxLFxuICAgIElFOiAxLFxuICAgIElROiA2LFxuICAgIElSOiA2LFxuICAgIElTOiAxLFxuICAgIElUOiAxLFxuICAgIEpPOiA2LFxuICAgIEtHOiAxLFxuICAgIEtXOiA2LFxuICAgIEtaOiAxLFxuICAgIExCOiAxLFxuICAgIExJOiAxLFxuICAgIExLOiAxLFxuICAgIExUOiAxLFxuICAgIExVOiAxLFxuICAgIExWOiAxLFxuICAgIExZOiA2LFxuICAgIE1DOiAxLFxuICAgIE1EOiAxLFxuICAgIE1FOiAxLFxuICAgIE1LOiAxLFxuICAgIE1OOiAxLFxuICAgIE1ROiAxLFxuICAgIE1WOiA1LFxuICAgIE1ZOiAxLFxuICAgIE5MOiAxLFxuICAgIE5POiAxLFxuICAgIE5aOiAxLFxuICAgIE9NOiA2LFxuICAgIFBMOiAxLFxuICAgIFFBOiA2LFxuICAgIFJFOiAxLFxuICAgIFJPOiAxLFxuICAgIFJTOiAxLFxuICAgIFJVOiAxLFxuICAgIFNEOiA2LFxuICAgIFNFOiAxLFxuICAgIFNJOiAxLFxuICAgIFNLOiAxLFxuICAgIFNNOiAxLFxuICAgIFNZOiA2LFxuICAgIFRKOiAxLFxuICAgIFRNOiAxLFxuICAgIFRSOiAxLFxuICAgIFVBOiAxLFxuICAgIFVZOiAxLFxuICAgIFVaOiAxLFxuICAgIFZBOiAxLFxuICAgIFZOOiAxLFxuICAgIFhLOiAxXG59O1xuXG5cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRlYTM5ZWMxOTc5OTNhZWYwKGEsIGIpIHtcbiAgICBiID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKShiLCBhLmNhbGVuZGFyKTtcbiAgICByZXR1cm4gYS5lcmEgPT09IGIuZXJhICYmIGEueWVhciA9PT0gYi55ZWFyICYmIGEubW9udGggPT09IGIubW9udGggJiYgYS5kYXkgPT09IGIuZGF5O1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGExOGM4OWNiZDI0MTcwZmYoYSwgYikge1xuICAgIGIgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIpKGIsIGEuY2FsZW5kYXIpO1xuICAgIC8vIEluIHRoZSBKYXBhbmVzZSBjYWxlbmRhciwgbW9udGhzIGNhbiBzcGFuIG11bHRpcGxlIGVyYXMveWVhcnMsIHNvIG9ubHkgY29tcGFyZSB0aGUgZmlyc3Qgb2YgdGhlIG1vbnRoLlxuICAgIGEgPSAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYTVhM2I0NTRhZGEyMjY4ZShhKTtcbiAgICBiID0gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE1YTNiNDU0YWRhMjI2OGUoYik7XG4gICAgcmV0dXJuIGEuZXJhID09PSBiLmVyYSAmJiBhLnllYXIgPT09IGIueWVhciAmJiBhLm1vbnRoID09PSBiLm1vbnRoO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDU4NDFmOWViOTc3M2YyNWYoYSwgYikge1xuICAgIGIgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIpKGIsIGEuY2FsZW5kYXIpO1xuICAgIGEgPSAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZjkxZTg5ZDNkMDQwNjEwMihhKTtcbiAgICBiID0gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGY5MWU4OWQzZDA0MDYxMDIoYik7XG4gICAgcmV0dXJuIGEuZXJhID09PSBiLmVyYSAmJiBhLnllYXIgPT09IGIueWVhcjtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ5MWI2MmViZjJiYTcwM2VlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5jYWxlbmRhci5pZGVudGlmaWVyID09PSBiLmNhbGVuZGFyLmlkZW50aWZpZXIgJiYgYS5lcmEgPT09IGIuZXJhICYmIGEueWVhciA9PT0gYi55ZWFyICYmIGEubW9udGggPT09IGIubW9udGggJiYgYS5kYXkgPT09IGIuZGF5O1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDVhOGRhMGM0NGEzYWZkZjIoYSwgYikge1xuICAgIGEgPSAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYTVhM2I0NTRhZGEyMjY4ZShhKTtcbiAgICBiID0gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE1YTNiNDU0YWRhMjI2OGUoYik7XG4gICAgcmV0dXJuIGEuY2FsZW5kYXIuaWRlbnRpZmllciA9PT0gYi5jYWxlbmRhci5pZGVudGlmaWVyICYmIGEuZXJhID09PSBiLmVyYSAmJiBhLnllYXIgPT09IGIueWVhciAmJiBhLm1vbnRoID09PSBiLm1vbnRoO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGVhODQwZjVhNmRkYTgxNDcoYSwgYikge1xuICAgIGEgPSAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZjkxZTg5ZDNkMDQwNjEwMihhKTtcbiAgICBiID0gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGY5MWU4OWQzZDA0MDYxMDIoYik7XG4gICAgcmV0dXJuIGEuY2FsZW5kYXIuaWRlbnRpZmllciA9PT0gYi5jYWxlbmRhci5pZGVudGlmaWVyICYmIGEuZXJhID09PSBiLmVyYSAmJiBhLnllYXIgPT09IGIueWVhcjtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ2MjliMGE0OTdhYTY1MjY3KGRhdGUsIHRpbWVab25lKSB7XG4gICAgcmV0dXJuICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRlYTM5ZWMxOTc5OTNhZWYwKGRhdGUsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRkMGJkZjQ1YWYwM2E2ZWEzKHRpbWVab25lKSk7XG59XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkMjA2MTA1NmQwNmQ3Y2RmNyhkYXRlLCBsb2NhbGUpIHtcbiAgICBsZXQganVsaWFuID0gZGF0ZS5jYWxlbmRhci50b0p1bGlhbkRheShkYXRlKTtcbiAgICAvLyBJZiBqdWxpYW4gaXMgbmVnYXRpdmUsIHRoZW4ganVsaWFuICUgNyB3aWxsIGJlIG5lZ2F0aXZlLCBzbyB3ZSBhZGp1c3RcbiAgICAvLyBhY2NvcmRpbmdseS4gIEp1bGlhbiBkYXkgMCBpcyBNb25kYXkuXG4gICAgbGV0IGRheU9mV2VlayA9IE1hdGguY2VpbChqdWxpYW4gKyAxIC0gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJGdldFdlZWtTdGFydChsb2NhbGUpKSAlIDc7XG4gICAgaWYgKGRheU9mV2VlayA8IDApIGRheU9mV2VlayArPSA3O1xuICAgIHJldHVybiBkYXlPZldlZWs7XG59XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNDYxOTM5ZGQ0NDIyMTUzKHRpbWVab25lKSB7XG4gICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMWI5NjY5MmExYmEwNDJhYykoRGF0ZS5ub3coKSwgdGltZVpvbmUpO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGQwYmRmNDVhZjAzYTZlYTModGltZVpvbmUpIHtcbiAgICByZXR1cm4gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ5MzUyMmQxYTQzOWYzNjE3KSgkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNDYxOTM5ZGQ0NDIyMTUzKHRpbWVab25lKSk7XG59XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNjg3ODFkZGYzMWMwMDkwZihhLCBiKSB7XG4gICAgcmV0dXJuIGEuY2FsZW5kYXIudG9KdWxpYW5EYXkoYSkgLSBiLmNhbGVuZGFyLnRvSnVsaWFuRGF5KGIpO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGMxOWE4MGE5NzIxYjgwZjYoYSwgYikge1xuICAgIHJldHVybiAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkdGltZVRvTXMoYSkgLSAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkdGltZVRvTXMoYik7XG59XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkdGltZVRvTXMoYSkge1xuICAgIHJldHVybiBhLmhvdXIgKiAzNjAwMDAwICsgYS5taW51dGUgKiA2MDAwMCArIGEuc2Vjb25kICogMTAwMCArIGEubWlsbGlzZWNvbmQ7XG59XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkMTI2YzkxYzk0MWRlN2UoYSwgdGltZVpvbmUpIHtcbiAgICBsZXQgbXMgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUxMDdjODJmOTQ1MThmNWMpKGEsIHRpbWVab25lKTtcbiAgICBsZXQgdG9tb3Jyb3cgPSBhLmFkZCh7XG4gICAgICAgIGRheXM6IDFcbiAgICB9KTtcbiAgICBsZXQgdG9tb3Jyb3dNcyA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YykodG9tb3Jyb3csIHRpbWVab25lKTtcbiAgICByZXR1cm4gKHRvbW9ycm93TXMgLSBtcykgLyAzNjAwMDAwO1xufVxubGV0ICQxNGUwZjI0ZWY0YWM1YzkyJHZhciRsb2NhbFRpbWVab25lID0gbnVsbDtcbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhYThiNDE3MzVhZmNhYmQyKCkge1xuICAgIC8vIFRPRE86IGludmFsaWRhdGUgdGhpcyBzb21laG93P1xuICAgIGlmICgkMTRlMGYyNGVmNGFjNWM5MiR2YXIkbG9jYWxUaW1lWm9uZSA9PSBudWxsKSAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkbG9jYWxUaW1lWm9uZSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XG4gICAgcmV0dXJuICQxNGUwZjI0ZWY0YWM1YzkyJHZhciRsb2NhbFRpbWVab25lO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE1YTNiNDU0YWRhMjI2OGUoZGF0ZSkge1xuICAgIC8vIFVzZSBgc3VidHJhY3RgIGluc3RlYWQgb2YgYHNldGAgc28gd2UgZG9uJ3QgZ2V0IGNvbnN0cmFpbmVkIGluIGFuIGVyYS5cbiAgICByZXR1cm4gZGF0ZS5zdWJ0cmFjdCh7XG4gICAgICAgIGRheXM6IGRhdGUuZGF5IC0gMVxuICAgIH0pO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGEyMjU4ZDljNDExODgyNWMoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmFkZCh7XG4gICAgICAgIGRheXM6IGRhdGUuY2FsZW5kYXIuZ2V0RGF5c0luTW9udGgoZGF0ZSkgLSBkYXRlLmRheVxuICAgIH0pO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGY5MWU4OWQzZDA0MDYxMDIoZGF0ZSkge1xuICAgIHJldHVybiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYTVhM2I0NTRhZGEyMjY4ZShkYXRlLnN1YnRyYWN0KHtcbiAgICAgICAgbW9udGhzOiBkYXRlLm1vbnRoIC0gMVxuICAgIH0pKTtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ4YjdhYTU1YzY2ZDU1NjllKGRhdGUpIHtcbiAgICByZXR1cm4gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGEyMjU4ZDljNDExODgyNWMoZGF0ZS5hZGQoe1xuICAgICAgICBtb250aHM6IGRhdGUuY2FsZW5kYXIuZ2V0TW9udGhzSW5ZZWFyKGRhdGUpIC0gZGF0ZS5tb250aFxuICAgIH0pKTtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1NDEyYWMxMTcxM2I3MmFkKGRhdGUpIHtcbiAgICBpZiAoZGF0ZS5jYWxlbmRhci5nZXRNaW5pbXVtTW9udGhJblllYXIpIHJldHVybiBkYXRlLmNhbGVuZGFyLmdldE1pbmltdW1Nb250aEluWWVhcihkYXRlKTtcbiAgICByZXR1cm4gMTtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRiMmY0OTUzZDMwMTk4MWQ1KGRhdGUpIHtcbiAgICBpZiAoZGF0ZS5jYWxlbmRhci5nZXRNaW5pbXVtRGF5SW5Nb250aCkgcmV0dXJuIGRhdGUuY2FsZW5kYXIuZ2V0TWluaW11bURheUluTW9udGgoZGF0ZSk7XG4gICAgcmV0dXJuIDE7XG59XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNDJjODFhNDQ0ZmJmYjVkNChkYXRlLCBsb2NhbGUpIHtcbiAgICBsZXQgZGF5T2ZXZWVrID0gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDIwNjEwNTZkMDZkN2NkZjcoZGF0ZSwgbG9jYWxlKTtcbiAgICByZXR1cm4gZGF0ZS5zdWJ0cmFjdCh7XG4gICAgICAgIGRheXM6IGRheU9mV2Vla1xuICAgIH0pO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGVmOGI2ZDkxMzMwODRmNGUoZGF0ZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ0MmM4MWE0NDRmYmZiNWQ0KGRhdGUsIGxvY2FsZSkuYWRkKHtcbiAgICAgICAgZGF5czogNlxuICAgIH0pO1xufVxuY29uc3QgJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJGNhY2hlZFJlZ2lvbnMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkZ2V0UmVnaW9uKGxvY2FsZSkge1xuICAgIC8vIElmIHRoZSBJbnRsLkxvY2FsZSBBUEkgaXMgYXZhaWxhYmxlLCB1c2UgaXQgdG8gZ2V0IHRoZSByZWdpb24gZm9yIHRoZSBsb2NhbGUuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChJbnRsLkxvY2FsZSkge1xuICAgICAgICAvLyBDb25zdHJ1Y3RpbmcgYW4gSW50bC5Mb2NhbGUgaXMgZXhwZW5zaXZlLCBzbyBjYWNoZSB0aGUgcmVzdWx0LlxuICAgICAgICBsZXQgcmVnaW9uID0gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJGNhY2hlZFJlZ2lvbnMuZ2V0KGxvY2FsZSk7XG4gICAgICAgIGlmICghcmVnaW9uKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZWdpb24gPSBuZXcgSW50bC5Mb2NhbGUobG9jYWxlKS5tYXhpbWl6ZSgpLnJlZ2lvbjtcbiAgICAgICAgICAgIGlmIChyZWdpb24pICQxNGUwZjI0ZWY0YWM1YzkyJHZhciRjYWNoZWRSZWdpb25zLnNldChsb2NhbGUsIHJlZ2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZ2lvbjtcbiAgICB9XG4gICAgLy8gSWYgbm90LCBqdXN0IHRyeSBzcGxpdHRpbmcgdGhlIHN0cmluZy5cbiAgICAvLyBJZiB0aGUgc2Vjb25kIHBhcnQgb2YgdGhlIGxvY2FsZSBzdHJpbmcgaXMgJ3UnLFxuICAgIC8vIHRoZW4gdGhpcyBpcyBhIHVuaWNvZGUgZXh0ZW5zaW9uLCBzbyBpZ25vcmUgaXQuXG4gICAgLy8gT3RoZXJ3aXNlLCBpdCBzaG91bGQgYmUgdGhlIHJlZ2lvbi5cbiAgICBsZXQgcGFydCA9IGxvY2FsZS5zcGxpdChcIi1cIilbMV07XG4gICAgcmV0dXJuIHBhcnQgPT09IFwidVwiID8gdW5kZWZpbmVkIDogcGFydDtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJHZhciRnZXRXZWVrU3RhcnQobG9jYWxlKSB7XG4gICAgLy8gVE9ETzogdXNlIEludGwuTG9jYWxlIGZvciB0aGlzIG9uY2UgYnJvd3NlcnMgc3VwcG9ydCB0aGUgd2Vla0luZm8gcHJvcGVydHlcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1pbnRsLWxvY2FsZS1pbmZvXG4gICAgbGV0IHJlZ2lvbiA9ICQxNGUwZjI0ZWY0YWM1YzkyJHZhciRnZXRSZWdpb24obG9jYWxlKTtcbiAgICByZXR1cm4gcmVnaW9uID8gKDAsICQyZmUyODZkMmZiNDQ5YWJiJGV4cG9ydCQ3YTVhY2JkNzdkNDE0YmQ5KVtyZWdpb25dIHx8IDAgOiAwO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGNjYzFiMjQ3OWU3ZGQ2NTQoZGF0ZSwgbG9jYWxlKSB7XG4gICAgbGV0IGRheXMgPSBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoKCQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQyMDYxMDU2ZDA2ZDdjZGY3KCQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhNWEzYjQ1NGFkYTIyNjhlKGRhdGUpLCBsb2NhbGUpICsgZGF5cykgLyA3KTtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1YzMzM2ExMTZlOTQ5Y2RkKGEsIGIpIHtcbiAgICBpZiAoYSAmJiBiKSByZXR1cm4gYS5jb21wYXJlKGIpIDw9IDAgPyBhIDogYjtcbiAgICByZXR1cm4gYSB8fCBiO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE3NWYyYmZmNTc4MTEwNTUoYSwgYikge1xuICAgIGlmIChhICYmIGIpIHJldHVybiBhLmNvbXBhcmUoYikgPj0gMCA/IGEgOiBiO1xuICAgIHJldHVybiBhIHx8IGI7XG59XG5jb25zdCAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkV0VFS0VORF9EQVRBID0ge1xuICAgIEFGOiBbXG4gICAgICAgIDQsXG4gICAgICAgIDVcbiAgICBdLFxuICAgIEFFOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIEJIOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIERaOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIEVHOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIElMOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIElROiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIElSOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDVcbiAgICBdLFxuICAgIEpPOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIEtXOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIExZOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIE9NOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIFFBOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIFNBOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIFNEOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIFNZOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIFlFOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdXG59O1xuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDYxOGQ2MGVhMjk5ZGE0MihkYXRlLCBsb2NhbGUpIHtcbiAgICBsZXQganVsaWFuID0gZGF0ZS5jYWxlbmRhci50b0p1bGlhbkRheShkYXRlKTtcbiAgICAvLyBJZiBqdWxpYW4gaXMgbmVnYXRpdmUsIHRoZW4ganVsaWFuICUgNyB3aWxsIGJlIG5lZ2F0aXZlLCBzbyB3ZSBhZGp1c3RcbiAgICAvLyBhY2NvcmRpbmdseS4gIEp1bGlhbiBkYXkgMCBpcyBNb25kYXkuXG4gICAgbGV0IGRheU9mV2VlayA9IE1hdGguY2VpbChqdWxpYW4gKyAxKSAlIDc7XG4gICAgaWYgKGRheU9mV2VlayA8IDApIGRheU9mV2VlayArPSA3O1xuICAgIGxldCByZWdpb24gPSAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkZ2V0UmVnaW9uKGxvY2FsZSk7XG4gICAgLy8gVXNlIEludGwuTG9jYWxlIGZvciB0aGlzIG9uY2Ugd2Vla0luZm8gaXMgc3VwcG9ydGVkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWludGwtbG9jYWxlLWluZm9cbiAgICBsZXQgW3N0YXJ0LCBlbmRdID0gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJFdFRUtFTkRfREFUQVtyZWdpb25dIHx8IFtcbiAgICAgICAgNixcbiAgICAgICAgMFxuICAgIF07XG4gICAgcmV0dXJuIGRheU9mV2VlayA9PT0gc3RhcnQgfHwgZGF5T2ZXZWVrID09PSBlbmQ7XG59XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZWU5ZDg3MjU4ZTFkMTllZChkYXRlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gISQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ2MThkNjBlYTI5OWRhNDIoZGF0ZSwgbG9jYWxlKTtcbn1cblxuXG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYmQ0ZmIyYmM4YmIwNmZiKGRhdGUpIHtcbiAgICBkYXRlID0gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIoZGF0ZSwgbmV3ICgwLCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkODBlZTYyNDVlYzRmMjllYykoKSk7XG4gICAgbGV0IHllYXIgPSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGMzNmUwZWNiMmQ0ZmE2OWQpKGRhdGUuZXJhLCBkYXRlLnllYXIpO1xuICAgIHJldHVybiAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZXBvY2hGcm9tUGFydHMoeWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXksIGRhdGUuaG91ciwgZGF0ZS5taW51dGUsIGRhdGUuc2Vjb25kLCBkYXRlLm1pbGxpc2Vjb25kKTtcbn1cbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRlcG9jaEZyb21QYXJ0cyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpIHtcbiAgICAvLyBOb3RlOiBEYXRlLlVUQygpIGludGVycHJldHMgb25lIGFuZCB0d28tZGlnaXQgeWVhcnMgYXMgYmVpbmcgaW4gdGhlXG4gICAgLy8gMjB0aCBjZW50dXJ5LCBzbyBkb24ndCB1c2UgaXRcbiAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgZGF0ZS5zZXRVVENIb3Vycyhob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpO1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgbW9udGggLSAxLCBkYXkpO1xuICAgIHJldHVybiBkYXRlLmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1OWM5OWYzNTE1ZDM0OTNmKG1zLCB0aW1lWm9uZSkge1xuICAgIC8vIEZhc3QgcGF0aCBmb3IgVVRDLlxuICAgIGlmICh0aW1lWm9uZSA9PT0gXCJVVENcIikgcmV0dXJuIDA7XG4gICAgLy8gRmFzdCBwYXRoOiBmb3IgbG9jYWwgdGltZXpvbmUgYWZ0ZXIgMTk3MCwgdXNlIG5hdGl2ZSBEYXRlLlxuICAgIGlmIChtcyA+IDAgJiYgdGltZVpvbmUgPT09ICgwLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYWE4YjQxNzM1YWZjYWJkMikoKSkgcmV0dXJuIG5ldyBEYXRlKG1zKS5nZXRUaW1lem9uZU9mZnNldCgpICogLTYwMDAwO1xuICAgIGxldCB7IHllYXI6IHllYXIsIG1vbnRoOiBtb250aCwgZGF5OiBkYXksIGhvdXI6IGhvdXIsIG1pbnV0ZTogbWludXRlLCBzZWNvbmQ6IHNlY29uZCB9ID0gJDExZDg3ZjNmNzZlODg2NTckdmFyJGdldFRpbWVab25lUGFydHMobXMsIHRpbWVab25lKTtcbiAgICBsZXQgdXRjID0gJDExZDg3ZjNmNzZlODg2NTckdmFyJGVwb2NoRnJvbVBhcnRzKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCAwKTtcbiAgICByZXR1cm4gdXRjIC0gTWF0aC5mbG9vcihtcyAvIDEwMDApICogMTAwMDtcbn1cbmNvbnN0ICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRmb3JtYXR0ZXJzQnlUaW1lWm9uZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRnZXRUaW1lWm9uZVBhcnRzKG1zLCB0aW1lWm9uZSkge1xuICAgIGxldCBmb3JtYXR0ZXIgPSAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZm9ybWF0dGVyc0J5VGltZVpvbmUuZ2V0KHRpbWVab25lKTtcbiAgICBpZiAoIWZvcm1hdHRlcikge1xuICAgICAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICAgICAgICAgIHRpbWVab25lOiB0aW1lWm9uZSxcbiAgICAgICAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICAgICAgICBlcmE6IFwic2hvcnRcIixcbiAgICAgICAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgbW9udGg6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICAgICAgICAgIGhvdXI6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgbWludXRlOiBcIm51bWVyaWNcIixcbiAgICAgICAgICAgIHNlY29uZDogXCJudW1lcmljXCJcbiAgICAgICAgfSk7XG4gICAgICAgICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRmb3JtYXR0ZXJzQnlUaW1lWm9uZS5zZXQodGltZVpvbmUsIGZvcm1hdHRlcik7XG4gICAgfVxuICAgIGxldCBwYXJ0cyA9IGZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKG5ldyBEYXRlKG1zKSk7XG4gICAgbGV0IG5hbWVkUGFydHMgPSB7fTtcbiAgICBmb3IgKGxldCBwYXJ0IG9mIHBhcnRzKWlmIChwYXJ0LnR5cGUgIT09IFwibGl0ZXJhbFwiKSBuYW1lZFBhcnRzW3BhcnQudHlwZV0gPSBwYXJ0LnZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEZpcmVmb3ggcmV0dXJucyBCIGluc3RlYWQgb2YgQkMuLi4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTc1MjI1M1xuICAgICAgICB5ZWFyOiBuYW1lZFBhcnRzLmVyYSA9PT0gXCJCQ1wiIHx8IG5hbWVkUGFydHMuZXJhID09PSBcIkJcIiA/IC1uYW1lZFBhcnRzLnllYXIgKyAxIDogK25hbWVkUGFydHMueWVhcixcbiAgICAgICAgbW9udGg6ICtuYW1lZFBhcnRzLm1vbnRoLFxuICAgICAgICBkYXk6ICtuYW1lZFBhcnRzLmRheSxcbiAgICAgICAgaG91cjogbmFtZWRQYXJ0cy5ob3VyID09PSBcIjI0XCIgPyAwIDogK25hbWVkUGFydHMuaG91cixcbiAgICAgICAgbWludXRlOiArbmFtZWRQYXJ0cy5taW51dGUsXG4gICAgICAgIHNlY29uZDogK25hbWVkUGFydHMuc2Vjb25kXG4gICAgfTtcbn1cbmNvbnN0ICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciREQVlNSUxMSVMgPSA4NjQwMDAwMDtcbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxMzZmMzhlZmU3Y2FmNTQ5KGRhdGUsIHRpbWVab25lKSB7XG4gICAgbGV0IG1zID0gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGJkNGZiMmJjOGJiMDZmYihkYXRlKTtcbiAgICBsZXQgZWFybGllciA9IG1zIC0gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDU5Yzk5ZjM1MTVkMzQ5M2YobXMgLSAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkREFZTUlMTElTLCB0aW1lWm9uZSk7XG4gICAgbGV0IGxhdGVyID0gbXMgLSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTljOTlmMzUxNWQzNDkzZihtcyArICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciREQVlNSUxMSVMsIHRpbWVab25lKTtcbiAgICByZXR1cm4gJDExZDg3ZjNmNzZlODg2NTckdmFyJGdldFZhbGlkV2FsbFRpbWVzKGRhdGUsIHRpbWVab25lLCBlYXJsaWVyLCBsYXRlcik7XG59XG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZ2V0VmFsaWRXYWxsVGltZXMoZGF0ZSwgdGltZVpvbmUsIGVhcmxpZXIsIGxhdGVyKSB7XG4gICAgbGV0IGZvdW5kID0gZWFybGllciA9PT0gbGF0ZXIgPyBbXG4gICAgICAgIGVhcmxpZXJcbiAgICBdIDogW1xuICAgICAgICBlYXJsaWVyLFxuICAgICAgICBsYXRlclxuICAgIF07XG4gICAgcmV0dXJuIGZvdW5kLmZpbHRlcigoYWJzb2x1dGUpPT4kMTFkODdmM2Y3NmU4ODY1NyR2YXIkaXNWYWxpZFdhbGxUaW1lKGRhdGUsIHRpbWVab25lLCBhYnNvbHV0ZSkpO1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckdmFyJGlzVmFsaWRXYWxsVGltZShkYXRlLCB0aW1lWm9uZSwgYWJzb2x1dGUpIHtcbiAgICBsZXQgcGFydHMgPSAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZ2V0VGltZVpvbmVQYXJ0cyhhYnNvbHV0ZSwgdGltZVpvbmUpO1xuICAgIHJldHVybiBkYXRlLnllYXIgPT09IHBhcnRzLnllYXIgJiYgZGF0ZS5tb250aCA9PT0gcGFydHMubW9udGggJiYgZGF0ZS5kYXkgPT09IHBhcnRzLmRheSAmJiBkYXRlLmhvdXIgPT09IHBhcnRzLmhvdXIgJiYgZGF0ZS5taW51dGUgPT09IHBhcnRzLm1pbnV0ZSAmJiBkYXRlLnNlY29uZCA9PT0gcGFydHMuc2Vjb25kO1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUxMDdjODJmOTQ1MThmNWMoZGF0ZSwgdGltZVpvbmUsIGRpc2FtYmlndWF0aW9uID0gXCJjb21wYXRpYmxlXCIpIHtcbiAgICBsZXQgZGF0ZVRpbWUgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjIxZTBiMTI0ZTIyNDQ4NChkYXRlKTtcbiAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZSB0aW1lIHpvbmUgaXMgVVRDLCB1c2UgbmF0aXZlIERhdGUuXG4gICAgaWYgKHRpbWVab25lID09PSBcIlVUQ1wiKSByZXR1cm4gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGJkNGZiMmJjOGJiMDZmYihkYXRlVGltZSk7XG4gICAgLy8gRmFzdCBwYXRoOiBpZiB0aGUgdGltZSB6b25lIGlzIHRoZSBsb2NhbCB0aW1lem9uZSBhbmQgZGlzYW1iaWd1YXRpb24gaXMgY29tcGF0aWJsZSwgdXNlIG5hdGl2ZSBEYXRlLlxuICAgIGlmICh0aW1lWm9uZSA9PT0gKDAsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhYThiNDE3MzVhZmNhYmQyKSgpICYmIGRpc2FtYmlndWF0aW9uID09PSBcImNvbXBhdGlibGVcIikge1xuICAgICAgICBkYXRlVGltZSA9ICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKGRhdGVUaW1lLCBuZXcgKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjKSgpKTtcbiAgICAgICAgLy8gRG9uJ3QgdXNlIERhdGUgY29uc3RydWN0b3IgaGVyZSBiZWNhdXNlIHR3by1kaWdpdCB5ZWFycyBhcmUgaW50ZXJwcmV0ZWQgaW4gdGhlIDIwdGggY2VudHVyeS5cbiAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBsZXQgeWVhciA9ICgwLCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkYzM2ZTBlY2IyZDRmYTY5ZCkoZGF0ZVRpbWUuZXJhLCBkYXRlVGltZS55ZWFyKTtcbiAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5ZWFyLCBkYXRlVGltZS5tb250aCAtIDEsIGRhdGVUaW1lLmRheSk7XG4gICAgICAgIGRhdGUuc2V0SG91cnMoZGF0ZVRpbWUuaG91ciwgZGF0ZVRpbWUubWludXRlLCBkYXRlVGltZS5zZWNvbmQsIGRhdGVUaW1lLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBsZXQgbXMgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYmQ0ZmIyYmM4YmIwNmZiKGRhdGVUaW1lKTtcbiAgICBsZXQgb2Zmc2V0QmVmb3JlID0gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDU5Yzk5ZjM1MTVkMzQ5M2YobXMgLSAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkREFZTUlMTElTLCB0aW1lWm9uZSk7XG4gICAgbGV0IG9mZnNldEFmdGVyID0gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDU5Yzk5ZjM1MTVkMzQ5M2YobXMgKyAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkREFZTUlMTElTLCB0aW1lWm9uZSk7XG4gICAgbGV0IHZhbGlkID0gJDExZDg3ZjNmNzZlODg2NTckdmFyJGdldFZhbGlkV2FsbFRpbWVzKGRhdGVUaW1lLCB0aW1lWm9uZSwgbXMgLSBvZmZzZXRCZWZvcmUsIG1zIC0gb2Zmc2V0QWZ0ZXIpO1xuICAgIGlmICh2YWxpZC5sZW5ndGggPT09IDEpIHJldHVybiB2YWxpZFswXTtcbiAgICBpZiAodmFsaWQubGVuZ3RoID4gMSkgc3dpdGNoKGRpc2FtYmlndWF0aW9uKXtcbiAgICAgICAgLy8gJ2NvbXBhdGlibGUnIG1lYW5zICdlYXJsaWVyJyBmb3IgXCJmYWxsIGJhY2tcIiB0cmFuc2l0aW9uc1xuICAgICAgICBjYXNlIFwiY29tcGF0aWJsZVwiOlxuICAgICAgICBjYXNlIFwiZWFybGllclwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkWzBdO1xuICAgICAgICBjYXNlIFwibGF0ZXJcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWxpZFt2YWxpZC5sZW5ndGggLSAxXTtcbiAgICAgICAgY2FzZSBcInJlamVjdFwiOlxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdWx0aXBsZSBwb3NzaWJsZSBhYnNvbHV0ZSB0aW1lcyBmb3VuZFwiKTtcbiAgICB9XG4gICAgc3dpdGNoKGRpc2FtYmlndWF0aW9uKXtcbiAgICAgICAgY2FzZSBcImVhcmxpZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihtcyAtIG9mZnNldEJlZm9yZSwgbXMgLSBvZmZzZXRBZnRlcik7XG4gICAgICAgIC8vICdjb21wYXRpYmxlJyBtZWFucyAnbGF0ZXInIGZvciBcInNwcmluZyBmb3J3YXJkXCIgdHJhbnNpdGlvbnNcbiAgICAgICAgY2FzZSBcImNvbXBhdGlibGVcIjpcbiAgICAgICAgY2FzZSBcImxhdGVyXCI6XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgobXMgLSBvZmZzZXRCZWZvcmUsIG1zIC0gb2Zmc2V0QWZ0ZXIpO1xuICAgICAgICBjYXNlIFwicmVqZWN0XCI6XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHN1Y2ggYWJzb2x1dGUgdGltZSBmb3VuZFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkZTY3YTA5NWM2MjBiODZmZShkYXRlVGltZSwgdGltZVpvbmUsIGRpc2FtYmlndWF0aW9uID0gXCJjb21wYXRpYmxlXCIpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUxMDdjODJmOTQ1MThmNWMoZGF0ZVRpbWUsIHRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbikpO1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMobXMsIHRpbWVab25lKSB7XG4gICAgbGV0IG9mZnNldCA9ICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1OWM5OWYzNTE1ZDM0OTNmKG1zLCB0aW1lWm9uZSk7XG4gICAgbGV0IGRhdGUgPSBuZXcgRGF0ZShtcyArIG9mZnNldCk7XG4gICAgbGV0IHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgbGV0IG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpICsgMTtcbiAgICBsZXQgZGF5ID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgbGV0IGhvdXIgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgbGV0IG1pbnV0ZSA9IGRhdGUuZ2V0VVRDTWludXRlcygpO1xuICAgIGxldCBzZWNvbmQgPSBkYXRlLmdldFVUQ1NlY29uZHMoKTtcbiAgICBsZXQgbWlsbGlzZWNvbmQgPSBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRkM2I3Mjg4ZTc5OTRlZGVhKSh5ZWFyLCBtb250aCwgZGF5LCB0aW1lWm9uZSwgb2Zmc2V0LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpO1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGU1N2ZmMTAwZDkxYmQ0YjkoZGF0ZSwgdGltZVpvbmUpIHtcbiAgICByZXR1cm4gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMoZGF0ZS5nZXRUaW1lKCksIHRpbWVab25lKTtcbn1cbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRkN2Y5MmJjZDM1OTZiMDg2KGRhdGUpIHtcbiAgICByZXR1cm4gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGU1N2ZmMTAwZDkxYmQ0YjkoZGF0ZSwgKDAsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhYThiNDE3MzVhZmNhYmQyKSgpKTtcbn1cbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ5MzUyMmQxYTQzOWYzNjE3KGRhdGVUaW1lKSB7XG4gICAgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYpKGRhdGVUaW1lLmNhbGVuZGFyLCBkYXRlVGltZS5lcmEsIGRhdGVUaW1lLnllYXIsIGRhdGVUaW1lLm1vbnRoLCBkYXRlVGltZS5kYXkpO1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDZmNGQ3ODE0OWYzZjUzYWMoZGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVyYTogZGF0ZS5lcmEsXG4gICAgICAgIHllYXI6IGRhdGUueWVhcixcbiAgICAgICAgbW9udGg6IGRhdGUubW9udGgsXG4gICAgICAgIGRheTogZGF0ZS5kYXlcbiAgICB9O1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDRkMDM5M2U3MzI4NTdiZTUoZGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhvdXI6IGRhdGUuaG91cixcbiAgICAgICAgbWludXRlOiBkYXRlLm1pbnV0ZSxcbiAgICAgICAgc2Vjb25kOiBkYXRlLnNlY29uZCxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IGRhdGUubWlsbGlzZWNvbmRcbiAgICB9O1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGIyMWUwYjEyNGUyMjQ0ODQoZGF0ZSwgdGltZSkge1xuICAgIGxldCBob3VyID0gMCwgbWludXRlID0gMCwgc2Vjb25kID0gMCwgbWlsbGlzZWNvbmQgPSAwO1xuICAgIGlmIChcInRpbWVab25lXCIgaW4gZGF0ZSkgKHsgaG91cjogaG91ciwgbWludXRlOiBtaW51dGUsIHNlY29uZDogc2Vjb25kLCBtaWxsaXNlY29uZDogbWlsbGlzZWNvbmQgfSA9IGRhdGUpO1xuICAgIGVsc2UgaWYgKFwiaG91clwiIGluIGRhdGUgJiYgIXRpbWUpIHJldHVybiBkYXRlO1xuICAgIGlmICh0aW1lKSAoeyBob3VyOiBob3VyLCBtaW51dGU6IG1pbnV0ZSwgc2Vjb25kOiBzZWNvbmQsIG1pbGxpc2Vjb25kOiBtaWxsaXNlY29uZCB9ID0gdGltZSk7XG4gICAgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGNhODcxZThkYmI4MDk2NmYpKGRhdGUuY2FsZW5kYXIsIGRhdGUuZXJhLCBkYXRlLnllYXIsIGRhdGUubW9udGgsIGRhdGUuZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpO1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGQzM2Y3OWUzZmZjM2RjODMoZGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkNjgwZWExOTZlZmZjZTVmKShkYXRlVGltZS5ob3VyLCBkYXRlVGltZS5taW51dGUsIGRhdGVUaW1lLnNlY29uZCwgZGF0ZVRpbWUubWlsbGlzZWNvbmQpO1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIoZGF0ZSwgY2FsZW5kYXIpIHtcbiAgICBpZiAoZGF0ZS5jYWxlbmRhci5pZGVudGlmaWVyID09PSBjYWxlbmRhci5pZGVudGlmaWVyKSByZXR1cm4gZGF0ZTtcbiAgICBsZXQgY2FsZW5kYXJEYXRlID0gY2FsZW5kYXIuZnJvbUp1bGlhbkRheShkYXRlLmNhbGVuZGFyLnRvSnVsaWFuRGF5KGRhdGUpKTtcbiAgICBsZXQgY29weSA9IGRhdGUuY29weSgpO1xuICAgIGNvcHkuY2FsZW5kYXIgPSBjYWxlbmRhcjtcbiAgICBjb3B5LmVyYSA9IGNhbGVuZGFyRGF0ZS5lcmE7XG4gICAgY29weS55ZWFyID0gY2FsZW5kYXJEYXRlLnllYXI7XG4gICAgY29weS5tb250aCA9IGNhbGVuZGFyRGF0ZS5tb250aDtcbiAgICBjb3B5LmRheSA9IGNhbGVuZGFyRGF0ZS5kYXk7XG4gICAgKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRjNGUyZWNhYzQ5MzUxZWYyKShjb3B5KTtcbiAgICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ4NGM5NWE4M2M3OTllMDc0KGRhdGUsIHRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbikge1xuICAgIGlmIChkYXRlIGluc3RhbmNlb2YgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRkM2I3Mjg4ZTc5OTRlZGVhKSkge1xuICAgICAgICBpZiAoZGF0ZS50aW1lWm9uZSA9PT0gdGltZVpvbmUpIHJldHVybiBkYXRlO1xuICAgICAgICByZXR1cm4gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUzOGIwMDAzM2NjMTFjNzUoZGF0ZSwgdGltZVpvbmUpO1xuICAgIH1cbiAgICBsZXQgbXMgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YyhkYXRlLCB0aW1lWm9uZSwgZGlzYW1iaWd1YXRpb24pO1xuICAgIHJldHVybiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMWI5NjY5MmExYmEwNDJhYyhtcywgdGltZVpvbmUpO1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDgzYWFjMDdiNGMzN2IyNShkYXRlKSB7XG4gICAgbGV0IG1zID0gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGJkNGZiMmJjOGJiMDZmYihkYXRlKSAtIGRhdGUub2Zmc2V0O1xuICAgIHJldHVybiBuZXcgRGF0ZShtcyk7XG59XG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTM4YjAwMDMzY2MxMWM3NShkYXRlLCB0aW1lWm9uZSkge1xuICAgIGxldCBtcyA9ICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiZDRmYjJiYzhiYjA2ZmIoZGF0ZSkgLSBkYXRlLm9mZnNldDtcbiAgICByZXR1cm4gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIoJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMobXMsIHRpbWVab25lKSwgZGF0ZS5jYWxlbmRhcik7XG59XG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkZDliNjdiYzkzYzA5NzQ5MShkYXRlKSB7XG4gICAgcmV0dXJuICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MzhiMDAwMzNjYzExYzc1KGRhdGUsICgwLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYWE4YjQxNzM1YWZjYWJkMikoKSk7XG59XG5cblxuXG5jb25zdCAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkT05FX0hPVVIgPSAzNjAwMDAwO1xuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGUxNmQ4NTIwYWY0NGEwOTYoZGF0ZSwgZHVyYXRpb24pIHtcbiAgICBsZXQgbXV0YWJsZURhdGUgPSBkYXRlLmNvcHkoKTtcbiAgICBsZXQgZGF5cyA9IFwiaG91clwiIGluIG11dGFibGVEYXRlID8gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGFkZFRpbWVGaWVsZHMobXV0YWJsZURhdGUsIGR1cmF0aW9uKSA6IDA7XG4gICAgJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGFkZFllYXJzKG11dGFibGVEYXRlLCBkdXJhdGlvbi55ZWFycyB8fCAwKTtcbiAgICBpZiAobXV0YWJsZURhdGUuY2FsZW5kYXIuYmFsYW5jZVllYXJNb250aCkgbXV0YWJsZURhdGUuY2FsZW5kYXIuYmFsYW5jZVllYXJNb250aChtdXRhYmxlRGF0ZSwgZGF0ZSk7XG4gICAgbXV0YWJsZURhdGUubW9udGggKz0gZHVyYXRpb24ubW9udGhzIHx8IDA7XG4gICAgJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGJhbGFuY2VZZWFyTW9udGgobXV0YWJsZURhdGUpO1xuICAgICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRjb25zdHJhaW5Nb250aERheShtdXRhYmxlRGF0ZSk7XG4gICAgbXV0YWJsZURhdGUuZGF5ICs9IChkdXJhdGlvbi53ZWVrcyB8fCAwKSAqIDc7XG4gICAgbXV0YWJsZURhdGUuZGF5ICs9IGR1cmF0aW9uLmRheXMgfHwgMDtcbiAgICBtdXRhYmxlRGF0ZS5kYXkgKz0gZGF5cztcbiAgICAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYmFsYW5jZURheShtdXRhYmxlRGF0ZSk7XG4gICAgaWYgKG11dGFibGVEYXRlLmNhbGVuZGFyLmJhbGFuY2VEYXRlKSBtdXRhYmxlRGF0ZS5jYWxlbmRhci5iYWxhbmNlRGF0ZShtdXRhYmxlRGF0ZSk7XG4gICAgLy8gQ29uc3RyYWluIGluIGNhc2UgYWRkaW5nIGVuZGVkIHVwIHdpdGggYSBkYXRlIG91dHNpZGUgdGhlIHZhbGlkIHJhbmdlIGZvciB0aGUgY2FsZW5kYXIgc3lzdGVtLlxuICAgIC8vIFRoZSBiZWhhdmlvciBoZXJlIGlzIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIHdoZW4gY29uc3RyYWluaW5nIGluIHRoZSBgc2V0YCBmdW5jdGlvbiBpbiB0aGF0XG4gICAgLy8gd2UgYWRqdXN0IHNtYWxsZXIgZmllbGRzIHRvIHRoZWlyIG1pbmltdW0vbWF4aW11bSB2YWx1ZXMgcmF0aGVyIHRoYW4gY29uc3RyYWluaW5nIGVhY2ggZmllbGRcbiAgICAvLyBpbmRpdmlkdWFsbHkuIFRoaXMgbWF0Y2hlcyB0aGUgZ2VuZXJhbCBiZWhhdmlvciBvZiBgYWRkYCB2cyBgc2V0YCByZWdhcmRpbmcgaG93IGZpZWxkcyBhcmUgYmFsYW5jZWQuXG4gICAgaWYgKG11dGFibGVEYXRlLnllYXIgPCAxKSB7XG4gICAgICAgIG11dGFibGVEYXRlLnllYXIgPSAxO1xuICAgICAgICBtdXRhYmxlRGF0ZS5tb250aCA9IDE7XG4gICAgICAgIG11dGFibGVEYXRlLmRheSA9IDE7XG4gICAgfVxuICAgIGxldCBtYXhZZWFyID0gbXV0YWJsZURhdGUuY2FsZW5kYXIuZ2V0WWVhcnNJbkVyYShtdXRhYmxlRGF0ZSk7XG4gICAgaWYgKG11dGFibGVEYXRlLnllYXIgPiBtYXhZZWFyKSB7XG4gICAgICAgIHZhciBfbXV0YWJsZURhdGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhLCBfbXV0YWJsZURhdGVfY2FsZW5kYXI7XG4gICAgICAgIGxldCBpc0ludmVyc2VFcmEgPSAoX211dGFibGVEYXRlX2NhbGVuZGFyX2lzSW52ZXJzZUVyYSA9IChfbXV0YWJsZURhdGVfY2FsZW5kYXIgPSBtdXRhYmxlRGF0ZS5jYWxlbmRhcikuaXNJbnZlcnNlRXJhKSA9PT0gbnVsbCB8fCBfbXV0YWJsZURhdGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbXV0YWJsZURhdGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhLmNhbGwoX211dGFibGVEYXRlX2NhbGVuZGFyLCBtdXRhYmxlRGF0ZSk7XG4gICAgICAgIG11dGFibGVEYXRlLnllYXIgPSBtYXhZZWFyO1xuICAgICAgICBtdXRhYmxlRGF0ZS5tb250aCA9IGlzSW52ZXJzZUVyYSA/IDEgOiBtdXRhYmxlRGF0ZS5jYWxlbmRhci5nZXRNb250aHNJblllYXIobXV0YWJsZURhdGUpO1xuICAgICAgICBtdXRhYmxlRGF0ZS5kYXkgPSBpc0ludmVyc2VFcmEgPyAxIDogbXV0YWJsZURhdGUuY2FsZW5kYXIuZ2V0RGF5c0luTW9udGgobXV0YWJsZURhdGUpO1xuICAgIH1cbiAgICBpZiAobXV0YWJsZURhdGUubW9udGggPCAxKSB7XG4gICAgICAgIG11dGFibGVEYXRlLm1vbnRoID0gMTtcbiAgICAgICAgbXV0YWJsZURhdGUuZGF5ID0gMTtcbiAgICB9XG4gICAgbGV0IG1heE1vbnRoID0gbXV0YWJsZURhdGUuY2FsZW5kYXIuZ2V0TW9udGhzSW5ZZWFyKG11dGFibGVEYXRlKTtcbiAgICBpZiAobXV0YWJsZURhdGUubW9udGggPiBtYXhNb250aCkge1xuICAgICAgICBtdXRhYmxlRGF0ZS5tb250aCA9IG1heE1vbnRoO1xuICAgICAgICBtdXRhYmxlRGF0ZS5kYXkgPSBtdXRhYmxlRGF0ZS5jYWxlbmRhci5nZXREYXlzSW5Nb250aChtdXRhYmxlRGF0ZSk7XG4gICAgfVxuICAgIG11dGFibGVEYXRlLmRheSA9IE1hdGgubWF4KDEsIE1hdGgubWluKG11dGFibGVEYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKG11dGFibGVEYXRlKSwgbXV0YWJsZURhdGUuZGF5KSk7XG4gICAgcmV0dXJuIG11dGFibGVEYXRlO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGFkZFllYXJzKGRhdGUsIHllYXJzKSB7XG4gICAgdmFyIF9kYXRlX2NhbGVuZGFyX2lzSW52ZXJzZUVyYSwgX2RhdGVfY2FsZW5kYXI7XG4gICAgaWYgKChfZGF0ZV9jYWxlbmRhcl9pc0ludmVyc2VFcmEgPSAoX2RhdGVfY2FsZW5kYXIgPSBkYXRlLmNhbGVuZGFyKS5pc0ludmVyc2VFcmEpID09PSBudWxsIHx8IF9kYXRlX2NhbGVuZGFyX2lzSW52ZXJzZUVyYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RhdGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhLmNhbGwoX2RhdGVfY2FsZW5kYXIsIGRhdGUpKSB5ZWFycyA9IC15ZWFycztcbiAgICBkYXRlLnllYXIgKz0geWVhcnM7XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYmFsYW5jZVllYXJNb250aChkYXRlKSB7XG4gICAgd2hpbGUoZGF0ZS5tb250aCA8IDEpe1xuICAgICAgICAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYWRkWWVhcnMoZGF0ZSwgLTEpO1xuICAgICAgICBkYXRlLm1vbnRoICs9IGRhdGUuY2FsZW5kYXIuZ2V0TW9udGhzSW5ZZWFyKGRhdGUpO1xuICAgIH1cbiAgICBsZXQgbW9udGhzSW5ZZWFyID0gMDtcbiAgICB3aGlsZShkYXRlLm1vbnRoID4gKG1vbnRoc0luWWVhciA9IGRhdGUuY2FsZW5kYXIuZ2V0TW9udGhzSW5ZZWFyKGRhdGUpKSl7XG4gICAgICAgIGRhdGUubW9udGggLT0gbW9udGhzSW5ZZWFyO1xuICAgICAgICAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYWRkWWVhcnMoZGF0ZSwgMSk7XG4gICAgfVxufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGJhbGFuY2VEYXkoZGF0ZSkge1xuICAgIHdoaWxlKGRhdGUuZGF5IDwgMSl7XG4gICAgICAgIGRhdGUubW9udGgtLTtcbiAgICAgICAgJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGJhbGFuY2VZZWFyTW9udGgoZGF0ZSk7XG4gICAgICAgIGRhdGUuZGF5ICs9IGRhdGUuY2FsZW5kYXIuZ2V0RGF5c0luTW9udGgoZGF0ZSk7XG4gICAgfVxuICAgIHdoaWxlKGRhdGUuZGF5ID4gZGF0ZS5jYWxlbmRhci5nZXREYXlzSW5Nb250aChkYXRlKSl7XG4gICAgICAgIGRhdGUuZGF5IC09IGRhdGUuY2FsZW5kYXIuZ2V0RGF5c0luTW9udGgoZGF0ZSk7XG4gICAgICAgIGRhdGUubW9udGgrKztcbiAgICAgICAgJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGJhbGFuY2VZZWFyTW9udGgoZGF0ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGNvbnN0cmFpbk1vbnRoRGF5KGRhdGUpIHtcbiAgICBkYXRlLm1vbnRoID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oZGF0ZS5jYWxlbmRhci5nZXRNb250aHNJblllYXIoZGF0ZSksIGRhdGUubW9udGgpKTtcbiAgICBkYXRlLmRheSA9IE1hdGgubWF4KDEsIE1hdGgubWluKGRhdGUuY2FsZW5kYXIuZ2V0RGF5c0luTW9udGgoZGF0ZSksIGRhdGUuZGF5KSk7XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkYzRlMmVjYWM0OTM1MWVmMihkYXRlKSB7XG4gICAgaWYgKGRhdGUuY2FsZW5kYXIuY29uc3RyYWluRGF0ZSkgZGF0ZS5jYWxlbmRhci5jb25zdHJhaW5EYXRlKGRhdGUpO1xuICAgIGRhdGUueWVhciA9IE1hdGgubWF4KDEsIE1hdGgubWluKGRhdGUuY2FsZW5kYXIuZ2V0WWVhcnNJbkVyYShkYXRlKSwgZGF0ZS55ZWFyKSk7XG4gICAgJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGNvbnN0cmFpbk1vbnRoRGF5KGRhdGUpO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDNlMjU0NGU4OGEyNWJmZjgoZHVyYXRpb24pIHtcbiAgICBsZXQgaW52ZXJzZUR1cmF0aW9uID0ge307XG4gICAgZm9yKGxldCBrZXkgaW4gZHVyYXRpb24paWYgKHR5cGVvZiBkdXJhdGlvbltrZXldID09PSBcIm51bWJlclwiKSBpbnZlcnNlRHVyYXRpb25ba2V5XSA9IC1kdXJhdGlvbltrZXldO1xuICAgIHJldHVybiBpbnZlcnNlRHVyYXRpb247XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNGUyZDJlYWQ2NWU1ZjdlMyhkYXRlLCBkdXJhdGlvbikge1xuICAgIHJldHVybiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZTE2ZDg1MjBhZjQ0YTA5NihkYXRlLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkM2UyNTQ0ZTg4YTI1YmZmOChkdXJhdGlvbikpO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGFkYWE0Y2Y3ZWYxYjY1YmUoZGF0ZSwgZmllbGRzKSB7XG4gICAgbGV0IG11dGFibGVEYXRlID0gZGF0ZS5jb3B5KCk7XG4gICAgaWYgKGZpZWxkcy5lcmEgIT0gbnVsbCkgbXV0YWJsZURhdGUuZXJhID0gZmllbGRzLmVyYTtcbiAgICBpZiAoZmllbGRzLnllYXIgIT0gbnVsbCkgbXV0YWJsZURhdGUueWVhciA9IGZpZWxkcy55ZWFyO1xuICAgIGlmIChmaWVsZHMubW9udGggIT0gbnVsbCkgbXV0YWJsZURhdGUubW9udGggPSBmaWVsZHMubW9udGg7XG4gICAgaWYgKGZpZWxkcy5kYXkgIT0gbnVsbCkgbXV0YWJsZURhdGUuZGF5ID0gZmllbGRzLmRheTtcbiAgICAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkYzRlMmVjYWM0OTM1MWVmMihtdXRhYmxlRGF0ZSk7XG4gICAgcmV0dXJuIG11dGFibGVEYXRlO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGU1ZDVlMWMxODIyYjZlNTYodmFsdWUsIGZpZWxkcykge1xuICAgIGxldCBtdXRhYmxlVmFsdWUgPSB2YWx1ZS5jb3B5KCk7XG4gICAgaWYgKGZpZWxkcy5ob3VyICE9IG51bGwpIG11dGFibGVWYWx1ZS5ob3VyID0gZmllbGRzLmhvdXI7XG4gICAgaWYgKGZpZWxkcy5taW51dGUgIT0gbnVsbCkgbXV0YWJsZVZhbHVlLm1pbnV0ZSA9IGZpZWxkcy5taW51dGU7XG4gICAgaWYgKGZpZWxkcy5zZWNvbmQgIT0gbnVsbCkgbXV0YWJsZVZhbHVlLnNlY29uZCA9IGZpZWxkcy5zZWNvbmQ7XG4gICAgaWYgKGZpZWxkcy5taWxsaXNlY29uZCAhPSBudWxsKSBtdXRhYmxlVmFsdWUubWlsbGlzZWNvbmQgPSBmaWVsZHMubWlsbGlzZWNvbmQ7XG4gICAgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDc1NTVkZTFlMDcwNTEwY2IobXV0YWJsZVZhbHVlKTtcbiAgICByZXR1cm4gbXV0YWJsZVZhbHVlO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGJhbGFuY2VUaW1lKHRpbWUpIHtcbiAgICB0aW1lLnNlY29uZCArPSBNYXRoLmZsb29yKHRpbWUubWlsbGlzZWNvbmQgLyAxMDAwKTtcbiAgICB0aW1lLm1pbGxpc2Vjb25kID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJG5vbk5lZ2F0aXZlTW9kKHRpbWUubWlsbGlzZWNvbmQsIDEwMDApO1xuICAgIHRpbWUubWludXRlICs9IE1hdGguZmxvb3IodGltZS5zZWNvbmQgLyA2MCk7XG4gICAgdGltZS5zZWNvbmQgPSAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkbm9uTmVnYXRpdmVNb2QodGltZS5zZWNvbmQsIDYwKTtcbiAgICB0aW1lLmhvdXIgKz0gTWF0aC5mbG9vcih0aW1lLm1pbnV0ZSAvIDYwKTtcbiAgICB0aW1lLm1pbnV0ZSA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRub25OZWdhdGl2ZU1vZCh0aW1lLm1pbnV0ZSwgNjApO1xuICAgIGxldCBkYXlzID0gTWF0aC5mbG9vcih0aW1lLmhvdXIgLyAyNCk7XG4gICAgdGltZS5ob3VyID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJG5vbk5lZ2F0aXZlTW9kKHRpbWUuaG91ciwgMjQpO1xuICAgIHJldHVybiBkYXlzO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDc1NTVkZTFlMDcwNTEwY2IodGltZSkge1xuICAgIHRpbWUubWlsbGlzZWNvbmQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aW1lLm1pbGxpc2Vjb25kLCAxMDAwKSk7XG4gICAgdGltZS5zZWNvbmQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aW1lLnNlY29uZCwgNTkpKTtcbiAgICB0aW1lLm1pbnV0ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRpbWUubWludXRlLCA1OSkpO1xuICAgIHRpbWUuaG91ciA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRpbWUuaG91ciwgMjMpKTtcbn1cbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRub25OZWdhdGl2ZU1vZChhLCBiKSB7XG4gICAgbGV0IHJlc3VsdCA9IGEgJSBiO1xuICAgIGlmIChyZXN1bHQgPCAwKSByZXN1bHQgKz0gYjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGFkZFRpbWVGaWVsZHModGltZSwgZHVyYXRpb24pIHtcbiAgICB0aW1lLmhvdXIgKz0gZHVyYXRpb24uaG91cnMgfHwgMDtcbiAgICB0aW1lLm1pbnV0ZSArPSBkdXJhdGlvbi5taW51dGVzIHx8IDA7XG4gICAgdGltZS5zZWNvbmQgKz0gZHVyYXRpb24uc2Vjb25kcyB8fCAwO1xuICAgIHRpbWUubWlsbGlzZWNvbmQgKz0gZHVyYXRpb24ubWlsbGlzZWNvbmRzIHx8IDA7XG4gICAgcmV0dXJuICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRiYWxhbmNlVGltZSh0aW1lKTtcbn1cbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ3ZWQ4N2I2YmMyNTA2NDcwKHRpbWUsIGR1cmF0aW9uKSB7XG4gICAgbGV0IHJlcyA9IHRpbWUuY29weSgpO1xuICAgICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRhZGRUaW1lRmllbGRzKHJlcywgZHVyYXRpb24pO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZmUzNGQzYTM4MWNkNzUwMSh0aW1lLCBkdXJhdGlvbikge1xuICAgIHJldHVybiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkN2VkODdiNmJjMjUwNjQ3MCh0aW1lLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkM2UyNTQ0ZTg4YTI1YmZmOChkdXJhdGlvbikpO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGQ1MmNlZDZiYWRmYjlhNGModmFsdWUsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpIHtcbiAgICBsZXQgbXV0YWJsZSA9IHZhbHVlLmNvcHkoKTtcbiAgICBzd2l0Y2goZmllbGQpe1xuICAgICAgICBjYXNlIFwiZXJhXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IGVyYXMgPSB2YWx1ZS5jYWxlbmRhci5nZXRFcmFzKCk7XG4gICAgICAgICAgICAgICAgbGV0IGVyYUluZGV4ID0gZXJhcy5pbmRleE9mKHZhbHVlLmVyYSk7XG4gICAgICAgICAgICAgICAgaWYgKGVyYUluZGV4IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlcmE6IFwiICsgdmFsdWUuZXJhKTtcbiAgICAgICAgICAgICAgICBlcmFJbmRleCA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRjeWNsZVZhbHVlKGVyYUluZGV4LCBhbW91bnQsIDAsIGVyYXMubGVuZ3RoIC0gMSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJvdW5kKTtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLmVyYSA9IGVyYXNbZXJhSW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIENvbnN0cmFpbiB0aGUgeWVhciBhbmQgb3RoZXIgZmllbGRzIHdpdGhpbiB0aGUgZXJhLCBzbyB0aGUgZXJhIGRvZXNuJ3QgY2hhbmdlIHdoZW4gd2UgYmFsYW5jZSBiZWxvdy5cbiAgICAgICAgICAgICAgICAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkYzRlMmVjYWM0OTM1MWVmMihtdXRhYmxlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInllYXJcIjpcbiAgICAgICAgICAgIHZhciBfbXV0YWJsZV9jYWxlbmRhcl9pc0ludmVyc2VFcmEsIF9tdXRhYmxlX2NhbGVuZGFyO1xuICAgICAgICAgICAgaWYgKChfbXV0YWJsZV9jYWxlbmRhcl9pc0ludmVyc2VFcmEgPSAoX211dGFibGVfY2FsZW5kYXIgPSBtdXRhYmxlLmNhbGVuZGFyKS5pc0ludmVyc2VFcmEpID09PSBudWxsIHx8IF9tdXRhYmxlX2NhbGVuZGFyX2lzSW52ZXJzZUVyYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX211dGFibGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhLmNhbGwoX211dGFibGVfY2FsZW5kYXIsIG11dGFibGUpKSBhbW91bnQgPSAtYW1vdW50O1xuICAgICAgICAgICAgLy8gVGhlIHllYXIgZmllbGQgc2hvdWxkIG5vdCBjeWNsZSB3aXRoaW4gdGhlIGVyYSBhcyB0aGF0IGNhbiBjYXVzZSB3ZWlyZCBiZWhhdmlvciBhZmZlY3Rpbmcgb3RoZXIgZmllbGRzLlxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBhbHNvIGFsbG93IHZhbHVlcyA8IDEgc28gdGhhdCBkZWNyZW1lbnRpbmcgZ29lcyB0byB0aGUgcHJldmlvdXMgZXJhLiBJZiB3ZSBnZXQgLUluZmluaXR5IGJhY2tcbiAgICAgICAgICAgIC8vIHdlIGtub3cgd2Ugd3JhcHBlZCBhcm91bmQgYWZ0ZXIgcmVhY2hpbmcgOTk5OSAodGhlIG1heGltdW0pLCBzbyBzZXQgdGhlIHllYXIgYmFjayB0byAxLlxuICAgICAgICAgICAgbXV0YWJsZS55ZWFyID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGN5Y2xlVmFsdWUodmFsdWUueWVhciwgYW1vdW50LCAtSW5maW5pdHksIDk5OTksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb3VuZCk7XG4gICAgICAgICAgICBpZiAobXV0YWJsZS55ZWFyID09PSAtSW5maW5pdHkpIG11dGFibGUueWVhciA9IDE7XG4gICAgICAgICAgICBpZiAobXV0YWJsZS5jYWxlbmRhci5iYWxhbmNlWWVhck1vbnRoKSBtdXRhYmxlLmNhbGVuZGFyLmJhbGFuY2VZZWFyTW9udGgobXV0YWJsZSwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtb250aFwiOlxuICAgICAgICAgICAgbXV0YWJsZS5tb250aCA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRjeWNsZVZhbHVlKHZhbHVlLm1vbnRoLCBhbW91bnQsIDEsIHZhbHVlLmNhbGVuZGFyLmdldE1vbnRoc0luWWVhcih2YWx1ZSksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb3VuZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRheVwiOlxuICAgICAgICAgICAgbXV0YWJsZS5kYXkgPSAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkY3ljbGVWYWx1ZSh2YWx1ZS5kYXksIGFtb3VudCwgMSwgdmFsdWUuY2FsZW5kYXIuZ2V0RGF5c0luTW9udGgodmFsdWUpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucm91bmQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBmaWVsZCBcIiArIGZpZWxkKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmNhbGVuZGFyLmJhbGFuY2VEYXRlKSB2YWx1ZS5jYWxlbmRhci5iYWxhbmNlRGF0ZShtdXRhYmxlKTtcbiAgICAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkYzRlMmVjYWM0OTM1MWVmMihtdXRhYmxlKTtcbiAgICByZXR1cm4gbXV0YWJsZTtcbn1cbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRkZDAyYjNlMDAwN2RmZTI4KHZhbHVlLCBmaWVsZCwgYW1vdW50LCBvcHRpb25zKSB7XG4gICAgbGV0IG11dGFibGUgPSB2YWx1ZS5jb3B5KCk7XG4gICAgc3dpdGNoKGZpZWxkKXtcbiAgICAgICAgY2FzZSBcImhvdXJcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgaG91cnMgPSB2YWx1ZS5ob3VyO1xuICAgICAgICAgICAgICAgIGxldCBtaW4gPSAwO1xuICAgICAgICAgICAgICAgIGxldCBtYXggPSAyMztcbiAgICAgICAgICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ob3VyQ3ljbGUpID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNQTSA9IGhvdXJzID49IDEyO1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBpc1BNID8gMTIgOiAwO1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBpc1BNID8gMjMgOiAxMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5ob3VyID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGN5Y2xlVmFsdWUoaG91cnMsIGFtb3VudCwgbWluLCBtYXgsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb3VuZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJtaW51dGVcIjpcbiAgICAgICAgICAgIG11dGFibGUubWludXRlID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGN5Y2xlVmFsdWUodmFsdWUubWludXRlLCBhbW91bnQsIDAsIDU5LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucm91bmQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZWNvbmRcIjpcbiAgICAgICAgICAgIG11dGFibGUuc2Vjb25kID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGN5Y2xlVmFsdWUodmFsdWUuc2Vjb25kLCBhbW91bnQsIDAsIDU5LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucm91bmQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtaWxsaXNlY29uZFwiOlxuICAgICAgICAgICAgbXV0YWJsZS5taWxsaXNlY29uZCA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRjeWNsZVZhbHVlKHZhbHVlLm1pbGxpc2Vjb25kLCBhbW91bnQsIDAsIDk5OSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJvdW5kKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZmllbGQgXCIgKyBmaWVsZCk7XG4gICAgfVxuICAgIHJldHVybiBtdXRhYmxlO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGN5Y2xlVmFsdWUodmFsdWUsIGFtb3VudCwgbWluLCBtYXgsIHJvdW5kID0gZmFsc2UpIHtcbiAgICBpZiAocm91bmQpIHtcbiAgICAgICAgdmFsdWUgKz0gTWF0aC5zaWduKGFtb3VudCk7XG4gICAgICAgIGlmICh2YWx1ZSA8IG1pbikgdmFsdWUgPSBtYXg7XG4gICAgICAgIGxldCBkaXYgPSBNYXRoLmFicyhhbW91bnQpO1xuICAgICAgICBpZiAoYW1vdW50ID4gMCkgdmFsdWUgPSBNYXRoLmNlaWwodmFsdWUgLyBkaXYpICogZGl2O1xuICAgICAgICBlbHNlIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIGRpdikgKiBkaXY7XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heCkgdmFsdWUgPSBtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgKz0gYW1vdW50O1xuICAgICAgICBpZiAodmFsdWUgPCBtaW4pIHZhbHVlID0gbWF4IC0gKG1pbiAtIHZhbHVlIC0gMSk7XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID4gbWF4KSB2YWx1ZSA9IG1pbiArICh2YWx1ZSAtIG1heCAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkOTZiMWQyODM0OTI3NDYzNyhkYXRlVGltZSwgZHVyYXRpb24pIHtcbiAgICBsZXQgbXM7XG4gICAgaWYgKGR1cmF0aW9uLnllYXJzICE9IG51bGwgJiYgZHVyYXRpb24ueWVhcnMgIT09IDAgfHwgZHVyYXRpb24ubW9udGhzICE9IG51bGwgJiYgZHVyYXRpb24ubW9udGhzICE9PSAwIHx8IGR1cmF0aW9uLndlZWtzICE9IG51bGwgJiYgZHVyYXRpb24ud2Vla3MgIT09IDAgfHwgZHVyYXRpb24uZGF5cyAhPSBudWxsICYmIGR1cmF0aW9uLmRheXMgIT09IDApIHtcbiAgICAgICAgbGV0IHJlcyA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRlMTZkODUyMGFmNDRhMDk2KCgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjIxZTBiMTI0ZTIyNDQ4NCkoZGF0ZVRpbWUpLCB7XG4gICAgICAgICAgICB5ZWFyczogZHVyYXRpb24ueWVhcnMsXG4gICAgICAgICAgICBtb250aHM6IGR1cmF0aW9uLm1vbnRocyxcbiAgICAgICAgICAgIHdlZWtzOiBkdXJhdGlvbi53ZWVrcyxcbiAgICAgICAgICAgIGRheXM6IGR1cmF0aW9uLmRheXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENoYW5naW5nIHRoZSBkYXRlIG1heSBjaGFuZ2UgdGhlIHRpbWV6b25lIG9mZnNldCwgc28gd2UgbmVlZCB0byByZWNvbXB1dGVcbiAgICAgICAgLy8gdXNpbmcgdGhlICdjb21wYXRpYmxlJyBkaXNhbWJpZ3VhdGlvbi5cbiAgICAgICAgbXMgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUxMDdjODJmOTQ1MThmNWMpKHJlcywgZGF0ZVRpbWUudGltZVpvbmUpO1xuICAgIH0gZWxzZSAvLyBPdGhlcndpc2UsIHByZXNlcnZlIHRoZSBvZmZzZXQgb2YgdGhlIG9yaWdpbmFsIGRhdGUuXG4gICAgbXMgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGJkNGZiMmJjOGJiMDZmYikoZGF0ZVRpbWUpIC0gZGF0ZVRpbWUub2Zmc2V0O1xuICAgIC8vIFBlcmZvcm0gdGltZSBtYW5pcHVsYXRpb24gaW4gbWlsbGlzZWNvbmRzIHJhdGhlciB0aGFuIG9uIHRoZSBvcmlnaW5hbCB0aW1lIGZpZWxkcyB0byBhY2NvdW50IGZvciBEU1QuXG4gICAgLy8gRm9yIGV4YW1wbGUsIGFkZGluZyBvbmUgaG91ciBkdXJpbmcgYSBEU1QgdHJhbnNpdGlvbiBtYXkgcmVzdWx0IGluIHRoZSBob3VyIGZpZWxkIHN0YXlpbmcgdGhlIHNhbWUgb3JcbiAgICAvLyBza2lwcGluZyBhbiBob3VyLiBUaGlzIHJlc3VsdHMgaW4gdGhlIG9mZnNldCBmaWVsZCBjaGFuZ2luZyB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSBzcGVjaWZpZWQgZmllbGQuXG4gICAgbXMgKz0gZHVyYXRpb24ubWlsbGlzZWNvbmRzIHx8IDA7XG4gICAgbXMgKz0gKGR1cmF0aW9uLnNlY29uZHMgfHwgMCkgKiAxMDAwO1xuICAgIG1zICs9IChkdXJhdGlvbi5taW51dGVzIHx8IDApICogNjAwMDA7XG4gICAgbXMgKz0gKGR1cmF0aW9uLmhvdXJzIHx8IDApICogMzYwMDAwMDtcbiAgICBsZXQgcmVzID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjKShtcywgZGF0ZVRpbWUudGltZVpvbmUpO1xuICAgIHJldHVybiAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIpKHJlcywgZGF0ZVRpbWUuY2FsZW5kYXIpO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDY4MTRjYWFjMzRjYTAzYzcoZGF0ZVRpbWUsIGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ5NmIxZDI4MzQ5Mjc0NjM3KGRhdGVUaW1lLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkM2UyNTQ0ZTg4YTI1YmZmOChkdXJhdGlvbikpO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDlhMjk3ZDExMWZjODZiNzkoZGF0ZVRpbWUsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpIHtcbiAgICAvLyBGb3IgZGF0ZSBmaWVsZHMsIHdlIHdhbnQgdGhlIHRpbWUgdG8gcmVtYWluIGNvbnNpc3RlbnQgYW5kIHRoZSBVVEMgb2Zmc2V0IHRvIHBvdGVudGlhbGx5IGNoYW5nZSB0byBhY2NvdW50IGZvciBEU1QgY2hhbmdlcy5cbiAgICAvLyBGb3IgdGltZSBmaWVsZHMsIHdlIHdhbnQgdGhlIHRpbWUgdG8gY2hhbmdlIGJ5IHRoZSBhbW91bnQgZ2l2ZW4uIFRoaXMgbWF5IHJlc3VsdCBpbiB0aGUgaG91ciBmaWVsZCBzdGF5aW5nIHRoZSBzYW1lLCBidXQgdGhlIFVUQ1xuICAgIC8vIG9mZnNldCBjaGFuZ2luZyBpbiB0aGUgY2FzZSBvZiBhIGJhY2t3YXJkIERTVCB0cmFuc2l0aW9uLCBvciBza2lwcGluZyBhbiBob3VyIGluIHRoZSBjYXNlIG9mIGEgZm9yd2FyZCBEU1QgdHJhbnNpdGlvbi5cbiAgICBzd2l0Y2goZmllbGQpe1xuICAgICAgICBjYXNlIFwiaG91clwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBtaW4gPSAwO1xuICAgICAgICAgICAgICAgIGxldCBtYXggPSAyMztcbiAgICAgICAgICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ob3VyQ3ljbGUpID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNQTSA9IGRhdGVUaW1lLmhvdXIgPj0gMTI7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGlzUE0gPyAxMiA6IDA7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGlzUE0gPyAyMyA6IDExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBob3VyIG1heSBiZSBhZmZlY3RlZCBieSBkYXlsaWdodCBzYXZpbmcgdGltZS5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgaXQgbWlnaHQganVtcCBmb3J3YXJkIGF0IG1pZG5pZ2h0LCBhbmQgc2tpcCAxYW0uXG4gICAgICAgICAgICAgICAgLy8gT3IgaXQgbWlnaHQgZW5kIGF0IG1pZG5pZ2h0IGFuZCByZXBlYXQgdGhlIDExcG0gaG91ci4gVG8gaGFuZGxlIHRoaXMsIHdlIGdldFxuICAgICAgICAgICAgICAgIC8vIHRoZSBwb3NzaWJsZSBhYnNvbHV0ZSB0aW1lcyBmb3IgdGhlIG1pbiBhbmQgbWF4LCBhbmQgZmluZCB0aGUgbWF4aW11bSByYW5nZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgaXMgd2l0aGluIHRoZSBjdXJyZW50IGRheS5cbiAgICAgICAgICAgICAgICBsZXQgcGxhaW5EYXRlVGltZSA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjIxZTBiMTI0ZTIyNDQ4NCkoZGF0ZVRpbWUpO1xuICAgICAgICAgICAgICAgIGxldCBtaW5EYXRlID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKSgkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZTVkNWUxYzE4MjJiNmU1NihwbGFpbkRhdGVUaW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGhvdXI6IG1pblxuICAgICAgICAgICAgICAgIH0pLCBuZXcgKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjKSgpKTtcbiAgICAgICAgICAgICAgICBsZXQgbWluQWJzb2x1dGUgPSBbXG4gICAgICAgICAgICAgICAgICAgICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YykobWluRGF0ZSwgZGF0ZVRpbWUudGltZVpvbmUsIFwiZWFybGllclwiKSxcbiAgICAgICAgICAgICAgICAgICAgKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MTA3YzgyZjk0NTE4ZjVjKShtaW5EYXRlLCBkYXRlVGltZS50aW1lWm9uZSwgXCJsYXRlclwiKVxuICAgICAgICAgICAgICAgIF0uZmlsdGVyKChtcyk9PigwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMWI5NjY5MmExYmEwNDJhYykobXMsIGRhdGVUaW1lLnRpbWVab25lKS5kYXkgPT09IG1pbkRhdGUuZGF5KVswXTtcbiAgICAgICAgICAgICAgICBsZXQgbWF4RGF0ZSA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMikoJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGU1ZDVlMWMxODIyYjZlNTYocGxhaW5EYXRlVGltZSwge1xuICAgICAgICAgICAgICAgICAgICBob3VyOiBtYXhcbiAgICAgICAgICAgICAgICB9KSwgbmV3ICgwLCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkODBlZTYyNDVlYzRmMjllYykoKSk7XG4gICAgICAgICAgICAgICAgbGV0IG1heEFic29sdXRlID0gW1xuICAgICAgICAgICAgICAgICAgICAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUxMDdjODJmOTQ1MThmNWMpKG1heERhdGUsIGRhdGVUaW1lLnRpbWVab25lLCBcImVhcmxpZXJcIiksXG4gICAgICAgICAgICAgICAgICAgICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YykobWF4RGF0ZSwgZGF0ZVRpbWUudGltZVpvbmUsIFwibGF0ZXJcIilcbiAgICAgICAgICAgICAgICBdLmZpbHRlcigobXMpPT4oMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMpKG1zLCBkYXRlVGltZS50aW1lWm9uZSkuZGF5ID09PSBtYXhEYXRlLmRheSkucG9wKCk7XG4gICAgICAgICAgICAgICAgLy8gU2luY2UgaG91cnMgbWF5IHJlcGVhdCwgd2UgbmVlZCB0byBvcGVyYXRlIG9uIHRoZSBhYnNvbHV0ZSB0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGRvbmUgaW4gaG91cnMgZnJvbSB0aGUgVW5peCBlcG9jaCBzbyB0aGF0IGN5Y2xlVmFsdWUgd29ya3MgY29ycmVjdGx5LFxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGVuIGNvbnZlcnRlZCBiYWNrIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAgICAgICBsZXQgbXMgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGJkNGZiMmJjOGJiMDZmYikoZGF0ZVRpbWUpIC0gZGF0ZVRpbWUub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGxldCBob3VycyA9IE1hdGguZmxvb3IobXMgLyAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkT05FX0hPVVIpO1xuICAgICAgICAgICAgICAgIGxldCByZW1haW5kZXIgPSBtcyAlICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRPTkVfSE9VUjtcbiAgICAgICAgICAgICAgICBtcyA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRjeWNsZVZhbHVlKGhvdXJzLCBhbW91bnQsIE1hdGguZmxvb3IobWluQWJzb2x1dGUgLyAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkT05FX0hPVVIpLCBNYXRoLmZsb29yKG1heEFic29sdXRlIC8gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJE9ORV9IT1VSKSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJvdW5kKSAqICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRPTkVfSE9VUiArIHJlbWFpbmRlcjtcbiAgICAgICAgICAgICAgICAvLyBOb3cgY29tcHV0ZSB0aGUgbmV3IHRpbWV6b25lIG9mZnNldCwgYW5kIGNvbnZlcnQgdGhlIGFic29sdXRlIHRpbWUgYmFjayB0byBsb2NhbCB0aW1lLlxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIpKCgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMWI5NjY5MmExYmEwNDJhYykobXMsIGRhdGVUaW1lLnRpbWVab25lKSwgZGF0ZVRpbWUuY2FsZW5kYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFwibWludXRlXCI6XG4gICAgICAgIGNhc2UgXCJzZWNvbmRcIjpcbiAgICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kXCI6XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZXR1cm4gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGRkMDJiM2UwMDA3ZGZlMjgoZGF0ZVRpbWUsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpO1xuICAgICAgICBjYXNlIFwiZXJhXCI6XG4gICAgICAgIGNhc2UgXCJ5ZWFyXCI6XG4gICAgICAgIGNhc2UgXCJtb250aFwiOlxuICAgICAgICBjYXNlIFwiZGF5XCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IHJlcyA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRkNTJjZWQ2YmFkZmI5YTRjKCgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjIxZTBiMTI0ZTIyNDQ4NCkoZGF0ZVRpbWUpLCBmaWVsZCwgYW1vdW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBsZXQgbXMgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUxMDdjODJmOTQ1MThmNWMpKHJlcywgZGF0ZVRpbWUudGltZVpvbmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIpKCgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMWI5NjY5MmExYmEwNDJhYykobXMsIGRhdGVUaW1lLnRpbWVab25lKSwgZGF0ZVRpbWUuY2FsZW5kYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZmllbGQgXCIgKyBmaWVsZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDMxYjU0MzBlYjE4YmU0ZjgoZGF0ZVRpbWUsIGZpZWxkcywgZGlzYW1iaWd1YXRpb24pIHtcbiAgICAvLyBTZXQgdGhlIGRhdGUvdGltZSBmaWVsZHMsIGFuZCByZWNvbXB1dGUgdGhlIFVUQyBvZmZzZXQgdG8gYWNjb3VudCBmb3IgRFNUIGNoYW5nZXMuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIHZhbGlkYXRlIGJ5IGNvbnZlcnRpbmcgYmFjayB0byBhIGxvY2FsIHRpbWUgaW4gY2FzZSBob3VycyBhcmUgc2tpcHBlZCBkdXJpbmcgZm9yd2FyZCBEU1QgdHJhbnNpdGlvbnMuXG4gICAgbGV0IHBsYWluRGF0ZVRpbWUgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGIyMWUwYjEyNGUyMjQ0ODQpKGRhdGVUaW1lKTtcbiAgICBsZXQgcmVzID0gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGU1ZDVlMWMxODIyYjZlNTYoJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGFkYWE0Y2Y3ZWYxYjY1YmUocGxhaW5EYXRlVGltZSwgZmllbGRzKSwgZmllbGRzKTtcbiAgICAvLyBJZiB0aGUgcmVzdWx0aW5nIHBsYWluIGRhdGUgdGltZSB2YWx1ZXMgYXJlIGVxdWFsLCByZXR1cm4gdGhlIG9yaWdpbmFsIHRpbWUuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjaGFuZ2UgdGhlIG9mZnNldCB3aGVuIHNldHRpbmcgdGhlIHRpbWUgdG8gdGhlIHNhbWUgdmFsdWUuXG4gICAgaWYgKHJlcy5jb21wYXJlKHBsYWluRGF0ZVRpbWUpID09PSAwKSByZXR1cm4gZGF0ZVRpbWU7XG4gICAgbGV0IG1zID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MTA3YzgyZjk0NTE4ZjVjKShyZXMsIGRhdGVUaW1lLnRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbik7XG4gICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMikoKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjKShtcywgZGF0ZVRpbWUudGltZVpvbmUpLCBkYXRlVGltZS5jYWxlbmRhcik7XG59XG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuXG5jb25zdCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkVElNRV9SRSA9IC9eKFxcZHsyfSkoPzo6KFxcZHsyfSkpPyg/OjooXFxkezJ9KSk/KFxcLlxcZCspPyQvO1xuY29uc3QgJGZhZTk3N2FhZmMzOTNjNWMkdmFyJERBVEVfUkUgPSAvXihcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pJC87XG5jb25zdCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkREFURV9USU1FX1JFID0gL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KSg/OlQoXFxkezJ9KSk/KD86OihcXGR7Mn0pKT8oPzo6KFxcZHsyfSkpPyhcXC5cXGQrKT8kLztcbmNvbnN0ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRaT05FRF9EQVRFX1RJTUVfUkUgPSAvXihcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pKD86VChcXGR7Mn0pKT8oPzo6KFxcZHsyfSkpPyg/OjooXFxkezJ9KSk/KFxcLlxcZCspPyg/OihbKy1dXFxkezJ9KSg/Ojo/KFxcZHsyfSkpPyk/XFxbKC4qPylcXF0kLztcbmNvbnN0ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRBQlNPTFVURV9SRSA9IC9eKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSkoPzpUKFxcZHsyfSkpPyg/OjooXFxkezJ9KSk/KD86OihcXGR7Mn0pKT8oXFwuXFxkKyk/KD86KD86KFsrLV1cXGR7Mn0pKD86Oj8oXFxkezJ9KSk/KXxaKSQvO1xuY29uc3QgJGZhZTk3N2FhZmMzOTNjNWMkdmFyJERBVEVfVElNRV9EVVJBVElPTl9SRSA9IC9eKCg/PG5lZ2F0aXZlPi0pfFxcKyk/UCgoPzx5ZWFycz5cXGQqKVkpPygoPzxtb250aHM+XFxkKilNKT8oKD88d2Vla3M+XFxkKilXKT8oKD88ZGF5cz5cXGQqKUQpPygoPzx0aW1lPlQpKCg/PGhvdXJzPlxcZCpbLixdP1xcZHsxLDl9KUgpPygoPzxtaW51dGVzPlxcZCpbLixdP1xcZHsxLDl9KU0pPygoPzxzZWNvbmRzPlxcZCpbLixdP1xcZHsxLDl9KVMpPyk/JC87XG5jb25zdCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcmVxdWlyZWREdXJhdGlvblRpbWVHcm91cHMgPSBbXG4gICAgXCJob3Vyc1wiLFxuICAgIFwibWludXRlc1wiLFxuICAgIFwic2Vjb25kc1wiXG5dO1xuY29uc3QgJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHJlcXVpcmVkRHVyYXRpb25Hcm91cHMgPSBbXG4gICAgXCJ5ZWFyc1wiLFxuICAgIFwibW9udGhzXCIsXG4gICAgXCJ3ZWVrc1wiLFxuICAgIFwiZGF5c1wiLFxuICAgIC4uLiRmYWU5NzdhYWZjMzkzYzVjJHZhciRyZXF1aXJlZER1cmF0aW9uVGltZUdyb3Vwc1xuXTtcbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRjOTY5OGVjN2YwNWEwN2UxKHZhbHVlKSB7XG4gICAgbGV0IG0gPSB2YWx1ZS5tYXRjaCgkZmFlOTc3YWFmYzM5M2M1YyR2YXIkVElNRV9SRSk7XG4gICAgaWYgKCFtKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElTTyA4NjAxIHRpbWUgc3RyaW5nOiBcIiArIHZhbHVlKTtcbiAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkNjgwZWExOTZlZmZjZTVmKSgkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVsxXSwgMCwgMjMpLCBtWzJdID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bMl0sIDAsIDU5KSA6IDAsIG1bM10gPyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVszXSwgMCwgNTkpIDogMCwgbVs0XSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzRdLCAwLCBJbmZpbml0eSkgKiAxMDAwIDogMCk7XG59XG5mdW5jdGlvbiAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkNmI4NjIxNjBkMjk1YzhlKHZhbHVlKSB7XG4gICAgbGV0IG0gPSB2YWx1ZS5tYXRjaCgkZmFlOTc3YWFmYzM5M2M1YyR2YXIkREFURV9SRSk7XG4gICAgaWYgKCFtKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElTTyA4NjAxIGRhdGUgc3RyaW5nOiBcIiArIHZhbHVlKTtcbiAgICBsZXQgZGF0ZSA9IG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYpKCRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzFdLCAwLCA5OTk5KSwgJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bMl0sIDEsIDEyKSwgMSk7XG4gICAgZGF0ZS5kYXkgPSAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVszXSwgMCwgZGF0ZS5jYWxlbmRhci5nZXREYXlzSW5Nb250aChkYXRlKSk7XG4gICAgcmV0dXJuIGRhdGU7XG59XG5mdW5jdGlvbiAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkNTg4OTM3YmNkNjBhZGU1NSh2YWx1ZSkge1xuICAgIGxldCBtID0gdmFsdWUubWF0Y2goJGZhZTk3N2FhZmMzOTNjNWMkdmFyJERBVEVfVElNRV9SRSk7XG4gICAgaWYgKCFtKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmc6IFwiICsgdmFsdWUpO1xuICAgIGxldCBkYXRlID0gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkY2E4NzFlOGRiYjgwOTY2ZikoJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bMV0sIDEsIDk5OTkpLCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVsyXSwgMSwgMTIpLCAxLCBtWzRdID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bNF0sIDAsIDIzKSA6IDAsIG1bNV0gPyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVs1XSwgMCwgNTkpIDogMCwgbVs2XSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzZdLCAwLCA1OSkgOiAwLCBtWzddID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bN10sIDAsIEluZmluaXR5KSAqIDEwMDAgOiAwKTtcbiAgICBkYXRlLmRheSA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzNdLCAwLCBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpKTtcbiAgICByZXR1cm4gZGF0ZTtcbn1cbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRmZDc4OTNmMDZlOTJhNmE0KHZhbHVlLCBkaXNhbWJpZ3VhdGlvbikge1xuICAgIGxldCBtID0gdmFsdWUubWF0Y2goJGZhZTk3N2FhZmMzOTNjNWMkdmFyJFpPTkVEX0RBVEVfVElNRV9SRSk7XG4gICAgaWYgKCFtKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmc6IFwiICsgdmFsdWUpO1xuICAgIGxldCBkYXRlID0gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkZDNiNzI4OGU3OTk0ZWRlYSkoJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bMV0sIDEsIDk5OTkpLCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVsyXSwgMSwgMTIpLCAxLCBtWzEwXSwgMCwgbVs0XSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzRdLCAwLCAyMykgOiAwLCBtWzVdID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bNV0sIDAsIDU5KSA6IDAsIG1bNl0gPyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVs2XSwgMCwgNTkpIDogMCwgbVs3XSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzddLCAwLCBJbmZpbml0eSkgKiAxMDAwIDogMCk7XG4gICAgZGF0ZS5kYXkgPSAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVszXSwgMCwgZGF0ZS5jYWxlbmRhci5nZXREYXlzSW5Nb250aChkYXRlKSk7XG4gICAgbGV0IHBsYWluRGF0ZVRpbWUgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGIyMWUwYjEyNGUyMjQ0ODQpKGRhdGUpO1xuICAgIGxldCBtcztcbiAgICBpZiAobVs4XSkge1xuICAgICAgICB2YXIgX21fO1xuICAgICAgICBkYXRlLm9mZnNldCA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzhdLCAtMjMsIDIzKSAqIDM2MDAwMDAgKyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIoKF9tXyA9IG1bOV0pICE9PSBudWxsICYmIF9tXyAhPT0gdm9pZCAwID8gX21fIDogXCIwXCIsIDAsIDU5KSAqIDYwMDAwO1xuICAgICAgICBtcyA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYmQ0ZmIyYmM4YmIwNmZiKShkYXRlKSAtIGRhdGUub2Zmc2V0O1xuICAgICAgICAvLyBWYWxpZGF0ZSBvZmZzZXQgYWdhaW5zdCBwYXJzZWQgZGF0ZS5cbiAgICAgICAgbGV0IGFic29sdXRlcyA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMTM2ZjM4ZWZlN2NhZjU0OSkocGxhaW5EYXRlVGltZSwgZGF0ZS50aW1lWm9uZSk7XG4gICAgICAgIGlmICghYWJzb2x1dGVzLmluY2x1ZGVzKG1zKSkgdGhyb3cgbmV3IEVycm9yKGBPZmZzZXQgJHskZmFlOTc3YWFmYzM5M2M1YyR2YXIkb2Zmc2V0VG9TdHJpbmcoZGF0ZS5vZmZzZXQpfSBpcyBpbnZhbGlkIGZvciAkeyRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ0MjIzZGUxNDcwOGFkYzYzKGRhdGUpfSBpbiAke2RhdGUudGltZVpvbmV9YCk7XG4gICAgfSBlbHNlIC8vIENvbnZlcnQgdG8gYWJzb2x1dGUgYW5kIGJhY2sgdG8gZml4IGludmFsaWQgdGltZXMgZHVlIHRvIERTVC5cbiAgICBtcyA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YykoKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiMjFlMGIxMjRlMjI0NDg0KShwbGFpbkRhdGVUaW1lKSwgZGF0ZS50aW1lWm9uZSwgZGlzYW1iaWd1YXRpb24pO1xuICAgIHJldHVybiAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMpKG1zLCBkYXRlLnRpbWVab25lKTtcbn1cbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ1YWRmZGFiMDUxNjhjMjE5KHZhbHVlLCB0aW1lWm9uZSkge1xuICAgIGxldCBtID0gdmFsdWUubWF0Y2goJGZhZTk3N2FhZmMzOTNjNWMkdmFyJEFCU09MVVRFX1JFKTtcbiAgICBpZiAoIW0pIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZzogXCIgKyB2YWx1ZSk7XG4gICAgbGV0IGRhdGUgPSBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRkM2I3Mjg4ZTc5OTRlZGVhKSgkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVsxXSwgMSwgOTk5OSksICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzJdLCAxLCAxMiksIDEsIHRpbWVab25lLCAwLCBtWzRdID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bNF0sIDAsIDIzKSA6IDAsIG1bNV0gPyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVs1XSwgMCwgNTkpIDogMCwgbVs2XSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzZdLCAwLCA1OSkgOiAwLCBtWzddID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bN10sIDAsIEluZmluaXR5KSAqIDEwMDAgOiAwKTtcbiAgICBkYXRlLmRheSA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzNdLCAwLCBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpKTtcbiAgICB2YXIgX21fO1xuICAgIGlmIChtWzhdKSBkYXRlLm9mZnNldCA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzhdLCAtMjMsIDIzKSAqIDM2MDAwMDAgKyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIoKF9tXyA9IG1bOV0pICE9PSBudWxsICYmIF9tXyAhPT0gdm9pZCAwID8gX21fIDogXCIwXCIsIDAsIDU5KSAqIDYwMDAwO1xuICAgIHJldHVybiAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUzOGIwMDAzM2NjMTFjNzUpKGRhdGUsIHRpbWVab25lKTtcbn1cbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ4ZTM4NDQzMjM2MmVkMGYwKHZhbHVlKSB7XG4gICAgcmV0dXJuICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ1YWRmZGFiMDUxNjhjMjE5KHZhbHVlLCAoMCwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGFhOGI0MTczNWFmY2FiZDIpKCkpO1xufVxuZnVuY3Rpb24gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIGxldCB2YWwgPSBOdW1iZXIodmFsdWUpO1xuICAgIGlmICh2YWwgPCBtaW4gfHwgdmFsID4gbWF4KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVmFsdWUgb3V0IG9mIHJhbmdlOiAke21pbn0gPD0gJHt2YWx9IDw9ICR7bWF4fWApO1xuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkZjU5ZGVlODIyNDhmNWFkNCh0aW1lKSB7XG4gICAgcmV0dXJuIGAke1N0cmluZyh0aW1lLmhvdXIpLnBhZFN0YXJ0KDIsIFwiMFwiKX06JHtTdHJpbmcodGltZS5taW51dGUpLnBhZFN0YXJ0KDIsIFwiMFwiKX06JHtTdHJpbmcodGltZS5zZWNvbmQpLnBhZFN0YXJ0KDIsIFwiMFwiKX0ke3RpbWUubWlsbGlzZWNvbmQgPyBTdHJpbmcodGltZS5taWxsaXNlY29uZCAvIDEwMDApLnNsaWNlKDEpIDogXCJcIn1gO1xufVxuZnVuY3Rpb24gJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDYwZGZkNzRhYTk2NzkxYmQoZGF0ZSkge1xuICAgIGxldCBncmVnb3JpYW5EYXRlID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKShkYXRlLCBuZXcgKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjKSgpKTtcbiAgICByZXR1cm4gYCR7U3RyaW5nKGdyZWdvcmlhbkRhdGUueWVhcikucGFkU3RhcnQoNCwgXCIwXCIpfS0ke1N0cmluZyhncmVnb3JpYW5EYXRlLm1vbnRoKS5wYWRTdGFydCgyLCBcIjBcIil9LSR7U3RyaW5nKGdyZWdvcmlhbkRhdGUuZGF5KS5wYWRTdGFydCgyLCBcIjBcIil9YDtcbn1cbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ0MjIzZGUxNDcwOGFkYzYzKGRhdGUpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGAkeyRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ2MGRmZDc0YWE5Njc5MWJkKGRhdGUpfVQkeyRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRmNTlkZWU4MjI0OGY1YWQ0KGRhdGUpfWA7XG59XG5mdW5jdGlvbiAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkb2Zmc2V0VG9TdHJpbmcob2Zmc2V0KSB7XG4gICAgbGV0IHNpZ24gPSBNYXRoLnNpZ24ob2Zmc2V0KSA8IDAgPyBcIi1cIiA6IFwiK1wiO1xuICAgIG9mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG4gICAgbGV0IG9mZnNldEhvdXJzID0gTWF0aC5mbG9vcihvZmZzZXQgLyAzNjAwMDAwKTtcbiAgICBsZXQgb2Zmc2V0TWludXRlcyA9IG9mZnNldCAlIDM2MDAwMDAgLyA2MDAwMDtcbiAgICByZXR1cm4gYCR7c2lnbn0ke1N0cmluZyhvZmZzZXRIb3VycykucGFkU3RhcnQoMiwgXCIwXCIpfToke1N0cmluZyhvZmZzZXRNaW51dGVzKS5wYWRTdGFydCgyLCBcIjBcIil9YDtcbn1cbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRiZjc5ZjFlYmY0YjE4NzkyKGRhdGUpIHtcbiAgICByZXR1cm4gYCR7JGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDQyMjNkZTE0NzA4YWRjNjMoZGF0ZSl9JHskZmFlOTc3YWFmYzM5M2M1YyR2YXIkb2Zmc2V0VG9TdHJpbmcoZGF0ZS5vZmZzZXQpfVske2RhdGUudGltZVpvbmV9XWA7XG59XG5mdW5jdGlvbiAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkZWNhZTgyOWJiMzc0N2VhNih2YWx1ZSkge1xuICAgIHZhciBfbWF0Y2hfZ3JvdXBzLCBfbWF0Y2hfZ3JvdXBzMSwgX21hdGNoX2dyb3VwczIsIF9tYXRjaF9ncm91cHMzLCBfbWF0Y2hfZ3JvdXBzNCwgX21hdGNoX2dyb3VwczUsIF9tYXRjaF9ncm91cHM2LCBfbWF0Y2hfZ3JvdXBzNywgX21hdGNoX2dyb3Vwczg7XG4gICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgkZmFlOTc3YWFmYzM5M2M1YyR2YXIkREFURV9USU1FX0RVUkFUSU9OX1JFKTtcbiAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSVNPIDg2MDEgRHVyYXRpb24gc3RyaW5nOiAke3ZhbHVlfWApO1xuICAgIGNvbnN0IHBhcnNlRHVyYXRpb25Hcm91cCA9IChncm91cCwgaXNOZWdhdGl2ZSwgbWluLCBtYXgpPT57XG4gICAgICAgIGlmICghZ3JvdXApIHJldHVybiAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbiA9IGlzTmVnYXRpdmUgPyAtMSA6IDE7XG4gICAgICAgICAgICByZXR1cm4gc2lnbiAqICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihncm91cC5yZXBsYWNlKFwiLFwiLCBcIi5cIiksIG1pbiwgbWF4KTtcbiAgICAgICAgfSBjYXRjaCAge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElTTyA4NjAxIER1cmF0aW9uIHN0cmluZzogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNOZWdhdGl2ZSA9ICEhKChfbWF0Y2hfZ3JvdXBzID0gbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbWF0Y2hfZ3JvdXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzLm5lZ2F0aXZlKTtcbiAgICBjb25zdCBoYXNSZXF1aXJlZEdyb3VwcyA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRyZXF1aXJlZER1cmF0aW9uR3JvdXBzLnNvbWUoKGdyb3VwKT0+e1xuICAgICAgICB2YXIgX21hdGNoX2dyb3VwcztcbiAgICAgICAgcmV0dXJuIChfbWF0Y2hfZ3JvdXBzID0gbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbWF0Y2hfZ3JvdXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzW2dyb3VwXTtcbiAgICB9KTtcbiAgICBpZiAoIWhhc1JlcXVpcmVkR3JvdXBzKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSVNPIDg2MDEgRHVyYXRpb24gc3RyaW5nOiAke3ZhbHVlfWApO1xuICAgIGNvbnN0IGR1cmF0aW9uU3RyaW5nSW5jbHVkZXNUaW1lID0gKF9tYXRjaF9ncm91cHMxID0gbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbWF0Y2hfZ3JvdXBzMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hdGNoX2dyb3VwczEudGltZTtcbiAgICBpZiAoZHVyYXRpb25TdHJpbmdJbmNsdWRlc1RpbWUpIHtcbiAgICAgICAgY29uc3QgaGFzUmVxdWlyZWREdXJhdGlvblRpbWVHcm91cHMgPSAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcmVxdWlyZWREdXJhdGlvblRpbWVHcm91cHMuc29tZSgoZ3JvdXApPT57XG4gICAgICAgICAgICB2YXIgX21hdGNoX2dyb3VwcztcbiAgICAgICAgICAgIHJldHVybiAoX21hdGNoX2dyb3VwcyA9IG1hdGNoLmdyb3VwcykgPT09IG51bGwgfHwgX21hdGNoX2dyb3VwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hdGNoX2dyb3Vwc1tncm91cF07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWhhc1JlcXVpcmVkRHVyYXRpb25UaW1lR3JvdXBzKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSVNPIDg2MDEgRHVyYXRpb24gc3RyaW5nOiAke3ZhbHVlfWApO1xuICAgIH1cbiAgICBjb25zdCBkdXJhdGlvbiA9IHtcbiAgICAgICAgeWVhcnM6IHBhcnNlRHVyYXRpb25Hcm91cCgoX21hdGNoX2dyb3VwczIgPSBtYXRjaC5ncm91cHMpID09PSBudWxsIHx8IF9tYXRjaF9ncm91cHMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzMi55ZWFycywgaXNOZWdhdGl2ZSwgMCwgOTk5OSksXG4gICAgICAgIG1vbnRoczogcGFyc2VEdXJhdGlvbkdyb3VwKChfbWF0Y2hfZ3JvdXBzMyA9IG1hdGNoLmdyb3VwcykgPT09IG51bGwgfHwgX21hdGNoX2dyb3VwczMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYXRjaF9ncm91cHMzLm1vbnRocywgaXNOZWdhdGl2ZSwgMCwgMTIpLFxuICAgICAgICB3ZWVrczogcGFyc2VEdXJhdGlvbkdyb3VwKChfbWF0Y2hfZ3JvdXBzNCA9IG1hdGNoLmdyb3VwcykgPT09IG51bGwgfHwgX21hdGNoX2dyb3VwczQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYXRjaF9ncm91cHM0LndlZWtzLCBpc05lZ2F0aXZlLCAwLCBJbmZpbml0eSksXG4gICAgICAgIGRheXM6IHBhcnNlRHVyYXRpb25Hcm91cCgoX21hdGNoX2dyb3VwczUgPSBtYXRjaC5ncm91cHMpID09PSBudWxsIHx8IF9tYXRjaF9ncm91cHM1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzNS5kYXlzLCBpc05lZ2F0aXZlLCAwLCAzMSksXG4gICAgICAgIGhvdXJzOiBwYXJzZUR1cmF0aW9uR3JvdXAoKF9tYXRjaF9ncm91cHM2ID0gbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbWF0Y2hfZ3JvdXBzNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hdGNoX2dyb3VwczYuaG91cnMsIGlzTmVnYXRpdmUsIDAsIDIzKSxcbiAgICAgICAgbWludXRlczogcGFyc2VEdXJhdGlvbkdyb3VwKChfbWF0Y2hfZ3JvdXBzNyA9IG1hdGNoLmdyb3VwcykgPT09IG51bGwgfHwgX21hdGNoX2dyb3VwczcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYXRjaF9ncm91cHM3Lm1pbnV0ZXMsIGlzTmVnYXRpdmUsIDAsIDU5KSxcbiAgICAgICAgc2Vjb25kczogcGFyc2VEdXJhdGlvbkdyb3VwKChfbWF0Y2hfZ3JvdXBzOCA9IG1hdGNoLmdyb3VwcykgPT09IG51bGwgfHwgX21hdGNoX2dyb3VwczggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYXRjaF9ncm91cHM4LnNlY29uZHMsIGlzTmVnYXRpdmUsIDAsIDU5KVxuICAgIH07XG4gICAgaWYgKGR1cmF0aW9uLmhvdXJzICE9PSB1bmRlZmluZWQgJiYgZHVyYXRpb24uaG91cnMgJSAxICE9PSAwICYmIChkdXJhdGlvbi5taW51dGVzIHx8IGR1cmF0aW9uLnNlY29uZHMpKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSVNPIDg2MDEgRHVyYXRpb24gc3RyaW5nOiAke3ZhbHVlfSAtIG9ubHkgdGhlIHNtYWxsZXN0IHVuaXQgY2FuIGJlIGZyYWN0aW9uYWxgKTtcbiAgICBpZiAoZHVyYXRpb24ubWludXRlcyAhPT0gdW5kZWZpbmVkICYmIGR1cmF0aW9uLm1pbnV0ZXMgJSAxICE9PSAwICYmIGR1cmF0aW9uLnNlY29uZHMpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBJU08gODYwMSBEdXJhdGlvbiBzdHJpbmc6ICR7dmFsdWV9IC0gb25seSB0aGUgc21hbGxlc3QgdW5pdCBjYW4gYmUgZnJhY3Rpb25hbGApO1xuICAgIHJldHVybiBkdXJhdGlvbjtcbn1cblxuXG5cblxuZnVuY3Rpb24gJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJHNoaWZ0QXJncyhhcmdzKSB7XG4gICAgbGV0IGNhbGVuZGFyID0gdHlwZW9mIGFyZ3NbMF0gPT09IFwib2JqZWN0XCIgPyBhcmdzLnNoaWZ0KCkgOiBuZXcgKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjKSgpO1xuICAgIGxldCBlcmE7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiKSBlcmEgPSBhcmdzLnNoaWZ0KCk7XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBlcmFzID0gY2FsZW5kYXIuZ2V0RXJhcygpO1xuICAgICAgICBlcmEgPSBlcmFzW2VyYXMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGxldCB5ZWFyID0gYXJncy5zaGlmdCgpO1xuICAgIGxldCBtb250aCA9IGFyZ3Muc2hpZnQoKTtcbiAgICBsZXQgZGF5ID0gYXJncy5zaGlmdCgpO1xuICAgIHJldHVybiBbXG4gICAgICAgIGNhbGVuZGFyLFxuICAgICAgICBlcmEsXG4gICAgICAgIHllYXIsXG4gICAgICAgIG1vbnRoLFxuICAgICAgICBkYXlcbiAgICBdO1xufVxudmFyIC8vIFRoaXMgcHJldmVudHMgVHlwZVNjcmlwdCBmcm9tIGFsbG93aW5nIG90aGVyIHR5cGVzIHdpdGggdGhlIHNhbWUgZmllbGRzIHRvIG1hdGNoLlxuLy8gaS5lLiBhIFpvbmVkRGF0ZVRpbWUgc2hvdWxkIG5vdCBiZSBiZSBwYXNzYWJsZSB0byBhIHBhcmFtZXRlciB0aGF0IGV4cGVjdHMgQ2FsZW5kYXJEYXRlLlxuLy8gSWYgdGhhdCBiZWhhdmlvciBpcyBkZXNpcmVkLCB1c2UgdGhlIEFueUNhbGVuZGFyRGF0ZSBpbnRlcmZhY2UgaW5zdGVhZC5cbi8vIEB0cy1pZ25vcmVcbiQzNWVhOGRiOWNiMmNjYjkwJHZhciRfdHlwZSA9IC8qI19fUFVSRV9fKi8gbmV3IFdlYWtNYXAoKTtcbmNsYXNzICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmIHtcbiAgICAvKiogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBkYXRlLiAqLyBjb3B5KCkge1xuICAgICAgICBpZiAodGhpcy5lcmEpIHJldHVybiBuZXcgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYodGhpcy5jYWxlbmRhciwgdGhpcy5lcmEsIHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXkpO1xuICAgICAgICBlbHNlIHJldHVybiBuZXcgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYodGhpcy5jYWxlbmRhciwgdGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGBDYWxlbmRhckRhdGVgIHdpdGggdGhlIGdpdmVuIGR1cmF0aW9uIGFkZGVkIHRvIGl0LiAqLyBhZGQoZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZTE2ZDg1MjBhZjQ0YTA5NikodGhpcywgZHVyYXRpb24pO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIG5ldyBgQ2FsZW5kYXJEYXRlYCB3aXRoIHRoZSBnaXZlbiBkdXJhdGlvbiBzdWJ0cmFjdGVkIGZyb20gaXQuICovIHN1YnRyYWN0KGR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDRlMmQyZWFkNjVlNWY3ZTMpKHRoaXMsIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBuZXcgYENhbGVuZGFyRGF0ZWAgd2l0aCB0aGUgZ2l2ZW4gZmllbGRzIHNldCB0byB0aGUgcHJvdmlkZWQgdmFsdWVzLiBPdGhlciBmaWVsZHMgd2lsbCBiZSBjb25zdHJhaW5lZCBhY2NvcmRpbmdseS4gKi8gc2V0KGZpZWxkcykge1xuICAgICAgICByZXR1cm4gKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRhZGFhNGNmN2VmMWI2NWJlKSh0aGlzLCBmaWVsZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBgQ2FsZW5kYXJEYXRlYCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBhZGp1c3RlZCBieSBhIHNwZWNpZmllZCBhbW91bnQuXG4gICAqIFdoZW4gdGhlIHJlc3VsdGluZyB2YWx1ZSByZWFjaGVzIHRoZSBsaW1pdHMgb2YgdGhlIGZpZWxkLCBpdCB3cmFwcyBhcm91bmQuXG4gICAqLyBjeWNsZShmaWVsZCwgYW1vdW50LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGQ1MmNlZDZiYWRmYjlhNGMpKHRoaXMsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogQ29udmVydHMgdGhlIGRhdGUgdG8gYSBuYXRpdmUgSmF2YVNjcmlwdCBEYXRlIG9iamVjdCwgd2l0aCB0aGUgdGltZSBzZXQgdG8gbWlkbmlnaHQgaW4gdGhlIGdpdmVuIHRpbWUgem9uZS4gKi8gdG9EYXRlKHRpbWVab25lKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGU2N2EwOTVjNjIwYjg2ZmUpKHRoaXMsIHRpbWVab25lKTtcbiAgICB9XG4gICAgLyoqIENvbnZlcnRzIHRoZSBkYXRlIHRvIGFuIElTTyA4NjAxIGZvcm1hdHRlZCBzdHJpbmcuICovIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKDAsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ2MGRmZDc0YWE5Njc5MWJkKSh0aGlzKTtcbiAgICB9XG4gICAgLyoqIENvbXBhcmVzIHRoaXMgZGF0ZSB3aXRoIGFub3RoZXIuIEEgbmVnYXRpdmUgcmVzdWx0IGluZGljYXRlcyB0aGF0IHRoaXMgZGF0ZSBpcyBiZWZvcmUgdGhlIGdpdmVuIG9uZSwgYW5kIGEgcG9zaXRpdmUgZGF0ZSBpbmRpY2F0ZXMgdGhhdCBpdCBpcyBhZnRlci4gKi8gY29tcGFyZShiKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDY4NzgxZGRmMzFjMDA5MGYpKHRoaXMsIGIpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgKDAsICRjVVZ1TiRfKSh0aGlzLCAkMzVlYThkYjljYjJjY2I5MCR2YXIkX3R5cGUsIHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IFtjYWxlbmRhciwgZXJhLCB5ZWFyLCBtb250aCwgZGF5XSA9ICQzNWVhOGRiOWNiMmNjYjkwJHZhciRzaGlmdEFyZ3MoYXJncyk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXIgPSBjYWxlbmRhcjtcbiAgICAgICAgdGhpcy5lcmEgPSBlcmE7XG4gICAgICAgIHRoaXMueWVhciA9IHllYXI7XG4gICAgICAgIHRoaXMubW9udGggPSBtb250aDtcbiAgICAgICAgdGhpcy5kYXkgPSBkYXk7XG4gICAgICAgICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkYzRlMmVjYWM0OTM1MWVmMikodGhpcyk7XG4gICAgfVxufVxudmFyIC8vIFRoaXMgcHJldmVudHMgVHlwZVNjcmlwdCBmcm9tIGFsbG93aW5nIG90aGVyIHR5cGVzIHdpdGggdGhlIHNhbWUgZmllbGRzIHRvIG1hdGNoLlxuLy8gQHRzLWlnbm9yZVxuJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJF90eXBlMSA9IC8qI19fUFVSRV9fKi8gbmV3IFdlYWtNYXAoKTtcbmNsYXNzICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ2ODBlYTE5NmVmZmNlNWYge1xuICAgIC8qKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHRpbWUuICovIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDY4MGVhMTk2ZWZmY2U1Zih0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5taWxsaXNlY29uZCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGBUaW1lYCB3aXRoIHRoZSBnaXZlbiBkdXJhdGlvbiBhZGRlZCB0byBpdC4gKi8gYWRkKGR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDdlZDg3YjZiYzI1MDY0NzApKHRoaXMsIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBuZXcgYFRpbWVgIHdpdGggdGhlIGdpdmVuIGR1cmF0aW9uIHN1YnRyYWN0ZWQgZnJvbSBpdC4gKi8gc3VidHJhY3QoZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZmUzNGQzYTM4MWNkNzUwMSkodGhpcywgZHVyYXRpb24pO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIG5ldyBgVGltZWAgd2l0aCB0aGUgZ2l2ZW4gZmllbGRzIHNldCB0byB0aGUgcHJvdmlkZWQgdmFsdWVzLiBPdGhlciBmaWVsZHMgd2lsbCBiZSBjb25zdHJhaW5lZCBhY2NvcmRpbmdseS4gKi8gc2V0KGZpZWxkcykge1xuICAgICAgICByZXR1cm4gKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRlNWQ1ZTFjMTgyMmI2ZTU2KSh0aGlzLCBmaWVsZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBgVGltZWAgd2l0aCB0aGUgZ2l2ZW4gZmllbGQgYWRqdXN0ZWQgYnkgYSBzcGVjaWZpZWQgYW1vdW50LlxuICAgKiBXaGVuIHRoZSByZXN1bHRpbmcgdmFsdWUgcmVhY2hlcyB0aGUgbGltaXRzIG9mIHRoZSBmaWVsZCwgaXQgd3JhcHMgYXJvdW5kLlxuICAgKi8gY3ljbGUoZmllbGQsIGFtb3VudCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRkZDAyYjNlMDAwN2RmZTI4KSh0aGlzLCBmaWVsZCwgYW1vdW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIENvbnZlcnRzIHRoZSB0aW1lIHRvIGFuIElTTyA4NjAxIGZvcm1hdHRlZCBzdHJpbmcuICovIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKDAsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRmNTlkZWU4MjI0OGY1YWQ0KSh0aGlzKTtcbiAgICB9XG4gICAgLyoqIENvbXBhcmVzIHRoaXMgdGltZSB3aXRoIGFub3RoZXIuIEEgbmVnYXRpdmUgcmVzdWx0IGluZGljYXRlcyB0aGF0IHRoaXMgdGltZSBpcyBiZWZvcmUgdGhlIGdpdmVuIG9uZSwgYW5kIGEgcG9zaXRpdmUgdGltZSBpbmRpY2F0ZXMgdGhhdCBpdCBpcyBhZnRlci4gKi8gY29tcGFyZShiKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGMxOWE4MGE5NzIxYjgwZjYpKHRoaXMsIGIpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihob3VyID0gMCwgbWludXRlID0gMCwgc2Vjb25kID0gMCwgbWlsbGlzZWNvbmQgPSAwKXtcbiAgICAgICAgKDAsICRjVVZ1TiRfKSh0aGlzLCAkMzVlYThkYjljYjJjY2I5MCR2YXIkX3R5cGUxLCB7XG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaG91ciA9IGhvdXI7XG4gICAgICAgIHRoaXMubWludXRlID0gbWludXRlO1xuICAgICAgICB0aGlzLnNlY29uZCA9IHNlY29uZDtcbiAgICAgICAgdGhpcy5taWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuICAgICAgICAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDc1NTVkZTFlMDcwNTEwY2IpKHRoaXMpO1xuICAgIH1cbn1cbnZhciAvLyBUaGlzIHByZXZlbnRzIFR5cGVTY3JpcHQgZnJvbSBhbGxvd2luZyBvdGhlciB0eXBlcyB3aXRoIHRoZSBzYW1lIGZpZWxkcyB0byBtYXRjaC5cbi8vIEB0cy1pZ25vcmVcbiQzNWVhOGRiOWNiMmNjYjkwJHZhciRfdHlwZTIgPSAvKiNfX1BVUkVfXyovIG5ldyBXZWFrTWFwKCk7XG5jbGFzcyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkY2E4NzFlOGRiYjgwOTY2ZiB7XG4gICAgLyoqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgZGF0ZS4gKi8gY29weSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJhKSByZXR1cm4gbmV3ICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRjYTg3MWU4ZGJiODA5NjZmKHRoaXMuY2FsZW5kYXIsIHRoaXMuZXJhLCB0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5taWxsaXNlY29uZCk7XG4gICAgICAgIGVsc2UgcmV0dXJuIG5ldyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkY2E4NzFlOGRiYjgwOTY2Zih0aGlzLmNhbGVuZGFyLCB0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5taWxsaXNlY29uZCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGBDYWxlbmRhckRhdGVUaW1lYCB3aXRoIHRoZSBnaXZlbiBkdXJhdGlvbiBhZGRlZCB0byBpdC4gKi8gYWRkKGR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGUxNmQ4NTIwYWY0NGEwOTYpKHRoaXMsIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBuZXcgYENhbGVuZGFyRGF0ZVRpbWVgIHdpdGggdGhlIGdpdmVuIGR1cmF0aW9uIHN1YnRyYWN0ZWQgZnJvbSBpdC4gKi8gc3VidHJhY3QoZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNGUyZDJlYWQ2NWU1ZjdlMykodGhpcywgZHVyYXRpb24pO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIG5ldyBgQ2FsZW5kYXJEYXRlVGltZWAgd2l0aCB0aGUgZ2l2ZW4gZmllbGRzIHNldCB0byB0aGUgcHJvdmlkZWQgdmFsdWVzLiBPdGhlciBmaWVsZHMgd2lsbCBiZSBjb25zdHJhaW5lZCBhY2NvcmRpbmdseS4gKi8gc2V0KGZpZWxkcykge1xuICAgICAgICByZXR1cm4gKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRhZGFhNGNmN2VmMWI2NWJlKSgoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGU1ZDVlMWMxODIyYjZlNTYpKHRoaXMsIGZpZWxkcyksIGZpZWxkcyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGBDYWxlbmRhckRhdGVUaW1lYCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBhZGp1c3RlZCBieSBhIHNwZWNpZmllZCBhbW91bnQuXG4gICAqIFdoZW4gdGhlIHJlc3VsdGluZyB2YWx1ZSByZWFjaGVzIHRoZSBsaW1pdHMgb2YgdGhlIGZpZWxkLCBpdCB3cmFwcyBhcm91bmQuXG4gICAqLyBjeWNsZShmaWVsZCwgYW1vdW50LCBvcHRpb25zKSB7XG4gICAgICAgIHN3aXRjaChmaWVsZCl7XG4gICAgICAgICAgICBjYXNlIFwiZXJhXCI6XG4gICAgICAgICAgICBjYXNlIFwieWVhclwiOlxuICAgICAgICAgICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGF5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZDUyY2VkNmJhZGZiOWE0YykodGhpcywgZmllbGQsIGFtb3VudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGRkMDJiM2UwMDA3ZGZlMjgpKHRoaXMsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBDb252ZXJ0cyB0aGUgZGF0ZSB0byBhIG5hdGl2ZSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0IGluIHRoZSBnaXZlbiB0aW1lIHpvbmUuICovIHRvRGF0ZSh0aW1lWm9uZSwgZGlzYW1iaWd1YXRpb24pIHtcbiAgICAgICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkZTY3YTA5NWM2MjBiODZmZSkodGhpcywgdGltZVpvbmUsIGRpc2FtYmlndWF0aW9uKTtcbiAgICB9XG4gICAgLyoqIENvbnZlcnRzIHRoZSBkYXRlIHRvIGFuIElTTyA4NjAxIGZvcm1hdHRlZCBzdHJpbmcuICovIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKDAsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ0MjIzZGUxNDcwOGFkYzYzKSh0aGlzKTtcbiAgICB9XG4gICAgLyoqIENvbXBhcmVzIHRoaXMgZGF0ZSB3aXRoIGFub3RoZXIuIEEgbmVnYXRpdmUgcmVzdWx0IGluZGljYXRlcyB0aGF0IHRoaXMgZGF0ZSBpcyBiZWZvcmUgdGhlIGdpdmVuIG9uZSwgYW5kIGEgcG9zaXRpdmUgZGF0ZSBpbmRpY2F0ZXMgdGhhdCBpdCBpcyBhZnRlci4gKi8gY29tcGFyZShiKSB7XG4gICAgICAgIGxldCByZXMgPSAoMCwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDY4NzgxZGRmMzFjMDA5MGYpKHRoaXMsIGIpO1xuICAgICAgICBpZiAocmVzID09PSAwKSByZXR1cm4gKDAsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRjMTlhODBhOTcyMWI4MGY2KSh0aGlzLCAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGIyMWUwYjEyNGUyMjQ0ODQpKGIpKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgICgwLCAkY1VWdU4kXykodGhpcywgJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJF90eXBlMiwge1xuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgW2NhbGVuZGFyLCBlcmEsIHllYXIsIG1vbnRoLCBkYXldID0gJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJHNoaWZ0QXJncyhhcmdzKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgICAgICB0aGlzLmVyYSA9IGVyYTtcbiAgICAgICAgdGhpcy55ZWFyID0geWVhcjtcbiAgICAgICAgdGhpcy5tb250aCA9IG1vbnRoO1xuICAgICAgICB0aGlzLmRheSA9IGRheTtcbiAgICAgICAgdGhpcy5ob3VyID0gYXJncy5zaGlmdCgpIHx8IDA7XG4gICAgICAgIHRoaXMubWludXRlID0gYXJncy5zaGlmdCgpIHx8IDA7XG4gICAgICAgIHRoaXMuc2Vjb25kID0gYXJncy5zaGlmdCgpIHx8IDA7XG4gICAgICAgIHRoaXMubWlsbGlzZWNvbmQgPSBhcmdzLnNoaWZ0KCkgfHwgMDtcbiAgICAgICAgKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRjNGUyZWNhYzQ5MzUxZWYyKSh0aGlzKTtcbiAgICB9XG59XG52YXIgLy8gVGhpcyBwcmV2ZW50cyBUeXBlU2NyaXB0IGZyb20gYWxsb3dpbmcgb3RoZXIgdHlwZXMgd2l0aCB0aGUgc2FtZSBmaWVsZHMgdG8gbWF0Y2guXG4vLyBAdHMtaWdub3JlXG4kMzVlYThkYjljYjJjY2I5MCR2YXIkX3R5cGUzID0gLyojX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xuY2xhc3MgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGQzYjcyODhlNzk5NGVkZWEge1xuICAgIC8qKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIGRhdGUuICovIGNvcHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmVyYSkgcmV0dXJuIG5ldyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkZDNiNzI4OGU3OTk0ZWRlYSh0aGlzLmNhbGVuZGFyLCB0aGlzLmVyYSwgdGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSwgdGhpcy50aW1lWm9uZSwgdGhpcy5vZmZzZXQsIHRoaXMuaG91ciwgdGhpcy5taW51dGUsIHRoaXMuc2Vjb25kLCB0aGlzLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgZWxzZSByZXR1cm4gbmV3ICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRkM2I3Mjg4ZTc5OTRlZGVhKHRoaXMuY2FsZW5kYXIsIHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXksIHRoaXMudGltZVpvbmUsIHRoaXMub2Zmc2V0LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5taWxsaXNlY29uZCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGBab25lZERhdGVUaW1lYCB3aXRoIHRoZSBnaXZlbiBkdXJhdGlvbiBhZGRlZCB0byBpdC4gKi8gYWRkKGR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDk2YjFkMjgzNDkyNzQ2MzcpKHRoaXMsIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBuZXcgYFpvbmVkRGF0ZVRpbWVgIHdpdGggdGhlIGdpdmVuIGR1cmF0aW9uIHN1YnRyYWN0ZWQgZnJvbSBpdC4gKi8gc3VidHJhY3QoZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNjgxNGNhYWMzNGNhMDNjNykodGhpcywgZHVyYXRpb24pO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIG5ldyBgWm9uZWREYXRlVGltZWAgd2l0aCB0aGUgZ2l2ZW4gZmllbGRzIHNldCB0byB0aGUgcHJvdmlkZWQgdmFsdWVzLiBPdGhlciBmaWVsZHMgd2lsbCBiZSBjb25zdHJhaW5lZCBhY2NvcmRpbmdseS4gKi8gc2V0KGZpZWxkcywgZGlzYW1iaWd1YXRpb24pIHtcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkMzFiNTQzMGViMThiZTRmOCkodGhpcywgZmllbGRzLCBkaXNhbWJpZ3VhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGBab25lZERhdGVUaW1lYCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBhZGp1c3RlZCBieSBhIHNwZWNpZmllZCBhbW91bnQuXG4gICAqIFdoZW4gdGhlIHJlc3VsdGluZyB2YWx1ZSByZWFjaGVzIHRoZSBsaW1pdHMgb2YgdGhlIGZpZWxkLCBpdCB3cmFwcyBhcm91bmQuXG4gICAqLyBjeWNsZShmaWVsZCwgYW1vdW50LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDlhMjk3ZDExMWZjODZiNzkpKHRoaXMsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogQ29udmVydHMgdGhlIGRhdGUgdG8gYSBuYXRpdmUgSmF2YVNjcmlwdCBEYXRlIG9iamVjdC4gKi8gdG9EYXRlKCkge1xuICAgICAgICByZXR1cm4gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ4M2FhYzA3YjRjMzdiMjUpKHRoaXMpO1xuICAgIH1cbiAgICAvKiogQ29udmVydHMgdGhlIGRhdGUgdG8gYW4gSVNPIDg2MDEgZm9ybWF0dGVkIHN0cmluZywgaW5jbHVkaW5nIHRoZSBVVEMgb2Zmc2V0IGFuZCB0aW1lIHpvbmUgaWRlbnRpZmllci4gKi8gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoMCwgJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JGJmNzlmMWViZjRiMTg3OTIpKHRoaXMpO1xuICAgIH1cbiAgICAvKiogQ29udmVydHMgdGhlIGRhdGUgdG8gYW4gSVNPIDg2MDEgZm9ybWF0dGVkIHN0cmluZyBpbiBVVEMuICovIHRvQWJzb2x1dGVTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKiBDb21wYXJlcyB0aGlzIGRhdGUgd2l0aCBhbm90aGVyLiBBIG5lZ2F0aXZlIHJlc3VsdCBpbmRpY2F0ZXMgdGhhdCB0aGlzIGRhdGUgaXMgYmVmb3JlIHRoZSBnaXZlbiBvbmUsIGFuZCBhIHBvc2l0aXZlIGRhdGUgaW5kaWNhdGVzIHRoYXQgaXQgaXMgYWZ0ZXIuICovIGNvbXBhcmUoYikge1xuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIGEgYmFkIGlkZWE/P1xuICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS5nZXRUaW1lKCkgLSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDg0Yzk1YTgzYzc5OWUwNzQpKGIsIHRoaXMudGltZVpvbmUpLnRvRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgICgwLCAkY1VWdU4kXykodGhpcywgJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJF90eXBlMywge1xuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgW2NhbGVuZGFyLCBlcmEsIHllYXIsIG1vbnRoLCBkYXldID0gJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJHNoaWZ0QXJncyhhcmdzKTtcbiAgICAgICAgbGV0IHRpbWVab25lID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gYXJncy5zaGlmdCgpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XG4gICAgICAgIHRoaXMuZXJhID0gZXJhO1xuICAgICAgICB0aGlzLnllYXIgPSB5ZWFyO1xuICAgICAgICB0aGlzLm1vbnRoID0gbW9udGg7XG4gICAgICAgIHRoaXMuZGF5ID0gZGF5O1xuICAgICAgICB0aGlzLnRpbWVab25lID0gdGltZVpvbmU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmhvdXIgPSBhcmdzLnNoaWZ0KCkgfHwgMDtcbiAgICAgICAgdGhpcy5taW51dGUgPSBhcmdzLnNoaWZ0KCkgfHwgMDtcbiAgICAgICAgdGhpcy5zZWNvbmQgPSBhcmdzLnNoaWZ0KCkgfHwgMDtcbiAgICAgICAgdGhpcy5taWxsaXNlY29uZCA9IGFyZ3Muc2hpZnQoKSB8fCAwO1xuICAgICAgICAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGM0ZTJlY2FjNDkzNTFlZjIpKHRoaXMpO1xuICAgIH1cbn1cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIGNvZGUgZnJvbSB0aGUgVEMzOSBUZW1wb3JhbCBwcm9wb3NhbC5cbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBjYW4gYmUgZm91bmQgaW4gdGhlIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXG5cbmNvbnN0ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfU1RBUlRfREFURVMgPSBbXG4gICAgW1xuICAgICAgICAxODY4LFxuICAgICAgICA5LFxuICAgICAgICA4XG4gICAgXSxcbiAgICBbXG4gICAgICAgIDE5MTIsXG4gICAgICAgIDcsXG4gICAgICAgIDMwXG4gICAgXSxcbiAgICBbXG4gICAgICAgIDE5MjYsXG4gICAgICAgIDEyLFxuICAgICAgICAyNVxuICAgIF0sXG4gICAgW1xuICAgICAgICAxOTg5LFxuICAgICAgICAxLFxuICAgICAgICA4XG4gICAgXSxcbiAgICBbXG4gICAgICAgIDIwMTksXG4gICAgICAgIDUsXG4gICAgICAgIDFcbiAgICBdXG5dO1xuY29uc3QgJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9FTkRfREFURVMgPSBbXG4gICAgW1xuICAgICAgICAxOTEyLFxuICAgICAgICA3LFxuICAgICAgICAyOVxuICAgIF0sXG4gICAgW1xuICAgICAgICAxOTI2LFxuICAgICAgICAxMixcbiAgICAgICAgMjRcbiAgICBdLFxuICAgIFtcbiAgICAgICAgMTk4OSxcbiAgICAgICAgMSxcbiAgICAgICAgN1xuICAgIF0sXG4gICAgW1xuICAgICAgICAyMDE5LFxuICAgICAgICA0LFxuICAgICAgICAzMFxuICAgIF1cbl07XG5jb25zdCAkNjIyMjUwMDgwMjBmMGExMyR2YXIkRVJBX0FEREVORFMgPSBbXG4gICAgMTg2NyxcbiAgICAxOTExLFxuICAgIDE5MjUsXG4gICAgMTk4OCxcbiAgICAyMDE4XG5dO1xuY29uc3QgJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9OQU1FUyA9IFtcbiAgICBcIm1laWppXCIsXG4gICAgXCJ0YWlzaG9cIixcbiAgICBcInNob3dhXCIsXG4gICAgXCJoZWlzZWlcIixcbiAgICBcInJlaXdhXCJcbl07XG5mdW5jdGlvbiAkNjIyMjUwMDgwMjBmMGExMyR2YXIkZmluZEVyYUZyb21HcmVnb3JpYW5EYXRlKGRhdGUpIHtcbiAgICBjb25zdCBpZHggPSAkNjIyMjUwMDgwMjBmMGExMyR2YXIkRVJBX1NUQVJUX0RBVEVTLmZpbmRJbmRleCgoW3llYXIsIG1vbnRoLCBkYXldKT0+e1xuICAgICAgICBpZiAoZGF0ZS55ZWFyIDwgeWVhcikgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChkYXRlLnllYXIgPT09IHllYXIgJiYgZGF0ZS5tb250aCA8IG1vbnRoKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGRhdGUueWVhciA9PT0geWVhciAmJiBkYXRlLm1vbnRoID09PSBtb250aCAmJiBkYXRlLmRheSA8IGRheSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfU1RBUlRfREFURVMubGVuZ3RoIC0gMTtcbiAgICBpZiAoaWR4ID09PSAwKSByZXR1cm4gMDtcbiAgICByZXR1cm4gaWR4IC0gMTtcbn1cbmZ1bmN0aW9uICQ2MjIyNTAwODAyMGYwYTEzJHZhciR0b0dyZWdvcmlhbihkYXRlKSB7XG4gICAgbGV0IGVyYUFkZGVuZCA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfQURERU5EU1skNjIyMjUwMDgwMjBmMGExMyR2YXIkRVJBX05BTUVTLmluZGV4T2YoZGF0ZS5lcmEpXTtcbiAgICBpZiAoIWVyYUFkZGVuZCkgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlcmE6IFwiICsgZGF0ZS5lcmEpO1xuICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKShkYXRlLnllYXIgKyBlcmFBZGRlbmQsIGRhdGUubW9udGgsIGRhdGUuZGF5KTtcbn1cbmNsYXNzICQ2MjIyNTAwODAyMGYwYTEzJGV4cG9ydCRiNzQ2YWIyYjYwY2RmZmJmIGV4dGVuZHMgKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjKSB7XG4gICAgZnJvbUp1bGlhbkRheShqZCkge1xuICAgICAgICBsZXQgZGF0ZSA9IHN1cGVyLmZyb21KdWxpYW5EYXkoamQpO1xuICAgICAgICBsZXQgZXJhID0gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJGZpbmRFcmFGcm9tR3JlZ29yaWFuRGF0ZShkYXRlKTtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYpKHRoaXMsICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfTkFNRVNbZXJhXSwgZGF0ZS55ZWFyIC0gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9BRERFTkRTW2VyYV0sIGRhdGUubW9udGgsIGRhdGUuZGF5KTtcbiAgICB9XG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xuICAgICAgICByZXR1cm4gc3VwZXIudG9KdWxpYW5EYXkoJDYyMjI1MDA4MDIwZjBhMTMkdmFyJHRvR3JlZ29yaWFuKGRhdGUpKTtcbiAgICB9XG4gICAgYmFsYW5jZURhdGUoZGF0ZSkge1xuICAgICAgICBsZXQgZ3JlZ29yaWFuRGF0ZSA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciR0b0dyZWdvcmlhbihkYXRlKTtcbiAgICAgICAgbGV0IGVyYSA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRmaW5kRXJhRnJvbUdyZWdvcmlhbkRhdGUoZ3JlZ29yaWFuRGF0ZSk7XG4gICAgICAgIGlmICgkNjIyMjUwMDgwMjBmMGExMyR2YXIkRVJBX05BTUVTW2VyYV0gIT09IGRhdGUuZXJhKSB7XG4gICAgICAgICAgICBkYXRlLmVyYSA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfTkFNRVNbZXJhXTtcbiAgICAgICAgICAgIGRhdGUueWVhciA9IGdyZWdvcmlhbkRhdGUueWVhciAtICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfQURERU5EU1tlcmFdO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnN0cmFpbiBpbiBjYXNlIHdlIHdlbnQgYmVmb3JlIHRoZSBmaXJzdCBzdXBwb3J0ZWQgZXJhLlxuICAgICAgICB0aGlzLmNvbnN0cmFpbkRhdGUoZGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0cmFpbkRhdGUoZGF0ZSkge1xuICAgICAgICBsZXQgaWR4ID0gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9OQU1FUy5pbmRleE9mKGRhdGUuZXJhKTtcbiAgICAgICAgbGV0IGVuZCA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfRU5EX0RBVEVTW2lkeF07XG4gICAgICAgIGlmIChlbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IFtlbmRZZWFyLCBlbmRNb250aCwgZW5kRGF5XSA9IGVuZDtcbiAgICAgICAgICAgIC8vIENvbnN0cmFpbiB0aGUgeWVhciB0byB0aGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZSBpbiB0aGUgZXJhLlxuICAgICAgICAgICAgLy8gVGhlbiBjb25zdHJhaW4gdGhlIG1vbnRoIGFuZCBkYXkgZmllbGRzIHdpdGhpbiB0aGF0LlxuICAgICAgICAgICAgbGV0IG1heFllYXIgPSBlbmRZZWFyIC0gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9BRERFTkRTW2lkeF07XG4gICAgICAgICAgICBkYXRlLnllYXIgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihtYXhZZWFyLCBkYXRlLnllYXIpKTtcbiAgICAgICAgICAgIGlmIChkYXRlLnllYXIgPT09IG1heFllYXIpIHtcbiAgICAgICAgICAgICAgICBkYXRlLm1vbnRoID0gTWF0aC5taW4oZW5kTW9udGgsIGRhdGUubW9udGgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRlLm1vbnRoID09PSBlbmRNb250aCkgZGF0ZS5kYXkgPSBNYXRoLm1pbihlbmREYXksIGRhdGUuZGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZS55ZWFyID09PSAxICYmIGlkeCA+PSAwKSB7XG4gICAgICAgICAgICBsZXQgWywgc3RhcnRNb250aCwgc3RhcnREYXldID0gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9TVEFSVF9EQVRFU1tpZHhdO1xuICAgICAgICAgICAgZGF0ZS5tb250aCA9IE1hdGgubWF4KHN0YXJ0TW9udGgsIGRhdGUubW9udGgpO1xuICAgICAgICAgICAgaWYgKGRhdGUubW9udGggPT09IHN0YXJ0TW9udGgpIGRhdGUuZGF5ID0gTWF0aC5tYXgoc3RhcnREYXksIGRhdGUuZGF5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRFcmFzKCkge1xuICAgICAgICByZXR1cm4gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9OQU1FUztcbiAgICB9XG4gICAgZ2V0WWVhcnNJbkVyYShkYXRlKSB7XG4gICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIHllYXJzIGluIHRoZSBlcmEsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIGRhdGUncyBtb250aCBhbmQgZGF5IGZpZWxkcy5cbiAgICAgICAgbGV0IGVyYSA9ICQ2MjIyNTAwODAyMGYwYTEzJHZhciRFUkFfTkFNRVMuaW5kZXhPZihkYXRlLmVyYSk7XG4gICAgICAgIGxldCBjdXIgPSAkNjIyMjUwMDgwMjBmMGExMyR2YXIkRVJBX1NUQVJUX0RBVEVTW2VyYV07XG4gICAgICAgIGxldCBuZXh0ID0gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9TVEFSVF9EQVRFU1tlcmEgKyAxXTtcbiAgICAgICAgaWYgKG5leHQgPT0gbnVsbCkgLy8gOTk5OSBncmVnb3JpYW4gaXMgdGhlIG1heGltdW0geWVhciBhbGxvd2VkLlxuICAgICAgICByZXR1cm4gOTk5OSAtIGN1clswXSArIDE7XG4gICAgICAgIGxldCB5ZWFycyA9IG5leHRbMF0gLSBjdXJbMF07XG4gICAgICAgIGlmIChkYXRlLm1vbnRoIDwgbmV4dFsxXSB8fCBkYXRlLm1vbnRoID09PSBuZXh0WzFdICYmIGRhdGUuZGF5IDwgbmV4dFsyXSkgeWVhcnMrKztcbiAgICAgICAgcmV0dXJuIHllYXJzO1xuICAgIH1cbiAgICBnZXREYXlzSW5Nb250aChkYXRlKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXREYXlzSW5Nb250aCgkNjIyMjUwMDgwMjBmMGExMyR2YXIkdG9HcmVnb3JpYW4oZGF0ZSkpO1xuICAgIH1cbiAgICBnZXRNaW5pbXVtTW9udGhJblllYXIoZGF0ZSkge1xuICAgICAgICBsZXQgc3RhcnQgPSAkNjIyMjUwMDgwMjBmMGExMyR2YXIkZ2V0TWluaW11bXMoZGF0ZSk7XG4gICAgICAgIHJldHVybiBzdGFydCA/IHN0YXJ0WzFdIDogMTtcbiAgICB9XG4gICAgZ2V0TWluaW11bURheUluTW9udGgoZGF0ZSkge1xuICAgICAgICBsZXQgc3RhcnQgPSAkNjIyMjUwMDgwMjBmMGExMyR2YXIkZ2V0TWluaW11bXMoZGF0ZSk7XG4gICAgICAgIHJldHVybiBzdGFydCAmJiBkYXRlLm1vbnRoID09PSBzdGFydFsxXSA/IHN0YXJ0WzJdIDogMTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBcImphcGFuZXNlXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJGdldE1pbmltdW1zKGRhdGUpIHtcbiAgICBpZiAoZGF0ZS55ZWFyID09PSAxKSB7XG4gICAgICAgIGxldCBpZHggPSAkNjIyMjUwMDgwMjBmMGExMyR2YXIkRVJBX05BTUVTLmluZGV4T2YoZGF0ZS5lcmEpO1xuICAgICAgICByZXR1cm4gJDYyMjI1MDA4MDIwZjBhMTMkdmFyJEVSQV9TVEFSVF9EQVRFU1tpZHhdO1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gSUNVLlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGNhbiBiZSBmb3VuZCBpbiB0aGUgTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cblxuY29uc3QgJDhkNzNkNDc0MjJjYTczMDIkdmFyJEJVRERISVNUX0VSQV9TVEFSVCA9IC01NDM7XG5jbGFzcyAkOGQ3M2Q0NzQyMmNhNzMwMiRleHBvcnQkNDJkMjBhNzgzMDFkZWU0NCBleHRlbmRzICgwLCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkODBlZTYyNDVlYzRmMjllYykge1xuICAgIGZyb21KdWxpYW5EYXkoamQpIHtcbiAgICAgICAgbGV0IGdyZWdvcmlhbkRhdGUgPSBzdXBlci5mcm9tSnVsaWFuRGF5KGpkKTtcbiAgICAgICAgbGV0IHllYXIgPSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGMzNmUwZWNiMmQ0ZmE2OWQpKGdyZWdvcmlhbkRhdGUuZXJhLCBncmVnb3JpYW5EYXRlLnllYXIpO1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikodGhpcywgeWVhciAtICQ4ZDczZDQ3NDIyY2E3MzAyJHZhciRCVURESElTVF9FUkFfU1RBUlQsIGdyZWdvcmlhbkRhdGUubW9udGgsIGdyZWdvcmlhbkRhdGUuZGF5KTtcbiAgICB9XG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xuICAgICAgICByZXR1cm4gc3VwZXIudG9KdWxpYW5EYXkoJDhkNzNkNDc0MjJjYTczMDIkdmFyJHRvR3JlZ29yaWFuKGRhdGUpKTtcbiAgICB9XG4gICAgZ2V0RXJhcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFwiQkVcIlxuICAgICAgICBdO1xuICAgIH1cbiAgICBnZXREYXlzSW5Nb250aChkYXRlKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXREYXlzSW5Nb250aCgkOGQ3M2Q0NzQyMmNhNzMwMiR2YXIkdG9HcmVnb3JpYW4oZGF0ZSkpO1xuICAgIH1cbiAgICBiYWxhbmNlRGF0ZSgpIHt9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBcImJ1ZGRoaXN0XCI7XG4gICAgfVxufVxuZnVuY3Rpb24gJDhkNzNkNDc0MjJjYTczMDIkdmFyJHRvR3JlZ29yaWFuKGRhdGUpIHtcbiAgICBsZXQgW2VyYSwgeWVhcl0gPSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDQ0NzViN2U2MTdlYjEyM2MpKGRhdGUueWVhciArICQ4ZDczZDQ3NDIyY2E3MzAyJHZhciRCVURESElTVF9FUkFfU1RBUlQpO1xuICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKShlcmEsIHllYXIsIGRhdGUubW9udGgsIGRhdGUuZGF5KTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gSUNVLlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGNhbiBiZSBmb3VuZCBpbiB0aGUgTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cblxuY29uc3QgJDVmMzFiZDZmMGM4OTQwYjIkdmFyJFRBSVdBTl9FUkFfU1RBUlQgPSAxOTExO1xuZnVuY3Rpb24gJDVmMzFiZDZmMGM4OTQwYjIkdmFyJGdyZWdvcmlhblllYXIoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmVyYSA9PT0gXCJtaW5ndW9cIiA/IGRhdGUueWVhciArICQ1ZjMxYmQ2ZjBjODk0MGIyJHZhciRUQUlXQU5fRVJBX1NUQVJUIDogMSAtIGRhdGUueWVhciArICQ1ZjMxYmQ2ZjBjODk0MGIyJHZhciRUQUlXQU5fRVJBX1NUQVJUO1xufVxuZnVuY3Rpb24gJDVmMzFiZDZmMGM4OTQwYjIkdmFyJGdyZWdvcmlhblRvVGFpd2FuKHllYXIpIHtcbiAgICBsZXQgeSA9IHllYXIgLSAkNWYzMWJkNmYwYzg5NDBiMiR2YXIkVEFJV0FOX0VSQV9TVEFSVDtcbiAgICBpZiAoeSA+IDApIHJldHVybiBbXG4gICAgICAgIFwibWluZ3VvXCIsXG4gICAgICAgIHlcbiAgICBdO1xuICAgIGVsc2UgcmV0dXJuIFtcbiAgICAgICAgXCJiZWZvcmVfbWluZ3VvXCIsXG4gICAgICAgIDEgLSB5XG4gICAgXTtcbn1cbmNsYXNzICQ1ZjMxYmQ2ZjBjODk0MGIyJGV4cG9ydCQ2NWUwMTA4MGFmY2IwNzk5IGV4dGVuZHMgKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjKSB7XG4gICAgZnJvbUp1bGlhbkRheShqZCkge1xuICAgICAgICBsZXQgZGF0ZSA9IHN1cGVyLmZyb21KdWxpYW5EYXkoamQpO1xuICAgICAgICBsZXQgZXh0ZW5kZWRZZWFyID0gKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCRjMzZlMGVjYjJkNGZhNjlkKShkYXRlLmVyYSwgZGF0ZS55ZWFyKTtcbiAgICAgICAgbGV0IFtlcmEsIHllYXJdID0gJDVmMzFiZDZmMGM4OTQwYjIkdmFyJGdyZWdvcmlhblRvVGFpd2FuKGV4dGVuZGVkWWVhcik7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKSh0aGlzLCBlcmEsIHllYXIsIGRhdGUubW9udGgsIGRhdGUuZGF5KTtcbiAgICB9XG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xuICAgICAgICByZXR1cm4gc3VwZXIudG9KdWxpYW5EYXkoJDVmMzFiZDZmMGM4OTQwYjIkdmFyJHRvR3JlZ29yaWFuKGRhdGUpKTtcbiAgICB9XG4gICAgZ2V0RXJhcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFwiYmVmb3JlX21pbmd1b1wiLFxuICAgICAgICAgICAgXCJtaW5ndW9cIlxuICAgICAgICBdO1xuICAgIH1cbiAgICBiYWxhbmNlRGF0ZShkYXRlKSB7XG4gICAgICAgIGxldCBbZXJhLCB5ZWFyXSA9ICQ1ZjMxYmQ2ZjBjODk0MGIyJHZhciRncmVnb3JpYW5Ub1RhaXdhbigkNWYzMWJkNmYwYzg5NDBiMiR2YXIkZ3JlZ29yaWFuWWVhcihkYXRlKSk7XG4gICAgICAgIGRhdGUuZXJhID0gZXJhO1xuICAgICAgICBkYXRlLnllYXIgPSB5ZWFyO1xuICAgIH1cbiAgICBpc0ludmVyc2VFcmEoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5lcmEgPT09IFwiYmVmb3JlX21pbmd1b1wiO1xuICAgIH1cbiAgICBnZXREYXlzSW5Nb250aChkYXRlKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXREYXlzSW5Nb250aCgkNWYzMWJkNmYwYzg5NDBiMiR2YXIkdG9HcmVnb3JpYW4oZGF0ZSkpO1xuICAgIH1cbiAgICBnZXRZZWFyc0luRXJhKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZXJhID09PSBcImJlZm9yZV9taW5ndW9cIiA/IDk5OTkgOiA5OTk5IC0gJDVmMzFiZDZmMGM4OTQwYjIkdmFyJFRBSVdBTl9FUkFfU1RBUlQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gXCJyb2NcIiAvLyBSZXB1YmxpYyBvZiBDaGluYVxuICAgICAgICA7XG4gICAgfVxufVxuZnVuY3Rpb24gJDVmMzFiZDZmMGM4OTQwYjIkdmFyJHRvR3JlZ29yaWFuKGRhdGUpIHtcbiAgICBsZXQgW2VyYSwgeWVhcl0gPSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDQ0NzViN2U2MTdlYjEyM2MpKCQ1ZjMxYmQ2ZjBjODk0MGIyJHZhciRncmVnb3JpYW5ZZWFyKGRhdGUpKTtcbiAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikoZXJhLCB5ZWFyLCBkYXRlLm1vbnRoLCBkYXRlLmRheSk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIElDVS5cbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBjYW4gYmUgZm91bmQgaW4gdGhlIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXG5cbmNvbnN0ICRmM2VkMmU0NDcyYWU3ZTI1JHZhciRQRVJTSUFOX0VQT0NIID0gMTk0ODMyMTsgLy8gNjIyLzAzLzE5IEp1bGlhbiBDLkUuXG5mdW5jdGlvbiAkZjNlZDJlNDQ3MmFlN2UyNSR2YXIkaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgbGV0IHkwID0geWVhciA+IDAgPyB5ZWFyIC0gNDc0IDogeWVhciAtIDQ3MztcbiAgICBsZXQgeTEgPSAoMCwgJDJiNGRjZTEzZGQ1YTE3ZmEkZXhwb3J0JDg0MmEyY2YzN2FmOTc3ZTEpKHkwLCAyODIwKSArIDQ3NDtcbiAgICByZXR1cm4gKDAsICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQ4NDJhMmNmMzdhZjk3N2UxKSgoeTEgKyAzOCkgKiAzMSwgMTI4KSA8IDMxO1xufVxuZnVuY3Rpb24gJGYzZWQyZTQ0NzJhZTdlMjUkdmFyJHBlcnNpYW5Ub0p1bGlhbkRheSh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgbGV0IHkwID0geWVhciA+IDAgPyB5ZWFyIC0gNDc0IDogeWVhciAtIDQ3MztcbiAgICBsZXQgeTEgPSAoMCwgJDJiNGRjZTEzZGQ1YTE3ZmEkZXhwb3J0JDg0MmEyY2YzN2FmOTc3ZTEpKHkwLCAyODIwKSArIDQ3NDtcbiAgICBsZXQgb2Zmc2V0ID0gbW9udGggPD0gNyA/IDMxICogKG1vbnRoIC0gMSkgOiAzMCAqIChtb250aCAtIDEpICsgNjtcbiAgICByZXR1cm4gJGYzZWQyZTQ0NzJhZTdlMjUkdmFyJFBFUlNJQU5fRVBPQ0ggLSAxICsgMTAyOTk4MyAqIE1hdGguZmxvb3IoeTAgLyAyODIwKSArIDM2NSAqICh5MSAtIDEpICsgTWF0aC5mbG9vcigoMzEgKiB5MSAtIDUpIC8gMTI4KSArIG9mZnNldCArIGRheTtcbn1cbmNsYXNzICRmM2VkMmU0NDcyYWU3ZTI1JGV4cG9ydCQzN2ZjY2RiZmQxNGM1OTM5IHtcbiAgICBmcm9tSnVsaWFuRGF5KGpkKSB7XG4gICAgICAgIGxldCBkMCA9IGpkIC0gJGYzZWQyZTQ0NzJhZTdlMjUkdmFyJHBlcnNpYW5Ub0p1bGlhbkRheSg0NzUsIDEsIDEpO1xuICAgICAgICBsZXQgbjI4MjAgPSBNYXRoLmZsb29yKGQwIC8gMTAyOTk4Myk7XG4gICAgICAgIGxldCBkMSA9ICgwLCAkMmI0ZGNlMTNkZDVhMTdmYSRleHBvcnQkODQyYTJjZjM3YWY5NzdlMSkoZDAsIDEwMjk5ODMpO1xuICAgICAgICBsZXQgeTI4MjAgPSBkMSA9PT0gMTAyOTk4MiA/IDI4MjAgOiBNYXRoLmZsb29yKCgxMjggKiBkMSArIDQ2ODc4KSAvIDQ2NzUxKTtcbiAgICAgICAgbGV0IHllYXIgPSA0NzQgKyAyODIwICogbjI4MjAgKyB5MjgyMDtcbiAgICAgICAgaWYgKHllYXIgPD0gMCkgeWVhci0tO1xuICAgICAgICBsZXQgeURheSA9IGpkIC0gJGYzZWQyZTQ0NzJhZTdlMjUkdmFyJHBlcnNpYW5Ub0p1bGlhbkRheSh5ZWFyLCAxLCAxKSArIDE7XG4gICAgICAgIGxldCBtb250aCA9IHlEYXkgPD0gMTg2ID8gTWF0aC5jZWlsKHlEYXkgLyAzMSkgOiBNYXRoLmNlaWwoKHlEYXkgLSA2KSAvIDMxKTtcbiAgICAgICAgbGV0IGRheSA9IGpkIC0gJGYzZWQyZTQ0NzJhZTdlMjUkdmFyJHBlcnNpYW5Ub0p1bGlhbkRheSh5ZWFyLCBtb250aCwgMSkgKyAxO1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikodGhpcywgeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuICAgIHRvSnVsaWFuRGF5KGRhdGUpIHtcbiAgICAgICAgcmV0dXJuICRmM2VkMmU0NDcyYWU3ZTI1JHZhciRwZXJzaWFuVG9KdWxpYW5EYXkoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoLCBkYXRlLmRheSk7XG4gICAgfVxuICAgIGdldE1vbnRoc0luWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIDEyO1xuICAgIH1cbiAgICBnZXREYXlzSW5Nb250aChkYXRlKSB7XG4gICAgICAgIGlmIChkYXRlLm1vbnRoIDw9IDYpIHJldHVybiAzMTtcbiAgICAgICAgaWYgKGRhdGUubW9udGggPD0gMTEpIHJldHVybiAzMDtcbiAgICAgICAgcmV0dXJuICRmM2VkMmU0NDcyYWU3ZTI1JHZhciRpc0xlYXBZZWFyKGRhdGUueWVhcikgPyAzMCA6IDI5O1xuICAgIH1cbiAgICBnZXRFcmFzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJBUFwiXG4gICAgICAgIF07XG4gICAgfVxuICAgIGdldFllYXJzSW5FcmEoKSB7XG4gICAgICAgIC8vIDkzNzgtMTAtMTAgcGVyc2lhbiBpcyA5OTk5LTEyLTMxIGdyZWdvcmlhbi5cbiAgICAgICAgLy8gUm91bmQgZG93biB0byA5Mzc3IHRvIHNldCB0aGUgbWF4aW11bSBmdWxsIHllYXIuXG4gICAgICAgIHJldHVybiA5Mzc3O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBcInBlcnNpYW5cIjtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIElDVS5cbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBjYW4gYmUgZm91bmQgaW4gdGhlIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXG5cbi8vIFN0YXJ0cyBpbiA3OCBBRCxcbmNvbnN0ICQ4MmMzNTgwMDNiZGRhMGE4JHZhciRJTkRJQU5fRVJBX1NUQVJUID0gNzg7XG4vLyBUaGUgSW5kaWFuIHllYXIgc3RhcnRzIDgwIGRheXMgbGF0ZXIgdGhhbiB0aGUgR3JlZ29yaWFuIHllYXIuXG5jb25zdCAkODJjMzU4MDAzYmRkYTBhOCR2YXIkSU5ESUFOX1lFQVJfU1RBUlQgPSA4MDtcbmNsYXNzICQ4MmMzNTgwMDNiZGRhMGE4JGV4cG9ydCQzOWYzMWM2MzlmYTE1NzI2IGV4dGVuZHMgKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjKSB7XG4gICAgZnJvbUp1bGlhbkRheShqZCkge1xuICAgICAgICAvLyBHcmVnb3JpYW4gZGF0ZSBmb3IgSnVsaWFuIGRheVxuICAgICAgICBsZXQgZGF0ZSA9IHN1cGVyLmZyb21KdWxpYW5EYXkoamQpO1xuICAgICAgICAvLyBZZWFyIGluIFNha2EgZXJhXG4gICAgICAgIGxldCBpbmRpYW5ZZWFyID0gZGF0ZS55ZWFyIC0gJDgyYzM1ODAwM2JkZGEwYTgkdmFyJElORElBTl9FUkFfU1RBUlQ7XG4gICAgICAgIC8vIERheSBudW1iZXIgaW4gR3JlZ29yaWFuIHllYXIgKHN0YXJ0aW5nIGZyb20gMClcbiAgICAgICAgbGV0IHlEYXkgPSBqZCAtICgwLCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkZjI5N2ViODM5MDA2ZDMzOSkoZGF0ZS5lcmEsIGRhdGUueWVhciwgMSwgMSk7XG4gICAgICAgIGxldCBsZWFwTW9udGg7XG4gICAgICAgIGlmICh5RGF5IDwgJDgyYzM1ODAwM2JkZGEwYTgkdmFyJElORElBTl9ZRUFSX1NUQVJUKSB7XG4gICAgICAgICAgICAvLyAgRGF5IGlzIGF0IHRoZSBlbmQgb2YgdGhlIHByZWNlZGluZyBTYWthIHllYXJcbiAgICAgICAgICAgIGluZGlhblllYXItLTtcbiAgICAgICAgICAgIC8vIERheXMgaW4gbGVhcE1vbnRoIHRoaXMgeWVhciwgcHJldmlvdXMgR3JlZ29yaWFuIHllYXJcbiAgICAgICAgICAgIGxlYXBNb250aCA9ICgwLCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkNTUzZDdmYThlMzgwNWZjMCkoZGF0ZS55ZWFyIC0gMSkgPyAzMSA6IDMwO1xuICAgICAgICAgICAgeURheSArPSBsZWFwTW9udGggKyAxNTUgKyA5MCArIDEwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGF5cyBpbiBsZWFwTW9udGggdGhpcyB5ZWFyXG4gICAgICAgICAgICBsZWFwTW9udGggPSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDU1M2Q3ZmE4ZTM4MDVmYzApKGRhdGUueWVhcikgPyAzMSA6IDMwO1xuICAgICAgICAgICAgeURheSAtPSAkODJjMzU4MDAzYmRkYTBhOCR2YXIkSU5ESUFOX1lFQVJfU1RBUlQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGlhbk1vbnRoO1xuICAgICAgICBsZXQgaW5kaWFuRGF5O1xuICAgICAgICBpZiAoeURheSA8IGxlYXBNb250aCkge1xuICAgICAgICAgICAgaW5kaWFuTW9udGggPSAxO1xuICAgICAgICAgICAgaW5kaWFuRGF5ID0geURheSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbURheSA9IHlEYXkgLSBsZWFwTW9udGg7XG4gICAgICAgICAgICBpZiAobURheSA8IDE1NSkge1xuICAgICAgICAgICAgICAgIGluZGlhbk1vbnRoID0gTWF0aC5mbG9vcihtRGF5IC8gMzEpICsgMjtcbiAgICAgICAgICAgICAgICBpbmRpYW5EYXkgPSBtRGF5ICUgMzEgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtRGF5IC09IDE1NTtcbiAgICAgICAgICAgICAgICBpbmRpYW5Nb250aCA9IE1hdGguZmxvb3IobURheSAvIDMwKSArIDc7XG4gICAgICAgICAgICAgICAgaW5kaWFuRGF5ID0gbURheSAlIDMwICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikodGhpcywgaW5kaWFuWWVhciwgaW5kaWFuTW9udGgsIGluZGlhbkRheSk7XG4gICAgfVxuICAgIHRvSnVsaWFuRGF5KGRhdGUpIHtcbiAgICAgICAgbGV0IGV4dGVuZGVkWWVhciA9IGRhdGUueWVhciArICQ4MmMzNTgwMDNiZGRhMGE4JHZhciRJTkRJQU5fRVJBX1NUQVJUO1xuICAgICAgICBsZXQgW2VyYSwgeWVhcl0gPSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDQ0NzViN2U2MTdlYjEyM2MpKGV4dGVuZGVkWWVhcik7XG4gICAgICAgIGxldCBsZWFwTW9udGg7XG4gICAgICAgIGxldCBqZDtcbiAgICAgICAgaWYgKCgwLCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkNTUzZDdmYThlMzgwNWZjMCkoeWVhcikpIHtcbiAgICAgICAgICAgIGxlYXBNb250aCA9IDMxO1xuICAgICAgICAgICAgamQgPSAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGYyOTdlYjgzOTAwNmQzMzkpKGVyYSwgeWVhciwgMywgMjEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVhcE1vbnRoID0gMzA7XG4gICAgICAgICAgICBqZCA9ICgwLCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkZjI5N2ViODM5MDA2ZDMzOSkoZXJhLCB5ZWFyLCAzLCAyMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGUubW9udGggPT09IDEpIHJldHVybiBqZCArIGRhdGUuZGF5IC0gMTtcbiAgICAgICAgamQgKz0gbGVhcE1vbnRoICsgTWF0aC5taW4oZGF0ZS5tb250aCAtIDIsIDUpICogMzE7XG4gICAgICAgIGlmIChkYXRlLm1vbnRoID49IDgpIGpkICs9IChkYXRlLm1vbnRoIC0gNykgKiAzMDtcbiAgICAgICAgamQgKz0gZGF0ZS5kYXkgLSAxO1xuICAgICAgICByZXR1cm4gamQ7XG4gICAgfVxuICAgIGdldERheXNJbk1vbnRoKGRhdGUpIHtcbiAgICAgICAgaWYgKGRhdGUubW9udGggPT09IDEgJiYgKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ1NTNkN2ZhOGUzODA1ZmMwKShkYXRlLnllYXIgKyAkODJjMzU4MDAzYmRkYTBhOCR2YXIkSU5ESUFOX0VSQV9TVEFSVCkpIHJldHVybiAzMTtcbiAgICAgICAgaWYgKGRhdGUubW9udGggPj0gMiAmJiBkYXRlLm1vbnRoIDw9IDYpIHJldHVybiAzMTtcbiAgICAgICAgcmV0dXJuIDMwO1xuICAgIH1cbiAgICBnZXRZZWFyc0luRXJhKCkge1xuICAgICAgICAvLyA5OTk5LTEyLTMxIGdyZWdvcmlhbiBpcyA5OTIwLTEwLTEwIGluZGlhbi5cbiAgICAgICAgLy8gUm91bmQgZG93biB0byA5OTE5IGZvciB0aGUgbGFzdCBmdWxsIHllYXIuXG4gICAgICAgIHJldHVybiA5OTE5O1xuICAgIH1cbiAgICBnZXRFcmFzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJzYWthXCJcbiAgICAgICAgXTtcbiAgICB9XG4gICAgYmFsYW5jZURhdGUoKSB7fVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gXCJpbmRpYW5cIjtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIElDVS5cbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBjYW4gYmUgZm91bmQgaW4gdGhlIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXG5jb25zdCAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkQ0lWSUxfRVBPQyA9IDE5NDg0NDA7IC8vIENFIDYyMiBKdWx5IDE2IEZyaWRheSAoSnVsaWFuIGNhbGVuZGFyKSAvIENFIDYyMiBKdWx5IDE5IChHcmVnb3JpYW4gY2FsZW5kYXIpXG5jb25zdCAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkQVNUUk9OT01JQ0FMX0VQT0MgPSAxOTQ4NDM5OyAvLyBDRSA2MjIgSnVseSAxNSBUaHVyc2RheSAoSnVsaWFuIGNhbGVuZGFyKVxuY29uc3QgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfU1RBUlQgPSAxMzAwO1xuY29uc3QgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfRU5EID0gMTYwMDtcbmNvbnN0ICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9TVEFSVF9EQVlTID0gNDYwMzIyO1xuZnVuY3Rpb24gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJGlzbGFtaWNUb0p1bGlhbkRheShlcG9jaCwgeWVhciwgbW9udGgsIGRheSkge1xuICAgIHJldHVybiBkYXkgKyBNYXRoLmNlaWwoMjkuNSAqIChtb250aCAtIDEpKSArICh5ZWFyIC0gMSkgKiAzNTQgKyBNYXRoLmZsb29yKCgzICsgMTEgKiB5ZWFyKSAvIDMwKSArIGVwb2NoIC0gMTtcbn1cbmZ1bmN0aW9uICRmMmYzZTBlM2E4MTdlZGJkJHZhciRqdWxpYW5EYXlUb0lzbGFtaWMoY2FsZW5kYXIsIGVwb2NoLCBqZCkge1xuICAgIGxldCB5ZWFyID0gTWF0aC5mbG9vcigoMzAgKiAoamQgLSBlcG9jaCkgKyAxMDY0NikgLyAxMDYzMSk7XG4gICAgbGV0IG1vbnRoID0gTWF0aC5taW4oMTIsIE1hdGguY2VpbCgoamQgLSAoMjkgKyAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkaXNsYW1pY1RvSnVsaWFuRGF5KGVwb2NoLCB5ZWFyLCAxLCAxKSkpIC8gMjkuNSkgKyAxKTtcbiAgICBsZXQgZGF5ID0gamQgLSAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkaXNsYW1pY1RvSnVsaWFuRGF5KGVwb2NoLCB5ZWFyLCBtb250aCwgMSkgKyAxO1xuICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKShjYWxlbmRhciwgeWVhciwgbW9udGgsIGRheSk7XG59XG5mdW5jdGlvbiAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuICgxNCArIDExICogeWVhcikgJSAzMCA8IDExO1xufVxuY2xhc3MgJGYyZjNlMGUzYTgxN2VkYmQkZXhwb3J0JDIwNjY3OTVhYWRkMzdiZmMge1xuICAgIGZyb21KdWxpYW5EYXkoamQpIHtcbiAgICAgICAgcmV0dXJuICRmMmYzZTBlM2E4MTdlZGJkJHZhciRqdWxpYW5EYXlUb0lzbGFtaWModGhpcywgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJENJVklMX0VQT0MsIGpkKTtcbiAgICB9XG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xuICAgICAgICByZXR1cm4gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJGlzbGFtaWNUb0p1bGlhbkRheSgkZjJmM2UwZTNhODE3ZWRiZCR2YXIkQ0lWSUxfRVBPQywgZGF0ZS55ZWFyLCBkYXRlLm1vbnRoLCBkYXRlLmRheSk7XG4gICAgfVxuICAgIGdldERheXNJbk1vbnRoKGRhdGUpIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDI5ICsgZGF0ZS5tb250aCAlIDI7XG4gICAgICAgIGlmIChkYXRlLm1vbnRoID09PSAxMiAmJiAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkaXNMZWFwWWVhcihkYXRlLnllYXIpKSBsZW5ndGgrKztcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gICAgZ2V0TW9udGhzSW5ZZWFyKCkge1xuICAgICAgICByZXR1cm4gMTI7XG4gICAgfVxuICAgIGdldERheXNJblllYXIoZGF0ZSkge1xuICAgICAgICByZXR1cm4gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJGlzTGVhcFllYXIoZGF0ZS55ZWFyKSA/IDM1NSA6IDM1NDtcbiAgICB9XG4gICAgZ2V0WWVhcnNJbkVyYSgpIHtcbiAgICAgICAgLy8gOTk5OSBncmVnb3JpYW5cbiAgICAgICAgcmV0dXJuIDk2NjU7XG4gICAgfVxuICAgIGdldEVyYXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBcIkFIXCJcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gXCJpc2xhbWljLWNpdmlsXCI7XG4gICAgfVxufVxuY2xhc3MgJGYyZjNlMGUzYTgxN2VkYmQkZXhwb3J0JDM3ZjA4ODdmMmY5ZDIyZjcgZXh0ZW5kcyAkZjJmM2UwZTNhODE3ZWRiZCRleHBvcnQkMjA2Njc5NWFhZGQzN2JmYyB7XG4gICAgZnJvbUp1bGlhbkRheShqZCkge1xuICAgICAgICByZXR1cm4gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJGp1bGlhbkRheVRvSXNsYW1pYyh0aGlzLCAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkQVNUUk9OT01JQ0FMX0VQT0MsIGpkKTtcbiAgICB9XG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xuICAgICAgICByZXR1cm4gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJGlzbGFtaWNUb0p1bGlhbkRheSgkZjJmM2UwZTNhODE3ZWRiZCR2YXIkQVNUUk9OT01JQ0FMX0VQT0MsIGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IFwiaXNsYW1pYy10YmxhXCI7XG4gICAgfVxufVxuLy8gR2VuZXJhdGVkIGJ5IHNjcmlwdHMvZ2VuZXJhdGUtdW1hbHF1cmEuanNcbmNvbnN0ICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9EQVRBID0gXCJxZ3BVRGNrTzFBYnFCbXdEclFwVkJha0drZ2VwQzlRRjJncGNCUzBObFFaS0IxUUxhZ3V0QmE0RVR3b1hCWXNHcFFiVkN0WUNXd21kQkUwS0pnMlZEYXdGdGdtNkFsc0tLd1dWQ3NvRzZRcjBBbllKdGdKV0Njb0twQXZTQzlrRjNBSnRDVTBGcFFwU0M2VUx0QVcyQ1ZjRmx3SkxCYU1HVWdkbEMyb0Zxd29yQlpVTVNnMmxEY29GMWdwWENhc0VTd21sQ2xJTGFndDFCWFlDdHdoYkJGVUZxUVcwQmRvSjNRUnVBallKcWdwVURiSU4xUVhhQWxzSnF3UlZDa2tMWkF0eEM3UUZ0UXBWQ2lVTmtnN0pEdFFHNlFwckNhc0Vrd3BKRGFRTnNnMjVDcm9FV3dvckJaVUtLZ3RWQzF3RnZRUTlBaDBKbFFwS0Mxb0xiUVcyQWpzSm13UlZCcWtHVkFkcUMyd0ZyUXBWQlNrTGtndXBDOVFGMmdwYUJhc0tsUVZKQjJRSHFndTFCYllDVmdwTkRpVUxVZ3RxQzYwRnJnSXZDWmNFU3dhbEJxd0cxZ3BkQlowRVRRb1dEWlVOcWdXMUJkb0NXd210QkpVRnlnYmtCdW9LOVFTMkFsWUpxZ3BVQzlJTDJRWHFBbTBKclFTVkNrb0xwUXV5QmJVSjFnU1hDa2NGa3daSkIxVUxhZ1ZyQ2lzRml3cEdEYU1OeWdYV0N0c0Vhd0pMQ2FVS1VndHBDM1VGZGdHM0NGc0NLd1ZsQmJRRjJnbnRCRzBCdGdpbUNsSU5xUTNVQmRvS1d3bXJCRk1HS1FkaUI2a0xzZ1cxQ2xVRkpRdVNEY2tPMGdicENtc0Zxd1JWQ2lrTlZBMnFEYlVKdWdRN0Nwc0VUUXFxQ3RVSzJnSmRDVjRFTGdxYURGVU5zZ2E1QnJvRVhRb3RCWlVLVWd1b0M3UUx1UVhhQWxvSlNndWtEZEVPNkFacUMyMEZOUVdWQmtvTnFBM1VEZG9HV3dXZEFpc0dGUXRLQzVVTHFnV3VDaTRKand3bkJaVUdxZ2JXQ2wwRm5RST1cIjtcbmxldCAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfTU9OVEhMRU5HVEg7XG5sZXQgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfU1RBUlRfVEFCTEU7XG5mdW5jdGlvbiAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkdW1hbHF1cmFZZWFyU3RhcnQoeWVhcikge1xuICAgIHJldHVybiAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfU1RBUlRfREFZUyArICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUX1RBQkxFW3llYXIgLSAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfWUVBUl9TVEFSVF07XG59XG5mdW5jdGlvbiAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkdW1hbHF1cmFNb250aExlbmd0aCh5ZWFyLCBtb250aCkge1xuICAgIGxldCBpZHggPSB5ZWFyIC0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfU1RBUlQ7XG4gICAgbGV0IG1hc2sgPSAweDAxIDw8IDExIC0gKG1vbnRoIC0gMSk7XG4gICAgaWYgKCgkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfTU9OVEhMRU5HVEhbaWR4XSAmIG1hc2spID09PSAwKSByZXR1cm4gMjk7XG4gICAgZWxzZSByZXR1cm4gMzA7XG59XG5mdW5jdGlvbiAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkdW1hbHF1cmFNb250aFN0YXJ0KHllYXIsIG1vbnRoKSB7XG4gICAgbGV0IGRheSA9ICRmMmYzZTBlM2E4MTdlZGJkJHZhciR1bWFscXVyYVllYXJTdGFydCh5ZWFyKTtcbiAgICBmb3IobGV0IGkgPSAxOyBpIDwgbW9udGg7IGkrKylkYXkgKz0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJHVtYWxxdXJhTW9udGhMZW5ndGgoeWVhciwgaSk7XG4gICAgcmV0dXJuIGRheTtcbn1cbmZ1bmN0aW9uICRmMmYzZTBlM2E4MTdlZGJkJHZhciR1bWFscXVyYVllYXJMZW5ndGgoeWVhcikge1xuICAgIHJldHVybiAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfWUVBUl9TVEFSVF9UQUJMRVt5ZWFyICsgMSAtICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUXSAtICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUX1RBQkxFW3llYXIgLSAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfWUVBUl9TVEFSVF07XG59XG5jbGFzcyAkZjJmM2UwZTNhODE3ZWRiZCRleHBvcnQkNWJhYWI0NzU4YzIzMTA3NiBleHRlbmRzICRmMmYzZTBlM2E4MTdlZGJkJGV4cG9ydCQyMDY2Nzk1YWFkZDM3YmZjIHtcbiAgICBmcm9tSnVsaWFuRGF5KGpkKSB7XG4gICAgICAgIGxldCBkYXlzID0gamQgLSAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkQ0lWSUxfRVBPQztcbiAgICAgICAgbGV0IHN0YXJ0RGF5cyA9ICRmMmYzZTBlM2E4MTdlZGJkJHZhciR1bWFscXVyYVllYXJTdGFydCgkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfWUVBUl9TVEFSVCk7XG4gICAgICAgIGxldCBlbmREYXlzID0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJHVtYWxxdXJhWWVhclN0YXJ0KCRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX0VORCk7XG4gICAgICAgIGlmIChkYXlzIDwgc3RhcnREYXlzIHx8IGRheXMgPiBlbmREYXlzKSByZXR1cm4gc3VwZXIuZnJvbUp1bGlhbkRheShqZCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHkgPSAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfWUVBUl9TVEFSVCAtIDE7XG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBsZXQgZCA9IDE7XG4gICAgICAgICAgICB3aGlsZShkID4gMCl7XG4gICAgICAgICAgICAgICAgeSsrO1xuICAgICAgICAgICAgICAgIGQgPSBkYXlzIC0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJHVtYWxxdXJhWWVhclN0YXJ0KHkpICsgMTtcbiAgICAgICAgICAgICAgICBsZXQgeWVhckxlbmd0aCA9ICRmMmYzZTBlM2E4MTdlZGJkJHZhciR1bWFscXVyYVllYXJMZW5ndGgoeSk7XG4gICAgICAgICAgICAgICAgaWYgKGQgPT09IHllYXJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbSA9IDEyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGQgPCB5ZWFyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb250aExlbmd0aCA9ICRmMmYzZTBlM2E4MTdlZGJkJHZhciR1bWFscXVyYU1vbnRoTGVuZ3RoKHksIG0pO1xuICAgICAgICAgICAgICAgICAgICBtID0gMTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoZCA+IG1vbnRoTGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgLT0gbW9udGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aExlbmd0aCA9ICRmMmYzZTBlM2E4MTdlZGJkJHZhciR1bWFscXVyYU1vbnRoTGVuZ3RoKHksIG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKSh0aGlzLCB5LCBtLCBkYXlzIC0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJHVtYWxxdXJhTW9udGhTdGFydCh5LCBtKSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSnVsaWFuRGF5KGRhdGUpIHtcbiAgICAgICAgaWYgKGRhdGUueWVhciA8ICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUIHx8IGRhdGUueWVhciA+ICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX0VORCkgcmV0dXJuIHN1cGVyLnRvSnVsaWFuRGF5KGRhdGUpO1xuICAgICAgICByZXR1cm4gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJENJVklMX0VQT0MgKyAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkdW1hbHF1cmFNb250aFN0YXJ0KGRhdGUueWVhciwgZGF0ZS5tb250aCkgKyAoZGF0ZS5kYXkgLSAxKTtcbiAgICB9XG4gICAgZ2V0RGF5c0luTW9udGgoZGF0ZSkge1xuICAgICAgICBpZiAoZGF0ZS55ZWFyIDwgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfU1RBUlQgfHwgZGF0ZS55ZWFyID4gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfRU5EKSByZXR1cm4gc3VwZXIuZ2V0RGF5c0luTW9udGgoZGF0ZSk7XG4gICAgICAgIHJldHVybiAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkdW1hbHF1cmFNb250aExlbmd0aChkYXRlLnllYXIsIGRhdGUubW9udGgpO1xuICAgIH1cbiAgICBnZXREYXlzSW5ZZWFyKGRhdGUpIHtcbiAgICAgICAgaWYgKGRhdGUueWVhciA8ICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUIHx8IGRhdGUueWVhciA+ICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX0VORCkgcmV0dXJuIHN1cGVyLmdldERheXNJblllYXIoZGF0ZSk7XG4gICAgICAgIHJldHVybiAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkdW1hbHF1cmFZZWFyTGVuZ3RoKGRhdGUueWVhcik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IFwiaXNsYW1pYy11bWFscXVyYVwiO1xuICAgICAgICBpZiAoISRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9NT05USExFTkdUSCkgJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX01PTlRITEVOR1RIID0gbmV3IFVpbnQxNkFycmF5KFVpbnQ4QXJyYXkuZnJvbShhdG9iKCRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9EQVRBKSwgKGMpPT5jLmNoYXJDb2RlQXQoMCkpLmJ1ZmZlcik7XG4gICAgICAgIGlmICghJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfU1RBUlRfVEFCTEUpIHtcbiAgICAgICAgICAgICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUX1RBQkxFID0gbmV3IFVpbnQzMkFycmF5KCRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX0VORCAtICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUICsgMSk7XG4gICAgICAgICAgICBsZXQgeWVhclN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGZvcihsZXQgeWVhciA9ICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX1NUQVJUOyB5ZWFyIDw9ICRmMmYzZTBlM2E4MTdlZGJkJHZhciRVTUFMUVVSQV9ZRUFSX0VORDsgeWVhcisrKXtcbiAgICAgICAgICAgICAgICAkZjJmM2UwZTNhODE3ZWRiZCR2YXIkVU1BTFFVUkFfWUVBUl9TVEFSVF9UQUJMRVt5ZWFyIC0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJFVNQUxRVVJBX1lFQVJfU1RBUlRdID0geWVhclN0YXJ0O1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPD0gMTI7IGkrKyl5ZWFyU3RhcnQgKz0gJGYyZjNlMGUzYTgxN2VkYmQkdmFyJHVtYWxxdXJhTW9udGhMZW5ndGgoeWVhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIElDVS5cbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBjYW4gYmUgZm91bmQgaW4gdGhlIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXG5cbmNvbnN0ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRIRUJSRVdfRVBPQ0ggPSAzNDc5OTc7XG4vLyBIZWJyZXcgZGF0ZSBjYWxjdWxhdGlvbnMgYXJlIHBlcmZvcm1lZCBpbiB0ZXJtcyBvZiBkYXlzLCBob3VycywgYW5kXG4vLyBcInBhcnRzXCIgKG9yIGhhbGFraW0pLCB3aGljaCBhcmUgMS8xMDgwIG9mIGFuIGhvdXIsIG9yIDMgMS8zIHNlY29uZHMuXG5jb25zdCAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkSE9VUl9QQVJUUyA9IDEwODA7XG5jb25zdCAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkREFZX1BBUlRTID0gMjQgKiAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkSE9VUl9QQVJUUztcbi8vIEFuIGFwcHJveGltYXRlIHZhbHVlIGZvciB0aGUgbGVuZ3RoIG9mIGEgbHVuYXIgbW9udGguXG4vLyBJdCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYXBwcm94aW1hdGUgeWVhciBhbmQgbW9udGggb2YgYSBnaXZlblxuLy8gYWJzb2x1dGUgZGF0ZS5cbmNvbnN0ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRNT05USF9EQVlTID0gMjk7XG5jb25zdCAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkTU9OVEhfRlJBQ1QgPSAxMiAqICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRIT1VSX1BBUlRTICsgNzkzO1xuY29uc3QgJDdjNWY2ZmJmNDIzODk3ODckdmFyJE1PTlRIX1BBUlRTID0gJDdjNWY2ZmJmNDIzODk3ODckdmFyJE1PTlRIX0RBWVMgKiAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkREFZX1BBUlRTICsgJDdjNWY2ZmJmNDIzODk3ODckdmFyJE1PTlRIX0ZSQUNUO1xuZnVuY3Rpb24gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGlzTGVhcFllYXIoeWVhcikge1xuICAgIHJldHVybiAoMCwgJDJiNGRjZTEzZGQ1YTE3ZmEkZXhwb3J0JDg0MmEyY2YzN2FmOTc3ZTEpKHllYXIgKiA3ICsgMSwgMTkpIDwgNztcbn1cbi8vIFRlc3QgZm9yIGRlbGF5IG9mIHN0YXJ0IG9mIG5ldyB5ZWFyIGFuZCB0byBhdm9pZFxuLy8gU3VuZGF5LCBXZWRuZXNkYXksIGFuZCBGcmlkYXkgYXMgc3RhcnQgb2YgdGhlIG5ldyB5ZWFyLlxuZnVuY3Rpb24gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGhlYnJld0RlbGF5MSh5ZWFyKSB7XG4gICAgbGV0IG1vbnRocyA9IE1hdGguZmxvb3IoKDIzNSAqIHllYXIgLSAyMzQpIC8gMTkpO1xuICAgIGxldCBwYXJ0cyA9IDEyMDg0ICsgMTM3NTMgKiBtb250aHM7XG4gICAgbGV0IGRheSA9IG1vbnRocyAqIDI5ICsgTWF0aC5mbG9vcihwYXJ0cyAvIDI1OTIwKTtcbiAgICBpZiAoKDAsICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQ4NDJhMmNmMzdhZjk3N2UxKSgzICogKGRheSArIDEpLCA3KSA8IDMpIGRheSArPSAxO1xuICAgIHJldHVybiBkYXk7XG59XG4vLyBDaGVjayBmb3IgZGVsYXkgaW4gc3RhcnQgb2YgbmV3IHllYXIgZHVlIHRvIGxlbmd0aCBvZiBhZGphY2VudCB5ZWFyc1xuZnVuY3Rpb24gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGhlYnJld0RlbGF5Mih5ZWFyKSB7XG4gICAgbGV0IGxhc3QgPSAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkaGVicmV3RGVsYXkxKHllYXIgLSAxKTtcbiAgICBsZXQgcHJlc2VudCA9ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRoZWJyZXdEZWxheTEoeWVhcik7XG4gICAgbGV0IG5leHQgPSAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkaGVicmV3RGVsYXkxKHllYXIgKyAxKTtcbiAgICBpZiAobmV4dCAtIHByZXNlbnQgPT09IDM1NikgcmV0dXJuIDI7XG4gICAgaWYgKHByZXNlbnQgLSBsYXN0ID09PSAzODIpIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gJDdjNWY2ZmJmNDIzODk3ODckdmFyJHN0YXJ0T2ZZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGhlYnJld0RlbGF5MSh5ZWFyKSArICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRoZWJyZXdEZWxheTIoeWVhcik7XG59XG5mdW5jdGlvbiAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkZ2V0RGF5c0luWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRzdGFydE9mWWVhcih5ZWFyICsgMSkgLSAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkc3RhcnRPZlllYXIoeWVhcik7XG59XG5mdW5jdGlvbiAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkZ2V0WWVhclR5cGUoeWVhcikge1xuICAgIGxldCB5ZWFyTGVuZ3RoID0gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGdldERheXNJblllYXIoeWVhcik7XG4gICAgaWYgKHllYXJMZW5ndGggPiAzODApIHllYXJMZW5ndGggLT0gMzA7IC8vIFN1YnRyYWN0IGxlbmd0aCBvZiBsZWFwIG1vbnRoLlxuICAgIHN3aXRjaCh5ZWFyTGVuZ3RoKXtcbiAgICAgICAgY2FzZSAzNTM6XG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gZGVmaWNpZW50XG4gICAgICAgIGNhc2UgMzU0OlxuICAgICAgICAgICAgcmV0dXJuIDE7IC8vIG5vcm1hbFxuICAgICAgICBjYXNlIDM1NTpcbiAgICAgICAgICAgIHJldHVybiAyOyAvLyBjb21wbGV0ZVxuICAgIH1cbn1cbmZ1bmN0aW9uICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRnZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgIC8vIE5vcm1hbGl6ZSBtb250aCBudW1iZXJzIGZyb20gMSAtIDEzLCBldmVuIG9uIG5vbi1sZWFwIHllYXJzXG4gICAgaWYgKG1vbnRoID49IDYgJiYgISQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRpc0xlYXBZZWFyKHllYXIpKSBtb250aCsrO1xuICAgIC8vIEZpcnN0IG9mIGFsbCwgZGlzcG9zZSBvZiBmaXhlZC1sZW5ndGggMjkgZGF5IG1vbnRoc1xuICAgIGlmIChtb250aCA9PT0gNCB8fCBtb250aCA9PT0gNyB8fCBtb250aCA9PT0gOSB8fCBtb250aCA9PT0gMTEgfHwgbW9udGggPT09IDEzKSByZXR1cm4gMjk7XG4gICAgbGV0IHllYXJUeXBlID0gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGdldFllYXJUeXBlKHllYXIpO1xuICAgIC8vIElmIGl0J3MgSGVzaHZhbiwgZGF5cyBkZXBlbmQgb24gbGVuZ3RoIG9mIHllYXJcbiAgICBpZiAobW9udGggPT09IDIpIHJldHVybiB5ZWFyVHlwZSA9PT0gMiA/IDMwIDogMjk7XG4gICAgLy8gU2ltaWxhcmx5LCBLaXNsZXYgdmFyaWVzIHdpdGggdGhlIGxlbmd0aCBvZiB5ZWFyXG4gICAgaWYgKG1vbnRoID09PSAzKSByZXR1cm4geWVhclR5cGUgPT09IDAgPyAyOSA6IDMwO1xuICAgIC8vIEFkYXIgSSBvbmx5IGV4aXN0cyBpbiBsZWFwIHllYXJzXG4gICAgaWYgKG1vbnRoID09PSA2KSByZXR1cm4gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGlzTGVhcFllYXIoeWVhcikgPyAzMCA6IDA7XG4gICAgcmV0dXJuIDMwO1xufVxuY2xhc3MgJDdjNWY2ZmJmNDIzODk3ODckZXhwb3J0JGNhNDA1MDQ4YjhmYjVhZiB7XG4gICAgZnJvbUp1bGlhbkRheShqZCkge1xuICAgICAgICBsZXQgZCA9IGpkIC0gJDdjNWY2ZmJmNDIzODk3ODckdmFyJEhFQlJFV19FUE9DSDtcbiAgICAgICAgbGV0IG0gPSBkICogJDdjNWY2ZmJmNDIzODk3ODckdmFyJERBWV9QQVJUUyAvICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRNT05USF9QQVJUUzsgLy8gTW9udGhzIChhcHByb3gpXG4gICAgICAgIGxldCB5ZWFyID0gTWF0aC5mbG9vcigoMTkgKiBtICsgMjM0KSAvIDIzNSkgKyAxOyAvLyBZZWFycyAoYXBwcm94KVxuICAgICAgICBsZXQgeXMgPSAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkc3RhcnRPZlllYXIoeWVhcik7IC8vIDFzdCBkYXkgb2YgeWVhclxuICAgICAgICBsZXQgZGF5T2ZZZWFyID0gTWF0aC5mbG9vcihkIC0geXMpO1xuICAgICAgICAvLyBCZWNhdXNlIG9mIHRoZSBwb3N0cG9uZW1lbnQgcnVsZXMsIGl0J3MgcG9zc2libGUgdG8gZ3Vlc3Mgd3JvbmcuICBGaXggaXQuXG4gICAgICAgIHdoaWxlKGRheU9mWWVhciA8IDEpe1xuICAgICAgICAgICAgeWVhci0tO1xuICAgICAgICAgICAgeXMgPSAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkc3RhcnRPZlllYXIoeWVhcik7XG4gICAgICAgICAgICBkYXlPZlllYXIgPSBNYXRoLmZsb29yKGQgLSB5cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IGZpZ3VyZSBvdXQgd2hpY2ggbW9udGggd2UncmUgaW4sIGFuZCB0aGUgZGF0ZSB3aXRoaW4gdGhhdCBtb250aFxuICAgICAgICBsZXQgbW9udGggPSAxO1xuICAgICAgICBsZXQgbW9udGhTdGFydCA9IDA7XG4gICAgICAgIHdoaWxlKG1vbnRoU3RhcnQgPCBkYXlPZlllYXIpe1xuICAgICAgICAgICAgbW9udGhTdGFydCArPSAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgbW9udGgrKztcbiAgICAgICAgfVxuICAgICAgICBtb250aC0tO1xuICAgICAgICBtb250aFN0YXJ0IC09ICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRnZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCk7XG4gICAgICAgIGxldCBkYXkgPSBkYXlPZlllYXIgLSBtb250aFN0YXJ0O1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikodGhpcywgeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuICAgIHRvSnVsaWFuRGF5KGRhdGUpIHtcbiAgICAgICAgbGV0IGpkID0gJDdjNWY2ZmJmNDIzODk3ODckdmFyJHN0YXJ0T2ZZZWFyKGRhdGUueWVhcik7XG4gICAgICAgIGZvcihsZXQgbW9udGggPSAxOyBtb250aCA8IGRhdGUubW9udGg7IG1vbnRoKyspamQgKz0gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGdldERheXNJbk1vbnRoKGRhdGUueWVhciwgbW9udGgpO1xuICAgICAgICByZXR1cm4gamQgKyBkYXRlLmRheSArICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRIRUJSRVdfRVBPQ0g7XG4gICAgfVxuICAgIGdldERheXNJbk1vbnRoKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuICQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRnZXREYXlzSW5Nb250aChkYXRlLnllYXIsIGRhdGUubW9udGgpO1xuICAgIH1cbiAgICBnZXRNb250aHNJblllYXIoZGF0ZSkge1xuICAgICAgICByZXR1cm4gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGlzTGVhcFllYXIoZGF0ZS55ZWFyKSA/IDEzIDogMTI7XG4gICAgfVxuICAgIGdldERheXNJblllYXIoZGF0ZSkge1xuICAgICAgICByZXR1cm4gJDdjNWY2ZmJmNDIzODk3ODckdmFyJGdldERheXNJblllYXIoZGF0ZS55ZWFyKTtcbiAgICB9XG4gICAgZ2V0WWVhcnNJbkVyYSgpIHtcbiAgICAgICAgLy8gNjIzOSBncmVnb3JpYW5cbiAgICAgICAgcmV0dXJuIDk5OTk7XG4gICAgfVxuICAgIGdldEVyYXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBcIkFNXCJcbiAgICAgICAgXTtcbiAgICB9XG4gICAgYmFsYW5jZVllYXJNb250aChkYXRlLCBwcmV2aW91c0RhdGUpIHtcbiAgICAgICAgLy8gS2VlcCBkYXRlIGluIHRoZSBzYW1lIG1vbnRoIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gbGVhcCB5ZWFycyBhbmQgbm9uIGxlYXAgeWVhcnNcbiAgICAgICAgaWYgKHByZXZpb3VzRGF0ZS55ZWFyICE9PSBkYXRlLnllYXIpIHtcbiAgICAgICAgICAgIGlmICgkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkaXNMZWFwWWVhcihwcmV2aW91c0RhdGUueWVhcikgJiYgISQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRpc0xlYXBZZWFyKGRhdGUueWVhcikgJiYgcHJldmlvdXNEYXRlLm1vbnRoID4gNikgZGF0ZS5tb250aC0tO1xuICAgICAgICAgICAgZWxzZSBpZiAoISQ3YzVmNmZiZjQyMzg5Nzg3JHZhciRpc0xlYXBZZWFyKHByZXZpb3VzRGF0ZS55ZWFyKSAmJiAkN2M1ZjZmYmY0MjM4OTc4NyR2YXIkaXNMZWFwWWVhcihkYXRlLnllYXIpICYmIHByZXZpb3VzRGF0ZS5tb250aCA+IDYpIGRhdGUubW9udGgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBcImhlYnJld1wiO1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gSUNVLlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGNhbiBiZSBmb3VuZCBpbiB0aGUgTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cbmNvbnN0ICRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRFVEhJT1BJQ19FUE9DSCA9IDE3MjM4NTY7XG5jb25zdCAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkQ09QVElDX0VQT0NIID0gMTgyNDY2NTtcbi8vIFRoZSBkZWx0YSBiZXR3ZWVuIEFtZXRlIEFsZW0gMSBhbmQgQW1ldGUgTWlocmV0IDFcbi8vIEFBIDU1MDEgPSBBTSAxXG5jb25zdCAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkQU1FVEVfTUlIUkVUX0RFTFRBID0gNTUwMDtcbmZ1bmN0aW9uICRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRjZVRvSnVsaWFuRGF5KGVwb2NoLCB5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgcmV0dXJuIGVwb2NoIC8vIGRpZmZlcmVuY2UgZnJvbSBKdWxpYW4gZXBvY2ggdG8gMSwxLDFcbiAgICAgKyAzNjUgKiB5ZWFyIC8vIG51bWJlciBvZiBkYXlzIGZyb20geWVhcnNcbiAgICAgKyBNYXRoLmZsb29yKHllYXIgLyA0KSAvLyBleHRyYSBkYXkgb2YgbGVhcCB5ZWFyXG4gICAgICsgMzAgKiAobW9udGggLSAxIC8vIG51bWJlciBvZiBkYXlzIGZyb20gbW9udGhzICgxIGJhc2VkKVxuICAgICkgKyBkYXkgLSAxIC8vIG51bWJlciBvZiBkYXlzIGZvciBwcmVzZW50IG1vbnRoICgxIGJhc2VkKVxuICAgIDtcbn1cbmZ1bmN0aW9uICRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRqdWxpYW5EYXlUb0NFKGVwb2NoLCBqZCkge1xuICAgIGxldCB5ZWFyID0gTWF0aC5mbG9vcig0ICogKGpkIC0gZXBvY2gpIC8gMTQ2MSk7XG4gICAgbGV0IG1vbnRoID0gMSArIE1hdGguZmxvb3IoKGpkIC0gJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJGNlVG9KdWxpYW5EYXkoZXBvY2gsIHllYXIsIDEsIDEpKSAvIDMwKTtcbiAgICBsZXQgZGF5ID0gamQgKyAxIC0gJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJGNlVG9KdWxpYW5EYXkoZXBvY2gsIHllYXIsIG1vbnRoLCAxKTtcbiAgICByZXR1cm4gW1xuICAgICAgICB5ZWFyLFxuICAgICAgICBtb250aCxcbiAgICAgICAgZGF5XG4gICAgXTtcbn1cbmZ1bmN0aW9uICRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRnZXRMZWFwRGF5KHllYXIpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih5ZWFyICUgNCAvIDMpO1xufVxuZnVuY3Rpb24gJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJGdldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgLy8gVGhlIEV0aGlvcGlhbiBhbmQgQ29wdGljIGNhbGVuZGFycyBoYXZlIDEzIG1vbnRocywgMTIgb2YgMzAgZGF5cyBlYWNoIGFuZFxuICAgIC8vIGFuIGludGVyY2FsYXJ5IG1vbnRoIGF0IHRoZSBlbmQgb2YgdGhlIHllYXIgb2YgNSBvciA2IGRheXMsIGRlcGVuZGluZyB3aGV0aGVyXG4gICAgLy8gdGhlIHllYXIgaXMgYSBsZWFwIHllYXIgb3Igbm90LiBUaGUgTGVhcCBZZWFyIGZvbGxvd3MgdGhlIHNhbWUgcnVsZXMgYXMgdGhlXG4gICAgLy8gSnVsaWFuIENhbGVuZGFyIHNvIHRoYXQgdGhlIGV4dHJhIG1vbnRoIGFsd2F5cyBoYXMgc2l4IGRheXMgaW4gdGhlIHllYXIgYmVmb3JlXG4gICAgLy8gYSBKdWxpYW4gTGVhcCBZZWFyLlxuICAgIGlmIChtb250aCAlIDEzICE9PSAwKSAvLyBub3QgaW50ZXJjYWxhcnkgbW9udGhcbiAgICByZXR1cm4gMzA7XG4gICAgZWxzZSAvLyBpbnRlcmNhbGFyeSBtb250aCA1IGRheXMgKyBwb3NzaWJsZSBsZWFwIGRheVxuICAgIHJldHVybiAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkZ2V0TGVhcERheSh5ZWFyKSArIDU7XG59XG5jbGFzcyAkYjk1NmIyZDdhNmNmNDUxZiRleHBvcnQkMjZiYTZlYWI1ZTIwY2Q3ZCB7XG4gICAgZnJvbUp1bGlhbkRheShqZCkge1xuICAgICAgICBsZXQgW3llYXIsIG1vbnRoLCBkYXldID0gJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJGp1bGlhbkRheVRvQ0UoJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJEVUSElPUElDX0VQT0NILCBqZCk7XG4gICAgICAgIGxldCBlcmEgPSBcIkFNXCI7XG4gICAgICAgIGlmICh5ZWFyIDw9IDApIHtcbiAgICAgICAgICAgIGVyYSA9IFwiQUFcIjtcbiAgICAgICAgICAgIHllYXIgKz0gJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJEFNRVRFX01JSFJFVF9ERUxUQTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikodGhpcywgZXJhLCB5ZWFyLCBtb250aCwgZGF5KTtcbiAgICB9XG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xuICAgICAgICBsZXQgeWVhciA9IGRhdGUueWVhcjtcbiAgICAgICAgaWYgKGRhdGUuZXJhID09PSBcIkFBXCIpIHllYXIgLT0gJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJEFNRVRFX01JSFJFVF9ERUxUQTtcbiAgICAgICAgcmV0dXJuICRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRjZVRvSnVsaWFuRGF5KCRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRFVEhJT1BJQ19FUE9DSCwgeWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXkpO1xuICAgIH1cbiAgICBnZXREYXlzSW5Nb250aChkYXRlKSB7XG4gICAgICAgIHJldHVybiAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkZ2V0RGF5c0luTW9udGgoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoKTtcbiAgICB9XG4gICAgZ2V0TW9udGhzSW5ZZWFyKCkge1xuICAgICAgICByZXR1cm4gMTM7XG4gICAgfVxuICAgIGdldERheXNJblllYXIoZGF0ZSkge1xuICAgICAgICByZXR1cm4gMzY1ICsgJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJGdldExlYXBEYXkoZGF0ZS55ZWFyKTtcbiAgICB9XG4gICAgZ2V0WWVhcnNJbkVyYShkYXRlKSB7XG4gICAgICAgIC8vIDk5OTktMTItMzEgZ3JlZ29yaWFuIGlzIDk5OTItMjAtMDIgZXRoaW9waWMuXG4gICAgICAgIC8vIFJvdW5kIGRvd24gdG8gOTk5MSBmb3IgdGhlIGxhc3QgZnVsbCB5ZWFyLlxuICAgICAgICAvLyBBQSA5OTk5LTAxLTAxIGV0aGlvcGljIGlzIDQ1MDYtMDktMzAgZ3JlZ29yaWFuLlxuICAgICAgICByZXR1cm4gZGF0ZS5lcmEgPT09IFwiQUFcIiA/IDk5OTkgOiA5OTkxO1xuICAgIH1cbiAgICBnZXRFcmFzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJBQVwiLFxuICAgICAgICAgICAgXCJBTVwiXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IFwiZXRoaW9waWNcIjtcbiAgICB9XG59XG5jbGFzcyAkYjk1NmIyZDdhNmNmNDUxZiRleHBvcnQkZDcyZTBjMzcwMDVhNDkxNCBleHRlbmRzICRiOTU2YjJkN2E2Y2Y0NTFmJGV4cG9ydCQyNmJhNmVhYjVlMjBjZDdkIHtcbiAgICBmcm9tSnVsaWFuRGF5KGpkKSB7XG4gICAgICAgIGxldCBbeWVhciwgbW9udGgsIGRheV0gPSAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkanVsaWFuRGF5VG9DRSgkYjk1NmIyZDdhNmNmNDUxZiR2YXIkRVRISU9QSUNfRVBPQ0gsIGpkKTtcbiAgICAgICAgeWVhciArPSAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkQU1FVEVfTUlIUkVUX0RFTFRBO1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikodGhpcywgXCJBQVwiLCB5ZWFyLCBtb250aCwgZGF5KTtcbiAgICB9XG4gICAgZ2V0RXJhcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFwiQUFcIlxuICAgICAgICBdO1xuICAgIH1cbiAgICBnZXRZZWFyc0luRXJhKCkge1xuICAgICAgICAvLyA5OTk5LTEzLTA0IGV0aGlvYWEgaXMgdGhlIG1heGltdW0gZGF0ZSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byA0NTA2LTA5LTI5IGdyZWdvcmlhbi5cbiAgICAgICAgcmV0dXJuIDk5OTk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gXCJldGhpb2FhXCIgLy8gYWxzbyBrbm93biBhcyAnZXRoaW9waWMtYW1ldGUtYWxlbScgaW4gSUNVXG4gICAgICAgIDtcbiAgICB9XG59XG5jbGFzcyAkYjk1NmIyZDdhNmNmNDUxZiRleHBvcnQkZmU2MjQzY2JlMWE0YjdjMSBleHRlbmRzICRiOTU2YjJkN2E2Y2Y0NTFmJGV4cG9ydCQyNmJhNmVhYjVlMjBjZDdkIHtcbiAgICBmcm9tSnVsaWFuRGF5KGpkKSB7XG4gICAgICAgIGxldCBbeWVhciwgbW9udGgsIGRheV0gPSAkYjk1NmIyZDdhNmNmNDUxZiR2YXIkanVsaWFuRGF5VG9DRSgkYjk1NmIyZDdhNmNmNDUxZiR2YXIkQ09QVElDX0VQT0NILCBqZCk7XG4gICAgICAgIGxldCBlcmEgPSBcIkNFXCI7XG4gICAgICAgIGlmICh5ZWFyIDw9IDApIHtcbiAgICAgICAgICAgIGVyYSA9IFwiQkNFXCI7XG4gICAgICAgICAgICB5ZWFyID0gMSAtIHllYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYpKHRoaXMsIGVyYSwgeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuICAgIHRvSnVsaWFuRGF5KGRhdGUpIHtcbiAgICAgICAgbGV0IHllYXIgPSBkYXRlLnllYXI7XG4gICAgICAgIGlmIChkYXRlLmVyYSA9PT0gXCJCQ0VcIikgeWVhciA9IDEgLSB5ZWFyO1xuICAgICAgICByZXR1cm4gJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJGNlVG9KdWxpYW5EYXkoJGI5NTZiMmQ3YTZjZjQ1MWYkdmFyJENPUFRJQ19FUE9DSCwgeWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXkpO1xuICAgIH1cbiAgICBnZXREYXlzSW5Nb250aChkYXRlKSB7XG4gICAgICAgIGxldCB5ZWFyID0gZGF0ZS55ZWFyO1xuICAgICAgICBpZiAoZGF0ZS5lcmEgPT09IFwiQkNFXCIpIHllYXIgPSAxIC0geWVhcjtcbiAgICAgICAgcmV0dXJuICRiOTU2YjJkN2E2Y2Y0NTFmJHZhciRnZXREYXlzSW5Nb250aCh5ZWFyLCBkYXRlLm1vbnRoKTtcbiAgICB9XG4gICAgaXNJbnZlcnNlRXJhKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZXJhID09PSBcIkJDRVwiO1xuICAgIH1cbiAgICBiYWxhbmNlRGF0ZShkYXRlKSB7XG4gICAgICAgIGlmIChkYXRlLnllYXIgPD0gMCkge1xuICAgICAgICAgICAgZGF0ZS5lcmEgPSBkYXRlLmVyYSA9PT0gXCJCQ0VcIiA/IFwiQ0VcIiA6IFwiQkNFXCI7XG4gICAgICAgICAgICBkYXRlLnllYXIgPSAxIC0gZGF0ZS55ZWFyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEVyYXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBcIkJDRVwiLFxuICAgICAgICAgICAgXCJDRVwiXG4gICAgICAgIF07XG4gICAgfVxuICAgIGdldFllYXJzSW5FcmEoZGF0ZSkge1xuICAgICAgICAvLyA5OTk5LTEyLTMwIGdyZWdvcmlhbiBpcyA5NzE2LTAyLTIwIGNvcHRpYy5cbiAgICAgICAgLy8gUm91bmQgZG93biB0byA5NzE1IGZvciB0aGUgbGFzdCBmdWxsIHllYXIuXG4gICAgICAgIC8vIEJDRSA5OTk5LTAxLTAxIGNvcHRpYyBpcyBCQyA5NzE2LTA2LTE1IGdyZWdvcmlhbi5cbiAgICAgICAgcmV0dXJuIGRhdGUuZXJhID09PSBcIkJDRVwiID8gOTk5OSA6IDk3MTU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gXCJjb3B0aWNcIjtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uICQ2NDI0NDMwMmMzMDEzMjk5JGV4cG9ydCRkZDBiYmM5YjI2ZGVmZTM3KG5hbWUpIHtcbiAgICBzd2l0Y2gobmFtZSl7XG4gICAgICAgIGNhc2UgXCJidWRkaGlzdFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDhkNzNkNDc0MjJjYTczMDIkZXhwb3J0JDQyZDIwYTc4MzAxZGVlNDQpKCk7XG4gICAgICAgIGNhc2UgXCJldGhpb3BpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJGI5NTZiMmQ3YTZjZjQ1MWYkZXhwb3J0JDI2YmE2ZWFiNWUyMGNkN2QpKCk7XG4gICAgICAgIGNhc2UgXCJldGhpb2FhXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3ICgwLCAkYjk1NmIyZDdhNmNmNDUxZiRleHBvcnQkZDcyZTBjMzcwMDVhNDkxNCkoKTtcbiAgICAgICAgY2FzZSBcImNvcHRpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJGI5NTZiMmQ3YTZjZjQ1MWYkZXhwb3J0JGZlNjI0M2NiZTFhNGI3YzEpKCk7XG4gICAgICAgIGNhc2UgXCJoZWJyZXdcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgKDAsICQ3YzVmNmZiZjQyMzg5Nzg3JGV4cG9ydCRjYTQwNTA0OGI4ZmI1YWYpKCk7XG4gICAgICAgIGNhc2UgXCJpbmRpYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgKDAsICQ4MmMzNTgwMDNiZGRhMGE4JGV4cG9ydCQzOWYzMWM2MzlmYTE1NzI2KSgpO1xuICAgICAgICBjYXNlIFwiaXNsYW1pYy1jaXZpbFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJGYyZjNlMGUzYTgxN2VkYmQkZXhwb3J0JDIwNjY3OTVhYWRkMzdiZmMpKCk7XG4gICAgICAgIGNhc2UgXCJpc2xhbWljLXRibGFcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgKDAsICRmMmYzZTBlM2E4MTdlZGJkJGV4cG9ydCQzN2YwODg3ZjJmOWQyMmY3KSgpO1xuICAgICAgICBjYXNlIFwiaXNsYW1pYy11bWFscXVyYVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJGYyZjNlMGUzYTgxN2VkYmQkZXhwb3J0JDViYWFiNDc1OGMyMzEwNzYpKCk7XG4gICAgICAgIGNhc2UgXCJqYXBhbmVzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDYyMjI1MDA4MDIwZjBhMTMkZXhwb3J0JGI3NDZhYjJiNjBjZGZmYmYpKCk7XG4gICAgICAgIGNhc2UgXCJwZXJzaWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3ICgwLCAkZjNlZDJlNDQ3MmFlN2UyNSRleHBvcnQkMzdmY2NkYmZkMTRjNTkzOSkoKTtcbiAgICAgICAgY2FzZSBcInJvY1wiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDVmMzFiZDZmMGM4OTQwYjIkZXhwb3J0JDY1ZTAxMDgwYWZjYjA3OTkpKCk7XG4gICAgICAgIGNhc2UgXCJncmVnb3J5XCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3ICgwLCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkODBlZTYyNDVlYzRmMjllYykoKTtcbiAgICB9XG59XG5cblxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGxldCAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkZm9ybWF0dGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG5jbGFzcyAkZmIxOGQ1NDFlYTFhZDcxNyRleHBvcnQkYWQ5OTFiNjYxMzM4NTFjZiB7XG4gICAgLyoqIEZvcm1hdHMgYSBkYXRlIGFzIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgbG9jYWxlIGFuZCBmb3JtYXQgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiAqLyBmb3JtYXQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKiBGb3JtYXRzIGEgZGF0ZSB0byBhbiBhcnJheSBvZiBwYXJ0cyBzdWNoIGFzIHNlcGFyYXRvcnMsIG51bWJlcnMsIHB1bmN0dWF0aW9uLCBhbmQgbW9yZS4gKi8gZm9ybWF0VG9QYXJ0cyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKiBGb3JtYXRzIGEgZGF0ZSByYW5nZSBhcyBhIHN0cmluZy4gKi8gZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5mb3JtYXR0ZXIuZm9ybWF0UmFuZ2UgPT09IFwiZnVuY3Rpb25cIikgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFbmQgZGF0ZSBtdXN0IGJlID49IHN0YXJ0IGRhdGVcIik7XG4gICAgICAgIC8vIFZlcnkgYmFzaWMgZmFsbGJhY2sgZm9yIG9sZCBicm93c2Vycy5cbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZm9ybWF0dGVyLmZvcm1hdChzdGFydCl9IFxcdXsyMDEzfSAke3RoaXMuZm9ybWF0dGVyLmZvcm1hdChlbmQpfWA7XG4gICAgfVxuICAgIC8qKiBGb3JtYXRzIGEgZGF0ZSByYW5nZSBhcyBhbiBhcnJheSBvZiBwYXJ0cy4gKi8gZm9ybWF0UmFuZ2VUb1BhcnRzKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZm9ybWF0dGVyLmZvcm1hdFJhbmdlVG9QYXJ0cyA9PT0gXCJmdW5jdGlvblwiKSAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5mb3JtYXRSYW5nZVRvUGFydHMoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFbmQgZGF0ZSBtdXN0IGJlID49IHN0YXJ0IGRhdGVcIik7XG4gICAgICAgIGxldCBzdGFydFBhcnRzID0gdGhpcy5mb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhzdGFydCk7XG4gICAgICAgIGxldCBlbmRQYXJ0cyA9IHRoaXMuZm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoZW5kKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLnN0YXJ0UGFydHMubWFwKChwKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBcInN0YXJ0UmFuZ2VcIlxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImxpdGVyYWxcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCIgXFx1MjAxMyBcIixcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFwic2hhcmVkXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5lbmRQYXJ0cy5tYXAoKHApPT4oe1xuICAgICAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IFwiZW5kUmFuZ2VcIlxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgcmVzb2x2ZWQgZm9ybWF0dGluZyBvcHRpb25zIGJhc2VkIG9uIHRoZSB2YWx1ZXMgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gKi8gcmVzb2x2ZWRPcHRpb25zKCkge1xuICAgICAgICBsZXQgcmVzb2x2ZWRPcHRpb25zID0gdGhpcy5mb3JtYXR0ZXIucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICAgIGlmICgkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkaGFzQnVnZ3lSZXNvbHZlZEhvdXJDeWNsZSgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVzb2x2ZWRIb3VyQ3ljbGUpIHRoaXMucmVzb2x2ZWRIb3VyQ3ljbGUgPSAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkZ2V0UmVzb2x2ZWRIb3VyQ3ljbGUocmVzb2x2ZWRPcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIHJlc29sdmVkT3B0aW9ucy5ob3VyQ3ljbGUgPSB0aGlzLnJlc29sdmVkSG91ckN5Y2xlO1xuICAgICAgICAgICAgcmVzb2x2ZWRPcHRpb25zLmhvdXIxMiA9IHRoaXMucmVzb2x2ZWRIb3VyQ3ljbGUgPT09IFwiaDExXCIgfHwgdGhpcy5yZXNvbHZlZEhvdXJDeWNsZSA9PT0gXCJoMTJcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWZhcmkgdXNlcyBhIGRpZmZlcmVudCBuYW1lIGZvciB0aGUgRXRoaW9waWMgKEFtZXRlIEFsZW0pIGNhbGVuZGFyLlxuICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjQxNTY0XG4gICAgICAgIGlmIChyZXNvbHZlZE9wdGlvbnMuY2FsZW5kYXIgPT09IFwiZXRoaW9waWMtYW1ldGUtYWxlbVwiKSByZXNvbHZlZE9wdGlvbnMuY2FsZW5kYXIgPSBcImV0aGlvYWFcIjtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkT3B0aW9ucztcbiAgICB9XG4gICAgY29uc3RydWN0b3IobG9jYWxlLCBvcHRpb25zID0ge30pe1xuICAgICAgICB0aGlzLmZvcm1hdHRlciA9ICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRnZXRDYWNoZWREYXRlRm9ybWF0dGVyKGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxufVxuLy8gVGhlcmUgYXJlIG11bHRpcGxlIGJ1Z3MgaW52b2x2aW5nIHRoZSBob3VyMTIgYW5kIGhvdXJDeWNsZSBvcHRpb25zIGluIHZhcmlvdXMgYnJvd3NlciBlbmdpbmVzLlxuLy8gICAtIENocm9tZSBbMV0gKGFuZCB0aGUgRUNNQSA0MDIgc3BlYyBbMl0pIHJlc29sdmUgaG91cjEyOiBmYWxzZSBpbiBFbmdsaXNoIGFuZCBvdGhlciBsb2NhbGVzIHRvIGgyNCAoMjQ6MDAgLSAyMzo1OSlcbi8vICAgICByYXRoZXIgdGhhbiBoMjMgKDAwOjAwIC0gMjM6NTkpLiBTYW1lIGNhbiBoYXBwZW4gd2l0aCBob3VyMTI6IHRydWUgaW4gRnJlbmNoLCB3aGljaCBDaHJvbWUgcmVzb2x2ZXMgdG8gaDExICgwMDowMCAtIDExOjU5KVxuLy8gICAgIHJhdGhlciB0aGFuIGgxMiAoMTI6MDAgLSAxMTo1OSkuXG4vLyAgIC0gV2ViS2l0IHJldHVybnMgYW4gaW5jb3JyZWN0IGhvdXJDeWNsZSByZXNvbHZlZCBvcHRpb24gaW4gdGhlIEZyZW5jaCBsb2NhbGUgZHVlIHRvIGluY29ycmVjdCBwYXJzaW5nIG9mICdoJyBsaXRlcmFsXG4vLyAgICAgaW4gdGhlIHJlc29sdmVkIHBhdHRlcm4uIEl0IGFsc28gZm9ybWF0cyBpbmNvcnJlY3RseSB3aGVuIHNwZWNpZnlpbmcgdGhlIGhvdXJDeWNsZSBvcHRpb24gZm9yIHRoZSBzYW1lIHJlYXNvbi4gWzNdXG4vLyBbMV0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTA0NTc5MVxuLy8gWzJdIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L2VjbWE0MDIvaXNzdWVzLzQwMlxuLy8gWzNdIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMjkzMTNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS91bmljb2RlLW9yZy9jbGRyL2Jsb2IvMDE4YjU1ZWZmN2NlYjM4OWM3ZTNmYzQ0ZTJmNjU3ZWFlM2IxMGIzOC9jb21tb24vc3VwcGxlbWVudGFsL3N1cHBsZW1lbnRhbERhdGEueG1sI0w0Nzc0LUw0ODAyXG5jb25zdCAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkaG91cjEyUHJlZmVyZW5jZXMgPSB7XG4gICAgdHJ1ZToge1xuICAgICAgICAvLyBPbmx5IEphcGFuZXNlIHVzZXMgdGhlIGgxMSBzdHlsZSBmb3IgMTIgaG91ciB0aW1lLiBBbGwgb3RoZXJzIHVzZSBoMTIuXG4gICAgICAgIGphOiBcImgxMVwiXG4gICAgfSxcbiAgICBmYWxzZToge1xuICAgIH1cbn07XG5mdW5jdGlvbiAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkZ2V0Q2FjaGVkRGF0ZUZvcm1hdHRlcihsb2NhbGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIFdvcmsgYXJvdW5kIGJ1Z2d5IGhvdXIxMiBiZWhhdmlvciBpbiBDaHJvbWUgLyBFQ01BIDQwMiBzcGVjIGJ5IHVzaW5nIGhvdXJDeWNsZSBpbnN0ZWFkLlxuICAgIC8vIE9ubHkgYXBwbHkgdGhlIHdvcmthcm91bmQgaWYgdGhlIGlzc3VlIGlzIGRldGVjdGVkLCBiZWNhdXNlIHRoZSBob3VyQ3ljbGUgb3B0aW9uIGlzIGJ1Z2d5IGluIFNhZmFyaS5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaG91cjEyID09PSBcImJvb2xlYW5cIiAmJiAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkaGFzQnVnZ3lIb3VyMTJCZWhhdmlvcigpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIGxldCBwcmVmID0gJGZiMThkNTQxZWExYWQ3MTckdmFyJGhvdXIxMlByZWZlcmVuY2VzW1N0cmluZyhvcHRpb25zLmhvdXIxMildW2xvY2FsZS5zcGxpdChcIi1cIilbMF1dO1xuICAgICAgICBsZXQgZGVmYXVsdEhvdXJDeWNsZSA9IG9wdGlvbnMuaG91cjEyID8gXCJoMTJcIiA6IFwiaDIzXCI7XG4gICAgICAgIG9wdGlvbnMuaG91ckN5Y2xlID0gcHJlZiAhPT0gbnVsbCAmJiBwcmVmICE9PSB2b2lkIDAgPyBwcmVmIDogZGVmYXVsdEhvdXJDeWNsZTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuaG91cjEyO1xuICAgIH1cbiAgICBsZXQgY2FjaGVLZXkgPSBsb2NhbGUgKyAob3B0aW9ucyA/IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLnNvcnQoKGEsIGIpPT5hWzBdIDwgYlswXSA/IC0xIDogMSkuam9pbigpIDogXCJcIik7XG4gICAgaWYgKCRmYjE4ZDU0MWVhMWFkNzE3JHZhciRmb3JtYXR0ZXJDYWNoZS5oYXMoY2FjaGVLZXkpKSByZXR1cm4gJGZiMThkNTQxZWExYWQ3MTckdmFyJGZvcm1hdHRlckNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgbGV0IG51bWJlckZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgJGZiMThkNTQxZWExYWQ3MTckdmFyJGZvcm1hdHRlckNhY2hlLnNldChjYWNoZUtleSwgbnVtYmVyRm9ybWF0dGVyKTtcbiAgICByZXR1cm4gbnVtYmVyRm9ybWF0dGVyO1xufVxubGV0ICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRfaGFzQnVnZ3lIb3VyMTJCZWhhdmlvciA9IG51bGw7XG5mdW5jdGlvbiAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkaGFzQnVnZ3lIb3VyMTJCZWhhdmlvcigpIHtcbiAgICBpZiAoJGZiMThkNTQxZWExYWQ3MTckdmFyJF9oYXNCdWdneUhvdXIxMkJlaGF2aW9yID09IG51bGwpICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRfaGFzQnVnZ3lIb3VyMTJCZWhhdmlvciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwge1xuICAgICAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICAgICAgaG91cjEyOiBmYWxzZVxuICAgIH0pLmZvcm1hdChuZXcgRGF0ZSgyMDIwLCAyLCAzLCAwKSkgPT09IFwiMjRcIjtcbiAgICByZXR1cm4gJGZiMThkNTQxZWExYWQ3MTckdmFyJF9oYXNCdWdneUhvdXIxMkJlaGF2aW9yO1xufVxubGV0ICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRfaGFzQnVnZ3lSZXNvbHZlZEhvdXJDeWNsZSA9IG51bGw7XG5mdW5jdGlvbiAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkaGFzQnVnZ3lSZXNvbHZlZEhvdXJDeWNsZSgpIHtcbiAgICBpZiAoJGZiMThkNTQxZWExYWQ3MTckdmFyJF9oYXNCdWdneVJlc29sdmVkSG91ckN5Y2xlID09IG51bGwpICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRfaGFzQnVnZ3lSZXNvbHZlZEhvdXJDeWNsZSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZnJcIiwge1xuICAgICAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICAgICAgaG91cjEyOiBmYWxzZVxuICAgIH0pLnJlc29sdmVkT3B0aW9ucygpLmhvdXJDeWNsZSA9PT0gXCJoMTJcIjtcbiAgICByZXR1cm4gJGZiMThkNTQxZWExYWQ3MTckdmFyJF9oYXNCdWdneVJlc29sdmVkSG91ckN5Y2xlO1xufVxuZnVuY3Rpb24gJGZiMThkNTQxZWExYWQ3MTckdmFyJGdldFJlc29sdmVkSG91ckN5Y2xlKGxvY2FsZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy50aW1lU3R5bGUgJiYgIW9wdGlvbnMuaG91cikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBXb3JrIGFyb3VuZCBidWdneSByZXN1bHRzIGluIHJlc29sdmVkIGhvdXJDeWNsZSBhbmQgaG91cjEyIG9wdGlvbnMgaW4gV2ViS2l0LlxuICAgIC8vIEZvcm1hdCB0aGUgbWluaW11bSBwb3NzaWJsZSBob3VyIGFuZCBtYXhpbXVtIHBvc3NpYmxlIGhvdXIgaW4gYSBkYXkgYW5kIHBhcnNlIHRoZSByZXN1bHRzLlxuICAgIGxvY2FsZSA9IGxvY2FsZS5yZXBsYWNlKC8oLXUtKT8tbnUtW2EtekEtWjAtOV0rLywgXCJcIik7XG4gICAgbG9jYWxlICs9IChsb2NhbGUuaW5jbHVkZXMoXCItdS1cIikgPyBcIlwiIDogXCItdVwiKSArIFwiLW51LWxhdG5cIjtcbiAgICBsZXQgZm9ybWF0dGVyID0gJGZiMThkNTQxZWExYWQ3MTckdmFyJGdldENhY2hlZERhdGVGb3JtYXR0ZXIobG9jYWxlLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHRpbWVab25lOiB1bmRlZmluZWQgLy8gdXNlIGxvY2FsIHRpbWV6b25lXG4gICAgfSk7XG4gICAgbGV0IG1pbiA9IHBhcnNlSW50KGZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKG5ldyBEYXRlKDIwMjAsIDIsIDMsIDApKS5maW5kKChwKT0+cC50eXBlID09PSBcImhvdXJcIikudmFsdWUsIDEwKTtcbiAgICBsZXQgbWF4ID0gcGFyc2VJbnQoZm9ybWF0dGVyLmZvcm1hdFRvUGFydHMobmV3IERhdGUoMjAyMCwgMiwgMywgMjMpKS5maW5kKChwKT0+cC50eXBlID09PSBcImhvdXJcIikudmFsdWUsIDEwKTtcbiAgICBpZiAobWluID09PSAwICYmIG1heCA9PT0gMjMpIHJldHVybiBcImgyM1wiO1xuICAgIGlmIChtaW4gPT09IDI0ICYmIG1heCA9PT0gMjMpIHJldHVybiBcImgyNFwiO1xuICAgIGlmIChtaW4gPT09IDAgJiYgbWF4ID09PSAxMSkgcmV0dXJuIFwiaDExXCI7XG4gICAgaWYgKG1pbiA9PT0gMTIgJiYgbWF4ID09PSAxMSkgcmV0dXJuIFwiaDEyXCI7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBob3VyIGN5Y2xlIHJlc3VsdFwiKTtcbn1cblxuXG5cblxuZXhwb3J0IHskMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZiBhcyBDYWxlbmRhckRhdGUsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRjYTg3MWU4ZGJiODA5NjZmIGFzIENhbGVuZGFyRGF0ZVRpbWUsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ2ODBlYTE5NmVmZmNlNWYgYXMgVGltZSwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGQzYjcyODhlNzk5NGVkZWEgYXMgWm9uZWREYXRlVGltZSwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWMgYXMgR3JlZ29yaWFuQ2FsZW5kYXIsICQ2MjIyNTAwODAyMGYwYTEzJGV4cG9ydCRiNzQ2YWIyYjYwY2RmZmJmIGFzIEphcGFuZXNlQ2FsZW5kYXIsICQ4ZDczZDQ3NDIyY2E3MzAyJGV4cG9ydCQ0MmQyMGE3ODMwMWRlZTQ0IGFzIEJ1ZGRoaXN0Q2FsZW5kYXIsICQ1ZjMxYmQ2ZjBjODk0MGIyJGV4cG9ydCQ2NWUwMTA4MGFmY2IwNzk5IGFzIFRhaXdhbkNhbGVuZGFyLCAkZjNlZDJlNDQ3MmFlN2UyNSRleHBvcnQkMzdmY2NkYmZkMTRjNTkzOSBhcyBQZXJzaWFuQ2FsZW5kYXIsICQ4MmMzNTgwMDNiZGRhMGE4JGV4cG9ydCQzOWYzMWM2MzlmYTE1NzI2IGFzIEluZGlhbkNhbGVuZGFyLCAkZjJmM2UwZTNhODE3ZWRiZCRleHBvcnQkMjA2Njc5NWFhZGQzN2JmYyBhcyBJc2xhbWljQ2l2aWxDYWxlbmRhciwgJGYyZjNlMGUzYTgxN2VkYmQkZXhwb3J0JDM3ZjA4ODdmMmY5ZDIyZjcgYXMgSXNsYW1pY1RhYnVsYXJDYWxlbmRhciwgJGYyZjNlMGUzYTgxN2VkYmQkZXhwb3J0JDViYWFiNDc1OGMyMzEwNzYgYXMgSXNsYW1pY1VtYWxxdXJhQ2FsZW5kYXIsICQ3YzVmNmZiZjQyMzg5Nzg3JGV4cG9ydCRjYTQwNTA0OGI4ZmI1YWYgYXMgSGVicmV3Q2FsZW5kYXIsICRiOTU2YjJkN2E2Y2Y0NTFmJGV4cG9ydCQyNmJhNmVhYjVlMjBjZDdkIGFzIEV0aGlvcGljQ2FsZW5kYXIsICRiOTU2YjJkN2E2Y2Y0NTFmJGV4cG9ydCRkNzJlMGMzNzAwNWE0OTE0IGFzIEV0aGlvcGljQW1ldGVBbGVtQ2FsZW5kYXIsICRiOTU2YjJkN2E2Y2Y0NTFmJGV4cG9ydCRmZTYyNDNjYmUxYTRiN2MxIGFzIENvcHRpY0NhbGVuZGFyLCAkNjQyNDQzMDJjMzAxMzI5OSRleHBvcnQkZGQwYmJjOWIyNmRlZmUzNyBhcyBjcmVhdGVDYWxlbmRhciwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDkzNTIyZDFhNDM5ZjM2MTcgYXMgdG9DYWxlbmRhckRhdGUsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiMjFlMGIxMjRlMjI0NDg0IGFzIHRvQ2FsZW5kYXJEYXRlVGltZSwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGQzM2Y3OWUzZmZjM2RjODMgYXMgdG9UaW1lLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMiBhcyB0b0NhbGVuZGFyLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkODRjOTVhODNjNzk5ZTA3NCBhcyB0b1pvbmVkLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTM4YjAwMDMzY2MxMWM3NSBhcyB0b1RpbWVab25lLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkZDliNjdiYzkzYzA5NzQ5MSBhcyB0b0xvY2FsVGltZVpvbmUsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRlNTdmZjEwMGQ5MWJkNGI5IGFzIGZyb21EYXRlLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMWI5NjY5MmExYmEwNDJhYyBhcyBmcm9tQWJzb2x1dGUsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRlYTM5ZWMxOTc5OTNhZWYwIGFzIGlzU2FtZURheSwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGExOGM4OWNiZDI0MTcwZmYgYXMgaXNTYW1lTW9udGgsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1ODQxZjllYjk3NzNmMjVmIGFzIGlzU2FtZVllYXIsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ5MWI2MmViZjJiYTcwM2VlIGFzIGlzRXF1YWxEYXksICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1YThkYTBjNDRhM2FmZGYyIGFzIGlzRXF1YWxNb250aCwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGVhODQwZjVhNmRkYTgxNDcgYXMgaXNFcXVhbFllYXIsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ2MjliMGE0OTdhYTY1MjY3IGFzIGlzVG9kYXksICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQyMDYxMDU2ZDA2ZDdjZGY3IGFzIGdldERheU9mV2VlaywgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDQ2MTkzOWRkNDQyMjE1MyBhcyBub3csICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRkMGJkZjQ1YWYwM2E2ZWEzIGFzIHRvZGF5LCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkMTI2YzkxYzk0MWRlN2UgYXMgZ2V0SG91cnNJbkRheSwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGFhOGI0MTczNWFmY2FiZDIgYXMgZ2V0TG9jYWxUaW1lWm9uZSwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE1YTNiNDU0YWRhMjI2OGUgYXMgc3RhcnRPZk1vbnRoLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNDJjODFhNDQ0ZmJmYjVkNCBhcyBzdGFydE9mV2VlaywgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGY5MWU4OWQzZDA0MDYxMDIgYXMgc3RhcnRPZlllYXIsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhMjI1OGQ5YzQxMTg4MjVjIGFzIGVuZE9mTW9udGgsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRlZjhiNmQ5MTMzMDg0ZjRlIGFzIGVuZE9mV2VlaywgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDhiN2FhNTVjNjZkNTU2OWUgYXMgZW5kT2ZZZWFyLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNTQxMmFjMTE3MTNiNzJhZCBhcyBnZXRNaW5pbXVtTW9udGhJblllYXIsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRiMmY0OTUzZDMwMTk4MWQ1IGFzIGdldE1pbmltdW1EYXlJbk1vbnRoLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkY2NjMWIyNDc5ZTdkZDY1NCBhcyBnZXRXZWVrc0luTW9udGgsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1YzMzM2ExMTZlOTQ5Y2RkIGFzIG1pbkRhdGUsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhNzVmMmJmZjU3ODExMDU1IGFzIG1heERhdGUsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ2MThkNjBlYTI5OWRhNDIgYXMgaXNXZWVrZW5kLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZWU5ZDg3MjU4ZTFkMTllZCBhcyBpc1dlZWtkYXksICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ2Yjg2MjE2MGQyOTVjOGUgYXMgcGFyc2VEYXRlLCAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkNTg4OTM3YmNkNjBhZGU1NSBhcyBwYXJzZURhdGVUaW1lLCAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkYzk2OThlYzdmMDVhMDdlMSBhcyBwYXJzZVRpbWUsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ1YWRmZGFiMDUxNjhjMjE5IGFzIHBhcnNlQWJzb2x1dGUsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ4ZTM4NDQzMjM2MmVkMGYwIGFzIHBhcnNlQWJzb2x1dGVUb0xvY2FsLCAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkZmQ3ODkzZjA2ZTkyYTZhNCBhcyBwYXJzZVpvbmVkRGF0ZVRpbWUsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRlY2FlODI5YmIzNzQ3ZWE2IGFzIHBhcnNlRHVyYXRpb24sICRmYjE4ZDU0MWVhMWFkNzE3JGV4cG9ydCRhZDk5MWI2NjEzMzg1MWNmIGFzIERhdGVGb3JtYXR0ZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@internationalized/date/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@internationalized/number/dist/import.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@internationalized/number/dist/import.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberFormatter: () => (/* binding */ $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5),\n/* harmony export */   NumberParser: () => (/* binding */ $6c7bd7858deea686$export$cd11ab140839f11d)\n/* harmony export */ });\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $488c6ddbf4ef74c2$var$formatterCache = new Map();\nlet $488c6ddbf4ef74c2$var$supportsSignDisplay = false;\ntry {\n    // @ts-ignore\n    $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat(\"de-DE\", {\n        signDisplay: \"exceptZero\"\n    }).resolvedOptions().signDisplay === \"exceptZero\";\n// eslint-disable-next-line no-empty\n} catch (e) {}\nlet $488c6ddbf4ef74c2$var$supportsUnit = false;\ntry {\n    // @ts-ignore\n    $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat(\"de-DE\", {\n        style: \"unit\",\n        unit: \"degree\"\n    }).resolvedOptions().style === \"unit\";\n// eslint-disable-next-line no-empty\n} catch (e) {}\n// Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.\n// Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.\n// Values were determined by switching to each locale manually in Chrome.\nconst $488c6ddbf4ef74c2$var$UNITS = {\n    degree: {\n        narrow: {\n            default: \"\\xb0\",\n            \"ja-JP\": \" \\u5EA6\",\n            \"zh-TW\": \"\\u5EA6\",\n            \"sl-SI\": \" \\xb0\"\n        }\n    }\n};\nclass $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 {\n    /** Formats a number value as a string, according to the locale and options provided to the constructor. */ format(value) {\n        let res = \"\";\n        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);\n        else res = this.numberFormatter.format(value);\n        if (this.options.style === \"unit\" && !$488c6ddbf4ef74c2$var$supportsUnit) {\n            var _UNITS_unit;\n            let { unit: unit, unitDisplay: unitDisplay = \"short\", locale: locale } = this.resolvedOptions();\n            if (!unit) return res;\n            let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];\n            res += values[locale] || values.default;\n        }\n        return res;\n    }\n    /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */ formatToParts(value) {\n        // TODO: implement signDisplay for formatToParts\n        // @ts-ignore\n        return this.numberFormatter.formatToParts(value);\n    }\n    /** Formats a number range as a string. */ formatRange(start, end) {\n        // @ts-ignore\n        if (typeof this.numberFormatter.formatRange === \"function\") // @ts-ignore\n        return this.numberFormatter.formatRange(start, end);\n        if (end < start) throw new RangeError(\"End date must be >= start date\");\n        // Very basic fallback for old browsers.\n        return `${this.format(start)} \\u{2013} ${this.format(end)}`;\n    }\n    /** Formats a number range as an array of parts. */ formatRangeToParts(start, end) {\n        // @ts-ignore\n        if (typeof this.numberFormatter.formatRangeToParts === \"function\") // @ts-ignore\n        return this.numberFormatter.formatRangeToParts(start, end);\n        if (end < start) throw new RangeError(\"End date must be >= start date\");\n        let startParts = this.numberFormatter.formatToParts(start);\n        let endParts = this.numberFormatter.formatToParts(end);\n        return [\n            ...startParts.map((p)=>({\n                    ...p,\n                    source: \"startRange\"\n                })),\n            {\n                type: \"literal\",\n                value: \" \\u2013 \",\n                source: \"shared\"\n            },\n            ...endParts.map((p)=>({\n                    ...p,\n                    source: \"endRange\"\n                }))\n        ];\n    }\n    /** Returns the resolved formatting options based on the values passed to the constructor. */ resolvedOptions() {\n        let options = this.numberFormatter.resolvedOptions();\n        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {\n            ...options,\n            signDisplay: this.options.signDisplay\n        };\n        if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === \"unit\") options = {\n            ...options,\n            style: \"unit\",\n            unit: this.options.unit,\n            unitDisplay: this.options.unitDisplay\n        };\n        return options;\n    }\n    constructor(locale, options = {}){\n        this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);\n        this.options = options;\n    }\n}\nfunction $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {\n    let { numberingSystem: numberingSystem } = options;\n    if (numberingSystem && locale.includes(\"-nu-\")) {\n        if (!locale.includes(\"-u-\")) locale += \"-u-\";\n        locale += `-nu-${numberingSystem}`;\n    }\n    if (options.style === \"unit\" && !$488c6ddbf4ef74c2$var$supportsUnit) {\n        var _UNITS_unit;\n        let { unit: unit, unitDisplay: unitDisplay = \"short\" } = options;\n        if (!unit) throw new Error('unit option must be provided with style: \"unit\"');\n        if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);\n        options = {\n            ...options,\n            style: \"decimal\"\n        };\n    }\n    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : \"\");\n    if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);\n    let numberFormatter = new Intl.NumberFormat(locale, options);\n    $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);\n    return numberFormatter;\n}\nfunction $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {\n    if (signDisplay === \"auto\") return numberFormat.format(num);\n    else if (signDisplay === \"never\") return numberFormat.format(Math.abs(num));\n    else {\n        let needsPositiveSign = false;\n        if (signDisplay === \"always\") needsPositiveSign = num > 0 || Object.is(num, 0);\n        else if (signDisplay === \"exceptZero\") {\n            if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);\n            else needsPositiveSign = num > 0;\n        }\n        if (needsPositiveSign) {\n            let negative = numberFormat.format(-num);\n            let noSign = numberFormat.format(num);\n            // ignore RTL/LTR marker character\n            let minus = negative.replace(noSign, \"\").replace(/\\u200e|\\u061C/, \"\");\n            if ([\n                ...minus\n            ].length !== 1) console.warn(\"@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case\");\n            let positive = negative.replace(noSign, \"!!!\").replace(minus, \"+\").replace(\"!!!\", noSign);\n            return positive;\n        } else return numberFormat.format(num);\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nconst $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp(\"^.*\\\\(.*\\\\).*$\");\nconst $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [\n    \"latn\",\n    \"arab\",\n    \"hanidec\"\n];\nclass $6c7bd7858deea686$export$cd11ab140839f11d {\n    /**\n   * Parses the given string to a number. Returns NaN if a valid number could not be parsed.\n   */ parse(value) {\n        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);\n    }\n    /**\n   * Returns whether the given string could potentially be a valid number. This should be used to\n   * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity\n   * of the minus/plus sign characters can be checked.\n   */ isValidPartialNumber(value, minValue, maxValue) {\n        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);\n    }\n    /**\n   * Returns a numbering system for which the given string is valid in the current locale.\n   * If no numbering system could be detected, the default numbering system for the current\n   * locale is returned.\n   */ getNumberingSystem(value) {\n        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;\n    }\n    constructor(locale, options = {}){\n        this.locale = locale;\n        this.options = options;\n    }\n}\nconst $6c7bd7858deea686$var$numberParserCache = new Map();\nfunction $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {\n    // First try the default numbering system for the provided locale\n    let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);\n    // If that doesn't match, and the locale doesn't include a hard coded numbering system,\n    // try each of the other supported numbering systems until we find one that matches.\n    if (!locale.includes(\"-nu-\") && !defaultParser.isValidPartialNumber(value)) {\n        for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS)if (numberingSystem !== defaultParser.options.numberingSystem) {\n            let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes(\"-u-\") ? \"-nu-\" : \"-u-nu-\") + numberingSystem, options);\n            if (parser.isValidPartialNumber(value)) return parser;\n        }\n    }\n    return defaultParser;\n}\nfunction $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {\n    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : \"\");\n    let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);\n    if (!parser) {\n        parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);\n        $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);\n    }\n    return parser;\n}\n// The actual number parser implementation. Instances of this class are cached\n// based on the locale, options, and detected numbering system.\nclass $6c7bd7858deea686$var$NumberParserImpl {\n    parse(value) {\n        // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'\n        let fullySanitizedValue = this.sanitize(value);\n        if (this.symbols.group) // Remove group characters, and replace decimal points and numerals with ASCII values.\n        fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, \"\");\n        if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, \".\");\n        if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, \"-\");\n        fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);\n        if (this.options.style === \"percent\") {\n            // javascript is bad at dividing by 100 and maintaining the same significant figures, so perform it on the string before parsing\n            let isNegative = fullySanitizedValue.indexOf(\"-\");\n            fullySanitizedValue = fullySanitizedValue.replace(\"-\", \"\");\n            let index = fullySanitizedValue.indexOf(\".\");\n            if (index === -1) index = fullySanitizedValue.length;\n            fullySanitizedValue = fullySanitizedValue.replace(\".\", \"\");\n            if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;\n            else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;\n            else if (index - 2 === -2) fullySanitizedValue = \"0.00\";\n            else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;\n            if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;\n        }\n        let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;\n        if (isNaN(newValue)) return NaN;\n        if (this.options.style === \"percent\") {\n            // extra step for rounding percents to what our formatter would output\n            let options = {\n                ...this.options,\n                style: \"decimal\",\n                minimumFractionDigits: Math.min(this.options.minimumFractionDigits + 2, 20),\n                maximumFractionDigits: Math.min(this.options.maximumFractionDigits + 2, 20)\n            };\n            return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));\n        }\n        // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again\n        if (this.options.currencySign === \"accounting\" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;\n        return newValue;\n    }\n    sanitize(value) {\n        // Remove literals and whitespace, which are allowed anywhere in the string\n        value = value.replace(this.symbols.literals, \"\");\n        // Replace the ASCII minus sign with the minus sign used in the current locale\n        // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.\n        if (this.symbols.minusSign) value = value.replace(\"-\", this.symbols.minusSign);\n        // In arab numeral system, their decimal character is 1643, but most keyboards don't type that\n        // instead they use the , (44) character or apparently the (1548) character.\n        if (this.options.numberingSystem === \"arab\") {\n            if (this.symbols.decimal) {\n                value = value.replace(\",\", this.symbols.decimal);\n                value = value.replace(String.fromCharCode(1548), this.symbols.decimal);\n            }\n            if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, \".\", this.symbols.group);\n        }\n        // fr-FR group character is char code 8239, but that's not a key on the french keyboard,\n        // so allow 'period' as a group char and replace it with a space\n        if (this.options.locale === \"fr-FR\") value = $6c7bd7858deea686$var$replaceAll(value, \".\", String.fromCharCode(8239));\n        return value;\n    }\n    isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {\n        value = this.sanitize(value);\n        // Remove minus or plus sign, which must be at the start of the string.\n        if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);\n        else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);\n        // Numbers cannot start with a group separator\n        if (this.symbols.group && value.startsWith(this.symbols.group)) return false;\n        // Numbers that can't have any decimal values fail if a decimal character is typed\n        if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;\n        // Remove numerals, groups, and decimals\n        if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, \"\");\n        value = value.replace(this.symbols.numeral, \"\");\n        if (this.symbols.decimal) value = value.replace(this.symbols.decimal, \"\");\n        // The number is valid if there are no remaining characters\n        return value.length === 0;\n    }\n    constructor(locale, options = {}){\n        this.locale = locale;\n        this.formatter = new Intl.NumberFormat(locale, options);\n        this.options = this.formatter.resolvedOptions();\n        this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);\n        var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;\n        if (this.options.style === \"percent\" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn(\"NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.\");\n    }\n}\nconst $6c7bd7858deea686$var$nonLiteralParts = new Set([\n    \"decimal\",\n    \"fraction\",\n    \"integer\",\n    \"minusSign\",\n    \"plusSign\",\n    \"group\"\n]);\n// This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes\n// all unique numbers which we need to check in order to determine all the plural forms for a given locale.\n// See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script\nconst $6c7bd7858deea686$var$pluralNumbers = [\n    0,\n    4,\n    2,\n    1,\n    11,\n    20,\n    3,\n    7,\n    100,\n    21,\n    0.1,\n    1.1\n];\nfunction $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {\n    var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;\n    // formatter needs access to all decimal places in order to generate the correct literal strings for the plural set\n    let symbolFormatter = new Intl.NumberFormat(locale, {\n        ...intlOptions,\n        minimumSignificantDigits: 1,\n        maximumSignificantDigits: 21\n    });\n    // Note: some locale's don't add a group symbol until there is a ten thousands place\n    let allParts = symbolFormatter.formatToParts(-10000.111);\n    let posAllParts = symbolFormatter.formatToParts(10000.111);\n    let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n)=>symbolFormatter.formatToParts(n));\n    var _allParts_find_value;\n    let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p)=>p.type === \"minusSign\")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : \"-\";\n    let plusSign = (_posAllParts_find = posAllParts.find((p)=>p.type === \"plusSign\")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;\n    // Safari does not support the signDisplay option, but our number parser polyfills it.\n    // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.\n    // @ts-ignore\n    if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === \"exceptZero\" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === \"always\")) plusSign = \"+\";\n    // If maximumSignificantDigits is 1 (the minimum) then we won't get decimal characters out of the above formatters\n    // Percent also defaults to 0 fractionDigits, so we need to make a new one that isn't percent to get an accurate decimal\n    let decimalParts = new Intl.NumberFormat(locale, {\n        ...intlOptions,\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n    }).formatToParts(0.001);\n    let decimal = (_decimalParts_find = decimalParts.find((p)=>p.type === \"decimal\")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;\n    let group = (_allParts_find1 = allParts.find((p)=>p.type === \"group\")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;\n    // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that\n    // don't contribute to the numerical value\n    let allPartsLiterals = allParts.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value));\n    let pluralPartsLiterals = pluralParts.flatMap((p)=>p.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value)));\n    let sortedLiterals = [\n        ...new Set([\n            ...allPartsLiterals,\n            ...pluralPartsLiterals\n        ])\n    ].sort((a, b)=>b.length - a.length);\n    let literals = sortedLiterals.length === 0 ? new RegExp(\"[\\\\p{White_Space}]\", \"gu\") : new RegExp(`${sortedLiterals.join(\"|\")}|[\\\\p{White_Space}]`, \"gu\");\n    // These are for replacing non-latn characters with the latn equivalent\n    let numerals = [\n        ...new Intl.NumberFormat(intlOptions.locale, {\n            useGrouping: false\n        }).format(9876543210)\n    ].reverse();\n    let indexes = new Map(numerals.map((d, i)=>[\n            d,\n            i\n        ]));\n    let numeral = new RegExp(`[${numerals.join(\"\")}]`, \"g\");\n    let index = (d)=>String(indexes.get(d));\n    return {\n        minusSign: minusSign,\n        plusSign: plusSign,\n        decimal: decimal,\n        group: group,\n        literals: literals,\n        numeral: numeral,\n        index: index\n    };\n}\nfunction $6c7bd7858deea686$var$replaceAll(str, find, replace) {\n    // @ts-ignore\n    if (str.replaceAll) // @ts-ignore\n    return str.replaceAll(find, replace);\n    return str.split(find).join(replace);\n}\nfunction $6c7bd7858deea686$var$escapeRegex(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGludGVybmF0aW9uYWxpemVkL251bWJlci9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFpRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQixHQUFHLE1BQU0sRUFBRSxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RSxVQUFVLG1DQUFtQztBQUM3QztBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFpRDtBQUMvRDtBQUNBLDZLQUE2SyxNQUFNLHFCQUFxQixZQUFZO0FBQ3BOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxvQkFBb0I7QUFDaEYsbUVBQW1FLG9CQUFvQjtBQUN2RjtBQUNBLDBDQUEwQyx3Q0FBd0MsR0FBRyxxQ0FBcUM7QUFDMUgsMkRBQTJELG9CQUFvQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVksMEJBQTBCLHlCQUF5QixNQUFNLFlBQVk7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOzs7OztBQUtpSTtBQUNqSSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlYXJudHViZS0xLjAvLi9ub2RlX21vZHVsZXMvQGludGVybmF0aW9uYWxpemVkL251bWJlci9kaXN0L2ltcG9ydC5tanM/NDM1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGxldCAkNDg4YzZkZGJmNGVmNzRjMiR2YXIkZm9ybWF0dGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG5sZXQgJDQ4OGM2ZGRiZjRlZjc0YzIkdmFyJHN1cHBvcnRzU2lnbkRpc3BsYXkgPSBmYWxzZTtcbnRyeSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgICQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRzdXBwb3J0c1NpZ25EaXNwbGF5ID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KFwiZGUtREVcIiwge1xuICAgICAgICBzaWduRGlzcGxheTogXCJleGNlcHRaZXJvXCJcbiAgICB9KS5yZXNvbHZlZE9wdGlvbnMoKS5zaWduRGlzcGxheSA9PT0gXCJleGNlcHRaZXJvXCI7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbn0gY2F0Y2ggKGUpIHt9XG5sZXQgJDQ4OGM2ZGRiZjRlZjc0YzIkdmFyJHN1cHBvcnRzVW5pdCA9IGZhbHNlO1xudHJ5IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgJDQ4OGM2ZGRiZjRlZjc0YzIkdmFyJHN1cHBvcnRzVW5pdCA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChcImRlLURFXCIsIHtcbiAgICAgICAgc3R5bGU6IFwidW5pdFwiLFxuICAgICAgICB1bml0OiBcImRlZ3JlZVwiXG4gICAgfSkucmVzb2x2ZWRPcHRpb25zKCkuc3R5bGUgPT09IFwidW5pdFwiO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG59IGNhdGNoIChlKSB7fVxuLy8gUG9seWZpbGwgZm9yIHVuaXRzIHNpbmNlIFNhZmFyaSBkb2Vzbid0IHN1cHBvcnQgdGhlbSB5ZXQuIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjE1NDM4LlxuLy8gQ3VycmVudGx5IG9ubHkgcG9seWZpbGxpbmcgdGhlIHVuaXQgZGVncmVlIGluIG5hcnJvdyBmb3JtYXQgZm9yIENvbG9yU2xpZGVyIGluIG91ciBzdXBwb3J0ZWQgbG9jYWxlcy5cbi8vIFZhbHVlcyB3ZXJlIGRldGVybWluZWQgYnkgc3dpdGNoaW5nIHRvIGVhY2ggbG9jYWxlIG1hbnVhbGx5IGluIENocm9tZS5cbmNvbnN0ICQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRVTklUUyA9IHtcbiAgICBkZWdyZWU6IHtcbiAgICAgICAgbmFycm93OiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBcIlxceGIwXCIsXG4gICAgICAgICAgICBcImphLUpQXCI6IFwiIFxcdTVFQTZcIixcbiAgICAgICAgICAgIFwiemgtVFdcIjogXCJcXHU1RUE2XCIsXG4gICAgICAgICAgICBcInNsLVNJXCI6IFwiIFxceGIwXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG5jbGFzcyAkNDg4YzZkZGJmNGVmNzRjMiRleHBvcnQkY2M3N2M0ZmY3ZTg2NzNjNSB7XG4gICAgLyoqIEZvcm1hdHMgYSBudW1iZXIgdmFsdWUgYXMgYSBzdHJpbmcsIGFjY29yZGluZyB0byB0aGUgbG9jYWxlIGFuZCBvcHRpb25zIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gKi8gZm9ybWF0KHZhbHVlKSB7XG4gICAgICAgIGxldCByZXMgPSBcIlwiO1xuICAgICAgICBpZiAoISQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRzdXBwb3J0c1NpZ25EaXNwbGF5ICYmIHRoaXMub3B0aW9ucy5zaWduRGlzcGxheSAhPSBudWxsKSByZXMgPSAkNDg4YzZkZGJmNGVmNzRjMiRleHBvcnQkNzExYjUwYjNjNTI1ZTBmMih0aGlzLm51bWJlckZvcm1hdHRlciwgdGhpcy5vcHRpb25zLnNpZ25EaXNwbGF5LCB2YWx1ZSk7XG4gICAgICAgIGVsc2UgcmVzID0gdGhpcy5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZSA9PT0gXCJ1bml0XCIgJiYgISQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRzdXBwb3J0c1VuaXQpIHtcbiAgICAgICAgICAgIHZhciBfVU5JVFNfdW5pdDtcbiAgICAgICAgICAgIGxldCB7IHVuaXQ6IHVuaXQsIHVuaXREaXNwbGF5OiB1bml0RGlzcGxheSA9IFwic2hvcnRcIiwgbG9jYWxlOiBsb2NhbGUgfSA9IHRoaXMucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICAgICAgICBpZiAoIXVuaXQpIHJldHVybiByZXM7XG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gKF9VTklUU191bml0ID0gJDQ4OGM2ZGRiZjRlZjc0YzIkdmFyJFVOSVRTW3VuaXRdKSA9PT0gbnVsbCB8fCBfVU5JVFNfdW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX1VOSVRTX3VuaXRbdW5pdERpc3BsYXldO1xuICAgICAgICAgICAgcmVzICs9IHZhbHVlc1tsb2NhbGVdIHx8IHZhbHVlcy5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKiBGb3JtYXRzIGEgbnVtYmVyIHRvIGFuIGFycmF5IG9mIHBhcnRzIHN1Y2ggYXMgc2VwYXJhdG9ycywgZGlnaXRzLCBwdW5jdHVhdGlvbiwgYW5kIG1vcmUuICovIGZvcm1hdFRvUGFydHModmFsdWUpIHtcbiAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHNpZ25EaXNwbGF5IGZvciBmb3JtYXRUb1BhcnRzXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyRm9ybWF0dGVyLmZvcm1hdFRvUGFydHModmFsdWUpO1xuICAgIH1cbiAgICAvKiogRm9ybWF0cyBhIG51bWJlciByYW5nZSBhcyBhIHN0cmluZy4gKi8gZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0UmFuZ2UgPT09IFwiZnVuY3Rpb25cIikgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFbmQgZGF0ZSBtdXN0IGJlID49IHN0YXJ0IGRhdGVcIik7XG4gICAgICAgIC8vIFZlcnkgYmFzaWMgZmFsbGJhY2sgZm9yIG9sZCBicm93c2Vycy5cbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZm9ybWF0KHN0YXJ0KX0gXFx1ezIwMTN9ICR7dGhpcy5mb3JtYXQoZW5kKX1gO1xuICAgIH1cbiAgICAvKiogRm9ybWF0cyBhIG51bWJlciByYW5nZSBhcyBhbiBhcnJheSBvZiBwYXJ0cy4gKi8gZm9ybWF0UmFuZ2VUb1BhcnRzKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMubnVtYmVyRm9ybWF0dGVyLmZvcm1hdFJhbmdlVG9QYXJ0cyA9PT0gXCJmdW5jdGlvblwiKSAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiB0aGlzLm51bWJlckZvcm1hdHRlci5mb3JtYXRSYW5nZVRvUGFydHMoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFbmQgZGF0ZSBtdXN0IGJlID49IHN0YXJ0IGRhdGVcIik7XG4gICAgICAgIGxldCBzdGFydFBhcnRzID0gdGhpcy5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhzdGFydCk7XG4gICAgICAgIGxldCBlbmRQYXJ0cyA9IHRoaXMubnVtYmVyRm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoZW5kKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLnN0YXJ0UGFydHMubWFwKChwKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBcInN0YXJ0UmFuZ2VcIlxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImxpdGVyYWxcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCIgXFx1MjAxMyBcIixcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFwic2hhcmVkXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5lbmRQYXJ0cy5tYXAoKHApPT4oe1xuICAgICAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IFwiZW5kUmFuZ2VcIlxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgcmVzb2x2ZWQgZm9ybWF0dGluZyBvcHRpb25zIGJhc2VkIG9uIHRoZSB2YWx1ZXMgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gKi8gcmVzb2x2ZWRPcHRpb25zKCkge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMubnVtYmVyRm9ybWF0dGVyLnJlc29sdmVkT3B0aW9ucygpO1xuICAgICAgICBpZiAoISQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRzdXBwb3J0c1NpZ25EaXNwbGF5ICYmIHRoaXMub3B0aW9ucy5zaWduRGlzcGxheSAhPSBudWxsKSBvcHRpb25zID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHNpZ25EaXNwbGF5OiB0aGlzLm9wdGlvbnMuc2lnbkRpc3BsYXlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCEkNDg4YzZkZGJmNGVmNzRjMiR2YXIkc3VwcG9ydHNVbml0ICYmIHRoaXMub3B0aW9ucy5zdHlsZSA9PT0gXCJ1bml0XCIpIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgc3R5bGU6IFwidW5pdFwiLFxuICAgICAgICAgICAgdW5pdDogdGhpcy5vcHRpb25zLnVuaXQsXG4gICAgICAgICAgICB1bml0RGlzcGxheTogdGhpcy5vcHRpb25zLnVuaXREaXNwbGF5XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUsIG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHRoaXMubnVtYmVyRm9ybWF0dGVyID0gJDQ4OGM2ZGRiZjRlZjc0YzIkdmFyJGdldENhY2hlZE51bWJlckZvcm1hdHRlcihsb2NhbGUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbn1cbmZ1bmN0aW9uICQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRnZXRDYWNoZWROdW1iZXJGb3JtYXR0ZXIobG9jYWxlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgeyBudW1iZXJpbmdTeXN0ZW06IG51bWJlcmluZ1N5c3RlbSB9ID0gb3B0aW9ucztcbiAgICBpZiAobnVtYmVyaW5nU3lzdGVtICYmIGxvY2FsZS5pbmNsdWRlcyhcIi1udS1cIikpIHtcbiAgICAgICAgaWYgKCFsb2NhbGUuaW5jbHVkZXMoXCItdS1cIikpIGxvY2FsZSArPSBcIi11LVwiO1xuICAgICAgICBsb2NhbGUgKz0gYC1udS0ke251bWJlcmluZ1N5c3RlbX1gO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdHlsZSA9PT0gXCJ1bml0XCIgJiYgISQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRzdXBwb3J0c1VuaXQpIHtcbiAgICAgICAgdmFyIF9VTklUU191bml0O1xuICAgICAgICBsZXQgeyB1bml0OiB1bml0LCB1bml0RGlzcGxheTogdW5pdERpc3BsYXkgPSBcInNob3J0XCIgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmICghdW5pdCkgdGhyb3cgbmV3IEVycm9yKCd1bml0IG9wdGlvbiBtdXN0IGJlIHByb3ZpZGVkIHdpdGggc3R5bGU6IFwidW5pdFwiJyk7XG4gICAgICAgIGlmICghKChfVU5JVFNfdW5pdCA9ICQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRVTklUU1t1bml0XSkgPT09IG51bGwgfHwgX1VOSVRTX3VuaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9VTklUU191bml0W3VuaXREaXNwbGF5XSkpIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdW5pdCAke3VuaXR9IHdpdGggdW5pdERpc3BsYXkgPSAke3VuaXREaXNwbGF5fWApO1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHN0eWxlOiBcImRlY2ltYWxcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgY2FjaGVLZXkgPSBsb2NhbGUgKyAob3B0aW9ucyA/IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLnNvcnQoKGEsIGIpPT5hWzBdIDwgYlswXSA/IC0xIDogMSkuam9pbigpIDogXCJcIik7XG4gICAgaWYgKCQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRmb3JtYXR0ZXJDYWNoZS5oYXMoY2FjaGVLZXkpKSByZXR1cm4gJDQ4OGM2ZGRiZjRlZjc0YzIkdmFyJGZvcm1hdHRlckNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgbGV0IG51bWJlckZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpO1xuICAgICQ0ODhjNmRkYmY0ZWY3NGMyJHZhciRmb3JtYXR0ZXJDYWNoZS5zZXQoY2FjaGVLZXksIG51bWJlckZvcm1hdHRlcik7XG4gICAgcmV0dXJuIG51bWJlckZvcm1hdHRlcjtcbn1cbmZ1bmN0aW9uICQ0ODhjNmRkYmY0ZWY3NGMyJGV4cG9ydCQ3MTFiNTBiM2M1MjVlMGYyKG51bWJlckZvcm1hdCwgc2lnbkRpc3BsYXksIG51bSkge1xuICAgIGlmIChzaWduRGlzcGxheSA9PT0gXCJhdXRvXCIpIHJldHVybiBudW1iZXJGb3JtYXQuZm9ybWF0KG51bSk7XG4gICAgZWxzZSBpZiAoc2lnbkRpc3BsYXkgPT09IFwibmV2ZXJcIikgcmV0dXJuIG51bWJlckZvcm1hdC5mb3JtYXQoTWF0aC5hYnMobnVtKSk7XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBuZWVkc1Bvc2l0aXZlU2lnbiA9IGZhbHNlO1xuICAgICAgICBpZiAoc2lnbkRpc3BsYXkgPT09IFwiYWx3YXlzXCIpIG5lZWRzUG9zaXRpdmVTaWduID0gbnVtID4gMCB8fCBPYmplY3QuaXMobnVtLCAwKTtcbiAgICAgICAgZWxzZSBpZiAoc2lnbkRpc3BsYXkgPT09IFwiZXhjZXB0WmVyb1wiKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmlzKG51bSwgLTApIHx8IE9iamVjdC5pcyhudW0sIDApKSBudW0gPSBNYXRoLmFicyhudW0pO1xuICAgICAgICAgICAgZWxzZSBuZWVkc1Bvc2l0aXZlU2lnbiA9IG51bSA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzUG9zaXRpdmVTaWduKSB7XG4gICAgICAgICAgICBsZXQgbmVnYXRpdmUgPSBudW1iZXJGb3JtYXQuZm9ybWF0KC1udW0pO1xuICAgICAgICAgICAgbGV0IG5vU2lnbiA9IG51bWJlckZvcm1hdC5mb3JtYXQobnVtKTtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBSVEwvTFRSIG1hcmtlciBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGxldCBtaW51cyA9IG5lZ2F0aXZlLnJlcGxhY2Uobm9TaWduLCBcIlwiKS5yZXBsYWNlKC9cXHUyMDBlfFxcdTA2MUMvLCBcIlwiKTtcbiAgICAgICAgICAgIGlmIChbXG4gICAgICAgICAgICAgICAgLi4ubWludXNcbiAgICAgICAgICAgIF0ubGVuZ3RoICE9PSAxKSBjb25zb2xlLndhcm4oXCJAcmVhY3QtYXJpYS9pMThuIHBvbHlmaWxsIGZvciBOdW1iZXJGb3JtYXQgc2lnbkRpc3BsYXk6IFVuc3VwcG9ydGVkIGNhc2VcIik7XG4gICAgICAgICAgICBsZXQgcG9zaXRpdmUgPSBuZWdhdGl2ZS5yZXBsYWNlKG5vU2lnbiwgXCIhISFcIikucmVwbGFjZShtaW51cywgXCIrXCIpLnJlcGxhY2UoXCIhISFcIiwgbm9TaWduKTtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGl2ZTtcbiAgICAgICAgfSBlbHNlIHJldHVybiBudW1iZXJGb3JtYXQuZm9ybWF0KG51bSk7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmNvbnN0ICQ2YzdiZDc4NThkZWVhNjg2JHZhciRDVVJSRU5DWV9TSUdOX1JFR0VYID0gbmV3IFJlZ0V4cChcIl4uKlxcXFwoLipcXFxcKS4qJFwiKTtcbmNvbnN0ICQ2YzdiZDc4NThkZWVhNjg2JHZhciROVU1CRVJJTkdfU1lTVEVNUyA9IFtcbiAgICBcImxhdG5cIixcbiAgICBcImFyYWJcIixcbiAgICBcImhhbmlkZWNcIlxuXTtcbmNsYXNzICQ2YzdiZDc4NThkZWVhNjg2JGV4cG9ydCRjZDExYWIxNDA4MzlmMTFkIHtcbiAgICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBzdHJpbmcgdG8gYSBudW1iZXIuIFJldHVybnMgTmFOIGlmIGEgdmFsaWQgbnVtYmVyIGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gICAqLyBwYXJzZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gJDZjN2JkNzg1OGRlZWE2ODYkdmFyJGdldE51bWJlclBhcnNlckltcGwodGhpcy5sb2NhbGUsIHRoaXMub3B0aW9ucywgdmFsdWUpLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gc3RyaW5nIGNvdWxkIHBvdGVudGlhbGx5IGJlIGEgdmFsaWQgbnVtYmVyLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvXG4gICAqIHZhbGlkYXRlIHVzZXIgaW5wdXQgYXMgdGhlIHVzZXIgdHlwZXMuIElmIGEgYG1pblZhbHVlYCBvciBgbWF4VmFsdWVgIGlzIHByb3ZpZGVkLCB0aGUgdmFsaWRpdHlcbiAgICogb2YgdGhlIG1pbnVzL3BsdXMgc2lnbiBjaGFyYWN0ZXJzIGNhbiBiZSBjaGVja2VkLlxuICAgKi8gaXNWYWxpZFBhcnRpYWxOdW1iZXIodmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSkge1xuICAgICAgICByZXR1cm4gJDZjN2JkNzg1OGRlZWE2ODYkdmFyJGdldE51bWJlclBhcnNlckltcGwodGhpcy5sb2NhbGUsIHRoaXMub3B0aW9ucywgdmFsdWUpLmlzVmFsaWRQYXJ0aWFsTnVtYmVyKHZhbHVlLCBtaW5WYWx1ZSwgbWF4VmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhIG51bWJlcmluZyBzeXN0ZW0gZm9yIHdoaWNoIHRoZSBnaXZlbiBzdHJpbmcgaXMgdmFsaWQgaW4gdGhlIGN1cnJlbnQgbG9jYWxlLlxuICAgKiBJZiBubyBudW1iZXJpbmcgc3lzdGVtIGNvdWxkIGJlIGRldGVjdGVkLCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIGZvciB0aGUgY3VycmVudFxuICAgKiBsb2NhbGUgaXMgcmV0dXJuZWQuXG4gICAqLyBnZXROdW1iZXJpbmdTeXN0ZW0odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICQ2YzdiZDc4NThkZWVhNjg2JHZhciRnZXROdW1iZXJQYXJzZXJJbXBsKHRoaXMubG9jYWxlLCB0aGlzLm9wdGlvbnMsIHZhbHVlKS5vcHRpb25zLm51bWJlcmluZ1N5c3RlbTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobG9jYWxlLCBvcHRpb25zID0ge30pe1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG59XG5jb25zdCAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkbnVtYmVyUGFyc2VyQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkZ2V0TnVtYmVyUGFyc2VySW1wbChsb2NhbGUsIG9wdGlvbnMsIHZhbHVlKSB7XG4gICAgLy8gRmlyc3QgdHJ5IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gZm9yIHRoZSBwcm92aWRlZCBsb2NhbGVcbiAgICBsZXQgZGVmYXVsdFBhcnNlciA9ICQ2YzdiZDc4NThkZWVhNjg2JHZhciRnZXRDYWNoZWROdW1iZXJQYXJzZXIobG9jYWxlLCBvcHRpb25zKTtcbiAgICAvLyBJZiB0aGF0IGRvZXNuJ3QgbWF0Y2gsIGFuZCB0aGUgbG9jYWxlIGRvZXNuJ3QgaW5jbHVkZSBhIGhhcmQgY29kZWQgbnVtYmVyaW5nIHN5c3RlbSxcbiAgICAvLyB0cnkgZWFjaCBvZiB0aGUgb3RoZXIgc3VwcG9ydGVkIG51bWJlcmluZyBzeXN0ZW1zIHVudGlsIHdlIGZpbmQgb25lIHRoYXQgbWF0Y2hlcy5cbiAgICBpZiAoIWxvY2FsZS5pbmNsdWRlcyhcIi1udS1cIikgJiYgIWRlZmF1bHRQYXJzZXIuaXNWYWxpZFBhcnRpYWxOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IG51bWJlcmluZ1N5c3RlbSBvZiAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkTlVNQkVSSU5HX1NZU1RFTVMpaWYgKG51bWJlcmluZ1N5c3RlbSAhPT0gZGVmYXVsdFBhcnNlci5vcHRpb25zLm51bWJlcmluZ1N5c3RlbSkge1xuICAgICAgICAgICAgbGV0IHBhcnNlciA9ICQ2YzdiZDc4NThkZWVhNjg2JHZhciRnZXRDYWNoZWROdW1iZXJQYXJzZXIobG9jYWxlICsgKGxvY2FsZS5pbmNsdWRlcyhcIi11LVwiKSA/IFwiLW51LVwiIDogXCItdS1udS1cIikgKyBudW1iZXJpbmdTeXN0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHBhcnNlci5pc1ZhbGlkUGFydGlhbE51bWJlcih2YWx1ZSkpIHJldHVybiBwYXJzZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRQYXJzZXI7XG59XG5mdW5jdGlvbiAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkZ2V0Q2FjaGVkTnVtYmVyUGFyc2VyKGxvY2FsZSwgb3B0aW9ucykge1xuICAgIGxldCBjYWNoZUtleSA9IGxvY2FsZSArIChvcHRpb25zID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucykuc29ydCgoYSwgYik9PmFbMF0gPCBiWzBdID8gLTEgOiAxKS5qb2luKCkgOiBcIlwiKTtcbiAgICBsZXQgcGFyc2VyID0gJDZjN2JkNzg1OGRlZWE2ODYkdmFyJG51bWJlclBhcnNlckNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgcGFyc2VyID0gbmV3ICQ2YzdiZDc4NThkZWVhNjg2JHZhciROdW1iZXJQYXJzZXJJbXBsKGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgICAgICQ2YzdiZDc4NThkZWVhNjg2JHZhciRudW1iZXJQYXJzZXJDYWNoZS5zZXQoY2FjaGVLZXksIHBhcnNlcik7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXI7XG59XG4vLyBUaGUgYWN0dWFsIG51bWJlciBwYXJzZXIgaW1wbGVtZW50YXRpb24uIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBjYWNoZWRcbi8vIGJhc2VkIG9uIHRoZSBsb2NhbGUsIG9wdGlvbnMsIGFuZCBkZXRlY3RlZCBudW1iZXJpbmcgc3lzdGVtLlxuY2xhc3MgJDZjN2JkNzg1OGRlZWE2ODYkdmFyJE51bWJlclBhcnNlckltcGwge1xuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICAgIC8vIHRvIHBhcnNlIHRoZSBudW1iZXIsIHdlIG5lZWQgdG8gcmVtb3ZlIGFueXRoaW5nIHRoYXQgaXNuJ3QgYWN0dWFsbHkgcGFydCBvZiB0aGUgbnVtYmVyLCBmb3IgZXhhbXBsZSB3ZSB3YW50ICctMTAuNDAnIG5vdCAnLTEwLjQwIFVTRCdcbiAgICAgICAgbGV0IGZ1bGx5U2FuaXRpemVkVmFsdWUgPSB0aGlzLnNhbml0aXplKHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuc3ltYm9scy5ncm91cCkgLy8gUmVtb3ZlIGdyb3VwIGNoYXJhY3RlcnMsIGFuZCByZXBsYWNlIGRlY2ltYWwgcG9pbnRzIGFuZCBudW1lcmFscyB3aXRoIEFTQ0lJIHZhbHVlcy5cbiAgICAgICAgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9ICQ2YzdiZDc4NThkZWVhNjg2JHZhciRyZXBsYWNlQWxsKGZ1bGx5U2FuaXRpemVkVmFsdWUsIHRoaXMuc3ltYm9scy5ncm91cCwgXCJcIik7XG4gICAgICAgIGlmICh0aGlzLnN5bWJvbHMuZGVjaW1hbCkgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGZ1bGx5U2FuaXRpemVkVmFsdWUucmVwbGFjZSh0aGlzLnN5bWJvbHMuZGVjaW1hbCwgXCIuXCIpO1xuICAgICAgICBpZiAodGhpcy5zeW1ib2xzLm1pbnVzU2lnbikgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGZ1bGx5U2FuaXRpemVkVmFsdWUucmVwbGFjZSh0aGlzLnN5bWJvbHMubWludXNTaWduLCBcIi1cIik7XG4gICAgICAgIGZ1bGx5U2FuaXRpemVkVmFsdWUgPSBmdWxseVNhbml0aXplZFZhbHVlLnJlcGxhY2UodGhpcy5zeW1ib2xzLm51bWVyYWwsIHRoaXMuc3ltYm9scy5pbmRleCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUgPT09IFwicGVyY2VudFwiKSB7XG4gICAgICAgICAgICAvLyBqYXZhc2NyaXB0IGlzIGJhZCBhdCBkaXZpZGluZyBieSAxMDAgYW5kIG1haW50YWluaW5nIHRoZSBzYW1lIHNpZ25pZmljYW50IGZpZ3VyZXMsIHNvIHBlcmZvcm0gaXQgb24gdGhlIHN0cmluZyBiZWZvcmUgcGFyc2luZ1xuICAgICAgICAgICAgbGV0IGlzTmVnYXRpdmUgPSBmdWxseVNhbml0aXplZFZhbHVlLmluZGV4T2YoXCItXCIpO1xuICAgICAgICAgICAgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGZ1bGx5U2FuaXRpemVkVmFsdWUucmVwbGFjZShcIi1cIiwgXCJcIik7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBmdWxseVNhbml0aXplZFZhbHVlLmluZGV4T2YoXCIuXCIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkgaW5kZXggPSBmdWxseVNhbml0aXplZFZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGZ1bGx5U2FuaXRpemVkVmFsdWUgPSBmdWxseVNhbml0aXplZFZhbHVlLnJlcGxhY2UoXCIuXCIsIFwiXCIpO1xuICAgICAgICAgICAgaWYgKGluZGV4IC0gMiA9PT0gMCkgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGAwLiR7ZnVsbHlTYW5pdGl6ZWRWYWx1ZX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggLSAyID09PSAtMSkgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGAwLjAke2Z1bGx5U2FuaXRpemVkVmFsdWV9YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4IC0gMiA9PT0gLTIpIGZ1bGx5U2FuaXRpemVkVmFsdWUgPSBcIjAuMDBcIjtcbiAgICAgICAgICAgIGVsc2UgZnVsbHlTYW5pdGl6ZWRWYWx1ZSA9IGAke2Z1bGx5U2FuaXRpemVkVmFsdWUuc2xpY2UoMCwgaW5kZXggLSAyKX0uJHtmdWxseVNhbml0aXplZFZhbHVlLnNsaWNlKGluZGV4IC0gMil9YDtcbiAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlID4gLTEpIGZ1bGx5U2FuaXRpemVkVmFsdWUgPSBgLSR7ZnVsbHlTYW5pdGl6ZWRWYWx1ZX1gO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IGZ1bGx5U2FuaXRpemVkVmFsdWUgPyArZnVsbHlTYW5pdGl6ZWRWYWx1ZSA6IE5hTjtcbiAgICAgICAgaWYgKGlzTmFOKG5ld1ZhbHVlKSkgcmV0dXJuIE5hTjtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZSA9PT0gXCJwZXJjZW50XCIpIHtcbiAgICAgICAgICAgIC8vIGV4dHJhIHN0ZXAgZm9yIHJvdW5kaW5nIHBlcmNlbnRzIHRvIHdoYXQgb3VyIGZvcm1hdHRlciB3b3VsZCBvdXRwdXRcbiAgICAgICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJkZWNpbWFsXCIsXG4gICAgICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBNYXRoLm1pbih0aGlzLm9wdGlvbnMubWluaW11bUZyYWN0aW9uRGlnaXRzICsgMiwgMjApLFxuICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogTWF0aC5taW4odGhpcy5vcHRpb25zLm1heGltdW1GcmFjdGlvbkRpZ2l0cyArIDIsIDIwKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgJDZjN2JkNzg1OGRlZWE2ODYkZXhwb3J0JGNkMTFhYjE0MDgzOWYxMWQodGhpcy5sb2NhbGUsIG9wdGlvbnMpLnBhcnNlKG5ldyAoMCwgJDQ4OGM2ZGRiZjRlZjc0YzIkZXhwb3J0JGNjNzdjNGZmN2U4NjczYzUpKHRoaXMubG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobmV3VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhY2NvdW50aW5nIHdpbGwgYWx3YXlzIGJlIHN0cmlwcGVkIHRvIGEgcG9zaXRpdmUgbnVtYmVyLCBzbyBpZiBpdCdzIGFjY291bnRpbmcgYW5kIGhhcyBhICgpIGFyb3VuZCBldmVyeXRoaW5nLCB0aGVuIHdlIG5lZWQgdG8gbWFrZSBpdCBuZWdhdGl2ZSBhZ2FpblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmN1cnJlbmN5U2lnbiA9PT0gXCJhY2NvdW50aW5nXCIgJiYgJDZjN2JkNzg1OGRlZWE2ODYkdmFyJENVUlJFTkNZX1NJR05fUkVHRVgudGVzdCh2YWx1ZSkpIG5ld1ZhbHVlID0gLTEgKiBuZXdWYWx1ZTtcbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgIH1cbiAgICBzYW5pdGl6ZSh2YWx1ZSkge1xuICAgICAgICAvLyBSZW1vdmUgbGl0ZXJhbHMgYW5kIHdoaXRlc3BhY2UsIHdoaWNoIGFyZSBhbGxvd2VkIGFueXdoZXJlIGluIHRoZSBzdHJpbmdcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHRoaXMuc3ltYm9scy5saXRlcmFscywgXCJcIik7XG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIEFTQ0lJIG1pbnVzIHNpZ24gd2l0aCB0aGUgbWludXMgc2lnbiB1c2VkIGluIHRoZSBjdXJyZW50IGxvY2FsZVxuICAgICAgICAvLyBzbyB0aGF0IGJvdGggYXJlIGFsbG93ZWQgaW4gY2FzZSB0aGUgdXNlcidzIGtleWJvYXJkIGRvZXNuJ3QgaGF2ZSB0aGUgbG9jYWxlJ3MgbWludXMgc2lnbi5cbiAgICAgICAgaWYgKHRoaXMuc3ltYm9scy5taW51c1NpZ24pIHZhbHVlID0gdmFsdWUucmVwbGFjZShcIi1cIiwgdGhpcy5zeW1ib2xzLm1pbnVzU2lnbik7XG4gICAgICAgIC8vIEluIGFyYWIgbnVtZXJhbCBzeXN0ZW0sIHRoZWlyIGRlY2ltYWwgY2hhcmFjdGVyIGlzIDE2NDMsIGJ1dCBtb3N0IGtleWJvYXJkcyBkb24ndCB0eXBlIHRoYXRcbiAgICAgICAgLy8gaW5zdGVhZCB0aGV5IHVzZSB0aGUgLCAoNDQpIGNoYXJhY3RlciBvciBhcHBhcmVudGx5IHRoZSAoMTU0OCkgY2hhcmFjdGVyLlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJhcmFiXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN5bWJvbHMuZGVjaW1hbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShcIixcIiwgdGhpcy5zeW1ib2xzLmRlY2ltYWwpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShTdHJpbmcuZnJvbUNoYXJDb2RlKDE1NDgpLCB0aGlzLnN5bWJvbHMuZGVjaW1hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zeW1ib2xzLmdyb3VwKSB2YWx1ZSA9ICQ2YzdiZDc4NThkZWVhNjg2JHZhciRyZXBsYWNlQWxsKHZhbHVlLCBcIi5cIiwgdGhpcy5zeW1ib2xzLmdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmci1GUiBncm91cCBjaGFyYWN0ZXIgaXMgY2hhciBjb2RlIDgyMzksIGJ1dCB0aGF0J3Mgbm90IGEga2V5IG9uIHRoZSBmcmVuY2gga2V5Ym9hcmQsXG4gICAgICAgIC8vIHNvIGFsbG93ICdwZXJpb2QnIGFzIGEgZ3JvdXAgY2hhciBhbmQgcmVwbGFjZSBpdCB3aXRoIGEgc3BhY2VcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhbGUgPT09IFwiZnItRlJcIikgdmFsdWUgPSAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkcmVwbGFjZUFsbCh2YWx1ZSwgXCIuXCIsIFN0cmluZy5mcm9tQ2hhckNvZGUoODIzOSkpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlzVmFsaWRQYXJ0aWFsTnVtYmVyKHZhbHVlLCBtaW5WYWx1ZSA9IC1JbmZpbml0eSwgbWF4VmFsdWUgPSBJbmZpbml0eSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuc2FuaXRpemUodmFsdWUpO1xuICAgICAgICAvLyBSZW1vdmUgbWludXMgb3IgcGx1cyBzaWduLCB3aGljaCBtdXN0IGJlIGF0IHRoZSBzdGFydCBvZiB0aGUgc3RyaW5nLlxuICAgICAgICBpZiAodGhpcy5zeW1ib2xzLm1pbnVzU2lnbiAmJiB2YWx1ZS5zdGFydHNXaXRoKHRoaXMuc3ltYm9scy5taW51c1NpZ24pICYmIG1pblZhbHVlIDwgMCkgdmFsdWUgPSB2YWx1ZS5zbGljZSh0aGlzLnN5bWJvbHMubWludXNTaWduLmxlbmd0aCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3ltYm9scy5wbHVzU2lnbiAmJiB2YWx1ZS5zdGFydHNXaXRoKHRoaXMuc3ltYm9scy5wbHVzU2lnbikgJiYgbWF4VmFsdWUgPiAwKSB2YWx1ZSA9IHZhbHVlLnNsaWNlKHRoaXMuc3ltYm9scy5wbHVzU2lnbi5sZW5ndGgpO1xuICAgICAgICAvLyBOdW1iZXJzIGNhbm5vdCBzdGFydCB3aXRoIGEgZ3JvdXAgc2VwYXJhdG9yXG4gICAgICAgIGlmICh0aGlzLnN5bWJvbHMuZ3JvdXAgJiYgdmFsdWUuc3RhcnRzV2l0aCh0aGlzLnN5bWJvbHMuZ3JvdXApKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIE51bWJlcnMgdGhhdCBjYW4ndCBoYXZlIGFueSBkZWNpbWFsIHZhbHVlcyBmYWlsIGlmIGEgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgdHlwZWRcbiAgICAgICAgaWYgKHRoaXMuc3ltYm9scy5kZWNpbWFsICYmIHZhbHVlLmluZGV4T2YodGhpcy5zeW1ib2xzLmRlY2ltYWwpID4gLTEgJiYgdGhpcy5vcHRpb25zLm1heGltdW1GcmFjdGlvbkRpZ2l0cyA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBSZW1vdmUgbnVtZXJhbHMsIGdyb3VwcywgYW5kIGRlY2ltYWxzXG4gICAgICAgIGlmICh0aGlzLnN5bWJvbHMuZ3JvdXApIHZhbHVlID0gJDZjN2JkNzg1OGRlZWE2ODYkdmFyJHJlcGxhY2VBbGwodmFsdWUsIHRoaXMuc3ltYm9scy5ncm91cCwgXCJcIik7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSh0aGlzLnN5bWJvbHMubnVtZXJhbCwgXCJcIik7XG4gICAgICAgIGlmICh0aGlzLnN5bWJvbHMuZGVjaW1hbCkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHRoaXMuc3ltYm9scy5kZWNpbWFsLCBcIlwiKTtcbiAgICAgICAgLy8gVGhlIG51bWJlciBpcyB2YWxpZCBpZiB0aGVyZSBhcmUgbm8gcmVtYWluaW5nIGNoYXJhY3RlcnNcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobG9jYWxlLCBvcHRpb25zID0ge30pe1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5mb3JtYXR0ZXIucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICAgIHRoaXMuc3ltYm9scyA9ICQ2YzdiZDc4NThkZWVhNjg2JHZhciRnZXRTeW1ib2xzKGxvY2FsZSwgdGhpcy5mb3JtYXR0ZXIsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHZhciBfdGhpc19vcHRpb25zX21pbmltdW1GcmFjdGlvbkRpZ2l0cywgX3RoaXNfb3B0aW9uc19tYXhpbXVtRnJhY3Rpb25EaWdpdHM7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUgPT09IFwicGVyY2VudFwiICYmICgoKF90aGlzX29wdGlvbnNfbWluaW11bUZyYWN0aW9uRGlnaXRzID0gdGhpcy5vcHRpb25zLm1pbmltdW1GcmFjdGlvbkRpZ2l0cykgIT09IG51bGwgJiYgX3RoaXNfb3B0aW9uc19taW5pbXVtRnJhY3Rpb25EaWdpdHMgIT09IHZvaWQgMCA/IF90aGlzX29wdGlvbnNfbWluaW11bUZyYWN0aW9uRGlnaXRzIDogMCkgPiAxOCB8fCAoKF90aGlzX29wdGlvbnNfbWF4aW11bUZyYWN0aW9uRGlnaXRzID0gdGhpcy5vcHRpb25zLm1heGltdW1GcmFjdGlvbkRpZ2l0cykgIT09IG51bGwgJiYgX3RoaXNfb3B0aW9uc19tYXhpbXVtRnJhY3Rpb25EaWdpdHMgIT09IHZvaWQgMCA/IF90aGlzX29wdGlvbnNfbWF4aW11bUZyYWN0aW9uRGlnaXRzIDogMCkgPiAxOCkpIGNvbnNvbGUud2FybihcIk51bWJlclBhcnNlciBjYW5ub3QgaGFuZGxlIHBlcmNlbnRhZ2VzIHdpdGggZ3JlYXRlciB0aGFuIDE4IGRlY2ltYWwgcGxhY2VzLCBwbGVhc2UgcmVkdWNlIHRoZSBudW1iZXIgaW4geW91ciBvcHRpb25zLlwiKTtcbiAgICB9XG59XG5jb25zdCAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkbm9uTGl0ZXJhbFBhcnRzID0gbmV3IFNldChbXG4gICAgXCJkZWNpbWFsXCIsXG4gICAgXCJmcmFjdGlvblwiLFxuICAgIFwiaW50ZWdlclwiLFxuICAgIFwibWludXNTaWduXCIsXG4gICAgXCJwbHVzU2lnblwiLFxuICAgIFwiZ3JvdXBcIlxuXSk7XG4vLyBUaGlzIGxpc3QgaXMgZGVyaXZlZCBmcm9tIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL2NsZHIvY2hhcnRzLzQzL3N1cHBsZW1lbnRhbC9sYW5ndWFnZV9wbHVyYWxfcnVsZXMuaHRtbCNjb21wYXJpc29uIGFuZCBpbmNsdWRlc1xuLy8gYWxsIHVuaXF1ZSBudW1iZXJzIHdoaWNoIHdlIG5lZWQgdG8gY2hlY2sgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIGFsbCB0aGUgcGx1cmFsIGZvcm1zIGZvciBhIGdpdmVuIGxvY2FsZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlL3JlYWN0LXNwZWN0cnVtL3B1bGwvNTEzNC9maWxlcyNyMTMzNzAzNzg1NSBmb3IgdXNlZCBzY3JpcHRcbmNvbnN0ICQ2YzdiZDc4NThkZWVhNjg2JHZhciRwbHVyYWxOdW1iZXJzID0gW1xuICAgIDAsXG4gICAgNCxcbiAgICAyLFxuICAgIDEsXG4gICAgMTEsXG4gICAgMjAsXG4gICAgMyxcbiAgICA3LFxuICAgIDEwMCxcbiAgICAyMSxcbiAgICAwLjEsXG4gICAgMS4xXG5dO1xuZnVuY3Rpb24gJDZjN2JkNzg1OGRlZWE2ODYkdmFyJGdldFN5bWJvbHMobG9jYWxlLCBmb3JtYXR0ZXIsIGludGxPcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMpIHtcbiAgICB2YXIgX2FsbFBhcnRzX2ZpbmQsIF9wb3NBbGxQYXJ0c19maW5kLCBfZGVjaW1hbFBhcnRzX2ZpbmQsIF9hbGxQYXJ0c19maW5kMTtcbiAgICAvLyBmb3JtYXR0ZXIgbmVlZHMgYWNjZXNzIHRvIGFsbCBkZWNpbWFsIHBsYWNlcyBpbiBvcmRlciB0byBnZW5lcmF0ZSB0aGUgY29ycmVjdCBsaXRlcmFsIHN0cmluZ3MgZm9yIHRoZSBwbHVyYWwgc2V0XG4gICAgbGV0IHN5bWJvbEZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIHtcbiAgICAgICAgLi4uaW50bE9wdGlvbnMsXG4gICAgICAgIG1pbmltdW1TaWduaWZpY2FudERpZ2l0czogMSxcbiAgICAgICAgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzOiAyMVxuICAgIH0pO1xuICAgIC8vIE5vdGU6IHNvbWUgbG9jYWxlJ3MgZG9uJ3QgYWRkIGEgZ3JvdXAgc3ltYm9sIHVudGlsIHRoZXJlIGlzIGEgdGVuIHRob3VzYW5kcyBwbGFjZVxuICAgIGxldCBhbGxQYXJ0cyA9IHN5bWJvbEZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKC0xMDAwMC4xMTEpO1xuICAgIGxldCBwb3NBbGxQYXJ0cyA9IHN5bWJvbEZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKDEwMDAwLjExMSk7XG4gICAgbGV0IHBsdXJhbFBhcnRzID0gJDZjN2JkNzg1OGRlZWE2ODYkdmFyJHBsdXJhbE51bWJlcnMubWFwKChuKT0+c3ltYm9sRm9ybWF0dGVyLmZvcm1hdFRvUGFydHMobikpO1xuICAgIHZhciBfYWxsUGFydHNfZmluZF92YWx1ZTtcbiAgICBsZXQgbWludXNTaWduID0gKF9hbGxQYXJ0c19maW5kX3ZhbHVlID0gKF9hbGxQYXJ0c19maW5kID0gYWxsUGFydHMuZmluZCgocCk9PnAudHlwZSA9PT0gXCJtaW51c1NpZ25cIikpID09PSBudWxsIHx8IF9hbGxQYXJ0c19maW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYWxsUGFydHNfZmluZC52YWx1ZSkgIT09IG51bGwgJiYgX2FsbFBhcnRzX2ZpbmRfdmFsdWUgIT09IHZvaWQgMCA/IF9hbGxQYXJ0c19maW5kX3ZhbHVlIDogXCItXCI7XG4gICAgbGV0IHBsdXNTaWduID0gKF9wb3NBbGxQYXJ0c19maW5kID0gcG9zQWxsUGFydHMuZmluZCgocCk9PnAudHlwZSA9PT0gXCJwbHVzU2lnblwiKSkgPT09IG51bGwgfHwgX3Bvc0FsbFBhcnRzX2ZpbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wb3NBbGxQYXJ0c19maW5kLnZhbHVlO1xuICAgIC8vIFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzaWduRGlzcGxheSBvcHRpb24sIGJ1dCBvdXIgbnVtYmVyIHBhcnNlciBwb2x5ZmlsbHMgaXQuXG4gICAgLy8gSWYgbm8gcGx1cyBzaWduIHdhcyByZXR1cm5lZCwgYnV0IHRoZSBvcmlnaW5hbCBvcHRpb25zIGNvbnRhaW5lZCBzaWduRGlzcGxheSwgZGVmYXVsdCB0byB0aGUgJysnIGNoYXJhY3Rlci5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKCFwbHVzU2lnbiAmJiAoKG9yaWdpbmFsT3B0aW9ucyA9PT0gbnVsbCB8fCBvcmlnaW5hbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsT3B0aW9ucy5zaWduRGlzcGxheSkgPT09IFwiZXhjZXB0WmVyb1wiIHx8IChvcmlnaW5hbE9wdGlvbnMgPT09IG51bGwgfHwgb3JpZ2luYWxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbE9wdGlvbnMuc2lnbkRpc3BsYXkpID09PSBcImFsd2F5c1wiKSkgcGx1c1NpZ24gPSBcIitcIjtcbiAgICAvLyBJZiBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgaXMgMSAodGhlIG1pbmltdW0pIHRoZW4gd2Ugd29uJ3QgZ2V0IGRlY2ltYWwgY2hhcmFjdGVycyBvdXQgb2YgdGhlIGFib3ZlIGZvcm1hdHRlcnNcbiAgICAvLyBQZXJjZW50IGFsc28gZGVmYXVsdHMgdG8gMCBmcmFjdGlvbkRpZ2l0cywgc28gd2UgbmVlZCB0byBtYWtlIGEgbmV3IG9uZSB0aGF0IGlzbid0IHBlcmNlbnQgdG8gZ2V0IGFuIGFjY3VyYXRlIGRlY2ltYWxcbiAgICBsZXQgZGVjaW1hbFBhcnRzID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwge1xuICAgICAgICAuLi5pbnRsT3B0aW9ucyxcbiAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDJcbiAgICB9KS5mb3JtYXRUb1BhcnRzKDAuMDAxKTtcbiAgICBsZXQgZGVjaW1hbCA9IChfZGVjaW1hbFBhcnRzX2ZpbmQgPSBkZWNpbWFsUGFydHMuZmluZCgocCk9PnAudHlwZSA9PT0gXCJkZWNpbWFsXCIpKSA9PT0gbnVsbCB8fCBfZGVjaW1hbFBhcnRzX2ZpbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kZWNpbWFsUGFydHNfZmluZC52YWx1ZTtcbiAgICBsZXQgZ3JvdXAgPSAoX2FsbFBhcnRzX2ZpbmQxID0gYWxsUGFydHMuZmluZCgocCk9PnAudHlwZSA9PT0gXCJncm91cFwiKSkgPT09IG51bGwgfHwgX2FsbFBhcnRzX2ZpbmQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYWxsUGFydHNfZmluZDEudmFsdWU7XG4gICAgLy8gdGhpcyBzZXQgaXMgYWxzbyBmb3IgYSByZWdleCwgaXQncyBhbGwgbGl0ZXJhbHMgdGhhdCBtaWdodCBiZSBpbiB0aGUgc3RyaW5nIHdlIHdhbnQgdG8gZXZlbnR1YWxseSBwYXJzZSB0aGF0XG4gICAgLy8gZG9uJ3QgY29udHJpYnV0ZSB0byB0aGUgbnVtZXJpY2FsIHZhbHVlXG4gICAgbGV0IGFsbFBhcnRzTGl0ZXJhbHMgPSBhbGxQYXJ0cy5maWx0ZXIoKHApPT4hJDZjN2JkNzg1OGRlZWE2ODYkdmFyJG5vbkxpdGVyYWxQYXJ0cy5oYXMocC50eXBlKSkubWFwKChwKT0+JDZjN2JkNzg1OGRlZWE2ODYkdmFyJGVzY2FwZVJlZ2V4KHAudmFsdWUpKTtcbiAgICBsZXQgcGx1cmFsUGFydHNMaXRlcmFscyA9IHBsdXJhbFBhcnRzLmZsYXRNYXAoKHApPT5wLmZpbHRlcigocCk9PiEkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkbm9uTGl0ZXJhbFBhcnRzLmhhcyhwLnR5cGUpKS5tYXAoKHApPT4kNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkZXNjYXBlUmVnZXgocC52YWx1ZSkpKTtcbiAgICBsZXQgc29ydGVkTGl0ZXJhbHMgPSBbXG4gICAgICAgIC4uLm5ldyBTZXQoW1xuICAgICAgICAgICAgLi4uYWxsUGFydHNMaXRlcmFscyxcbiAgICAgICAgICAgIC4uLnBsdXJhbFBhcnRzTGl0ZXJhbHNcbiAgICAgICAgXSlcbiAgICBdLnNvcnQoKGEsIGIpPT5iLmxlbmd0aCAtIGEubGVuZ3RoKTtcbiAgICBsZXQgbGl0ZXJhbHMgPSBzb3J0ZWRMaXRlcmFscy5sZW5ndGggPT09IDAgPyBuZXcgUmVnRXhwKFwiW1xcXFxwe1doaXRlX1NwYWNlfV1cIiwgXCJndVwiKSA6IG5ldyBSZWdFeHAoYCR7c29ydGVkTGl0ZXJhbHMuam9pbihcInxcIil9fFtcXFxccHtXaGl0ZV9TcGFjZX1dYCwgXCJndVwiKTtcbiAgICAvLyBUaGVzZSBhcmUgZm9yIHJlcGxhY2luZyBub24tbGF0biBjaGFyYWN0ZXJzIHdpdGggdGhlIGxhdG4gZXF1aXZhbGVudFxuICAgIGxldCBudW1lcmFscyA9IFtcbiAgICAgICAgLi4ubmV3IEludGwuTnVtYmVyRm9ybWF0KGludGxPcHRpb25zLmxvY2FsZSwge1xuICAgICAgICAgICAgdXNlR3JvdXBpbmc6IGZhbHNlXG4gICAgICAgIH0pLmZvcm1hdCg5ODc2NTQzMjEwKVxuICAgIF0ucmV2ZXJzZSgpO1xuICAgIGxldCBpbmRleGVzID0gbmV3IE1hcChudW1lcmFscy5tYXAoKGQsIGkpPT5bXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgaVxuICAgICAgICBdKSk7XG4gICAgbGV0IG51bWVyYWwgPSBuZXcgUmVnRXhwKGBbJHtudW1lcmFscy5qb2luKFwiXCIpfV1gLCBcImdcIik7XG4gICAgbGV0IGluZGV4ID0gKGQpPT5TdHJpbmcoaW5kZXhlcy5nZXQoZCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pbnVzU2lnbjogbWludXNTaWduLFxuICAgICAgICBwbHVzU2lnbjogcGx1c1NpZ24sXG4gICAgICAgIGRlY2ltYWw6IGRlY2ltYWwsXG4gICAgICAgIGdyb3VwOiBncm91cCxcbiAgICAgICAgbGl0ZXJhbHM6IGxpdGVyYWxzLFxuICAgICAgICBudW1lcmFsOiBudW1lcmFsLFxuICAgICAgICBpbmRleDogaW5kZXhcbiAgICB9O1xufVxuZnVuY3Rpb24gJDZjN2JkNzg1OGRlZWE2ODYkdmFyJHJlcGxhY2VBbGwoc3RyLCBmaW5kLCByZXBsYWNlKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChzdHIucmVwbGFjZUFsbCkgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBzdHIucmVwbGFjZUFsbChmaW5kLCByZXBsYWNlKTtcbiAgICByZXR1cm4gc3RyLnNwbGl0KGZpbmQpLmpvaW4ocmVwbGFjZSk7XG59XG5mdW5jdGlvbiAkNmM3YmQ3ODU4ZGVlYTY4NiR2YXIkZXNjYXBlUmVnZXgoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XG59XG5cblxuXG5cbmV4cG9ydCB7JDQ4OGM2ZGRiZjRlZjc0YzIkZXhwb3J0JGNjNzdjNGZmN2U4NjczYzUgYXMgTnVtYmVyRm9ybWF0dGVyLCAkNmM3YmQ3ODU4ZGVlYTY4NiRleHBvcnQkY2QxMWFiMTQwODM5ZjExZCBhcyBOdW1iZXJQYXJzZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@internationalized/number/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@internationalized/string/dist/import.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@internationalized/string/dist/import.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LocalizedStringDictionary: () => (/* binding */ $5b160d28a433310d$export$c17fa47878dc55b6),\n/* harmony export */   LocalizedStringFormatter: () => (/* binding */ $6db58dc88e78b024$export$2f817fcdc4b89ae0)\n/* harmony export */ });\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $5b160d28a433310d$var$localeSymbol = Symbol.for(\"react-aria.i18n.locale\");\nconst $5b160d28a433310d$var$stringsSymbol = Symbol.for(\"react-aria.i18n.strings\");\nlet $5b160d28a433310d$var$cachedGlobalStrings = undefined;\nclass $5b160d28a433310d$export$c17fa47878dc55b6 {\n    /** Returns a localized string for the given key and locale. */ getStringForLocale(key, locale) {\n        let strings = this.getStringsForLocale(locale);\n        let string = strings[key];\n        if (!string) throw new Error(`Could not find intl message ${key} in ${locale} locale`);\n        return string;\n    }\n    /** Returns all localized strings for the given locale. */ getStringsForLocale(locale) {\n        let strings = this.strings[locale];\n        if (!strings) {\n            strings = $5b160d28a433310d$var$getStringsForLocale(locale, this.strings, this.defaultLocale);\n            this.strings[locale] = strings;\n        }\n        return strings;\n    }\n    static getGlobalDictionaryForPackage(packageName) {\n        if (typeof window === \"undefined\") return null;\n        let locale = window[$5b160d28a433310d$var$localeSymbol];\n        if ($5b160d28a433310d$var$cachedGlobalStrings === undefined) {\n            let globalStrings = window[$5b160d28a433310d$var$stringsSymbol];\n            if (!globalStrings) return null;\n            $5b160d28a433310d$var$cachedGlobalStrings = {};\n            for(let pkg in globalStrings)$5b160d28a433310d$var$cachedGlobalStrings[pkg] = new $5b160d28a433310d$export$c17fa47878dc55b6({\n                [locale]: globalStrings[pkg]\n            }, locale);\n        }\n        let dictionary = $5b160d28a433310d$var$cachedGlobalStrings === null || $5b160d28a433310d$var$cachedGlobalStrings === void 0 ? void 0 : $5b160d28a433310d$var$cachedGlobalStrings[packageName];\n        if (!dictionary) throw new Error(`Strings for package \"${packageName}\" were not included by LocalizedStringProvider. Please add it to the list passed to createLocalizedStringDictionary.`);\n        return dictionary;\n    }\n    constructor(messages, defaultLocale = \"en-US\"){\n        // Clone messages so we don't modify the original object.\n        this.strings = {\n            ...messages\n        };\n        this.defaultLocale = defaultLocale;\n    }\n}\nfunction $5b160d28a433310d$var$getStringsForLocale(locale, strings, defaultLocale = \"en-US\") {\n    // If there is an exact match, use it.\n    if (strings[locale]) return strings[locale];\n    // Attempt to find the closest match by language.\n    // For example, if the locale is fr-CA (French Canadian), but there is only\n    // an fr-FR (France) set of strings, use that.\n    // This could be replaced with Intl.LocaleMatcher once it is supported.\n    // https://github.com/tc39/proposal-intl-localematcher\n    let language = $5b160d28a433310d$var$getLanguage(locale);\n    if (strings[language]) return strings[language];\n    for(let key in strings){\n        if (key.startsWith(language + \"-\")) return strings[key];\n    }\n    // Nothing close, use english.\n    return strings[defaultLocale];\n}\nfunction $5b160d28a433310d$var$getLanguage(locale) {\n    // @ts-ignore\n    if (Intl.Locale) // @ts-ignore\n    return new Intl.Locale(locale).language;\n    return locale.split(\"-\")[0];\n}\n\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $6db58dc88e78b024$var$pluralRulesCache = new Map();\nconst $6db58dc88e78b024$var$numberFormatCache = new Map();\nclass $6db58dc88e78b024$export$2f817fcdc4b89ae0 {\n    /** Formats a localized string for the given key with the provided variables. */ format(key, variables) {\n        let message = this.strings.getStringForLocale(key, this.locale);\n        return typeof message === \"function\" ? message(variables, this) : message;\n    }\n    plural(count, options, type = \"cardinal\") {\n        let opt = options[\"=\" + count];\n        if (opt) return typeof opt === \"function\" ? opt() : opt;\n        let key = this.locale + \":\" + type;\n        let pluralRules = $6db58dc88e78b024$var$pluralRulesCache.get(key);\n        if (!pluralRules) {\n            pluralRules = new Intl.PluralRules(this.locale, {\n                type: type\n            });\n            $6db58dc88e78b024$var$pluralRulesCache.set(key, pluralRules);\n        }\n        let selected = pluralRules.select(count);\n        opt = options[selected] || options.other;\n        return typeof opt === \"function\" ? opt() : opt;\n    }\n    number(value) {\n        let numberFormat = $6db58dc88e78b024$var$numberFormatCache.get(this.locale);\n        if (!numberFormat) {\n            numberFormat = new Intl.NumberFormat(this.locale);\n            $6db58dc88e78b024$var$numberFormatCache.set(this.locale, numberFormat);\n        }\n        return numberFormat.format(value);\n    }\n    select(options, value) {\n        let opt = options[value] || options.other;\n        return typeof opt === \"function\" ? opt() : opt;\n    }\n    constructor(locale, strings){\n        this.locale = locale;\n        this.strings = strings;\n    }\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGludGVybmF0aW9uYWxpemVkL3N0cmluZy9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsS0FBSyxLQUFLLFFBQVE7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlFQUFpRSxZQUFZO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS3VKO0FBQ3ZKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhcm50dWJlLTEuMC8uL25vZGVfbW9kdWxlcy9AaW50ZXJuYXRpb25hbGl6ZWQvc3RyaW5nL2Rpc3QvaW1wb3J0Lm1qcz9jOWFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY29uc3QgJDViMTYwZDI4YTQzMzMxMGQkdmFyJGxvY2FsZVN5bWJvbCA9IFN5bWJvbC5mb3IoXCJyZWFjdC1hcmlhLmkxOG4ubG9jYWxlXCIpO1xuY29uc3QgJDViMTYwZDI4YTQzMzMxMGQkdmFyJHN0cmluZ3NTeW1ib2wgPSBTeW1ib2wuZm9yKFwicmVhY3QtYXJpYS5pMThuLnN0cmluZ3NcIik7XG5sZXQgJDViMTYwZDI4YTQzMzMxMGQkdmFyJGNhY2hlZEdsb2JhbFN0cmluZ3MgPSB1bmRlZmluZWQ7XG5jbGFzcyAkNWIxNjBkMjhhNDMzMzEwZCRleHBvcnQkYzE3ZmE0Nzg3OGRjNTViNiB7XG4gICAgLyoqIFJldHVybnMgYSBsb2NhbGl6ZWQgc3RyaW5nIGZvciB0aGUgZ2l2ZW4ga2V5IGFuZCBsb2NhbGUuICovIGdldFN0cmluZ0ZvckxvY2FsZShrZXksIGxvY2FsZSkge1xuICAgICAgICBsZXQgc3RyaW5ncyA9IHRoaXMuZ2V0U3RyaW5nc0ZvckxvY2FsZShsb2NhbGUpO1xuICAgICAgICBsZXQgc3RyaW5nID0gc3RyaW5nc1trZXldO1xuICAgICAgICBpZiAoIXN0cmluZykgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBpbnRsIG1lc3NhZ2UgJHtrZXl9IGluICR7bG9jYWxlfSBsb2NhbGVgKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYWxsIGxvY2FsaXplZCBzdHJpbmdzIGZvciB0aGUgZ2l2ZW4gbG9jYWxlLiAqLyBnZXRTdHJpbmdzRm9yTG9jYWxlKGxvY2FsZSkge1xuICAgICAgICBsZXQgc3RyaW5ncyA9IHRoaXMuc3RyaW5nc1tsb2NhbGVdO1xuICAgICAgICBpZiAoIXN0cmluZ3MpIHtcbiAgICAgICAgICAgIHN0cmluZ3MgPSAkNWIxNjBkMjhhNDMzMzEwZCR2YXIkZ2V0U3RyaW5nc0ZvckxvY2FsZShsb2NhbGUsIHRoaXMuc3RyaW5ncywgdGhpcy5kZWZhdWx0TG9jYWxlKTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nc1tsb2NhbGVdID0gc3RyaW5ncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5ncztcbiAgICB9XG4gICAgc3RhdGljIGdldEdsb2JhbERpY3Rpb25hcnlGb3JQYWNrYWdlKHBhY2thZ2VOYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxvY2FsZSA9IHdpbmRvd1skNWIxNjBkMjhhNDMzMzEwZCR2YXIkbG9jYWxlU3ltYm9sXTtcbiAgICAgICAgaWYgKCQ1YjE2MGQyOGE0MzMzMTBkJHZhciRjYWNoZWRHbG9iYWxTdHJpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBnbG9iYWxTdHJpbmdzID0gd2luZG93WyQ1YjE2MGQyOGE0MzMzMTBkJHZhciRzdHJpbmdzU3ltYm9sXTtcbiAgICAgICAgICAgIGlmICghZ2xvYmFsU3RyaW5ncykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAkNWIxNjBkMjhhNDMzMzEwZCR2YXIkY2FjaGVkR2xvYmFsU3RyaW5ncyA9IHt9O1xuICAgICAgICAgICAgZm9yKGxldCBwa2cgaW4gZ2xvYmFsU3RyaW5ncykkNWIxNjBkMjhhNDMzMzEwZCR2YXIkY2FjaGVkR2xvYmFsU3RyaW5nc1twa2ddID0gbmV3ICQ1YjE2MGQyOGE0MzMzMTBkJGV4cG9ydCRjMTdmYTQ3ODc4ZGM1NWI2KHtcbiAgICAgICAgICAgICAgICBbbG9jYWxlXTogZ2xvYmFsU3RyaW5nc1twa2ddXG4gICAgICAgICAgICB9LCBsb2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWN0aW9uYXJ5ID0gJDViMTYwZDI4YTQzMzMxMGQkdmFyJGNhY2hlZEdsb2JhbFN0cmluZ3MgPT09IG51bGwgfHwgJDViMTYwZDI4YTQzMzMxMGQkdmFyJGNhY2hlZEdsb2JhbFN0cmluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6ICQ1YjE2MGQyOGE0MzMzMTBkJHZhciRjYWNoZWRHbG9iYWxTdHJpbmdzW3BhY2thZ2VOYW1lXTtcbiAgICAgICAgaWYgKCFkaWN0aW9uYXJ5KSB0aHJvdyBuZXcgRXJyb3IoYFN0cmluZ3MgZm9yIHBhY2thZ2UgXCIke3BhY2thZ2VOYW1lfVwiIHdlcmUgbm90IGluY2x1ZGVkIGJ5IExvY2FsaXplZFN0cmluZ1Byb3ZpZGVyLiBQbGVhc2UgYWRkIGl0IHRvIHRoZSBsaXN0IHBhc3NlZCB0byBjcmVhdGVMb2NhbGl6ZWRTdHJpbmdEaWN0aW9uYXJ5LmApO1xuICAgICAgICByZXR1cm4gZGljdGlvbmFyeTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWVzc2FnZXMsIGRlZmF1bHRMb2NhbGUgPSBcImVuLVVTXCIpe1xuICAgICAgICAvLyBDbG9uZSBtZXNzYWdlcyBzbyB3ZSBkb24ndCBtb2RpZnkgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgICAgdGhpcy5zdHJpbmdzID0ge1xuICAgICAgICAgICAgLi4ubWVzc2FnZXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICB9XG59XG5mdW5jdGlvbiAkNWIxNjBkMjhhNDMzMzEwZCR2YXIkZ2V0U3RyaW5nc0ZvckxvY2FsZShsb2NhbGUsIHN0cmluZ3MsIGRlZmF1bHRMb2NhbGUgPSBcImVuLVVTXCIpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBleGFjdCBtYXRjaCwgdXNlIGl0LlxuICAgIGlmIChzdHJpbmdzW2xvY2FsZV0pIHJldHVybiBzdHJpbmdzW2xvY2FsZV07XG4gICAgLy8gQXR0ZW1wdCB0byBmaW5kIHRoZSBjbG9zZXN0IG1hdGNoIGJ5IGxhbmd1YWdlLlxuICAgIC8vIEZvciBleGFtcGxlLCBpZiB0aGUgbG9jYWxlIGlzIGZyLUNBIChGcmVuY2ggQ2FuYWRpYW4pLCBidXQgdGhlcmUgaXMgb25seVxuICAgIC8vIGFuIGZyLUZSIChGcmFuY2UpIHNldCBvZiBzdHJpbmdzLCB1c2UgdGhhdC5cbiAgICAvLyBUaGlzIGNvdWxkIGJlIHJlcGxhY2VkIHdpdGggSW50bC5Mb2NhbGVNYXRjaGVyIG9uY2UgaXQgaXMgc3VwcG9ydGVkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWludGwtbG9jYWxlbWF0Y2hlclxuICAgIGxldCBsYW5ndWFnZSA9ICQ1YjE2MGQyOGE0MzMzMTBkJHZhciRnZXRMYW5ndWFnZShsb2NhbGUpO1xuICAgIGlmIChzdHJpbmdzW2xhbmd1YWdlXSkgcmV0dXJuIHN0cmluZ3NbbGFuZ3VhZ2VdO1xuICAgIGZvcihsZXQga2V5IGluIHN0cmluZ3Mpe1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgobGFuZ3VhZ2UgKyBcIi1cIikpIHJldHVybiBzdHJpbmdzW2tleV07XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgY2xvc2UsIHVzZSBlbmdsaXNoLlxuICAgIHJldHVybiBzdHJpbmdzW2RlZmF1bHRMb2NhbGVdO1xufVxuZnVuY3Rpb24gJDViMTYwZDI4YTQzMzMxMGQkdmFyJGdldExhbmd1YWdlKGxvY2FsZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoSW50bC5Mb2NhbGUpIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gbmV3IEludGwuTG9jYWxlKGxvY2FsZSkubGFuZ3VhZ2U7XG4gICAgcmV0dXJuIGxvY2FsZS5zcGxpdChcIi1cIilbMF07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNvbnN0ICQ2ZGI1OGRjODhlNzhiMDI0JHZhciRwbHVyYWxSdWxlc0NhY2hlID0gbmV3IE1hcCgpO1xuY29uc3QgJDZkYjU4ZGM4OGU3OGIwMjQkdmFyJG51bWJlckZvcm1hdENhY2hlID0gbmV3IE1hcCgpO1xuY2xhc3MgJDZkYjU4ZGM4OGU3OGIwMjQkZXhwb3J0JDJmODE3ZmNkYzRiODlhZTAge1xuICAgIC8qKiBGb3JtYXRzIGEgbG9jYWxpemVkIHN0cmluZyBmb3IgdGhlIGdpdmVuIGtleSB3aXRoIHRoZSBwcm92aWRlZCB2YXJpYWJsZXMuICovIGZvcm1hdChrZXksIHZhcmlhYmxlcykge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRoaXMuc3RyaW5ncy5nZXRTdHJpbmdGb3JMb2NhbGUoa2V5LCB0aGlzLmxvY2FsZSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiID8gbWVzc2FnZSh2YXJpYWJsZXMsIHRoaXMpIDogbWVzc2FnZTtcbiAgICB9XG4gICAgcGx1cmFsKGNvdW50LCBvcHRpb25zLCB0eXBlID0gXCJjYXJkaW5hbFwiKSB7XG4gICAgICAgIGxldCBvcHQgPSBvcHRpb25zW1wiPVwiICsgY291bnRdO1xuICAgICAgICBpZiAob3B0KSByZXR1cm4gdHlwZW9mIG9wdCA9PT0gXCJmdW5jdGlvblwiID8gb3B0KCkgOiBvcHQ7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLmxvY2FsZSArIFwiOlwiICsgdHlwZTtcbiAgICAgICAgbGV0IHBsdXJhbFJ1bGVzID0gJDZkYjU4ZGM4OGU3OGIwMjQkdmFyJHBsdXJhbFJ1bGVzQ2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmICghcGx1cmFsUnVsZXMpIHtcbiAgICAgICAgICAgIHBsdXJhbFJ1bGVzID0gbmV3IEludGwuUGx1cmFsUnVsZXModGhpcy5sb2NhbGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQ2ZGI1OGRjODhlNzhiMDI0JHZhciRwbHVyYWxSdWxlc0NhY2hlLnNldChrZXksIHBsdXJhbFJ1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBwbHVyYWxSdWxlcy5zZWxlY3QoY291bnQpO1xuICAgICAgICBvcHQgPSBvcHRpb25zW3NlbGVjdGVkXSB8fCBvcHRpb25zLm90aGVyO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9wdCA9PT0gXCJmdW5jdGlvblwiID8gb3B0KCkgOiBvcHQ7XG4gICAgfVxuICAgIG51bWJlcih2YWx1ZSkge1xuICAgICAgICBsZXQgbnVtYmVyRm9ybWF0ID0gJDZkYjU4ZGM4OGU3OGIwMjQkdmFyJG51bWJlckZvcm1hdENhY2hlLmdldCh0aGlzLmxvY2FsZSk7XG4gICAgICAgIGlmICghbnVtYmVyRm9ybWF0KSB7XG4gICAgICAgICAgICBudW1iZXJGb3JtYXQgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQodGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgJDZkYjU4ZGM4OGU3OGIwMjQkdmFyJG51bWJlckZvcm1hdENhY2hlLnNldCh0aGlzLmxvY2FsZSwgbnVtYmVyRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtYmVyRm9ybWF0LmZvcm1hdCh2YWx1ZSk7XG4gICAgfVxuICAgIHNlbGVjdChvcHRpb25zLCB2YWx1ZSkge1xuICAgICAgICBsZXQgb3B0ID0gb3B0aW9uc1t2YWx1ZV0gfHwgb3B0aW9ucy5vdGhlcjtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvcHQgPT09IFwiZnVuY3Rpb25cIiA/IG9wdCgpIDogb3B0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUsIHN0cmluZ3Mpe1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICB9XG59XG5cblxuXG5cbmV4cG9ydCB7JDViMTYwZDI4YTQzMzMxMGQkZXhwb3J0JGMxN2ZhNDc4NzhkYzU1YjYgYXMgTG9jYWxpemVkU3RyaW5nRGljdGlvbmFyeSwgJDZkYjU4ZGM4OGU3OGIwMjQkZXhwb3J0JDJmODE3ZmNkYzRiODlhZTAgYXMgTG9jYWxpemVkU3RyaW5nRm9ybWF0dGVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@internationalized/string/dist/import.mjs\n");

/***/ })

};
;