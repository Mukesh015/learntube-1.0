"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase";
exports.ids = ["vendor-chunks/@firebase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* binding */ _addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* binding */ _apps),\n/* harmony export */   _clearComponents: () => (/* binding */ _clearComponents),\n/* harmony export */   _components: () => (/* binding */ _components),\n/* harmony export */   _getProvider: () => (/* binding */ _getProvider),\n/* harmony export */   _isFirebaseApp: () => (/* binding */ _isFirebaseApp),\n/* harmony export */   _isFirebaseServerApp: () => (/* binding */ _isFirebaseServerApp),\n/* harmony export */   _registerComponent: () => (/* binding */ _registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* binding */ _removeServiceInstance),\n/* harmony export */   _serverApps: () => (/* binding */ _serverApps),\n/* harmony export */   deleteApp: () => (/* binding */ deleteApp),\n/* harmony export */   getApp: () => (/* binding */ getApp),\n/* harmony export */   getApps: () => (/* binding */ getApps),\n/* harmony export */   initializeApp: () => (/* binding */ initializeApp),\n/* harmony export */   initializeServerApp: () => (/* binding */ initializeServerApp),\n/* harmony export */   onLog: () => (/* binding */ onLog),\n/* harmony export */   registerVersion: () => (/* binding */ registerVersion),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(ssr)/./node_modules/idb/build/index.js\");\n\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass PlatformLoggerServiceImpl {\r\n    constructor(container) {\r\n        this.container = container;\r\n    }\r\n    // In initial implementation, this will be called by installations on\r\n    // auth token refresh, and installations will send this string.\r\n    getPlatformInfoString() {\r\n        const providers = this.container.getProviders();\r\n        // Loop through providers and get library/version pairs from any that are\r\n        // version components.\r\n        return providers\r\n            .map(provider => {\r\n            if (isVersionServiceProvider(provider)) {\r\n                const service = provider.getImmediate();\r\n                return `${service.library}/${service.version}`;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        })\r\n            .filter(logString => logString)\r\n            .join(' ');\r\n    }\r\n}\r\n/**\r\n *\r\n * @param provider check if this provider provides a VersionService\r\n *\r\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\r\n * provides VersionService. The provider is not necessarily a 'app-version'\r\n * provider.\r\n */\r\nfunction isVersionServiceProvider(provider) {\r\n    const component = provider.getComponent();\r\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */;\r\n}\n\nconst name$o = \"@firebase/app\";\nconst version$1 = \"0.10.2\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger('@firebase/app');\n\nconst name$n = \"@firebase/app-compat\";\n\nconst name$m = \"@firebase/analytics-compat\";\n\nconst name$l = \"@firebase/analytics\";\n\nconst name$k = \"@firebase/app-check-compat\";\n\nconst name$j = \"@firebase/app-check\";\n\nconst name$i = \"@firebase/auth\";\n\nconst name$h = \"@firebase/auth-compat\";\n\nconst name$g = \"@firebase/database\";\n\nconst name$f = \"@firebase/database-compat\";\n\nconst name$e = \"@firebase/functions\";\n\nconst name$d = \"@firebase/functions-compat\";\n\nconst name$c = \"@firebase/installations\";\n\nconst name$b = \"@firebase/installations-compat\";\n\nconst name$a = \"@firebase/messaging\";\n\nconst name$9 = \"@firebase/messaging-compat\";\n\nconst name$8 = \"@firebase/performance\";\n\nconst name$7 = \"@firebase/performance-compat\";\n\nconst name$6 = \"@firebase/remote-config\";\n\nconst name$5 = \"@firebase/remote-config-compat\";\n\nconst name$4 = \"@firebase/storage\";\n\nconst name$3 = \"@firebase/storage-compat\";\n\nconst name$2 = \"@firebase/firestore\";\n\nconst name$1 = \"@firebase/firestore-compat\";\n\nconst name = \"firebase\";\nconst version = \"10.11.1\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The default app name\r\n *\r\n * @internal\r\n */\r\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\r\nconst PLATFORM_LOG_STRING = {\r\n    [name$o]: 'fire-core',\r\n    [name$n]: 'fire-core-compat',\r\n    [name$l]: 'fire-analytics',\r\n    [name$m]: 'fire-analytics-compat',\r\n    [name$j]: 'fire-app-check',\r\n    [name$k]: 'fire-app-check-compat',\r\n    [name$i]: 'fire-auth',\r\n    [name$h]: 'fire-auth-compat',\r\n    [name$g]: 'fire-rtdb',\r\n    [name$f]: 'fire-rtdb-compat',\r\n    [name$e]: 'fire-fn',\r\n    [name$d]: 'fire-fn-compat',\r\n    [name$c]: 'fire-iid',\r\n    [name$b]: 'fire-iid-compat',\r\n    [name$a]: 'fire-fcm',\r\n    [name$9]: 'fire-fcm-compat',\r\n    [name$8]: 'fire-perf',\r\n    [name$7]: 'fire-perf-compat',\r\n    [name$6]: 'fire-rc',\r\n    [name$5]: 'fire-rc-compat',\r\n    [name$4]: 'fire-gcs',\r\n    [name$3]: 'fire-gcs-compat',\r\n    [name$2]: 'fire-fst',\r\n    [name$1]: 'fire-fst-compat',\r\n    'fire-js': 'fire-js',\r\n    [name]: 'fire-js-all'\r\n};\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @internal\r\n */\r\nconst _apps = new Map();\r\n/**\r\n * @internal\r\n */\r\nconst _serverApps = new Map();\r\n/**\r\n * Registered components.\r\n *\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst _components = new Map();\r\n/**\r\n * @param component - the component being added to this app's container\r\n *\r\n * @internal\r\n */\r\nfunction _addComponent(app, component) {\r\n    try {\r\n        app.container.addComponent(component);\r\n    }\r\n    catch (e) {\r\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\r\n    }\r\n}\r\n/**\r\n *\r\n * @internal\r\n */\r\nfunction _addOrOverwriteComponent(app, component) {\r\n    app.container.addOrOverwriteComponent(component);\r\n}\r\n/**\r\n *\r\n * @param component - the component to register\r\n * @returns whether or not the component is registered successfully\r\n *\r\n * @internal\r\n */\r\nfunction _registerComponent(component) {\r\n    const componentName = component.name;\r\n    if (_components.has(componentName)) {\r\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\r\n        return false;\r\n    }\r\n    _components.set(componentName, component);\r\n    // add the component to existing app instances\r\n    for (const app of _apps.values()) {\r\n        _addComponent(app, component);\r\n    }\r\n    for (const serverApp of _serverApps.values()) {\r\n        _addComponent(serverApp, component);\r\n    }\r\n    return true;\r\n}\r\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n *\r\n * @returns the provider for the service with the matching name\r\n *\r\n * @internal\r\n */\r\nfunction _getProvider(app, name) {\r\n    const heartbeatController = app.container\r\n        .getProvider('heartbeat')\r\n        .getImmediate({ optional: true });\r\n    if (heartbeatController) {\r\n        void heartbeatController.triggerHeartbeat();\r\n    }\r\n    return app.container.getProvider(name);\r\n}\r\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\r\n *\r\n * @internal\r\n */\r\nfunction _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\r\n    _getProvider(app, name).clearInstance(instanceIdentifier);\r\n}\r\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp or FirebaseOptions.\r\n *\r\n * @returns true if the provide object is of type FirebaseApp.\r\n *\r\n * @internal\r\n */\r\nfunction _isFirebaseApp(obj) {\r\n    return obj.options !== undefined;\r\n}\r\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp.\r\n *\r\n * @returns true if the provided object is of type FirebaseServerAppImpl.\r\n *\r\n * @internal\r\n */\r\nfunction _isFirebaseServerApp(obj) {\r\n    return obj.settings !== undefined;\r\n}\r\n/**\r\n * Test only\r\n *\r\n * @internal\r\n */\r\nfunction _clearComponents() {\r\n    _components.clear();\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERRORS = {\r\n    [\"no-app\" /* AppError.NO_APP */]: \"No Firebase App '{$appName}' has been created - \" +\r\n        'call initializeApp() first',\r\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */]: \"Illegal App name: '{$appName}'\",\r\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */]: \"Firebase App named '{$appName}' already exists with different options or config\",\r\n    [\"app-deleted\" /* AppError.APP_DELETED */]: \"Firebase App named '{$appName}' already deleted\",\r\n    [\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */]: 'Firebase Server App has been deleted',\r\n    [\"no-options\" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',\r\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +\r\n        'Firebase App instance.',\r\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',\r\n    [\"idb-open\" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"idb-get\" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"idb-set\" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"idb-delete\" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */]: 'FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.',\r\n    [\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */]: 'FirebaseServerApp is not for use in browser environments.'\r\n};\r\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory('app', 'Firebase', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass FirebaseAppImpl {\r\n    constructor(options, config, container) {\r\n        this._isDeleted = false;\r\n        this._options = Object.assign({}, options);\r\n        this._config = Object.assign({}, config);\r\n        this._name = config.name;\r\n        this._automaticDataCollectionEnabled =\r\n            config.automaticDataCollectionEnabled;\r\n        this._container = container;\r\n        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('app', () => this, \"PUBLIC\" /* ComponentType.PUBLIC */));\r\n    }\r\n    get automaticDataCollectionEnabled() {\r\n        this.checkDestroyed();\r\n        return this._automaticDataCollectionEnabled;\r\n    }\r\n    set automaticDataCollectionEnabled(val) {\r\n        this.checkDestroyed();\r\n        this._automaticDataCollectionEnabled = val;\r\n    }\r\n    get name() {\r\n        this.checkDestroyed();\r\n        return this._name;\r\n    }\r\n    get options() {\r\n        this.checkDestroyed();\r\n        return this._options;\r\n    }\r\n    get config() {\r\n        this.checkDestroyed();\r\n        return this._config;\r\n    }\r\n    get container() {\r\n        return this._container;\r\n    }\r\n    get isDeleted() {\r\n        return this._isDeleted;\r\n    }\r\n    set isDeleted(val) {\r\n        this._isDeleted = val;\r\n    }\r\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */\r\n    checkDestroyed() {\r\n        if (this.isDeleted) {\r\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */, { appName: this._name });\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass FirebaseServerAppImpl extends FirebaseAppImpl {\r\n    constructor(options, serverConfig, name, container) {\r\n        // Build configuration parameters for the FirebaseAppImpl base class.\r\n        const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== undefined\r\n            ? serverConfig.automaticDataCollectionEnabled\r\n            : false;\r\n        // Create the FirebaseAppSettings object for the FirebaseAppImp constructor.\r\n        const config = {\r\n            name,\r\n            automaticDataCollectionEnabled\r\n        };\r\n        if (options.apiKey !== undefined) {\r\n            // Construct the parent FirebaseAppImp object.\r\n            super(options, config, container);\r\n        }\r\n        else {\r\n            const appImpl = options;\r\n            super(appImpl.options, config, container);\r\n        }\r\n        // Now construct the data for the FirebaseServerAppImpl.\r\n        this._serverConfig = Object.assign({ automaticDataCollectionEnabled }, serverConfig);\r\n        this._finalizationRegistry = new FinalizationRegistry(() => {\r\n            this.automaticCleanup();\r\n        });\r\n        this._refCount = 0;\r\n        this.incRefCount(this._serverConfig.releaseOnDeref);\r\n        // Do not retain a hard reference to the dref object, otherwise the FinalizationRegisry\r\n        // will never trigger.\r\n        this._serverConfig.releaseOnDeref = undefined;\r\n        serverConfig.releaseOnDeref = undefined;\r\n        registerVersion(name$o, version$1, 'serverapp');\r\n    }\r\n    toJSON() {\r\n        return undefined;\r\n    }\r\n    get refCount() {\r\n        return this._refCount;\r\n    }\r\n    // Increment the reference count of this server app. If an object is provided, register it\r\n    // with the finalization registry.\r\n    incRefCount(obj) {\r\n        if (this.isDeleted) {\r\n            return;\r\n        }\r\n        this._refCount++;\r\n        if (obj !== undefined) {\r\n            this._finalizationRegistry.register(obj, this);\r\n        }\r\n    }\r\n    // Decrement the reference count.\r\n    decRefCount() {\r\n        if (this.isDeleted) {\r\n            return 0;\r\n        }\r\n        return --this._refCount;\r\n    }\r\n    // Invoked by the FinalizationRegistry callback to note that this app should go through its\r\n    // reference counts and delete itself if no reference count remain. The coordinating logic that\r\n    // handles this is in deleteApp(...).\r\n    automaticCleanup() {\r\n        void deleteApp(this);\r\n    }\r\n    get settings() {\r\n        this.checkDestroyed();\r\n        return this._serverConfig;\r\n    }\r\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */\r\n    checkDestroyed() {\r\n        if (this.isDeleted) {\r\n            throw ERROR_FACTORY.create(\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The current SDK version.\r\n *\r\n * @public\r\n */\r\nconst SDK_VERSION = version;\r\nfunction initializeApp(_options, rawConfig = {}) {\r\n    let options = _options;\r\n    if (typeof rawConfig !== 'object') {\r\n        const name = rawConfig;\r\n        rawConfig = { name };\r\n    }\r\n    const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);\r\n    const name = config.name;\r\n    if (typeof name !== 'string' || !name) {\r\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */, {\r\n            appName: String(name)\r\n        });\r\n    }\r\n    options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\r\n    if (!options) {\r\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */);\r\n    }\r\n    const existingApp = _apps.get(name);\r\n    if (existingApp) {\r\n        // return the existing app if options and config deep equal the ones in the existing app.\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) &&\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\r\n            return existingApp;\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */, { appName: name });\r\n        }\r\n    }\r\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\r\n    for (const component of _components.values()) {\r\n        container.addComponent(component);\r\n    }\r\n    const newApp = new FirebaseAppImpl(options, config, container);\r\n    _apps.set(name, newApp);\r\n    return newApp;\r\n}\r\nfunction initializeServerApp(_options, _serverAppConfig) {\r\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowser)()) {\r\n        // FirebaseServerApp isn't designed to be run in browsers.\r\n        throw ERROR_FACTORY.create(\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */);\r\n    }\r\n    if (_serverAppConfig.automaticDataCollectionEnabled === undefined) {\r\n        _serverAppConfig.automaticDataCollectionEnabled = false;\r\n    }\r\n    let appOptions;\r\n    if (_isFirebaseApp(_options)) {\r\n        appOptions = _options.options;\r\n    }\r\n    else {\r\n        appOptions = _options;\r\n    }\r\n    // Build an app name based on a hash of the configuration options.\r\n    const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);\r\n    // However, Do not mangle the name based on releaseOnDeref, since it will vary between the\r\n    // construction of FirebaseServerApp instances. For example, if the object is the request headers.\r\n    if (nameObj.releaseOnDeref !== undefined) {\r\n        delete nameObj.releaseOnDeref;\r\n    }\r\n    const hashCode = (s) => {\r\n        return [...s].reduce((hash, c) => (Math.imul(31, hash) + c.charCodeAt(0)) | 0, 0);\r\n    };\r\n    if (_serverAppConfig.releaseOnDeref !== undefined) {\r\n        if (typeof FinalizationRegistry === 'undefined') {\r\n            throw ERROR_FACTORY.create(\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */, {});\r\n        }\r\n    }\r\n    const nameString = '' + hashCode(JSON.stringify(nameObj));\r\n    const existingApp = _serverApps.get(nameString);\r\n    if (existingApp) {\r\n        existingApp.incRefCount(_serverAppConfig.releaseOnDeref);\r\n        return existingApp;\r\n    }\r\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(nameString);\r\n    for (const component of _components.values()) {\r\n        container.addComponent(component);\r\n    }\r\n    const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);\r\n    _serverApps.set(nameString, newApp);\r\n    return newApp;\r\n}\r\n/**\r\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * When called with no arguments, the default app is returned. When an app name\r\n * is provided, the app corresponding to that name is returned.\r\n *\r\n * An exception is thrown if the app being retrieved has not yet been\r\n * initialized.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return the default app\r\n * const app = getApp();\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return a named app\r\n * const otherApp = getApp(\"otherApp\");\r\n * ```\r\n *\r\n * @param name - Optional name of the app to return. If no name is\r\n *   provided, the default is `\"[DEFAULT]\"`.\r\n *\r\n * @returns The app corresponding to the provided app name.\r\n *   If no app name is provided, the default app is returned.\r\n *\r\n * @public\r\n */\r\nfunction getApp(name = DEFAULT_ENTRY_NAME) {\r\n    const app = _apps.get(name);\r\n    if (!app && name === DEFAULT_ENTRY_NAME && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)()) {\r\n        return initializeApp();\r\n    }\r\n    if (!app) {\r\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */, { appName: name });\r\n    }\r\n    return app;\r\n}\r\n/**\r\n * A (read-only) array of all initialized apps.\r\n * @public\r\n */\r\nfunction getApps() {\r\n    return Array.from(_apps.values());\r\n}\r\n/**\r\n * Renders this app unusable and frees the resources of all associated\r\n * services.\r\n *\r\n * @example\r\n * ```javascript\r\n * deleteApp(app)\r\n *   .then(function() {\r\n *     console.log(\"App deleted successfully\");\r\n *   })\r\n *   .catch(function(error) {\r\n *     console.log(\"Error deleting app:\", error);\r\n *   });\r\n * ```\r\n *\r\n * @public\r\n */\r\nasync function deleteApp(app) {\r\n    let cleanupProviders = false;\r\n    const name = app.name;\r\n    if (_apps.has(name)) {\r\n        cleanupProviders = true;\r\n        _apps.delete(name);\r\n    }\r\n    else if (_serverApps.has(name)) {\r\n        const firebaseServerApp = app;\r\n        if (firebaseServerApp.decRefCount() <= 0) {\r\n            _serverApps.delete(name);\r\n            cleanupProviders = true;\r\n        }\r\n    }\r\n    if (cleanupProviders) {\r\n        await Promise.all(app.container\r\n            .getProviders()\r\n            .map(provider => provider.delete()));\r\n        app.isDeleted = true;\r\n    }\r\n}\r\n/**\r\n * Registers a library's name and version for platform logging purposes.\r\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\r\n * @param version - Current version of that library.\r\n * @param variant - Bundle variant, e.g., node, rn, etc.\r\n *\r\n * @public\r\n */\r\nfunction registerVersion(libraryKeyOrName, version, variant) {\r\n    var _a;\r\n    // TODO: We can use this check to whitelist strings when/if we set up\r\n    // a good whitelist system.\r\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\r\n    if (variant) {\r\n        library += `-${variant}`;\r\n    }\r\n    const libraryMismatch = library.match(/\\s|\\//);\r\n    const versionMismatch = version.match(/\\s|\\//);\r\n    if (libraryMismatch || versionMismatch) {\r\n        const warning = [\r\n            `Unable to register library \"${library}\" with version \"${version}\":`\r\n        ];\r\n        if (libraryMismatch) {\r\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\r\n        }\r\n        if (libraryMismatch && versionMismatch) {\r\n            warning.push('and');\r\n        }\r\n        if (versionMismatch) {\r\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\r\n        }\r\n        logger.warn(warning.join(' '));\r\n        return;\r\n    }\r\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, () => ({ library, version }), \"VERSION\" /* ComponentType.VERSION */));\r\n}\r\n/**\r\n * Sets log handler for all Firebase SDKs.\r\n * @param logCallback - An optional custom log handler that executes user code whenever\r\n * the Firebase SDK makes a logging call.\r\n *\r\n * @public\r\n */\r\nfunction onLog(logCallback, options) {\r\n    if (logCallback !== null && typeof logCallback !== 'function') {\r\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */);\r\n    }\r\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\r\n}\r\n/**\r\n * Sets log level for all Firebase SDKs.\r\n *\r\n * All of the log types above the current log level are captured (i.e. if\r\n * you set the log level to `info`, errors are logged, but `debug` and\r\n * `verbose` logs are not).\r\n *\r\n * @public\r\n */\r\nfunction setLogLevel(logLevel) {\r\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DB_NAME = 'firebase-heartbeat-database';\r\nconst DB_VERSION = 1;\r\nconst STORE_NAME = 'firebase-heartbeat-store';\r\nlet dbPromise = null;\r\nfunction getDbPromise() {\r\n    if (!dbPromise) {\r\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\r\n            upgrade: (db, oldVersion) => {\r\n                // We don't use 'break' in this switch statement, the fall-through\r\n                // behavior is what we want, because if there are multiple versions between\r\n                // the old version and the current version, we want ALL the migrations\r\n                // that correspond to those versions to run, not only the last one.\r\n                // eslint-disable-next-line default-case\r\n                switch (oldVersion) {\r\n                    case 0:\r\n                        try {\r\n                            db.createObjectStore(STORE_NAME);\r\n                        }\r\n                        catch (e) {\r\n                            // Safari/iOS browsers throw occasional exceptions on\r\n                            // db.createObjectStore() that may be a bug. Avoid blocking\r\n                            // the rest of the app functionality.\r\n                            console.warn(e);\r\n                        }\r\n                }\r\n            }\r\n        }).catch(e => {\r\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */, {\r\n                originalErrorMessage: e.message\r\n            });\r\n        });\r\n    }\r\n    return dbPromise;\r\n}\r\nasync function readHeartbeatsFromIndexedDB(app) {\r\n    try {\r\n        const db = await getDbPromise();\r\n        const tx = db.transaction(STORE_NAME);\r\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\r\n        // We already have the value but tx.done can throw,\r\n        // so we need to await it here to catch errors\r\n        await tx.done;\r\n        return result;\r\n    }\r\n    catch (e) {\r\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\r\n            logger.warn(e.message);\r\n        }\r\n        else {\r\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */, {\r\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\r\n            });\r\n            logger.warn(idbGetError.message);\r\n        }\r\n    }\r\n}\r\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\r\n    try {\r\n        const db = await getDbPromise();\r\n        const tx = db.transaction(STORE_NAME, 'readwrite');\r\n        const objectStore = tx.objectStore(STORE_NAME);\r\n        await objectStore.put(heartbeatObject, computeKey(app));\r\n        await tx.done;\r\n    }\r\n    catch (e) {\r\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\r\n            logger.warn(e.message);\r\n        }\r\n        else {\r\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */, {\r\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\r\n            });\r\n            logger.warn(idbGetError.message);\r\n        }\r\n    }\r\n}\r\nfunction computeKey(app) {\r\n    return `${app.name}!${app.options.appId}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst MAX_HEADER_BYTES = 1024;\r\n// 30 days\r\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\r\nclass HeartbeatServiceImpl {\r\n    constructor(container) {\r\n        this.container = container;\r\n        /**\r\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\r\n         * the header string.\r\n         * Stores one record per date. This will be consolidated into the standard\r\n         * format of one record per user agent string before being sent as a header.\r\n         * Populated from indexedDB when the controller is instantiated and should\r\n         * be kept in sync with indexedDB.\r\n         * Leave public for easier testing.\r\n         */\r\n        this._heartbeatsCache = null;\r\n        const app = this.container.getProvider('app').getImmediate();\r\n        this._storage = new HeartbeatStorageImpl(app);\r\n        this._heartbeatsCachePromise = this._storage.read().then(result => {\r\n            this._heartbeatsCache = result;\r\n            return result;\r\n        });\r\n    }\r\n    /**\r\n     * Called to report a heartbeat. The function will generate\r\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\r\n     * to IndexedDB.\r\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\r\n     * already logged, subsequent calls to this function in the same day will be ignored.\r\n     */\r\n    async triggerHeartbeat() {\r\n        var _a, _b;\r\n        const platformLogger = this.container\r\n            .getProvider('platform-logger')\r\n            .getImmediate();\r\n        // This is the \"Firebase user agent\" string from the platform logger\r\n        // service, not the browser user agent.\r\n        const agent = platformLogger.getPlatformInfoString();\r\n        const date = getUTCDateString();\r\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\r\n            this._heartbeatsCache = await this._heartbeatsCachePromise;\r\n            // If we failed to construct a heartbeats cache, then return immediately.\r\n            if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\r\n                return;\r\n            }\r\n        }\r\n        // Do not store a heartbeat if one is already stored for this day\r\n        // or if a header has already been sent today.\r\n        if (this._heartbeatsCache.lastSentHeartbeatDate === date ||\r\n            this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {\r\n            return;\r\n        }\r\n        else {\r\n            // There is no entry for this date. Create one.\r\n            this._heartbeatsCache.heartbeats.push({ date, agent });\r\n        }\r\n        // Remove entries older than 30 days.\r\n        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(singleDateHeartbeat => {\r\n            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\r\n            const now = Date.now();\r\n            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\r\n        });\r\n        return this._storage.overwrite(this._heartbeatsCache);\r\n    }\r\n    /**\r\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\r\n     * It also clears all heartbeats from memory as well as in IndexedDB.\r\n     *\r\n     * NOTE: Consuming product SDKs should not send the header if this method\r\n     * returns an empty string.\r\n     */\r\n    async getHeartbeatsHeader() {\r\n        var _a;\r\n        if (this._heartbeatsCache === null) {\r\n            await this._heartbeatsCachePromise;\r\n        }\r\n        // If it's still null or the array is empty, there is no data to send.\r\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null ||\r\n            this._heartbeatsCache.heartbeats.length === 0) {\r\n            return '';\r\n        }\r\n        const date = getUTCDateString();\r\n        // Extract as many heartbeats from the cache as will fit under the size limit.\r\n        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\r\n        const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));\r\n        // Store last sent date to prevent another being logged/sent for the same day.\r\n        this._heartbeatsCache.lastSentHeartbeatDate = date;\r\n        if (unsentEntries.length > 0) {\r\n            // Store any unsent entries if they exist.\r\n            this._heartbeatsCache.heartbeats = unsentEntries;\r\n            // This seems more likely than emptying the array (below) to lead to some odd state\r\n            // since the cache isn't empty and this will be called again on the next request,\r\n            // and is probably safest if we await it.\r\n            await this._storage.overwrite(this._heartbeatsCache);\r\n        }\r\n        else {\r\n            this._heartbeatsCache.heartbeats = [];\r\n            // Do not wait for this, to reduce latency.\r\n            void this._storage.overwrite(this._heartbeatsCache);\r\n        }\r\n        return headerString;\r\n    }\r\n}\r\nfunction getUTCDateString() {\r\n    const today = new Date();\r\n    // Returns date format 'YYYY-MM-DD'\r\n    return today.toISOString().substring(0, 10);\r\n}\r\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\r\n    // Heartbeats grouped by user agent in the standard format to be sent in\r\n    // the header.\r\n    const heartbeatsToSend = [];\r\n    // Single date format heartbeats that are not sent.\r\n    let unsentEntries = heartbeatsCache.slice();\r\n    for (const singleDateHeartbeat of heartbeatsCache) {\r\n        // Look for an existing entry with the same user agent.\r\n        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);\r\n        if (!heartbeatEntry) {\r\n            // If no entry for this user agent exists, create one.\r\n            heartbeatsToSend.push({\r\n                agent: singleDateHeartbeat.agent,\r\n                dates: [singleDateHeartbeat.date]\r\n            });\r\n            if (countBytes(heartbeatsToSend) > maxSize) {\r\n                // If the header would exceed max size, remove the added heartbeat\r\n                // entry and stop adding to the header.\r\n                heartbeatsToSend.pop();\r\n                break;\r\n            }\r\n        }\r\n        else {\r\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\r\n            // If the header would exceed max size, remove the added date\r\n            // and stop adding to the header.\r\n            if (countBytes(heartbeatsToSend) > maxSize) {\r\n                heartbeatEntry.dates.pop();\r\n                break;\r\n            }\r\n        }\r\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\r\n        // quota and the loop breaks early.)\r\n        unsentEntries = unsentEntries.slice(1);\r\n    }\r\n    return {\r\n        heartbeatsToSend,\r\n        unsentEntries\r\n    };\r\n}\r\nclass HeartbeatStorageImpl {\r\n    constructor(app) {\r\n        this.app = app;\r\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\r\n    }\r\n    async runIndexedDBEnvironmentCheck() {\r\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\r\n            return false;\r\n        }\r\n        else {\r\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)()\r\n                .then(() => true)\r\n                .catch(() => false);\r\n        }\r\n    }\r\n    /**\r\n     * Read all heartbeats.\r\n     */\r\n    async read() {\r\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\r\n        if (!canUseIndexedDB) {\r\n            return { heartbeats: [] };\r\n        }\r\n        else {\r\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\r\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\r\n                return idbHeartbeatObject;\r\n            }\r\n            else {\r\n                return { heartbeats: [] };\r\n            }\r\n        }\r\n    }\r\n    // overwrite the storage with the provided heartbeats\r\n    async overwrite(heartbeatsObject) {\r\n        var _a;\r\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\r\n        if (!canUseIndexedDB) {\r\n            return;\r\n        }\r\n        else {\r\n            const existingHeartbeatsObject = await this.read();\r\n            return writeHeartbeatsToIndexedDB(this.app, {\r\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\r\n                heartbeats: heartbeatsObject.heartbeats\r\n            });\r\n        }\r\n    }\r\n    // add heartbeats\r\n    async add(heartbeatsObject) {\r\n        var _a;\r\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\r\n        if (!canUseIndexedDB) {\r\n            return;\r\n        }\r\n        else {\r\n            const existingHeartbeatsObject = await this.read();\r\n            return writeHeartbeatsToIndexedDB(this.app, {\r\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\r\n                heartbeats: [\r\n                    ...existingHeartbeatsObject.heartbeats,\r\n                    ...heartbeatsObject.heartbeats\r\n                ]\r\n            });\r\n        }\r\n    }\r\n}\r\n/**\r\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\r\n * in a platform logging header JSON object, stringified, and converted\r\n * to base 64.\r\n */\r\nfunction countBytes(heartbeatsCache) {\r\n    // base64 has a restricted set of characters, all of which should be 1 byte.\r\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(\r\n    // heartbeatsCache wrapper properties\r\n    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction registerCoreComponents(variant) {\r\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('platform-logger', container => new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('heartbeat', container => new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    // Register `app` package.\r\n    registerVersion(name$o, version$1, variant);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    registerVersion(name$o, version$1, 'esm2017');\r\n    // Register platform SDK identifier (no version).\r\n    registerVersion('fire-js', '');\r\n}\n\n/**\r\n * Firebase App\r\n *\r\n * @remarks This package coordinates the communication between the different Firebase components\r\n * @packageDocumentation\r\n */\r\nregisterCoreComponents('');\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQ3VCO0FBQzZGO0FBQ3pJO0FBQ2xCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQU07O0FBRXpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQixzQ0FBc0MsU0FBUztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxjQUFjO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0EsdUVBQXVFLFNBQVM7QUFDaEYsMEVBQTBFLFNBQVM7QUFDbkYsc0VBQXNFLFNBQVM7QUFDL0U7QUFDQTtBQUNBLDZFQUE2RSxTQUFTO0FBQ3RGO0FBQ0E7QUFDQSxpR0FBaUcsc0JBQXNCO0FBQ3ZILG9HQUFvRyxzQkFBc0I7QUFDMUgsb0dBQW9HLHNCQUFzQjtBQUMxSCwyR0FBMkcsc0JBQXNCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBWTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBEQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixxQkFBcUI7QUFDeEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQ0FBZ0M7QUFDN0U7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxtQ0FBbUMsaUVBQWlFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMEJBQTBCLG1FQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFTO0FBQ3JCLFlBQVkseURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBLDBCQUEwQixtRUFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1FQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1FQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZUFBZTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSxrQkFBa0IsUUFBUTtBQUM3RTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBEQUFTLElBQUksUUFBUSxvQkFBb0Isa0JBQWtCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZEQUFhO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseURBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsR0FBRyxrQkFBa0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDO0FBQ2xELDZCQUE2Qiw2RUFBNkIsa0JBQWtCLDBDQUEwQztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0VBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5RUFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZFQUE2QjtBQUN4QztBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBUztBQUNwQywyQkFBMkIsMERBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1XO0FBQ25XIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhcm50dWJlLTEuMC8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/NjRiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudENvbnRhaW5lciB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgTG9nZ2VyLCBzZXRVc2VyTG9nSGFuZGxlciwgc2V0TG9nTGV2ZWwgYXMgc2V0TG9nTGV2ZWwkMSB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5LCBnZXREZWZhdWx0QXBwQ29uZmlnLCBkZWVwRXF1YWwsIGlzQnJvd3NlciwgRmlyZWJhc2VFcnJvciwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuZXhwb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IG9wZW5EQiB9IGZyb20gJ2lkYic7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB9XHJcbiAgICAvLyBJbiBpbml0aWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGJ5IGluc3RhbGxhdGlvbnMgb25cclxuICAgIC8vIGF1dGggdG9rZW4gcmVmcmVzaCwgYW5kIGluc3RhbGxhdGlvbnMgd2lsbCBzZW5kIHRoaXMgc3RyaW5nLlxyXG4gICAgZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVycygpO1xyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBwcm92aWRlcnMgYW5kIGdldCBsaWJyYXJ5L3ZlcnNpb24gcGFpcnMgZnJvbSBhbnkgdGhhdCBhcmVcclxuICAgICAgICAvLyB2ZXJzaW9uIGNvbXBvbmVudHMuXHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1xyXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzZXJ2aWNlLmxpYnJhcnl9LyR7c2VydmljZS52ZXJzaW9ufWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIobG9nU3RyaW5nID0+IGxvZ1N0cmluZylcclxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHByb3ZpZGVyIGNoZWNrIGlmIHRoaXMgcHJvdmlkZXIgcHJvdmlkZXMgYSBWZXJzaW9uU2VydmljZVxyXG4gKlxyXG4gKiBOT1RFOiBVc2luZyBQcm92aWRlcjwnYXBwLXZlcnNpb24nPiBpcyBhIGhhY2sgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcHJvdmlkZXJcclxuICogcHJvdmlkZXMgVmVyc2lvblNlcnZpY2UuIFRoZSBwcm92aWRlciBpcyBub3QgbmVjZXNzYXJpbHkgYSAnYXBwLXZlcnNpb24nXHJcbiAqIHByb3ZpZGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSB7XHJcbiAgICBjb25zdCBjb21wb25lbnQgPSBwcm92aWRlci5nZXRDb21wb25lbnQoKTtcclxuICAgIHJldHVybiAoY29tcG9uZW50ID09PSBudWxsIHx8IGNvbXBvbmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50LnR5cGUpID09PSBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi87XHJcbn1cblxuY29uc3QgbmFtZSRvID0gXCJAZmlyZWJhc2UvYXBwXCI7XG5jb25zdCB2ZXJzaW9uJDEgPSBcIjAuMTAuMlwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvYXBwJyk7XG5cbmNvbnN0IG5hbWUkbiA9IFwiQGZpcmViYXNlL2FwcC1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRtID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGwgPSBcIkBmaXJlYmFzZS9hbmFseXRpY3NcIjtcblxuY29uc3QgbmFtZSRrID0gXCJAZmlyZWJhc2UvYXBwLWNoZWNrLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGogPSBcIkBmaXJlYmFzZS9hcHAtY2hlY2tcIjtcblxuY29uc3QgbmFtZSRpID0gXCJAZmlyZWJhc2UvYXV0aFwiO1xuXG5jb25zdCBuYW1lJGggPSBcIkBmaXJlYmFzZS9hdXRoLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGcgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZVwiO1xuXG5jb25zdCBuYW1lJGYgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRlID0gXCJAZmlyZWJhc2UvZnVuY3Rpb25zXCI7XG5cbmNvbnN0IG5hbWUkZCA9IFwiQGZpcmViYXNlL2Z1bmN0aW9ucy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRjID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9uc1wiO1xuXG5jb25zdCBuYW1lJGIgPSBcIkBmaXJlYmFzZS9pbnN0YWxsYXRpb25zLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGEgPSBcIkBmaXJlYmFzZS9tZXNzYWdpbmdcIjtcblxuY29uc3QgbmFtZSQ5ID0gXCJAZmlyZWJhc2UvbWVzc2FnaW5nLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDggPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZVwiO1xuXG5jb25zdCBuYW1lJDcgPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ2ID0gXCJAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZ1wiO1xuXG5jb25zdCBuYW1lJDUgPSBcIkBmaXJlYmFzZS9yZW1vdGUtY29uZmlnLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDQgPSBcIkBmaXJlYmFzZS9zdG9yYWdlXCI7XG5cbmNvbnN0IG5hbWUkMyA9IFwiQGZpcmViYXNlL3N0b3JhZ2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkMiA9IFwiQGZpcmViYXNlL2ZpcmVzdG9yZVwiO1xuXG5jb25zdCBuYW1lJDEgPSBcIkBmaXJlYmFzZS9maXJlc3RvcmUtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUgPSBcImZpcmViYXNlXCI7XG5jb25zdCB2ZXJzaW9uID0gXCIxMC4xMS4xXCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBhcHAgbmFtZVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xyXG5jb25zdCBQTEFURk9STV9MT0dfU1RSSU5HID0ge1xyXG4gICAgW25hbWUkb106ICdmaXJlLWNvcmUnLFxyXG4gICAgW25hbWUkbl06ICdmaXJlLWNvcmUtY29tcGF0JyxcclxuICAgIFtuYW1lJGxdOiAnZmlyZS1hbmFseXRpY3MnLFxyXG4gICAgW25hbWUkbV06ICdmaXJlLWFuYWx5dGljcy1jb21wYXQnLFxyXG4gICAgW25hbWUkal06ICdmaXJlLWFwcC1jaGVjaycsXHJcbiAgICBbbmFtZSRrXTogJ2ZpcmUtYXBwLWNoZWNrLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRpXTogJ2ZpcmUtYXV0aCcsXHJcbiAgICBbbmFtZSRoXTogJ2ZpcmUtYXV0aC1jb21wYXQnLFxyXG4gICAgW25hbWUkZ106ICdmaXJlLXJ0ZGInLFxyXG4gICAgW25hbWUkZl06ICdmaXJlLXJ0ZGItY29tcGF0JyxcclxuICAgIFtuYW1lJGVdOiAnZmlyZS1mbicsXHJcbiAgICBbbmFtZSRkXTogJ2ZpcmUtZm4tY29tcGF0JyxcclxuICAgIFtuYW1lJGNdOiAnZmlyZS1paWQnLFxyXG4gICAgW25hbWUkYl06ICdmaXJlLWlpZC1jb21wYXQnLFxyXG4gICAgW25hbWUkYV06ICdmaXJlLWZjbScsXHJcbiAgICBbbmFtZSQ5XTogJ2ZpcmUtZmNtLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQ4XTogJ2ZpcmUtcGVyZicsXHJcbiAgICBbbmFtZSQ3XTogJ2ZpcmUtcGVyZi1jb21wYXQnLFxyXG4gICAgW25hbWUkNl06ICdmaXJlLXJjJyxcclxuICAgIFtuYW1lJDVdOiAnZmlyZS1yYy1jb21wYXQnLFxyXG4gICAgW25hbWUkNF06ICdmaXJlLWdjcycsXHJcbiAgICBbbmFtZSQzXTogJ2ZpcmUtZ2NzLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQyXTogJ2ZpcmUtZnN0JyxcclxuICAgIFtuYW1lJDFdOiAnZmlyZS1mc3QtY29tcGF0JyxcclxuICAgICdmaXJlLWpzJzogJ2ZpcmUtanMnLFxyXG4gICAgW25hbWVdOiAnZmlyZS1qcy1hbGwnXHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IF9hcHBzID0gbmV3IE1hcCgpO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBfc2VydmVyQXBwcyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIFJlZ2lzdGVyZWQgY29tcG9uZW50cy5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5jb25zdCBfY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IGJlaW5nIGFkZGVkIHRvIHRoaXMgYXBwJ3MgY29udGFpbmVyXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhcHAuY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBsb2dnZXIuZGVidWcoYENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmYWlsZWQgdG8gcmVnaXN0ZXIgd2l0aCBGaXJlYmFzZUFwcCAke2FwcC5uYW1lfWAsIGUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xyXG4gICAgYXBwLmNvbnRhaW5lci5hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChjb21wb25lbnQpO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCB0byByZWdpc3RlclxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29tcG9uZW50IGlzIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5XHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX3JlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5uYW1lO1xyXG4gICAgaWYgKF9jb21wb25lbnRzLmhhcyhjb21wb25lbnROYW1lKSkge1xyXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlcmUgd2VyZSBtdWx0aXBsZSBhdHRlbXB0cyB0byByZWdpc3RlciBjb21wb25lbnQgJHtjb21wb25lbnROYW1lfS5gKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfY29tcG9uZW50cy5zZXQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcclxuICAgIC8vIGFkZCB0aGUgY29tcG9uZW50IHRvIGV4aXN0aW5nIGFwcCBpbnN0YW5jZXNcclxuICAgIGZvciAoY29uc3QgYXBwIG9mIF9hcHBzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHNlcnZlckFwcCBvZiBfc2VydmVyQXBwcy52YWx1ZXMoKSkge1xyXG4gICAgICAgIF9hZGRDb21wb25lbnQoc2VydmVyQXBwLCBjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB0aGUgcHJvdmlkZXIgZm9yIHRoZSBzZXJ2aWNlIHdpdGggdGhlIG1hdGNoaW5nIG5hbWVcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKSB7XHJcbiAgICBjb25zdCBoZWFydGJlYXRDb250cm9sbGVyID0gYXBwLmNvbnRhaW5lclxyXG4gICAgICAgIC5nZXRQcm92aWRlcignaGVhcnRiZWF0JylcclxuICAgICAgICAuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICBpZiAoaGVhcnRiZWF0Q29udHJvbGxlcikge1xyXG4gICAgICAgIHZvaWQgaGVhcnRiZWF0Q29udHJvbGxlci50cmlnZ2VySGVhcnRiZWF0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwLmNvbnRhaW5lci5nZXRQcm92aWRlcihuYW1lKTtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlQXBwIGluc3RhbmNlXHJcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXHJcbiAqIEBwYXJhbSBpbnN0YW5jZUlkZW50aWZpZXIgLSBzZXJ2aWNlIGluc3RhbmNlIGlkZW50aWZpZXIgaW4gY2FzZSB0aGUgc2VydmljZSBzdXBwb3J0cyBtdWx0aXBsZSBpbnN0YW5jZXNcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfcmVtb3ZlU2VydmljZUluc3RhbmNlKGFwcCwgbmFtZSwgaW5zdGFuY2VJZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKS5jbGVhckluc3RhbmNlKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmogLSBhbiBvYmplY3Qgb2YgdHlwZSBGaXJlYmFzZUFwcCBvciBGaXJlYmFzZU9wdGlvbnMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGUgb2JqZWN0IGlzIG9mIHR5cGUgRmlyZWJhc2VBcHAuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2lzRmlyZWJhc2VBcHAob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqLm9wdGlvbnMgIT09IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIG9iaiAtIGFuIG9iamVjdCBvZiB0eXBlIEZpcmViYXNlQXBwLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBvYmplY3QgaXMgb2YgdHlwZSBGaXJlYmFzZVNlcnZlckFwcEltcGwuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2lzRmlyZWJhc2VTZXJ2ZXJBcHAob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqLnNldHRpbmdzICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIFRlc3Qgb25seVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9jbGVhckNvbXBvbmVudHMoKSB7XHJcbiAgICBfY29tcG9uZW50cy5jbGVhcigpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IEVSUk9SUyA9IHtcclxuICAgIFtcIm5vLWFwcFwiIC8qIEFwcEVycm9yLk5PX0FQUCAqL106IFwiTm8gRmlyZWJhc2UgQXBwICd7JGFwcE5hbWV9JyBoYXMgYmVlbiBjcmVhdGVkIC0gXCIgK1xyXG4gICAgICAgICdjYWxsIGluaXRpYWxpemVBcHAoKSBmaXJzdCcsXHJcbiAgICBbXCJiYWQtYXBwLW5hbWVcIiAvKiBBcHBFcnJvci5CQURfQVBQX05BTUUgKi9dOiBcIklsbGVnYWwgQXBwIG5hbWU6ICd7JGFwcE5hbWV9J1wiLFxyXG4gICAgW1wiZHVwbGljYXRlLWFwcFwiIC8qIEFwcEVycm9yLkRVUExJQ0FURV9BUFAgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyBvciBjb25maWdcIixcclxuICAgIFtcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBkZWxldGVkXCIsXHJcbiAgICBbXCJzZXJ2ZXItYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5TRVJWRVJfQVBQX0RFTEVURUQgKi9dOiAnRmlyZWJhc2UgU2VydmVyIEFwcCBoYXMgYmVlbiBkZWxldGVkJyxcclxuICAgIFtcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovXTogJ05lZWQgdG8gcHJvdmlkZSBvcHRpb25zLCB3aGVuIG5vdCBiZWluZyBkZXBsb3llZCB0byBob3N0aW5nIHZpYSBzb3VyY2UuJyxcclxuICAgIFtcImludmFsaWQtYXBwLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9BUFBfQVJHVU1FTlQgKi9dOiAnZmlyZWJhc2UueyRhcHBOYW1lfSgpIHRha2VzIGVpdGhlciBubyBhcmd1bWVudCBvciBhICcgK1xyXG4gICAgICAgICdGaXJlYmFzZSBBcHAgaW5zdGFuY2UuJyxcclxuICAgIFtcImludmFsaWQtbG9nLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9MT0dfQVJHVU1FTlQgKi9dOiAnRmlyc3QgYXJndW1lbnQgdG8gYG9uTG9nYCBtdXN0IGJlIG51bGwgb3IgYSBmdW5jdGlvbi4nLFxyXG4gICAgW1wiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqL106ICdFcnJvciB0aHJvd24gd2hlbiBvcGVuaW5nIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXHJcbiAgICBbXCJpZGItZ2V0XCIgLyogQXBwRXJyb3IuSURCX0dFVCAqL106ICdFcnJvciB0aHJvd24gd2hlbiByZWFkaW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcclxuICAgIFtcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gd3JpdGluZyB0byBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiaWRiLWRlbGV0ZVwiIC8qIEFwcEVycm9yLklEQl9ERUxFVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gZGVsZXRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiZmluYWxpemF0aW9uLXJlZ2lzdHJ5LW5vdC1zdXBwb3J0ZWRcIiAvKiBBcHBFcnJvci5GSU5BTElaQVRJT05fUkVHSVNUUllfTk9UX1NVUFBPUlRFRCAqL106ICdGaXJlYmFzZVNlcnZlckFwcCBkZWxldGVPbkRlcmVmIGZpZWxkIGRlZmluZWQgYnV0IHRoZSBKUyBydW50aW1lIGRvZXMgbm90IHN1cHBvcnQgRmluYWxpemF0aW9uUmVnaXN0cnkuJyxcclxuICAgIFtcImludmFsaWQtc2VydmVyLWFwcC1lbnZpcm9ubWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfU0VSVkVSX0FQUF9FTlZJUk9OTUVOVCAqL106ICdGaXJlYmFzZVNlcnZlckFwcCBpcyBub3QgZm9yIHVzZSBpbiBicm93c2VyIGVudmlyb25tZW50cy4nXHJcbn07XHJcbmNvbnN0IEVSUk9SX0ZBQ1RPUlkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhcHAnLCAnRmlyZWJhc2UnLCBFUlJPUlMpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZUFwcEltcGwge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcclxuICAgICAgICB0aGlzLl9uYW1lID0gY29uZmlnLm5hbWU7XHJcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID1cclxuICAgICAgICAgICAgY29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FwcCcsICgpID0+IHRoaXMsIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pKTtcclxuICAgIH1cclxuICAgIGdldCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICBzZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKHZhbCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgbmFtZSgpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBnZXQgY29uZmlnKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRGVsZXRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEZWxldGVkO1xyXG4gICAgfVxyXG4gICAgc2V0IGlzRGVsZXRlZCh2YWwpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvciBpZiB0aGUgQXBwIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZCAtXHJcbiAgICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cclxuICAgICAqL1xyXG4gICAgY2hlY2tEZXN0cm95ZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5BUFBfREVMRVRFRCAqLywgeyBhcHBOYW1lOiB0aGlzLl9uYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZVNlcnZlckFwcEltcGwgZXh0ZW5kcyBGaXJlYmFzZUFwcEltcGwge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgc2VydmVyQ29uZmlnLCBuYW1lLCBjb250YWluZXIpIHtcclxuICAgICAgICAvLyBCdWlsZCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgZm9yIHRoZSBGaXJlYmFzZUFwcEltcGwgYmFzZSBjbGFzcy5cclxuICAgICAgICBjb25zdCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSBzZXJ2ZXJDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBzZXJ2ZXJDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXHJcbiAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBGaXJlYmFzZUFwcFNldHRpbmdzIG9iamVjdCBmb3IgdGhlIEZpcmViYXNlQXBwSW1wIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0aW9ucy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIHBhcmVudCBGaXJlYmFzZUFwcEltcCBvYmplY3QuXHJcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFwcEltcGwgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICBzdXBlcihhcHBJbXBsLm9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93IGNvbnN0cnVjdCB0aGUgZGF0YSBmb3IgdGhlIEZpcmViYXNlU2VydmVyQXBwSW1wbC5cclxuICAgICAgICB0aGlzLl9zZXJ2ZXJDb25maWcgPSBPYmplY3QuYXNzaWduKHsgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkIH0sIHNlcnZlckNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9tYXRpY0NsZWFudXAoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9yZWZDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5pbmNSZWZDb3VudCh0aGlzLl9zZXJ2ZXJDb25maWcucmVsZWFzZU9uRGVyZWYpO1xyXG4gICAgICAgIC8vIERvIG5vdCByZXRhaW4gYSBoYXJkIHJlZmVyZW5jZSB0byB0aGUgZHJlZiBvYmplY3QsIG90aGVyd2lzZSB0aGUgRmluYWxpemF0aW9uUmVnaXNyeVxyXG4gICAgICAgIC8vIHdpbGwgbmV2ZXIgdHJpZ2dlci5cclxuICAgICAgICB0aGlzLl9zZXJ2ZXJDb25maWcucmVsZWFzZU9uRGVyZWYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJG8sIHZlcnNpb24kMSwgJ3NlcnZlcmFwcCcpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBnZXQgcmVmQ291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZkNvdW50O1xyXG4gICAgfVxyXG4gICAgLy8gSW5jcmVtZW50IHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBzZXJ2ZXIgYXBwLiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQsIHJlZ2lzdGVyIGl0XHJcbiAgICAvLyB3aXRoIHRoZSBmaW5hbGl6YXRpb24gcmVnaXN0cnkuXHJcbiAgICBpbmNSZWZDb3VudChvYmopIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZWZDb3VudCsrO1xyXG4gICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeS5yZWdpc3RlcihvYmosIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIERlY3JlbWVudCB0aGUgcmVmZXJlbmNlIGNvdW50LlxyXG4gICAgZGVjUmVmQ291bnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLS10aGlzLl9yZWZDb3VudDtcclxuICAgIH1cclxuICAgIC8vIEludm9rZWQgYnkgdGhlIEZpbmFsaXphdGlvblJlZ2lzdHJ5IGNhbGxiYWNrIHRvIG5vdGUgdGhhdCB0aGlzIGFwcCBzaG91bGQgZ28gdGhyb3VnaCBpdHNcclxuICAgIC8vIHJlZmVyZW5jZSBjb3VudHMgYW5kIGRlbGV0ZSBpdHNlbGYgaWYgbm8gcmVmZXJlbmNlIGNvdW50IHJlbWFpbi4gVGhlIGNvb3JkaW5hdGluZyBsb2dpYyB0aGF0XHJcbiAgICAvLyBoYW5kbGVzIHRoaXMgaXMgaW4gZGVsZXRlQXBwKC4uLikuXHJcbiAgICBhdXRvbWF0aWNDbGVhbnVwKCkge1xyXG4gICAgICAgIHZvaWQgZGVsZXRlQXBwKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNldHRpbmdzKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVyQ29uZmlnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxyXG4gICAgICogdXNlIGJlZm9yZSBwZXJmb3JtaW5nIEFQSSBhY3Rpb25zIG9uIHRoZSBBcHAuXHJcbiAgICAgKi9cclxuICAgIGNoZWNrRGVzdHJveWVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInNlcnZlci1hcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLlNFUlZFUl9BUFBfREVMRVRFRCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgY3VycmVudCBTREsgdmVyc2lvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xyXG5mdW5jdGlvbiBpbml0aWFsaXplQXBwKF9vcHRpb25zLCByYXdDb25maWcgPSB7fSkge1xyXG4gICAgbGV0IG9wdGlvbnMgPSBfb3B0aW9ucztcclxuICAgIGlmICh0eXBlb2YgcmF3Q29uZmlnICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSByYXdDb25maWc7XHJcbiAgICAgICAgcmF3Q29uZmlnID0geyBuYW1lIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHsgbmFtZTogREVGQVVMVF9FTlRSWV9OQU1FLCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ6IGZhbHNlIH0sIHJhd0NvbmZpZyk7XHJcbiAgICBjb25zdCBuYW1lID0gY29uZmlnLm5hbWU7XHJcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8ICFuYW1lKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJiYWQtYXBwLW5hbWVcIiAvKiBBcHBFcnJvci5CQURfQVBQX05BTUUgKi8sIHtcclxuICAgICAgICAgICAgYXBwTmFtZTogU3RyaW5nKG5hbWUpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0gZ2V0RGVmYXVsdEFwcENvbmZpZygpKTtcclxuICAgIGlmICghb3B0aW9ucykge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tb3B0aW9uc1wiIC8qIEFwcEVycm9yLk5PX09QVElPTlMgKi8pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXhpc3RpbmdBcHAgPSBfYXBwcy5nZXQobmFtZSk7XHJcbiAgICBpZiAoZXhpc3RpbmdBcHApIHtcclxuICAgICAgICAvLyByZXR1cm4gdGhlIGV4aXN0aW5nIGFwcCBpZiBvcHRpb25zIGFuZCBjb25maWcgZGVlcCBlcXVhbCB0aGUgb25lcyBpbiB0aGUgZXhpc3RpbmcgYXBwLlxyXG4gICAgICAgIGlmIChkZWVwRXF1YWwob3B0aW9ucywgZXhpc3RpbmdBcHAub3B0aW9ucykgJiZcclxuICAgICAgICAgICAgZGVlcEVxdWFsKGNvbmZpZywgZXhpc3RpbmdBcHAuY29uZmlnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImR1cGxpY2F0ZS1hcHBcIiAvKiBBcHBFcnJvci5EVVBMSUNBVEVfQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbXBvbmVudENvbnRhaW5lcihuYW1lKTtcclxuICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIF9jb21wb25lbnRzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3QXBwID0gbmV3IEZpcmViYXNlQXBwSW1wbChvcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XHJcbiAgICBfYXBwcy5zZXQobmFtZSwgbmV3QXBwKTtcclxuICAgIHJldHVybiBuZXdBcHA7XHJcbn1cclxuZnVuY3Rpb24gaW5pdGlhbGl6ZVNlcnZlckFwcChfb3B0aW9ucywgX3NlcnZlckFwcENvbmZpZykge1xyXG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XHJcbiAgICAgICAgLy8gRmlyZWJhc2VTZXJ2ZXJBcHAgaXNuJ3QgZGVzaWduZWQgdG8gYmUgcnVuIGluIGJyb3dzZXJzLlxyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1zZXJ2ZXItYXBwLWVudmlyb25tZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9TRVJWRVJfQVBQX0VOVklST05NRU5UICovKTtcclxuICAgIH1cclxuICAgIGlmIChfc2VydmVyQXBwQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgX3NlcnZlckFwcENvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGxldCBhcHBPcHRpb25zO1xyXG4gICAgaWYgKF9pc0ZpcmViYXNlQXBwKF9vcHRpb25zKSkge1xyXG4gICAgICAgIGFwcE9wdGlvbnMgPSBfb3B0aW9ucy5vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXBwT3B0aW9ucyA9IF9vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgLy8gQnVpbGQgYW4gYXBwIG5hbWUgYmFzZWQgb24gYSBoYXNoIG9mIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICBjb25zdCBuYW1lT2JqID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfc2VydmVyQXBwQ29uZmlnKSwgYXBwT3B0aW9ucyk7XHJcbiAgICAvLyBIb3dldmVyLCBEbyBub3QgbWFuZ2xlIHRoZSBuYW1lIGJhc2VkIG9uIHJlbGVhc2VPbkRlcmVmLCBzaW5jZSBpdCB3aWxsIHZhcnkgYmV0d2VlbiB0aGVcclxuICAgIC8vIGNvbnN0cnVjdGlvbiBvZiBGaXJlYmFzZVNlcnZlckFwcCBpbnN0YW5jZXMuIEZvciBleGFtcGxlLCBpZiB0aGUgb2JqZWN0IGlzIHRoZSByZXF1ZXN0IGhlYWRlcnMuXHJcbiAgICBpZiAobmFtZU9iai5yZWxlYXNlT25EZXJlZiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZGVsZXRlIG5hbWVPYmoucmVsZWFzZU9uRGVyZWY7XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYXNoQ29kZSA9IChzKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi5zXS5yZWR1Y2UoKGhhc2gsIGMpID0+IChNYXRoLmltdWwoMzEsIGhhc2gpICsgYy5jaGFyQ29kZUF0KDApKSB8IDAsIDApO1xyXG4gICAgfTtcclxuICAgIGlmIChfc2VydmVyQXBwQ29uZmlnLnJlbGVhc2VPbkRlcmVmICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImZpbmFsaXphdGlvbi1yZWdpc3RyeS1ub3Qtc3VwcG9ydGVkXCIgLyogQXBwRXJyb3IuRklOQUxJWkFUSU9OX1JFR0lTVFJZX05PVF9TVVBQT1JURUQgKi8sIHt9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBuYW1lU3RyaW5nID0gJycgKyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShuYW1lT2JqKSk7XHJcbiAgICBjb25zdCBleGlzdGluZ0FwcCA9IF9zZXJ2ZXJBcHBzLmdldChuYW1lU3RyaW5nKTtcclxuICAgIGlmIChleGlzdGluZ0FwcCkge1xyXG4gICAgICAgIGV4aXN0aW5nQXBwLmluY1JlZkNvdW50KF9zZXJ2ZXJBcHBDb25maWcucmVsZWFzZU9uRGVyZWYpO1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ0FwcDtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIobmFtZVN0cmluZyk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZVNlcnZlckFwcEltcGwoYXBwT3B0aW9ucywgX3NlcnZlckFwcENvbmZpZywgbmFtZVN0cmluZywgY29udGFpbmVyKTtcclxuICAgIF9zZXJ2ZXJBcHBzLnNldChuYW1lU3RyaW5nLCBuZXdBcHApO1xyXG4gICAgcmV0dXJuIG5ld0FwcDtcclxufVxyXG4vKipcclxuICogUmV0cmlldmVzIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgdGhlIGRlZmF1bHQgYXBwIGlzIHJldHVybmVkLiBXaGVuIGFuIGFwcCBuYW1lXHJcbiAqIGlzIHByb3ZpZGVkLCB0aGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhhdCBuYW1lIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBBbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoZSBhcHAgYmVpbmcgcmV0cmlldmVkIGhhcyBub3QgeWV0IGJlZW5cclxuICogaW5pdGlhbGl6ZWQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gUmV0dXJuIHRoZSBkZWZhdWx0IGFwcFxyXG4gKiBjb25zdCBhcHAgPSBnZXRBcHAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gUmV0dXJuIGEgbmFtZWQgYXBwXHJcbiAqIGNvbnN0IG90aGVyQXBwID0gZ2V0QXBwKFwib3RoZXJBcHBcIik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSAtIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGFwcCB0byByZXR1cm4uIElmIG5vIG5hbWUgaXNcclxuICogICBwcm92aWRlZCwgdGhlIGRlZmF1bHQgaXMgYFwiW0RFRkFVTFRdXCJgLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIGFwcCBuYW1lLlxyXG4gKiAgIElmIG5vIGFwcCBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBhcHAgaXMgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEFwcChuYW1lID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICBjb25zdCBhcHAgPSBfYXBwcy5nZXQobmFtZSk7XHJcbiAgICBpZiAoIWFwcCAmJiBuYW1lID09PSBERUZBVUxUX0VOVFJZX05BTUUgJiYgZ2V0RGVmYXVsdEFwcENvbmZpZygpKSB7XHJcbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemVBcHAoKTtcclxuICAgIH1cclxuICAgIGlmICghYXBwKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1hcHBcIiAvKiBBcHBFcnJvci5OT19BUFAgKi8sIHsgYXBwTmFtZTogbmFtZSB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcHA7XHJcbn1cclxuLyoqXHJcbiAqIEEgKHJlYWQtb25seSkgYXJyYXkgb2YgYWxsIGluaXRpYWxpemVkIGFwcHMuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEFwcHMoKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShfYXBwcy52YWx1ZXMoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhpcyBhcHAgdW51c2FibGUgYW5kIGZyZWVzIHRoZSByZXNvdXJjZXMgb2YgYWxsIGFzc29jaWF0ZWRcclxuICogc2VydmljZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogZGVsZXRlQXBwKGFwcClcclxuICogICAudGhlbihmdW5jdGlvbigpIHtcclxuICogICAgIGNvbnNvbGUubG9nKFwiQXBwIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xyXG4gKiAgIH0pXHJcbiAqICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGRlbGV0aW5nIGFwcDpcIiwgZXJyb3IpO1xyXG4gKiAgIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlQXBwKGFwcCkge1xyXG4gICAgbGV0IGNsZWFudXBQcm92aWRlcnMgPSBmYWxzZTtcclxuICAgIGNvbnN0IG5hbWUgPSBhcHAubmFtZTtcclxuICAgIGlmIChfYXBwcy5oYXMobmFtZSkpIHtcclxuICAgICAgICBjbGVhbnVwUHJvdmlkZXJzID0gdHJ1ZTtcclxuICAgICAgICBfYXBwcy5kZWxldGUobmFtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfc2VydmVyQXBwcy5oYXMobmFtZSkpIHtcclxuICAgICAgICBjb25zdCBmaXJlYmFzZVNlcnZlckFwcCA9IGFwcDtcclxuICAgICAgICBpZiAoZmlyZWJhc2VTZXJ2ZXJBcHAuZGVjUmVmQ291bnQoKSA8PSAwKSB7XHJcbiAgICAgICAgICAgIF9zZXJ2ZXJBcHBzLmRlbGV0ZShuYW1lKTtcclxuICAgICAgICAgICAgY2xlYW51cFByb3ZpZGVycyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGNsZWFudXBQcm92aWRlcnMpIHtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChhcHAuY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcnMoKVxyXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyLmRlbGV0ZSgpKSk7XHJcbiAgICAgICAgYXBwLmlzRGVsZXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhIGxpYnJhcnkncyBuYW1lIGFuZCB2ZXJzaW9uIGZvciBwbGF0Zm9ybSBsb2dnaW5nIHB1cnBvc2VzLlxyXG4gKiBAcGFyYW0gbGlicmFyeSAtIE5hbWUgb2YgMXAgb3IgM3AgbGlicmFyeSAoZS5nLiBmaXJlc3RvcmUsIGFuZ3VsYXJmaXJlKVxyXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGF0IGxpYnJhcnkuXHJcbiAqIEBwYXJhbSB2YXJpYW50IC0gQnVuZGxlIHZhcmlhbnQsIGUuZy4sIG5vZGUsIHJuLCBldGMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyVmVyc2lvbihsaWJyYXJ5S2V5T3JOYW1lLCB2ZXJzaW9uLCB2YXJpYW50KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICAvLyBUT0RPOiBXZSBjYW4gdXNlIHRoaXMgY2hlY2sgdG8gd2hpdGVsaXN0IHN0cmluZ3Mgd2hlbi9pZiB3ZSBzZXQgdXBcclxuICAgIC8vIGEgZ29vZCB3aGl0ZWxpc3Qgc3lzdGVtLlxyXG4gICAgbGV0IGxpYnJhcnkgPSAoX2EgPSBQTEFURk9STV9MT0dfU1RSSU5HW2xpYnJhcnlLZXlPck5hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBsaWJyYXJ5S2V5T3JOYW1lO1xyXG4gICAgaWYgKHZhcmlhbnQpIHtcclxuICAgICAgICBsaWJyYXJ5ICs9IGAtJHt2YXJpYW50fWA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsaWJyYXJ5TWlzbWF0Y2ggPSBsaWJyYXJ5Lm1hdGNoKC9cXHN8XFwvLyk7XHJcbiAgICBjb25zdCB2ZXJzaW9uTWlzbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKC9cXHN8XFwvLyk7XHJcbiAgICBpZiAobGlicmFyeU1pc21hdGNoIHx8IHZlcnNpb25NaXNtYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IHdhcm5pbmcgPSBbXHJcbiAgICAgICAgICAgIGBVbmFibGUgdG8gcmVnaXN0ZXIgbGlicmFyeSBcIiR7bGlicmFyeX1cIiB3aXRoIHZlcnNpb24gXCIke3ZlcnNpb259XCI6YFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKGxpYnJhcnlNaXNtYXRjaCkge1xyXG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goYGxpYnJhcnkgbmFtZSBcIiR7bGlicmFyeX1cIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgKHdoaXRlc3BhY2Ugb3IgXCIvXCIpYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2ggJiYgdmVyc2lvbk1pc21hdGNoKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaCgnYW5kJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ZXJzaW9uTWlzbWF0Y2gpIHtcclxuICAgICAgICAgICAgd2FybmluZy5wdXNoKGB2ZXJzaW9uIG5hbWUgXCIke3ZlcnNpb259XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2dnZXIud2Fybih3YXJuaW5nLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoYCR7bGlicmFyeX0tdmVyc2lvbmAsICgpID0+ICh7IGxpYnJhcnksIHZlcnNpb24gfSksIFwiVkVSU0lPTlwiIC8qIENvbXBvbmVudFR5cGUuVkVSU0lPTiAqLykpO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIGxvZyBoYW5kbGVyIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cclxuICogQHBhcmFtIGxvZ0NhbGxiYWNrIC0gQW4gb3B0aW9uYWwgY3VzdG9tIGxvZyBoYW5kbGVyIHRoYXQgZXhlY3V0ZXMgdXNlciBjb2RlIHdoZW5ldmVyXHJcbiAqIHRoZSBGaXJlYmFzZSBTREsgbWFrZXMgYSBsb2dnaW5nIGNhbGwuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIG9uTG9nKGxvZ0NhbGxiYWNrLCBvcHRpb25zKSB7XHJcbiAgICBpZiAobG9nQ2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGxvZ0NhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnZhbGlkLWxvZy1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfTE9HX0FSR1VNRU5UICovKTtcclxuICAgIH1cclxuICAgIHNldFVzZXJMb2dIYW5kbGVyKGxvZ0NhbGxiYWNrLCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogU2V0cyBsb2cgbGV2ZWwgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxyXG4gKlxyXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgYXJlIGNhcHR1cmVkIChpLmUuIGlmXHJcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgaW5mb2AsIGVycm9ycyBhcmUgbG9nZ2VkLCBidXQgYGRlYnVnYCBhbmRcclxuICogYHZlcmJvc2VgIGxvZ3MgYXJlIG5vdCkuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XHJcbiAgICBzZXRMb2dMZXZlbCQxKGxvZ0xldmVsKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBEQl9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1kYXRhYmFzZSc7XHJcbmNvbnN0IERCX1ZFUlNJT04gPSAxO1xyXG5jb25zdCBTVE9SRV9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1zdG9yZSc7XHJcbmxldCBkYlByb21pc2UgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXREYlByb21pc2UoKSB7XHJcbiAgICBpZiAoIWRiUHJvbWlzZSkge1xyXG4gICAgICAgIGRiUHJvbWlzZSA9IG9wZW5EQihEQl9OQU1FLCBEQl9WRVJTSU9OLCB7XHJcbiAgICAgICAgICAgIHVwZ3JhZGU6IChkYiwgb2xkVmVyc2lvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlICdicmVhaycgaW4gdGhpcyBzd2l0Y2ggc3RhdGVtZW50LCB0aGUgZmFsbC10aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAvLyBiZWhhdmlvciBpcyB3aGF0IHdlIHdhbnQsIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHZlcnNpb25zIGJldHdlZW5cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBvbGQgdmVyc2lvbiBhbmQgdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2Ugd2FudCBBTEwgdGhlIG1pZ3JhdGlvbnNcclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY29ycmVzcG9uZCB0byB0aG9zZSB2ZXJzaW9ucyB0byBydW4sIG5vdCBvbmx5IHRoZSBsYXN0IG9uZS5cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob2xkVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkvaU9TIGJyb3dzZXJzIHRocm93IG9jY2FzaW9uYWwgZXhjZXB0aW9ucyBvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGIuY3JlYXRlT2JqZWN0U3RvcmUoKSB0aGF0IG1heSBiZSBhIGJ1Zy4gQXZvaWQgYmxvY2tpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXN0IG9mIHRoZSBhcHAgZnVuY3Rpb25hbGl0eS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqLywge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYlByb21pc2U7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKGFwcCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdHgub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSkuZ2V0KGNvbXB1dGVLZXkoYXBwKSk7XHJcbiAgICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIHRoZSB2YWx1ZSBidXQgdHguZG9uZSBjYW4gdGhyb3csXHJcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBhd2FpdCBpdCBoZXJlIHRvIGNhdGNoIGVycm9yc1xyXG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKGFwcCwgaGVhcnRiZWF0T2JqZWN0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICAgICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcclxuICAgICAgICBhd2FpdCBvYmplY3RTdG9yZS5wdXQoaGVhcnRiZWF0T2JqZWN0LCBjb21wdXRlS2V5KGFwcCkpO1xyXG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihlLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaWRiR2V0RXJyb3IgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVLZXkoYXBwKSB7XHJcbiAgICByZXR1cm4gYCR7YXBwLm5hbWV9ISR7YXBwLm9wdGlvbnMuYXBwSWR9YDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBNQVhfSEVBREVSX0JZVEVTID0gMTAyNDtcclxuLy8gMzAgZGF5c1xyXG5jb25zdCBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTID0gMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xyXG5jbGFzcyBIZWFydGJlYXRTZXJ2aWNlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbi1tZW1vcnkgY2FjaGUgZm9yIGhlYXJ0YmVhdHMsIHVzZWQgYnkgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHRvIGdlbmVyYXRlXHJcbiAgICAgICAgICogdGhlIGhlYWRlciBzdHJpbmcuXHJcbiAgICAgICAgICogU3RvcmVzIG9uZSByZWNvcmQgcGVyIGRhdGUuIFRoaXMgd2lsbCBiZSBjb25zb2xpZGF0ZWQgaW50byB0aGUgc3RhbmRhcmRcclxuICAgICAgICAgKiBmb3JtYXQgb2Ygb25lIHJlY29yZCBwZXIgdXNlciBhZ2VudCBzdHJpbmcgYmVmb3JlIGJlaW5nIHNlbnQgYXMgYSBoZWFkZXIuXHJcbiAgICAgICAgICogUG9wdWxhdGVkIGZyb20gaW5kZXhlZERCIHdoZW4gdGhlIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkIGFuZCBzaG91bGRcclxuICAgICAgICAgKiBiZSBrZXB0IGluIHN5bmMgd2l0aCBpbmRleGVkREIuXHJcbiAgICAgICAgICogTGVhdmUgcHVibGljIGZvciBlYXNpZXIgdGVzdGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICB0aGlzLl9zdG9yYWdlID0gbmV3IEhlYXJ0YmVhdFN0b3JhZ2VJbXBsKGFwcCk7XHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZSA9IHRoaXMuX3N0b3JhZ2UucmVhZCgpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gcmVzdWx0O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgdG8gcmVwb3J0IGEgaGVhcnRiZWF0LiBUaGUgZnVuY3Rpb24gd2lsbCBnZW5lcmF0ZVxyXG4gICAgICogYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgb2JqZWN0LCB1cGRhdGUgaGVhcnRiZWF0c0NhY2hlLCBhbmQgcGVyc2lzdCBpdFxyXG4gICAgICogdG8gSW5kZXhlZERCLlxyXG4gICAgICogTm90ZSB0aGF0IHdlIG9ubHkgc3RvcmUgb25lIGhlYXJ0YmVhdCBwZXIgZGF5LiBTbyBpZiBhIGhlYXJ0YmVhdCBmb3IgdG9kYXkgaXNcclxuICAgICAqIGFscmVhZHkgbG9nZ2VkLCBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgZnVuY3Rpb24gaW4gdGhlIHNhbWUgZGF5IHdpbGwgYmUgaWdub3JlZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgdHJpZ2dlckhlYXJ0YmVhdCgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHBsYXRmb3JtTG9nZ2VyID0gdGhpcy5jb250YWluZXJcclxuICAgICAgICAgICAgLmdldFByb3ZpZGVyKCdwbGF0Zm9ybS1sb2dnZXInKVxyXG4gICAgICAgICAgICAuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgXCJGaXJlYmFzZSB1c2VyIGFnZW50XCIgc3RyaW5nIGZyb20gdGhlIHBsYXRmb3JtIGxvZ2dlclxyXG4gICAgICAgIC8vIHNlcnZpY2UsIG5vdCB0aGUgYnJvd3NlciB1c2VyIGFnZW50LlxyXG4gICAgICAgIGNvbnN0IGFnZW50ID0gcGxhdGZvcm1Mb2dnZXIuZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcclxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYXJ0YmVhdHMpID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcclxuICAgICAgICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGNvbnN0cnVjdCBhIGhlYXJ0YmVhdHMgY2FjaGUsIHRoZW4gcmV0dXJuIGltbWVkaWF0ZWx5LlxyXG4gICAgICAgICAgICBpZiAoKChfYiA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlYXJ0YmVhdHMpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBub3Qgc3RvcmUgYSBoZWFydGJlYXQgaWYgb25lIGlzIGFscmVhZHkgc3RvcmVkIGZvciB0aGlzIGRheVxyXG4gICAgICAgIC8vIG9yIGlmIGEgaGVhZGVyIGhhcyBhbHJlYWR5IGJlZW4gc2VudCB0b2RheS5cclxuICAgICAgICBpZiAodGhpcy5faGVhcnRiZWF0c0NhY2hlLmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA9PT0gZGF0ZSB8fFxyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5zb21lKHNpbmdsZURhdGVIZWFydGJlYXQgPT4gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlID09PSBkYXRlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBlbnRyeSBmb3IgdGhpcyBkYXRlLiBDcmVhdGUgb25lLlxyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5wdXNoKHsgZGF0ZSwgYWdlbnQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBlbnRyaWVzIG9sZGVyIHRoYW4gMzAgZGF5cy5cclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLmZpbHRlcihzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaGJUaW1lc3RhbXAgPSBuZXcgRGF0ZShzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vdyAtIGhiVGltZXN0YW1wIDw9IFNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgd2hpY2ggY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBoZWFydGJlYXQtc3BlY2lmaWMgaGVhZGVyIGRpcmVjdGx5LlxyXG4gICAgICogSXQgYWxzbyBjbGVhcnMgYWxsIGhlYXJ0YmVhdHMgZnJvbSBtZW1vcnkgYXMgd2VsbCBhcyBpbiBJbmRleGVkREIuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogQ29uc3VtaW5nIHByb2R1Y3QgU0RLcyBzaG91bGQgbm90IHNlbmQgdGhlIGhlYWRlciBpZiB0aGlzIG1ldGhvZFxyXG4gICAgICogcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEhlYXJ0YmVhdHNIZWFkZXIoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgaXQncyBzdGlsbCBudWxsIG9yIHRoZSBhcnJheSBpcyBlbXB0eSwgdGhlcmUgaXMgbm8gZGF0YSB0byBzZW5kLlxyXG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhcnRiZWF0cykgPT0gbnVsbCB8fFxyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xyXG4gICAgICAgIC8vIEV4dHJhY3QgYXMgbWFueSBoZWFydGJlYXRzIGZyb20gdGhlIGNhY2hlIGFzIHdpbGwgZml0IHVuZGVyIHRoZSBzaXplIGxpbWl0LlxyXG4gICAgICAgIGNvbnN0IHsgaGVhcnRiZWF0c1RvU2VuZCwgdW5zZW50RW50cmllcyB9ID0gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIodGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMpO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlclN0cmluZyA9IGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c1RvU2VuZCB9KSk7XHJcbiAgICAgICAgLy8gU3RvcmUgbGFzdCBzZW50IGRhdGUgdG8gcHJldmVudCBhbm90aGVyIGJlaW5nIGxvZ2dlZC9zZW50IGZvciB0aGUgc2FtZSBkYXkuXHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA9IGRhdGU7XHJcbiAgICAgICAgaWYgKHVuc2VudEVudHJpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBTdG9yZSBhbnkgdW5zZW50IGVudHJpZXMgaWYgdGhleSBleGlzdC5cclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSB1bnNlbnRFbnRyaWVzO1xyXG4gICAgICAgICAgICAvLyBUaGlzIHNlZW1zIG1vcmUgbGlrZWx5IHRoYW4gZW1wdHlpbmcgdGhlIGFycmF5IChiZWxvdykgdG8gbGVhZCB0byBzb21lIG9kZCBzdGF0ZVxyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgY2FjaGUgaXNuJ3QgZW1wdHkgYW5kIHRoaXMgd2lsbCBiZSBjYWxsZWQgYWdhaW4gb24gdGhlIG5leHQgcmVxdWVzdCxcclxuICAgICAgICAgICAgLy8gYW5kIGlzIHByb2JhYmx5IHNhZmVzdCBpZiB3ZSBhd2FpdCBpdC5cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gW107XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCB3YWl0IGZvciB0aGlzLCB0byByZWR1Y2UgbGF0ZW5jeS5cclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGVhZGVyU3RyaW5nO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFVUQ0RhdGVTdHJpbmcoKSB7XHJcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XHJcbiAgICAvLyBSZXR1cm5zIGRhdGUgZm9ybWF0ICdZWVlZLU1NLUREJ1xyXG4gICAgcmV0dXJuIHRvZGF5LnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDEwKTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0SGVhcnRiZWF0c0ZvckhlYWRlcihoZWFydGJlYXRzQ2FjaGUsIG1heFNpemUgPSBNQVhfSEVBREVSX0JZVEVTKSB7XHJcbiAgICAvLyBIZWFydGJlYXRzIGdyb3VwZWQgYnkgdXNlciBhZ2VudCBpbiB0aGUgc3RhbmRhcmQgZm9ybWF0IHRvIGJlIHNlbnQgaW5cclxuICAgIC8vIHRoZSBoZWFkZXIuXHJcbiAgICBjb25zdCBoZWFydGJlYXRzVG9TZW5kID0gW107XHJcbiAgICAvLyBTaW5nbGUgZGF0ZSBmb3JtYXQgaGVhcnRiZWF0cyB0aGF0IGFyZSBub3Qgc2VudC5cclxuICAgIGxldCB1bnNlbnRFbnRyaWVzID0gaGVhcnRiZWF0c0NhY2hlLnNsaWNlKCk7XHJcbiAgICBmb3IgKGNvbnN0IHNpbmdsZURhdGVIZWFydGJlYXQgb2YgaGVhcnRiZWF0c0NhY2hlKSB7XHJcbiAgICAgICAgLy8gTG9vayBmb3IgYW4gZXhpc3RpbmcgZW50cnkgd2l0aCB0aGUgc2FtZSB1c2VyIGFnZW50LlxyXG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdEVudHJ5ID0gaGVhcnRiZWF0c1RvU2VuZC5maW5kKGhiID0+IGhiLmFnZW50ID09PSBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50KTtcclxuICAgICAgICBpZiAoIWhlYXJ0YmVhdEVudHJ5KSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGVudHJ5IGZvciB0aGlzIHVzZXIgYWdlbnQgZXhpc3RzLCBjcmVhdGUgb25lLlxyXG4gICAgICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYWdlbnQ6IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnQsXHJcbiAgICAgICAgICAgICAgICBkYXRlczogW3NpbmdsZURhdGVIZWFydGJlYXQuZGF0ZV1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChjb3VudEJ5dGVzKGhlYXJ0YmVhdHNUb1NlbmQpID4gbWF4U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgaGVhcnRiZWF0XHJcbiAgICAgICAgICAgICAgICAvLyBlbnRyeSBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucHVzaChzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHdvdWxkIGV4Y2VlZCBtYXggc2l6ZSwgcmVtb3ZlIHRoZSBhZGRlZCBkYXRlXHJcbiAgICAgICAgICAgIC8vIGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxyXG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUG9wIHVuc2VudCBlbnRyeSBmcm9tIHF1ZXVlLiAoU2tpcHBlZCBpZiBhZGRpbmcgdGhlIGVudHJ5IGV4Y2VlZGVkXHJcbiAgICAgICAgLy8gcXVvdGEgYW5kIHRoZSBsb29wIGJyZWFrcyBlYXJseS4pXHJcbiAgICAgICAgdW5zZW50RW50cmllcyA9IHVuc2VudEVudHJpZXMuc2xpY2UoMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQsXHJcbiAgICAgICAgdW5zZW50RW50cmllc1xyXG4gICAgfTtcclxufVxyXG5jbGFzcyBIZWFydGJlYXRTdG9yYWdlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHApIHtcclxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgICAgICB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlID0gdGhpcy5ydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCkge1xyXG4gICAgICAgIGlmICghaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0cnVlKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYWxsIGhlYXJ0YmVhdHMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYWQoKSB7XHJcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xyXG4gICAgICAgICAgICByZXR1cm4geyBoZWFydGJlYXRzOiBbXSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaWRiSGVhcnRiZWF0T2JqZWN0ID0gYXdhaXQgcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKHRoaXMuYXBwKTtcclxuICAgICAgICAgICAgaWYgKGlkYkhlYXJ0YmVhdE9iamVjdCA9PT0gbnVsbCB8fCBpZGJIZWFydGJlYXRPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkYkhlYXJ0YmVhdE9iamVjdC5oZWFydGJlYXRzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRiSGVhcnRiZWF0T2JqZWN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaGVhcnRiZWF0czogW10gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG92ZXJ3cml0ZSB0aGUgc3RvcmFnZSB3aXRoIHRoZSBwcm92aWRlZCBoZWFydGJlYXRzXHJcbiAgICBhc3luYyBvdmVyd3JpdGUoaGVhcnRiZWF0c09iamVjdCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xyXG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIodGhpcy5hcHAsIHtcclxuICAgICAgICAgICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTogKF9hID0gaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzOiBoZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gYWRkIGhlYXJ0YmVhdHNcclxuICAgIGFzeW5jIGFkZChoZWFydGJlYXRzT2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0ID0gYXdhaXQgdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xyXG4gICAgICAgICAgICAgICAgbGFzdFNlbnRIZWFydGJlYXREYXRlOiAoX2EgPSBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSxcclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHM6IFtcclxuICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0cyxcclxuICAgICAgICAgICAgICAgICAgICAuLi5oZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgYnl0ZXMgb2YgYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgYXJyYXkgYWZ0ZXIgYmVpbmcgd3JhcHBlZFxyXG4gKiBpbiBhIHBsYXRmb3JtIGxvZ2dpbmcgaGVhZGVyIEpTT04gb2JqZWN0LCBzdHJpbmdpZmllZCwgYW5kIGNvbnZlcnRlZFxyXG4gKiB0byBiYXNlIDY0LlxyXG4gKi9cclxuZnVuY3Rpb24gY291bnRCeXRlcyhoZWFydGJlYXRzQ2FjaGUpIHtcclxuICAgIC8vIGJhc2U2NCBoYXMgYSByZXN0cmljdGVkIHNldCBvZiBjaGFyYWN0ZXJzLCBhbGwgb2Ygd2hpY2ggc2hvdWxkIGJlIDEgYnl0ZS5cclxuICAgIHJldHVybiBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhcclxuICAgIC8vIGhlYXJ0YmVhdHNDYWNoZSB3cmFwcGVyIHByb3BlcnRpZXNcclxuICAgIEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c0NhY2hlIH0pKS5sZW5ndGg7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJDb3JlQ29tcG9uZW50cyh2YXJpYW50KSB7XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgncGxhdGZvcm0tbG9nZ2VyJywgY29udGFpbmVyID0+IG5ldyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsKGNvbnRhaW5lciksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2hlYXJ0YmVhdCcsIGNvbnRhaW5lciA9PiBuZXcgSGVhcnRiZWF0U2VydmljZUltcGwoY29udGFpbmVyKSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XHJcbiAgICAvLyBSZWdpc3RlciBgYXBwYCBwYWNrYWdlLlxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUkbywgdmVyc2lvbiQxLCB2YXJpYW50KTtcclxuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTUsIGVzbTIwMTcsIGNqczUsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSRvLCB2ZXJzaW9uJDEsICdlc20yMDE3Jyk7XHJcbiAgICAvLyBSZWdpc3RlciBwbGF0Zm9ybSBTREsgaWRlbnRpZmllciAobm8gdmVyc2lvbikuXHJcbiAgICByZWdpc3RlclZlcnNpb24oJ2ZpcmUtanMnLCAnJyk7XHJcbn1cblxuLyoqXHJcbiAqIEZpcmViYXNlIEFwcFxyXG4gKlxyXG4gKiBAcmVtYXJrcyBUaGlzIHBhY2thZ2UgY29vcmRpbmF0ZXMgdGhlIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgZGlmZmVyZW50IEZpcmViYXNlIGNvbXBvbmVudHNcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5yZWdpc3RlckNvcmVDb21wb25lbnRzKCcnKTtcblxuZXhwb3J0IHsgU0RLX1ZFUlNJT04sIERFRkFVTFRfRU5UUllfTkFNRSBhcyBfREVGQVVMVF9FTlRSWV9OQU1FLCBfYWRkQ29tcG9uZW50LCBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQsIF9hcHBzLCBfY2xlYXJDb21wb25lbnRzLCBfY29tcG9uZW50cywgX2dldFByb3ZpZGVyLCBfaXNGaXJlYmFzZUFwcCwgX2lzRmlyZWJhc2VTZXJ2ZXJBcHAsIF9yZWdpc3RlckNvbXBvbmVudCwgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSwgX3NlcnZlckFwcHMsIGRlbGV0ZUFwcCwgZ2V0QXBwLCBnZXRBcHBzLCBpbml0aWFsaXplQXBwLCBpbml0aWFsaXplU2VydmVyQXBwLCBvbkxvZywgcmVnaXN0ZXJWZXJzaW9uLCBzZXRMb2dMZXZlbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/auth/dist/node-esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@firebase/auth/dist/node-esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionCodeOperation: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   ActionCodeURL: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.ai),\n/* harmony export */   AuthCredential: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.L),\n/* harmony export */   AuthErrorCodes: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   EmailAuthCredential: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   EmailAuthProvider: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.V),\n/* harmony export */   FacebookAuthProvider: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.W),\n/* harmony export */   FactorId: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   GithubAuthProvider: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.Y),\n/* harmony export */   GoogleAuthProvider: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.X),\n/* harmony export */   OAuthCredential: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.N),\n/* harmony export */   OAuthProvider: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.Z),\n/* harmony export */   OperationType: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.O),\n/* harmony export */   PhoneAuthCredential: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.Q),\n/* harmony export */   PhoneAuthProvider: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.P),\n/* harmony export */   PhoneMultiFactorGenerator: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   ProviderId: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   RecaptchaVerifier: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.R),\n/* harmony export */   SAMLAuthProvider: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   SignInMethod: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   TotpMultiFactorGenerator: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.T),\n/* harmony export */   TotpSecret: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   TwitterAuthProvider: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.$),\n/* harmony export */   applyActionCode: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.a7),\n/* harmony export */   beforeAuthStateChanged: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   browserLocalPersistence: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   browserPopupRedirectResolver: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   browserSessionPersistence: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   checkActionCode: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.a8),\n/* harmony export */   confirmPasswordReset: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.a6),\n/* harmony export */   connectAuthEmulator: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.K),\n/* harmony export */   createUserWithEmailAndPassword: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.aa),\n/* harmony export */   debugErrorMap: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   deleteUser: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   fetchSignInMethodsForEmail: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.af),\n/* harmony export */   getAdditionalUserInfo: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.aq),\n/* harmony export */   getAuth: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   getIdToken: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.an),\n/* harmony export */   getIdTokenResult: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.ao),\n/* harmony export */   getMultiFactorResolver: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.as),\n/* harmony export */   getRedirectResult: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   inMemoryPersistence: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.U),\n/* harmony export */   indexedDBLocalPersistence: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   initializeAuth: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.J),\n/* harmony export */   initializeRecaptchaConfig: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   isSignInWithEmailLink: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.ad),\n/* harmony export */   linkWithCredential: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.a2),\n/* harmony export */   linkWithPhoneNumber: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   linkWithPopup: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   linkWithRedirect: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   multiFactor: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.at),\n/* harmony export */   onAuthStateChanged: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   onIdTokenChanged: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   parseActionCodeURL: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.aj),\n/* harmony export */   prodErrorMap: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.H),\n/* harmony export */   reauthenticateWithCredential: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.a3),\n/* harmony export */   reauthenticateWithPhoneNumber: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   reauthenticateWithPopup: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   reauthenticateWithRedirect: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   reload: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.ar),\n/* harmony export */   revokeAccessToken: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   sendEmailVerification: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.ag),\n/* harmony export */   sendPasswordResetEmail: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.a5),\n/* harmony export */   sendSignInLinkToEmail: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.ac),\n/* harmony export */   setPersistence: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   signInAnonymously: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.a0),\n/* harmony export */   signInWithCredential: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.a1),\n/* harmony export */   signInWithCustomToken: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.a4),\n/* harmony export */   signInWithEmailAndPassword: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.ab),\n/* harmony export */   signInWithEmailLink: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.ae),\n/* harmony export */   signInWithPhoneNumber: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   signInWithPopup: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   signInWithRedirect: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   signOut: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   unlink: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.ap),\n/* harmony export */   updateCurrentUser: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.B),\n/* harmony export */   updateEmail: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.al),\n/* harmony export */   updatePassword: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.am),\n/* harmony export */   updatePhoneNumber: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   updateProfile: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.ak),\n/* harmony export */   useDeviceLanguage: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   validatePassword: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   verifyBeforeUpdateEmail: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.ah),\n/* harmony export */   verifyPasswordResetCode: () => (/* reexport safe */ _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__.a9)\n/* harmony export */ });\n/* harmony import */ var _totp_cb6285c7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./totp-cb6285c7.js */ \"(ssr)/./node_modules/@firebase/auth/dist/node-esm/totp-cb6285c7.js\");\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! undici */ \"undici\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvZGlzdC9ub2RlLWVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd2xFO0FBQ2prRTtBQUNDO0FBQ1Q7QUFDYztBQUNiO0FBQ1U7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFybnR1YmUtMS4wLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3Qvbm9kZS1lc20vaW5kZXguanM/MTk0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBBIGFzIEFjdGlvbkNvZGVPcGVyYXRpb24sIGFpIGFzIEFjdGlvbkNvZGVVUkwsIEwgYXMgQXV0aENyZWRlbnRpYWwsIEkgYXMgQXV0aEVycm9yQ29kZXMsIE0gYXMgRW1haWxBdXRoQ3JlZGVudGlhbCwgViBhcyBFbWFpbEF1dGhQcm92aWRlciwgVyBhcyBGYWNlYm9va0F1dGhQcm92aWRlciwgRiBhcyBGYWN0b3JJZCwgWSBhcyBHaXRodWJBdXRoUHJvdmlkZXIsIFggYXMgR29vZ2xlQXV0aFByb3ZpZGVyLCBOIGFzIE9BdXRoQ3JlZGVudGlhbCwgWiBhcyBPQXV0aFByb3ZpZGVyLCBPIGFzIE9wZXJhdGlvblR5cGUsIFEgYXMgUGhvbmVBdXRoQ3JlZGVudGlhbCwgUCBhcyBQaG9uZUF1dGhQcm92aWRlciwgbSBhcyBQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yLCBwIGFzIFByb3ZpZGVySWQsIFIgYXMgUmVjYXB0Y2hhVmVyaWZpZXIsIF8gYXMgU0FNTEF1dGhQcm92aWRlciwgUyBhcyBTaWduSW5NZXRob2QsIFQgYXMgVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yLCBuIGFzIFRvdHBTZWNyZXQsICQgYXMgVHdpdHRlckF1dGhQcm92aWRlciwgYTcgYXMgYXBwbHlBY3Rpb25Db2RlLCB4IGFzIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQsIGIgYXMgYnJvd3NlckxvY2FsUGVyc2lzdGVuY2UsIGsgYXMgYnJvd3NlclBvcHVwUmVkaXJlY3RSZXNvbHZlciwgYSBhcyBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlLCBhOCBhcyBjaGVja0FjdGlvbkNvZGUsIGE2IGFzIGNvbmZpcm1QYXNzd29yZFJlc2V0LCBLIGFzIGNvbm5lY3RBdXRoRW11bGF0b3IsIGFhIGFzIGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZCwgRyBhcyBkZWJ1Z0Vycm9yTWFwLCBFIGFzIGRlbGV0ZVVzZXIsIGFmIGFzIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsLCBhcSBhcyBnZXRBZGRpdGlvbmFsVXNlckluZm8sIG8gYXMgZ2V0QXV0aCwgYW4gYXMgZ2V0SWRUb2tlbiwgYW8gYXMgZ2V0SWRUb2tlblJlc3VsdCwgYXMgYXMgZ2V0TXVsdGlGYWN0b3JSZXNvbHZlciwgaiBhcyBnZXRSZWRpcmVjdFJlc3VsdCwgVSBhcyBpbk1lbW9yeVBlcnNpc3RlbmNlLCBpIGFzIGluZGV4ZWREQkxvY2FsUGVyc2lzdGVuY2UsIEogYXMgaW5pdGlhbGl6ZUF1dGgsIHQgYXMgaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZywgYWQgYXMgaXNTaWduSW5XaXRoRW1haWxMaW5rLCBhMiBhcyBsaW5rV2l0aENyZWRlbnRpYWwsIGwgYXMgbGlua1dpdGhQaG9uZU51bWJlciwgZCBhcyBsaW5rV2l0aFBvcHVwLCBnIGFzIGxpbmtXaXRoUmVkaXJlY3QsIGF0IGFzIG11bHRpRmFjdG9yLCB5IGFzIG9uQXV0aFN0YXRlQ2hhbmdlZCwgdyBhcyBvbklkVG9rZW5DaGFuZ2VkLCBhaiBhcyBwYXJzZUFjdGlvbkNvZGVVUkwsIEggYXMgcHJvZEVycm9yTWFwLCBhMyBhcyByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsLCByIGFzIHJlYXV0aGVudGljYXRlV2l0aFBob25lTnVtYmVyLCBlIGFzIHJlYXV0aGVudGljYXRlV2l0aFBvcHVwLCBoIGFzIHJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0LCBhciBhcyByZWxvYWQsIEQgYXMgcmV2b2tlQWNjZXNzVG9rZW4sIGFnIGFzIHNlbmRFbWFpbFZlcmlmaWNhdGlvbiwgYTUgYXMgc2VuZFBhc3N3b3JkUmVzZXRFbWFpbCwgYWMgYXMgc2VuZFNpZ25JbkxpbmtUb0VtYWlsLCBxIGFzIHNldFBlcnNpc3RlbmNlLCBhMCBhcyBzaWduSW5Bbm9ueW1vdXNseSwgYTEgYXMgc2lnbkluV2l0aENyZWRlbnRpYWwsIGE0IGFzIHNpZ25JbldpdGhDdXN0b21Ub2tlbiwgYWIgYXMgc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQsIGFlIGFzIHNpZ25JbldpdGhFbWFpbExpbmssIHMgYXMgc2lnbkluV2l0aFBob25lTnVtYmVyLCBjIGFzIHNpZ25JbldpdGhQb3B1cCwgZiBhcyBzaWduSW5XaXRoUmVkaXJlY3QsIEMgYXMgc2lnbk91dCwgYXAgYXMgdW5saW5rLCBCIGFzIHVwZGF0ZUN1cnJlbnRVc2VyLCBhbCBhcyB1cGRhdGVFbWFpbCwgYW0gYXMgdXBkYXRlUGFzc3dvcmQsIHUgYXMgdXBkYXRlUGhvbmVOdW1iZXIsIGFrIGFzIHVwZGF0ZVByb2ZpbGUsIHogYXMgdXNlRGV2aWNlTGFuZ3VhZ2UsIHYgYXMgdmFsaWRhdGVQYXNzd29yZCwgYWggYXMgdmVyaWZ5QmVmb3JlVXBkYXRlRW1haWwsIGE5IGFzIHZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlIH0gZnJvbSAnLi90b3RwLWNiNjI4NWM3LmpzJztcbmltcG9ydCAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCAndHNsaWInO1xuaW1wb3J0ICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCAndW5kaWNpJztcbmltcG9ydCAnQGZpcmViYXNlL2xvZ2dlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/auth/dist/node-esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/auth/dist/node-esm/totp-cb6285c7.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/auth/dist/node-esm/totp-cb6285c7.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ TwitterAuthProvider),\n/* harmony export */   A: () => (/* binding */ ActionCodeOperation),\n/* harmony export */   B: () => (/* binding */ updateCurrentUser),\n/* harmony export */   C: () => (/* binding */ signOut),\n/* harmony export */   D: () => (/* binding */ revokeAccessToken),\n/* harmony export */   E: () => (/* binding */ deleteUser),\n/* harmony export */   F: () => (/* binding */ FactorId),\n/* harmony export */   G: () => (/* binding */ debugErrorMap),\n/* harmony export */   H: () => (/* binding */ prodErrorMap),\n/* harmony export */   I: () => (/* binding */ AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY),\n/* harmony export */   J: () => (/* binding */ initializeAuth),\n/* harmony export */   K: () => (/* binding */ connectAuthEmulator),\n/* harmony export */   L: () => (/* binding */ AuthCredential),\n/* harmony export */   M: () => (/* binding */ EmailAuthCredential),\n/* harmony export */   N: () => (/* binding */ OAuthCredential),\n/* harmony export */   O: () => (/* binding */ OperationType),\n/* harmony export */   P: () => (/* binding */ PhoneAuthProvider),\n/* harmony export */   Q: () => (/* binding */ PhoneAuthCredential),\n/* harmony export */   R: () => (/* binding */ RecaptchaVerifier),\n/* harmony export */   S: () => (/* binding */ SignInMethod),\n/* harmony export */   T: () => (/* binding */ TotpMultiFactorGenerator),\n/* harmony export */   U: () => (/* binding */ inMemoryPersistence),\n/* harmony export */   V: () => (/* binding */ EmailAuthProvider),\n/* harmony export */   W: () => (/* binding */ FacebookAuthProvider),\n/* harmony export */   X: () => (/* binding */ GoogleAuthProvider),\n/* harmony export */   Y: () => (/* binding */ GithubAuthProvider),\n/* harmony export */   Z: () => (/* binding */ OAuthProvider),\n/* harmony export */   _: () => (/* binding */ SAMLAuthProvider),\n/* harmony export */   a: () => (/* binding */ browserSessionPersistence),\n/* harmony export */   a0: () => (/* binding */ signInAnonymously),\n/* harmony export */   a1: () => (/* binding */ signInWithCredential),\n/* harmony export */   a2: () => (/* binding */ linkWithCredential),\n/* harmony export */   a3: () => (/* binding */ reauthenticateWithCredential),\n/* harmony export */   a4: () => (/* binding */ signInWithCustomToken),\n/* harmony export */   a5: () => (/* binding */ sendPasswordResetEmail),\n/* harmony export */   a6: () => (/* binding */ confirmPasswordReset),\n/* harmony export */   a7: () => (/* binding */ applyActionCode),\n/* harmony export */   a8: () => (/* binding */ checkActionCode),\n/* harmony export */   a9: () => (/* binding */ verifyPasswordResetCode),\n/* harmony export */   aA: () => (/* binding */ _fail),\n/* harmony export */   aB: () => (/* binding */ debugAssert),\n/* harmony export */   aC: () => (/* binding */ _persistenceKeyName),\n/* harmony export */   aD: () => (/* binding */ _serverAppCurrentUserOperationNotSupportedError),\n/* harmony export */   aE: () => (/* binding */ _castAuth),\n/* harmony export */   aF: () => (/* binding */ FederatedAuthProvider),\n/* harmony export */   aG: () => (/* binding */ BaseOAuthProvider),\n/* harmony export */   aH: () => (/* binding */ _emulatorUrl),\n/* harmony export */   aI: () => (/* binding */ _performApiRequest),\n/* harmony export */   aJ: () => (/* binding */ _isIOS),\n/* harmony export */   aK: () => (/* binding */ _isAndroid),\n/* harmony export */   aL: () => (/* binding */ _isIOS7Or8),\n/* harmony export */   aM: () => (/* binding */ _createError),\n/* harmony export */   aN: () => (/* binding */ _isIframe),\n/* harmony export */   aO: () => (/* binding */ _isMobileBrowser),\n/* harmony export */   aP: () => (/* binding */ _isIE10),\n/* harmony export */   aQ: () => (/* binding */ _isSafari),\n/* harmony export */   aR: () => (/* binding */ UserImpl),\n/* harmony export */   aS: () => (/* binding */ AuthImpl),\n/* harmony export */   aT: () => (/* binding */ _getClientVersion),\n/* harmony export */   aU: () => (/* binding */ FetchProvider),\n/* harmony export */   aV: () => (/* binding */ SAMLAuthCredential),\n/* harmony export */   aa: () => (/* binding */ createUserWithEmailAndPassword),\n/* harmony export */   ab: () => (/* binding */ signInWithEmailAndPassword),\n/* harmony export */   ac: () => (/* binding */ sendSignInLinkToEmail),\n/* harmony export */   ad: () => (/* binding */ isSignInWithEmailLink),\n/* harmony export */   ae: () => (/* binding */ signInWithEmailLink),\n/* harmony export */   af: () => (/* binding */ fetchSignInMethodsForEmail),\n/* harmony export */   ag: () => (/* binding */ sendEmailVerification),\n/* harmony export */   ah: () => (/* binding */ verifyBeforeUpdateEmail),\n/* harmony export */   ai: () => (/* binding */ ActionCodeURL),\n/* harmony export */   aj: () => (/* binding */ parseActionCodeURL),\n/* harmony export */   ak: () => (/* binding */ updateProfile),\n/* harmony export */   al: () => (/* binding */ updateEmail),\n/* harmony export */   am: () => (/* binding */ updatePassword),\n/* harmony export */   an: () => (/* binding */ getIdToken),\n/* harmony export */   ao: () => (/* binding */ getIdTokenResult),\n/* harmony export */   ap: () => (/* binding */ unlink),\n/* harmony export */   aq: () => (/* binding */ getAdditionalUserInfo),\n/* harmony export */   ar: () => (/* binding */ reload),\n/* harmony export */   as: () => (/* binding */ getMultiFactorResolver),\n/* harmony export */   at: () => (/* binding */ multiFactor),\n/* harmony export */   au: () => (/* binding */ _getInstance),\n/* harmony export */   av: () => (/* binding */ _assert),\n/* harmony export */   aw: () => (/* binding */ _signInWithCredential),\n/* harmony export */   ax: () => (/* binding */ _reauthenticate),\n/* harmony export */   ay: () => (/* binding */ _link),\n/* harmony export */   az: () => (/* binding */ signInWithIdp),\n/* harmony export */   b: () => (/* binding */ browserLocalPersistence),\n/* harmony export */   c: () => (/* binding */ signInWithPopup),\n/* harmony export */   d: () => (/* binding */ linkWithPopup),\n/* harmony export */   e: () => (/* binding */ reauthenticateWithPopup),\n/* harmony export */   f: () => (/* binding */ signInWithRedirect),\n/* harmony export */   g: () => (/* binding */ linkWithRedirect),\n/* harmony export */   h: () => (/* binding */ reauthenticateWithRedirect),\n/* harmony export */   i: () => (/* binding */ indexedDBLocalPersistence),\n/* harmony export */   j: () => (/* binding */ getRedirectResult),\n/* harmony export */   k: () => (/* binding */ browserPopupRedirectResolver),\n/* harmony export */   l: () => (/* binding */ linkWithPhoneNumber),\n/* harmony export */   m: () => (/* binding */ PhoneMultiFactorGenerator),\n/* harmony export */   n: () => (/* binding */ TotpSecret),\n/* harmony export */   o: () => (/* binding */ getAuth),\n/* harmony export */   p: () => (/* binding */ ProviderId),\n/* harmony export */   q: () => (/* binding */ setPersistence),\n/* harmony export */   r: () => (/* binding */ reauthenticateWithPhoneNumber),\n/* harmony export */   s: () => (/* binding */ signInWithPhoneNumber),\n/* harmony export */   t: () => (/* binding */ initializeRecaptchaConfig),\n/* harmony export */   u: () => (/* binding */ updatePhoneNumber),\n/* harmony export */   v: () => (/* binding */ validatePassword),\n/* harmony export */   w: () => (/* binding */ onIdTokenChanged),\n/* harmony export */   x: () => (/* binding */ beforeAuthStateChanged),\n/* harmony export */   y: () => (/* binding */ onAuthStateChanged),\n/* harmony export */   z: () => (/* binding */ useDeviceLanguage)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! undici */ \"undici\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An enum of factors that may be used for multifactor authentication.\r\n *\r\n * @public\r\n */\r\nconst FactorId = {\r\n    /** Phone as second factor */\r\n    PHONE: 'phone',\r\n    TOTP: 'totp'\r\n};\r\n/**\r\n * Enumeration of supported providers.\r\n *\r\n * @public\r\n */\r\nconst ProviderId = {\r\n    /** Facebook provider ID */\r\n    FACEBOOK: 'facebook.com',\r\n    /** GitHub provider ID */\r\n    GITHUB: 'github.com',\r\n    /** Google provider ID */\r\n    GOOGLE: 'google.com',\r\n    /** Password provider */\r\n    PASSWORD: 'password',\r\n    /** Phone provider */\r\n    PHONE: 'phone',\r\n    /** Twitter provider ID */\r\n    TWITTER: 'twitter.com'\r\n};\r\n/**\r\n * Enumeration of supported sign-in methods.\r\n *\r\n * @public\r\n */\r\nconst SignInMethod = {\r\n    /** Email link sign in method */\r\n    EMAIL_LINK: 'emailLink',\r\n    /** Email/password sign in method */\r\n    EMAIL_PASSWORD: 'password',\r\n    /** Facebook sign in method */\r\n    FACEBOOK: 'facebook.com',\r\n    /** GitHub sign in method */\r\n    GITHUB: 'github.com',\r\n    /** Google sign in method */\r\n    GOOGLE: 'google.com',\r\n    /** Phone sign in method */\r\n    PHONE: 'phone',\r\n    /** Twitter sign in method */\r\n    TWITTER: 'twitter.com'\r\n};\r\n/**\r\n * Enumeration of supported operation types.\r\n *\r\n * @public\r\n */\r\nconst OperationType = {\r\n    /** Operation involving linking an additional provider to an already signed-in user. */\r\n    LINK: 'link',\r\n    /** Operation involving using a provider to reauthenticate an already signed-in user. */\r\n    REAUTHENTICATE: 'reauthenticate',\r\n    /** Operation involving signing in a user. */\r\n    SIGN_IN: 'signIn'\r\n};\r\n/**\r\n * An enumeration of the possible email action types.\r\n *\r\n * @public\r\n */\r\nconst ActionCodeOperation = {\r\n    /** The email link sign-in action. */\r\n    EMAIL_SIGNIN: 'EMAIL_SIGNIN',\r\n    /** The password reset action. */\r\n    PASSWORD_RESET: 'PASSWORD_RESET',\r\n    /** The email revocation action. */\r\n    RECOVER_EMAIL: 'RECOVER_EMAIL',\r\n    /** The revert second factor addition email action. */\r\n    REVERT_SECOND_FACTOR_ADDITION: 'REVERT_SECOND_FACTOR_ADDITION',\r\n    /** The revert second factor addition email action. */\r\n    VERIFY_AND_CHANGE_EMAIL: 'VERIFY_AND_CHANGE_EMAIL',\r\n    /** The email verification action. */\r\n    VERIFY_EMAIL: 'VERIFY_EMAIL'\r\n};\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction _debugErrorMap() {\r\n    return {\r\n        [\"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */]: 'This operation is restricted to administrators only.',\r\n        [\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */]: '',\r\n        [\"app-not-authorized\" /* AuthErrorCode.APP_NOT_AUTHORIZED */]: \"This app, identified by the domain where it's hosted, is not \" +\r\n            'authorized to use Firebase Authentication with the provided API key. ' +\r\n            'Review your key configuration in the Google API console.',\r\n        [\"app-not-installed\" /* AuthErrorCode.APP_NOT_INSTALLED */]: 'The requested mobile application corresponding to the identifier (' +\r\n            'Android package name or iOS bundle ID) provided is not installed on ' +\r\n            'this device.',\r\n        [\"captcha-check-failed\" /* AuthErrorCode.CAPTCHA_CHECK_FAILED */]: 'The reCAPTCHA response token provided is either invalid, expired, ' +\r\n            'already used or the domain associated with it does not match the list ' +\r\n            'of whitelisted domains.',\r\n        [\"code-expired\" /* AuthErrorCode.CODE_EXPIRED */]: 'The SMS code has expired. Please re-send the verification code to try ' +\r\n            'again.',\r\n        [\"cordova-not-ready\" /* AuthErrorCode.CORDOVA_NOT_READY */]: 'Cordova framework is not ready.',\r\n        [\"cors-unsupported\" /* AuthErrorCode.CORS_UNSUPPORTED */]: 'This browser is not supported.',\r\n        [\"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */]: 'This credential is already associated with a different user account.',\r\n        [\"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */]: 'The custom token corresponds to a different audience.',\r\n        [\"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: 'This operation is sensitive and requires recent authentication. Log in ' +\r\n            'again before retrying this request.',\r\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +\r\n            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +\r\n            'starting any other Firebase SDK.',\r\n        [\"dynamic-link-not-activated\" /* AuthErrorCode.DYNAMIC_LINK_NOT_ACTIVATED */]: 'Please activate Dynamic Links in the Firebase Console and agree to the terms and ' +\r\n            'conditions.',\r\n        [\"email-change-needs-verification\" /* AuthErrorCode.EMAIL_CHANGE_NEEDS_VERIFICATION */]: 'Multi-factor users must always have a verified email.',\r\n        [\"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */]: 'The email address is already in use by another account.',\r\n        [\"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */]: 'Auth instance has already been used to make a network call. Auth can ' +\r\n            'no longer be configured to use the emulator. Try calling ' +\r\n            '\"connectAuthEmulator()\" sooner.',\r\n        [\"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */]: 'The action code has expired.',\r\n        [\"cancelled-popup-request\" /* AuthErrorCode.EXPIRED_POPUP_REQUEST */]: 'This operation has been cancelled due to another conflicting popup being opened.',\r\n        [\"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */]: 'An internal AuthError has occurred.',\r\n        [\"invalid-app-credential\" /* AuthErrorCode.INVALID_APP_CREDENTIAL */]: 'The phone verification request contains an invalid application verifier.' +\r\n            ' The reCAPTCHA token response is either invalid or expired.',\r\n        [\"invalid-app-id\" /* AuthErrorCode.INVALID_APP_ID */]: 'The mobile app identifier is not registed for the current project.',\r\n        [\"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */]: \"This user's credential isn't valid for this project. This can happen \" +\r\n            \"if the user's token has been tampered with, or if the user isn't for \" +\r\n            'the project associated with this API key.',\r\n        [\"invalid-auth-event\" /* AuthErrorCode.INVALID_AUTH_EVENT */]: 'An internal AuthError has occurred.',\r\n        [\"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */]: 'The SMS verification code used to create the phone auth credential is ' +\r\n            'invalid. Please resend the verification code sms and be sure to use the ' +\r\n            'verification code provided by the user.',\r\n        [\"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */]: 'The continue URL provided in the request is invalid.',\r\n        [\"invalid-cordova-configuration\" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */]: 'The following Cordova plugins must be installed to enable OAuth sign-in: ' +\r\n            'cordova-plugin-buildinfo, cordova-universal-links-plugin, ' +\r\n            'cordova-plugin-browsertab, cordova-plugin-inappbrowser and ' +\r\n            'cordova-plugin-customurlscheme.',\r\n        [\"invalid-custom-token\" /* AuthErrorCode.INVALID_CUSTOM_TOKEN */]: 'The custom token format is incorrect. Please check the documentation.',\r\n        [\"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */]: 'The provided dynamic link domain is not configured or authorized for the current project.',\r\n        [\"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */]: 'The email address is badly formatted.',\r\n        [\"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */]: 'Emulator URL must start with a valid scheme (http:// or https://).',\r\n        [\"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */]: 'Your API key is invalid, please check you have copied it correctly.',\r\n        [\"invalid-cert-hash\" /* AuthErrorCode.INVALID_CERT_HASH */]: 'The SHA-1 certificate hash provided is invalid.',\r\n        [\"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */]: 'The supplied auth credential is incorrect, malformed or has expired.',\r\n        [\"invalid-message-payload\" /* AuthErrorCode.INVALID_MESSAGE_PAYLOAD */]: 'The email template corresponding to this action contains invalid characters in its message. ' +\r\n            'Please fix by going to the Auth email templates section in the Firebase Console.',\r\n        [\"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */]: 'The request does not contain a valid proof of first factor successful sign-in.',\r\n        [\"invalid-oauth-provider\" /* AuthErrorCode.INVALID_OAUTH_PROVIDER */]: 'EmailAuthProvider is not supported for this operation. This operation ' +\r\n            'only supports OAuth providers.',\r\n        [\"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */]: 'The OAuth client ID provided is either invalid or does not match the ' +\r\n            'specified API key.',\r\n        [\"unauthorized-domain\" /* AuthErrorCode.INVALID_ORIGIN */]: 'This domain is not authorized for OAuth operations for your Firebase ' +\r\n            'project. Edit the list of authorized domains from the Firebase console.',\r\n        [\"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */]: 'The action code is invalid. This can happen if the code is malformed, ' +\r\n            'expired, or has already been used.',\r\n        [\"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */]: 'The password is invalid or the user does not have a password.',\r\n        [\"invalid-persistence-type\" /* AuthErrorCode.INVALID_PERSISTENCE */]: 'The specified persistence type is invalid. It can only be local, session or none.',\r\n        [\"invalid-phone-number\" /* AuthErrorCode.INVALID_PHONE_NUMBER */]: 'The format of the phone number provided is incorrect. Please enter the ' +\r\n            'phone number in a format that can be parsed into E.164 format. E.164 ' +\r\n            'phone numbers are written in the format [+][country code][subscriber ' +\r\n            'number including area code].',\r\n        [\"invalid-provider-id\" /* AuthErrorCode.INVALID_PROVIDER_ID */]: 'The specified provider ID is invalid.',\r\n        [\"invalid-recipient-email\" /* AuthErrorCode.INVALID_RECIPIENT_EMAIL */]: 'The email corresponding to this action failed to send as the provided ' +\r\n            'recipient email address is invalid.',\r\n        [\"invalid-sender\" /* AuthErrorCode.INVALID_SENDER */]: 'The email template corresponding to this action contains an invalid sender email or name. ' +\r\n            'Please fix by going to the Auth email templates section in the Firebase Console.',\r\n        [\"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */]: 'The verification ID used to create the phone auth credential is invalid.',\r\n        [\"invalid-tenant-id\" /* AuthErrorCode.INVALID_TENANT_ID */]: \"The Auth instance's tenant ID is invalid.\",\r\n        [\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */]: 'Login blocked by user-provided method: {$originalMessage}',\r\n        [\"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */]: 'An Android Package Name must be provided if the Android App is required to be installed.',\r\n        [\"auth-domain-config-required\" /* AuthErrorCode.MISSING_AUTH_DOMAIN */]: 'Be sure to include authDomain when calling firebase.initializeApp(), ' +\r\n            'by following the instructions in the Firebase console.',\r\n        [\"missing-app-credential\" /* AuthErrorCode.MISSING_APP_CREDENTIAL */]: 'The phone verification request is missing an application verifier ' +\r\n            'assertion. A reCAPTCHA response token needs to be provided.',\r\n        [\"missing-verification-code\" /* AuthErrorCode.MISSING_CODE */]: 'The phone auth credential was created with an empty SMS verification code.',\r\n        [\"missing-continue-uri\" /* AuthErrorCode.MISSING_CONTINUE_URI */]: 'A continue URL must be provided in the request.',\r\n        [\"missing-iframe-start\" /* AuthErrorCode.MISSING_IFRAME_START */]: 'An internal AuthError has occurred.',\r\n        [\"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */]: 'An iOS Bundle ID must be provided if an App Store ID is provided.',\r\n        [\"missing-or-invalid-nonce\" /* AuthErrorCode.MISSING_OR_INVALID_NONCE */]: 'The request does not contain a valid nonce. This can occur if the ' +\r\n            'SHA-256 hash of the provided raw nonce does not match the hashed nonce ' +\r\n            'in the ID token payload.',\r\n        [\"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */]: 'A non-empty password must be provided',\r\n        [\"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */]: 'No second factor identifier is provided.',\r\n        [\"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */]: 'The request is missing proof of first factor successful sign-in.',\r\n        [\"missing-phone-number\" /* AuthErrorCode.MISSING_PHONE_NUMBER */]: 'To send verification codes, provide a phone number for the recipient.',\r\n        [\"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */]: 'The phone auth credential was created with an empty verification ID.',\r\n        [\"app-deleted\" /* AuthErrorCode.MODULE_DESTROYED */]: 'This instance of FirebaseApp has been deleted.',\r\n        [\"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */]: 'The user does not have a second factor matching the identifier provided.',\r\n        [\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */]: 'Proof of ownership of a second factor is required to complete sign-in.',\r\n        [\"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */]: 'An account already exists with the same email address but different ' +\r\n            'sign-in credentials. Sign in using a provider associated with this ' +\r\n            'email address.',\r\n        [\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */]: 'A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.',\r\n        [\"no-auth-event\" /* AuthErrorCode.NO_AUTH_EVENT */]: 'An internal AuthError has occurred.',\r\n        [\"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */]: 'User was not linked to an account with the given provider.',\r\n        [\"null-user\" /* AuthErrorCode.NULL_USER */]: 'A null user object was provided as the argument for an operation which ' +\r\n            'requires a non-null user object.',\r\n        [\"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */]: 'The given sign-in provider is disabled for this Firebase project. ' +\r\n            'Enable it in the Firebase console, under the sign-in method tab of the ' +\r\n            'Auth section.',\r\n        [\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */]: 'This operation is not supported in the environment this application is ' +\r\n            'running on. \"location.protocol\" must be http, https or chrome-extension' +\r\n            ' and web storage must be enabled.',\r\n        [\"popup-blocked\" /* AuthErrorCode.POPUP_BLOCKED */]: 'Unable to establish a connection with the popup. It may have been blocked by the browser.',\r\n        [\"popup-closed-by-user\" /* AuthErrorCode.POPUP_CLOSED_BY_USER */]: 'The popup has been closed by the user before finalizing the operation.',\r\n        [\"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */]: 'User can only be linked to one identity for the given provider.',\r\n        [\"quota-exceeded\" /* AuthErrorCode.QUOTA_EXCEEDED */]: \"The project's quota for this operation has been exceeded.\",\r\n        [\"redirect-cancelled-by-user\" /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */]: 'The redirect operation has been cancelled by the user before finalizing.',\r\n        [\"redirect-operation-pending\" /* AuthErrorCode.REDIRECT_OPERATION_PENDING */]: 'A redirect sign-in operation is already pending.',\r\n        [\"rejected-credential\" /* AuthErrorCode.REJECTED_CREDENTIAL */]: 'The request contains malformed or mismatching credentials.',\r\n        [\"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */]: 'The second factor is already enrolled on this account.',\r\n        [\"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */]: 'The maximum allowed number of second factors on a user has been exceeded.',\r\n        [\"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */]: \"The provided tenant ID does not match the Auth instance's tenant ID\",\r\n        [\"timeout\" /* AuthErrorCode.TIMEOUT */]: 'The operation has timed out.',\r\n        [\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */]: \"The user's credential is no longer valid. The user must sign in again.\",\r\n        [\"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */]: 'We have blocked all requests from this device due to unusual activity. ' +\r\n            'Try again later.',\r\n        [\"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */]: 'The domain of the continue URL is not whitelisted.  Please whitelist ' +\r\n            'the domain in the Firebase console.',\r\n        [\"unsupported-first-factor\" /* AuthErrorCode.UNSUPPORTED_FIRST_FACTOR */]: 'Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.',\r\n        [\"unsupported-persistence-type\" /* AuthErrorCode.UNSUPPORTED_PERSISTENCE */]: 'The current environment does not support the specified persistence type.',\r\n        [\"unsupported-tenant-operation\" /* AuthErrorCode.UNSUPPORTED_TENANT_OPERATION */]: 'This operation is not supported in a multi-tenant context.',\r\n        [\"unverified-email\" /* AuthErrorCode.UNVERIFIED_EMAIL */]: 'The operation requires a verified email.',\r\n        [\"user-cancelled\" /* AuthErrorCode.USER_CANCELLED */]: 'The user did not grant your application the permissions it requested.',\r\n        [\"user-not-found\" /* AuthErrorCode.USER_DELETED */]: 'There is no user record corresponding to this identifier. The user may ' +\r\n            'have been deleted.',\r\n        [\"user-disabled\" /* AuthErrorCode.USER_DISABLED */]: 'The user account has been disabled by an administrator.',\r\n        [\"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */]: 'The supplied credentials do not correspond to the previously signed in user.',\r\n        [\"user-signed-out\" /* AuthErrorCode.USER_SIGNED_OUT */]: '',\r\n        [\"weak-password\" /* AuthErrorCode.WEAK_PASSWORD */]: 'The password must be 6 characters long or more.',\r\n        [\"web-storage-unsupported\" /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */]: 'This browser is not supported or 3rd party cookies and data may be disabled.',\r\n        [\"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */]: 'initializeAuth() has already been called with ' +\r\n            'different options. To avoid this error, call initializeAuth() with the ' +\r\n            'same options as when it was originally called, or call getAuth() to return the' +\r\n            ' already initialized instance.',\r\n        [\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is missing when sending request to the backend.',\r\n        [\"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is invalid when sending request to the backend.',\r\n        [\"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */]: 'The reCAPTCHA action is invalid when sending request to the backend.',\r\n        [\"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */]: 'reCAPTCHA Enterprise integration is not enabled for this project.',\r\n        [\"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */]: 'The reCAPTCHA client type is missing when sending request to the backend.',\r\n        [\"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is missing when sending request to the backend.',\r\n        [\"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */]: 'Invalid request parameters.',\r\n        [\"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is invalid when sending request to the backend.',\r\n        [\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */]: 'The password policy received from the backend uses a schema version that is not supported by this version of the Firebase SDK.',\r\n        [\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */]: 'The password does not meet the requirements.'\r\n    };\r\n}\r\nfunction _prodErrorMap() {\r\n    // We will include this one message in the prod error map since by the very\r\n    // nature of this error, developers will never be able to see the message\r\n    // using the debugErrorMap (which is installed during auth initialization).\r\n    return {\r\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +\r\n            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +\r\n            'starting any other Firebase SDK.'\r\n    };\r\n}\r\n/**\r\n * A verbose error map with detailed descriptions for most error codes.\r\n *\r\n * See discussion at {@link AuthErrorMap}\r\n *\r\n * @public\r\n */\r\nconst debugErrorMap = _debugErrorMap;\r\n/**\r\n * A minimal error map with all verbose error messages stripped.\r\n *\r\n * See discussion at {@link AuthErrorMap}\r\n *\r\n * @public\r\n */\r\nconst prodErrorMap = _prodErrorMap;\r\nconst _DEFAULT_AUTH_ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory('auth', 'Firebase', _prodErrorMap());\r\n/**\r\n * A map of potential `Auth` error codes, for easier comparison with errors\r\n * thrown by the SDK.\r\n *\r\n * @remarks\r\n * Note that you can't tree-shake individual keys\r\n * in the map, so by using the map you might substantially increase your\r\n * bundle size.\r\n *\r\n * @public\r\n */\r\nconst AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = {\r\n    ADMIN_ONLY_OPERATION: 'auth/admin-restricted-operation',\r\n    ARGUMENT_ERROR: 'auth/argument-error',\r\n    APP_NOT_AUTHORIZED: 'auth/app-not-authorized',\r\n    APP_NOT_INSTALLED: 'auth/app-not-installed',\r\n    CAPTCHA_CHECK_FAILED: 'auth/captcha-check-failed',\r\n    CODE_EXPIRED: 'auth/code-expired',\r\n    CORDOVA_NOT_READY: 'auth/cordova-not-ready',\r\n    CORS_UNSUPPORTED: 'auth/cors-unsupported',\r\n    CREDENTIAL_ALREADY_IN_USE: 'auth/credential-already-in-use',\r\n    CREDENTIAL_MISMATCH: 'auth/custom-token-mismatch',\r\n    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: 'auth/requires-recent-login',\r\n    DEPENDENT_SDK_INIT_BEFORE_AUTH: 'auth/dependent-sdk-initialized-before-auth',\r\n    DYNAMIC_LINK_NOT_ACTIVATED: 'auth/dynamic-link-not-activated',\r\n    EMAIL_CHANGE_NEEDS_VERIFICATION: 'auth/email-change-needs-verification',\r\n    EMAIL_EXISTS: 'auth/email-already-in-use',\r\n    EMULATOR_CONFIG_FAILED: 'auth/emulator-config-failed',\r\n    EXPIRED_OOB_CODE: 'auth/expired-action-code',\r\n    EXPIRED_POPUP_REQUEST: 'auth/cancelled-popup-request',\r\n    INTERNAL_ERROR: 'auth/internal-error',\r\n    INVALID_API_KEY: 'auth/invalid-api-key',\r\n    INVALID_APP_CREDENTIAL: 'auth/invalid-app-credential',\r\n    INVALID_APP_ID: 'auth/invalid-app-id',\r\n    INVALID_AUTH: 'auth/invalid-user-token',\r\n    INVALID_AUTH_EVENT: 'auth/invalid-auth-event',\r\n    INVALID_CERT_HASH: 'auth/invalid-cert-hash',\r\n    INVALID_CODE: 'auth/invalid-verification-code',\r\n    INVALID_CONTINUE_URI: 'auth/invalid-continue-uri',\r\n    INVALID_CORDOVA_CONFIGURATION: 'auth/invalid-cordova-configuration',\r\n    INVALID_CUSTOM_TOKEN: 'auth/invalid-custom-token',\r\n    INVALID_DYNAMIC_LINK_DOMAIN: 'auth/invalid-dynamic-link-domain',\r\n    INVALID_EMAIL: 'auth/invalid-email',\r\n    INVALID_EMULATOR_SCHEME: 'auth/invalid-emulator-scheme',\r\n    INVALID_IDP_RESPONSE: 'auth/invalid-credential',\r\n    INVALID_LOGIN_CREDENTIALS: 'auth/invalid-credential',\r\n    INVALID_MESSAGE_PAYLOAD: 'auth/invalid-message-payload',\r\n    INVALID_MFA_SESSION: 'auth/invalid-multi-factor-session',\r\n    INVALID_OAUTH_CLIENT_ID: 'auth/invalid-oauth-client-id',\r\n    INVALID_OAUTH_PROVIDER: 'auth/invalid-oauth-provider',\r\n    INVALID_OOB_CODE: 'auth/invalid-action-code',\r\n    INVALID_ORIGIN: 'auth/unauthorized-domain',\r\n    INVALID_PASSWORD: 'auth/wrong-password',\r\n    INVALID_PERSISTENCE: 'auth/invalid-persistence-type',\r\n    INVALID_PHONE_NUMBER: 'auth/invalid-phone-number',\r\n    INVALID_PROVIDER_ID: 'auth/invalid-provider-id',\r\n    INVALID_RECIPIENT_EMAIL: 'auth/invalid-recipient-email',\r\n    INVALID_SENDER: 'auth/invalid-sender',\r\n    INVALID_SESSION_INFO: 'auth/invalid-verification-id',\r\n    INVALID_TENANT_ID: 'auth/invalid-tenant-id',\r\n    MFA_INFO_NOT_FOUND: 'auth/multi-factor-info-not-found',\r\n    MFA_REQUIRED: 'auth/multi-factor-auth-required',\r\n    MISSING_ANDROID_PACKAGE_NAME: 'auth/missing-android-pkg-name',\r\n    MISSING_APP_CREDENTIAL: 'auth/missing-app-credential',\r\n    MISSING_AUTH_DOMAIN: 'auth/auth-domain-config-required',\r\n    MISSING_CODE: 'auth/missing-verification-code',\r\n    MISSING_CONTINUE_URI: 'auth/missing-continue-uri',\r\n    MISSING_IFRAME_START: 'auth/missing-iframe-start',\r\n    MISSING_IOS_BUNDLE_ID: 'auth/missing-ios-bundle-id',\r\n    MISSING_OR_INVALID_NONCE: 'auth/missing-or-invalid-nonce',\r\n    MISSING_MFA_INFO: 'auth/missing-multi-factor-info',\r\n    MISSING_MFA_SESSION: 'auth/missing-multi-factor-session',\r\n    MISSING_PHONE_NUMBER: 'auth/missing-phone-number',\r\n    MISSING_SESSION_INFO: 'auth/missing-verification-id',\r\n    MODULE_DESTROYED: 'auth/app-deleted',\r\n    NEED_CONFIRMATION: 'auth/account-exists-with-different-credential',\r\n    NETWORK_REQUEST_FAILED: 'auth/network-request-failed',\r\n    NULL_USER: 'auth/null-user',\r\n    NO_AUTH_EVENT: 'auth/no-auth-event',\r\n    NO_SUCH_PROVIDER: 'auth/no-such-provider',\r\n    OPERATION_NOT_ALLOWED: 'auth/operation-not-allowed',\r\n    OPERATION_NOT_SUPPORTED: 'auth/operation-not-supported-in-this-environment',\r\n    POPUP_BLOCKED: 'auth/popup-blocked',\r\n    POPUP_CLOSED_BY_USER: 'auth/popup-closed-by-user',\r\n    PROVIDER_ALREADY_LINKED: 'auth/provider-already-linked',\r\n    QUOTA_EXCEEDED: 'auth/quota-exceeded',\r\n    REDIRECT_CANCELLED_BY_USER: 'auth/redirect-cancelled-by-user',\r\n    REDIRECT_OPERATION_PENDING: 'auth/redirect-operation-pending',\r\n    REJECTED_CREDENTIAL: 'auth/rejected-credential',\r\n    SECOND_FACTOR_ALREADY_ENROLLED: 'auth/second-factor-already-in-use',\r\n    SECOND_FACTOR_LIMIT_EXCEEDED: 'auth/maximum-second-factor-count-exceeded',\r\n    TENANT_ID_MISMATCH: 'auth/tenant-id-mismatch',\r\n    TIMEOUT: 'auth/timeout',\r\n    TOKEN_EXPIRED: 'auth/user-token-expired',\r\n    TOO_MANY_ATTEMPTS_TRY_LATER: 'auth/too-many-requests',\r\n    UNAUTHORIZED_DOMAIN: 'auth/unauthorized-continue-uri',\r\n    UNSUPPORTED_FIRST_FACTOR: 'auth/unsupported-first-factor',\r\n    UNSUPPORTED_PERSISTENCE: 'auth/unsupported-persistence-type',\r\n    UNSUPPORTED_TENANT_OPERATION: 'auth/unsupported-tenant-operation',\r\n    UNVERIFIED_EMAIL: 'auth/unverified-email',\r\n    USER_CANCELLED: 'auth/user-cancelled',\r\n    USER_DELETED: 'auth/user-not-found',\r\n    USER_DISABLED: 'auth/user-disabled',\r\n    USER_MISMATCH: 'auth/user-mismatch',\r\n    USER_SIGNED_OUT: 'auth/user-signed-out',\r\n    WEAK_PASSWORD: 'auth/weak-password',\r\n    WEB_STORAGE_UNSUPPORTED: 'auth/web-storage-unsupported',\r\n    ALREADY_INITIALIZED: 'auth/already-initialized',\r\n    RECAPTCHA_NOT_ENABLED: 'auth/recaptcha-not-enabled',\r\n    MISSING_RECAPTCHA_TOKEN: 'auth/missing-recaptcha-token',\r\n    INVALID_RECAPTCHA_TOKEN: 'auth/invalid-recaptcha-token',\r\n    INVALID_RECAPTCHA_ACTION: 'auth/invalid-recaptcha-action',\r\n    MISSING_CLIENT_TYPE: 'auth/missing-client-type',\r\n    MISSING_RECAPTCHA_VERSION: 'auth/missing-recaptcha-version',\r\n    INVALID_RECAPTCHA_VERSION: 'auth/invalid-recaptcha-version',\r\n    INVALID_REQ_TYPE: 'auth/invalid-req-type'\r\n};\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_4__.Logger('@firebase/auth');\r\nfunction _logWarn(msg, ...args) {\r\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.WARN) {\r\n        logClient.warn(`Auth (${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}): ${msg}`, ...args);\r\n    }\r\n}\r\nfunction _logError(msg, ...args) {\r\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.ERROR) {\r\n        logClient.error(`Auth (${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}): ${msg}`, ...args);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction _fail(authOrCode, ...rest) {\r\n    throw createErrorInternal(authOrCode, ...rest);\r\n}\r\nfunction _createError(authOrCode, ...rest) {\r\n    return createErrorInternal(authOrCode, ...rest);\r\n}\r\nfunction _errorWithCustomMessage(auth, code, message) {\r\n    const errorMap = Object.assign(Object.assign({}, prodErrorMap()), { [code]: message });\r\n    const factory = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory('auth', 'Firebase', errorMap);\r\n    return factory.create(code, {\r\n        appName: auth.name\r\n    });\r\n}\r\nfunction _serverAppCurrentUserOperationNotSupportedError(auth) {\r\n    return _errorWithCustomMessage(auth, \"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */, 'Operations that alter the current user are not supported in conjunction with FirebaseServerApp');\r\n}\r\nfunction createErrorInternal(authOrCode, ...rest) {\r\n    if (typeof authOrCode !== 'string') {\r\n        const code = rest[0];\r\n        const fullParams = [...rest.slice(1)];\r\n        if (fullParams[0]) {\r\n            fullParams[0].appName = authOrCode.name;\r\n        }\r\n        return authOrCode._errorFactory.create(code, ...fullParams);\r\n    }\r\n    return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);\r\n}\r\nfunction _assert(assertion, authOrCode, ...rest) {\r\n    if (!assertion) {\r\n        throw createErrorInternal(authOrCode, ...rest);\r\n    }\r\n}\r\n/**\r\n * Unconditionally fails, throwing an internal error with the given message.\r\n *\r\n * @param failure type of failure encountered\r\n * @throws Error\r\n */\r\nfunction debugFail(failure) {\r\n    // Log the failure in addition to throw an exception, just in case the\r\n    // exception is swallowed.\r\n    const message = `INTERNAL ASSERTION FAILED: ` + failure;\r\n    _logError(message);\r\n    // NOTE: We don't use FirebaseError here because these are internal failures\r\n    // that cannot be handled by the user. (Also it would create a circular\r\n    // dependency between the error and assert modules which doesn't work.)\r\n    throw new Error(message);\r\n}\r\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * @param assertion\r\n * @param message\r\n */\r\nfunction debugAssert(assertion, message) {\r\n    if (!assertion) {\r\n        debugFail(message);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction _getCurrentUrl() {\r\n    var _a;\r\n    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.href)) || '';\r\n}\r\nfunction _isHttpOrHttps() {\r\n    return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';\r\n}\r\nfunction _getCurrentScheme() {\r\n    var _a;\r\n    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.protocol)) || null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Determine whether the browser is working online\r\n */\r\nfunction _isOnline() {\r\n    if (typeof navigator !== 'undefined' &&\r\n        navigator &&\r\n        'onLine' in navigator &&\r\n        typeof navigator.onLine === 'boolean' &&\r\n        // Apply only for traditional web apps and Chrome extensions.\r\n        // This is especially true for Cordova apps which have unreliable\r\n        // navigator.onLine behavior unless cordova-plugin-network-information is\r\n        // installed which overwrites the native navigator.onLine value and\r\n        // defines navigator.connection.\r\n        (_isHttpOrHttps() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isBrowserExtension)() || 'connection' in navigator)) {\r\n        return navigator.onLine;\r\n    }\r\n    // If we can't determine the state, assume it is online.\r\n    return true;\r\n}\r\nfunction _getUserLanguage() {\r\n    if (typeof navigator === 'undefined') {\r\n        return null;\r\n    }\r\n    const navigatorLanguage = navigator;\r\n    return (\r\n    // Most reliable, but only supported in Chrome/Firefox.\r\n    (navigatorLanguage.languages && navigatorLanguage.languages[0]) ||\r\n        // Supported in most browsers, but returns the language of the browser\r\n        // UI, not the language set in browser settings.\r\n        navigatorLanguage.language ||\r\n        // Couldn't determine language.\r\n        null);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A structure to help pick between a range of long and short delay durations\r\n * depending on the current environment. In general, the long delay is used for\r\n * mobile environments whereas short delays are used for desktop environments.\r\n */\r\nclass Delay {\r\n    constructor(shortDelay, longDelay) {\r\n        this.shortDelay = shortDelay;\r\n        this.longDelay = longDelay;\r\n        // Internal error when improperly initialized.\r\n        debugAssert(longDelay > shortDelay, 'Short delay should be less than long delay!');\r\n        this.isMobile = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isMobileCordova)() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isReactNative)();\r\n    }\r\n    get() {\r\n        if (!_isOnline()) {\r\n            // Pick the shorter timeout.\r\n            return Math.min(5000 /* DelayMin.OFFLINE */, this.shortDelay);\r\n        }\r\n        // If running in a mobile environment, return the long delay, otherwise\r\n        // return the short delay.\r\n        // This could be improved in the future to dynamically change based on other\r\n        // variables instead of just reading the current environment.\r\n        return this.isMobile ? this.longDelay : this.shortDelay;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction _emulatorUrl(config, path) {\r\n    debugAssert(config.emulator, 'Emulator should always be set here');\r\n    const { url } = config.emulator;\r\n    if (!path) {\r\n        return url;\r\n    }\r\n    return `${url}${path.startsWith('/') ? path.slice(1) : path}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass FetchProvider {\r\n    static initialize(fetchImpl, headersImpl, responseImpl) {\r\n        this.fetchImpl = fetchImpl;\r\n        if (headersImpl) {\r\n            this.headersImpl = headersImpl;\r\n        }\r\n        if (responseImpl) {\r\n            this.responseImpl = responseImpl;\r\n        }\r\n    }\r\n    static fetch() {\r\n        if (this.fetchImpl) {\r\n            return this.fetchImpl;\r\n        }\r\n        if (typeof self !== 'undefined' && 'fetch' in self) {\r\n            return self.fetch;\r\n        }\r\n        if (typeof globalThis !== 'undefined' && globalThis.fetch) {\r\n            return globalThis.fetch;\r\n        }\r\n        if (typeof fetch !== 'undefined') {\r\n            return fetch;\r\n        }\r\n        debugFail('Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\r\n    }\r\n    static headers() {\r\n        if (this.headersImpl) {\r\n            return this.headersImpl;\r\n        }\r\n        if (typeof self !== 'undefined' && 'Headers' in self) {\r\n            return self.Headers;\r\n        }\r\n        if (typeof globalThis !== 'undefined' && globalThis.Headers) {\r\n            return globalThis.Headers;\r\n        }\r\n        if (typeof Headers !== 'undefined') {\r\n            return Headers;\r\n        }\r\n        debugFail('Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\r\n    }\r\n    static response() {\r\n        if (this.responseImpl) {\r\n            return this.responseImpl;\r\n        }\r\n        if (typeof self !== 'undefined' && 'Response' in self) {\r\n            return self.Response;\r\n        }\r\n        if (typeof globalThis !== 'undefined' && globalThis.Response) {\r\n            return globalThis.Response;\r\n        }\r\n        if (typeof Response !== 'undefined') {\r\n            return Response;\r\n        }\r\n        debugFail('Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Map from errors returned by the server to errors to developer visible errors\r\n */\r\nconst SERVER_ERROR_MAP = {\r\n    // Custom token errors.\r\n    [\"CREDENTIAL_MISMATCH\" /* ServerError.CREDENTIAL_MISMATCH */]: \"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */,\r\n    // This can only happen if the SDK sends a bad request.\r\n    [\"MISSING_CUSTOM_TOKEN\" /* ServerError.MISSING_CUSTOM_TOKEN */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\r\n    // Create Auth URI errors.\r\n    [\"INVALID_IDENTIFIER\" /* ServerError.INVALID_IDENTIFIER */]: \"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */,\r\n    // This can only happen if the SDK sends a bad request.\r\n    [\"MISSING_CONTINUE_URI\" /* ServerError.MISSING_CONTINUE_URI */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\r\n    // Sign in with email and password errors (some apply to sign up too).\r\n    [\"INVALID_PASSWORD\" /* ServerError.INVALID_PASSWORD */]: \"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */,\r\n    // This can only happen if the SDK sends a bad request.\r\n    [\"MISSING_PASSWORD\" /* ServerError.MISSING_PASSWORD */]: \"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */,\r\n    // Thrown if Email Enumeration Protection is enabled in the project and the email or password is\r\n    // invalid.\r\n    [\"INVALID_LOGIN_CREDENTIALS\" /* ServerError.INVALID_LOGIN_CREDENTIALS */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\r\n    // Sign up with email and password errors.\r\n    [\"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */]: \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */,\r\n    [\"PASSWORD_LOGIN_DISABLED\" /* ServerError.PASSWORD_LOGIN_DISABLED */]: \"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */,\r\n    // Verify assertion for sign in with credential errors:\r\n    [\"INVALID_IDP_RESPONSE\" /* ServerError.INVALID_IDP_RESPONSE */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\r\n    [\"INVALID_PENDING_TOKEN\" /* ServerError.INVALID_PENDING_TOKEN */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\r\n    [\"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */]: \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */,\r\n    // This can only happen if the SDK sends a bad request.\r\n    [\"MISSING_REQ_TYPE\" /* ServerError.MISSING_REQ_TYPE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\r\n    // Send Password reset email errors:\r\n    [\"EMAIL_NOT_FOUND\" /* ServerError.EMAIL_NOT_FOUND */]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */,\r\n    [\"RESET_PASSWORD_EXCEED_LIMIT\" /* ServerError.RESET_PASSWORD_EXCEED_LIMIT */]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,\r\n    [\"EXPIRED_OOB_CODE\" /* ServerError.EXPIRED_OOB_CODE */]: \"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */,\r\n    [\"INVALID_OOB_CODE\" /* ServerError.INVALID_OOB_CODE */]: \"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */,\r\n    // This can only happen if the SDK sends a bad request.\r\n    [\"MISSING_OOB_CODE\" /* ServerError.MISSING_OOB_CODE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\r\n    // Operations that require ID token in request:\r\n    [\"CREDENTIAL_TOO_OLD_LOGIN_AGAIN\" /* ServerError.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: \"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */,\r\n    [\"INVALID_ID_TOKEN\" /* ServerError.INVALID_ID_TOKEN */]: \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */,\r\n    [\"TOKEN_EXPIRED\" /* ServerError.TOKEN_EXPIRED */]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */,\r\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */,\r\n    // Other errors.\r\n    [\"TOO_MANY_ATTEMPTS_TRY_LATER\" /* ServerError.TOO_MANY_ATTEMPTS_TRY_LATER */]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,\r\n    [\"PASSWORD_DOES_NOT_MEET_REQUIREMENTS\" /* ServerError.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */]: \"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */,\r\n    // Phone Auth related errors.\r\n    [\"INVALID_CODE\" /* ServerError.INVALID_CODE */]: \"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */,\r\n    [\"INVALID_SESSION_INFO\" /* ServerError.INVALID_SESSION_INFO */]: \"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */,\r\n    [\"INVALID_TEMPORARY_PROOF\" /* ServerError.INVALID_TEMPORARY_PROOF */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\r\n    [\"MISSING_SESSION_INFO\" /* ServerError.MISSING_SESSION_INFO */]: \"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */,\r\n    [\"SESSION_EXPIRED\" /* ServerError.SESSION_EXPIRED */]: \"code-expired\" /* AuthErrorCode.CODE_EXPIRED */,\r\n    // Other action code errors when additional settings passed.\r\n    // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.\r\n    // This is OK as this error will be caught by client side validation.\r\n    [\"MISSING_ANDROID_PACKAGE_NAME\" /* ServerError.MISSING_ANDROID_PACKAGE_NAME */]: \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */,\r\n    [\"UNAUTHORIZED_DOMAIN\" /* ServerError.UNAUTHORIZED_DOMAIN */]: \"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */,\r\n    // getProjectConfig errors when clientId is passed.\r\n    [\"INVALID_OAUTH_CLIENT_ID\" /* ServerError.INVALID_OAUTH_CLIENT_ID */]: \"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */,\r\n    // User actions (sign-up or deletion) disabled errors.\r\n    [\"ADMIN_ONLY_OPERATION\" /* ServerError.ADMIN_ONLY_OPERATION */]: \"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */,\r\n    // Multi factor related errors.\r\n    [\"INVALID_MFA_PENDING_CREDENTIAL\" /* ServerError.INVALID_MFA_PENDING_CREDENTIAL */]: \"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */,\r\n    [\"MFA_ENROLLMENT_NOT_FOUND\" /* ServerError.MFA_ENROLLMENT_NOT_FOUND */]: \"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */,\r\n    [\"MISSING_MFA_ENROLLMENT_ID\" /* ServerError.MISSING_MFA_ENROLLMENT_ID */]: \"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */,\r\n    [\"MISSING_MFA_PENDING_CREDENTIAL\" /* ServerError.MISSING_MFA_PENDING_CREDENTIAL */]: \"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */,\r\n    [\"SECOND_FACTOR_EXISTS\" /* ServerError.SECOND_FACTOR_EXISTS */]: \"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */,\r\n    [\"SECOND_FACTOR_LIMIT_EXCEEDED\" /* ServerError.SECOND_FACTOR_LIMIT_EXCEEDED */]: \"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */,\r\n    // Blocking functions related errors.\r\n    [\"BLOCKING_FUNCTION_ERROR_RESPONSE\" /* ServerError.BLOCKING_FUNCTION_ERROR_RESPONSE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\r\n    // Recaptcha related errors.\r\n    [\"RECAPTCHA_NOT_ENABLED\" /* ServerError.RECAPTCHA_NOT_ENABLED */]: \"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */,\r\n    [\"MISSING_RECAPTCHA_TOKEN\" /* ServerError.MISSING_RECAPTCHA_TOKEN */]: \"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */,\r\n    [\"INVALID_RECAPTCHA_TOKEN\" /* ServerError.INVALID_RECAPTCHA_TOKEN */]: \"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */,\r\n    [\"INVALID_RECAPTCHA_ACTION\" /* ServerError.INVALID_RECAPTCHA_ACTION */]: \"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */,\r\n    [\"MISSING_CLIENT_TYPE\" /* ServerError.MISSING_CLIENT_TYPE */]: \"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */,\r\n    [\"MISSING_RECAPTCHA_VERSION\" /* ServerError.MISSING_RECAPTCHA_VERSION */]: \"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */,\r\n    [\"INVALID_RECAPTCHA_VERSION\" /* ServerError.INVALID_RECAPTCHA_VERSION */]: \"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */,\r\n    [\"INVALID_REQ_TYPE\" /* ServerError.INVALID_REQ_TYPE */]: \"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */\r\n};\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_API_TIMEOUT_MS = new Delay(30000, 60000);\r\nfunction _addTidIfNecessary(auth, request) {\r\n    if (auth.tenantId && !request.tenantId) {\r\n        return Object.assign(Object.assign({}, request), { tenantId: auth.tenantId });\r\n    }\r\n    return request;\r\n}\r\nasync function _performApiRequest(auth, method, path, request, customErrorMap = {}) {\r\n    return _performFetchWithErrorHandling(auth, customErrorMap, async () => {\r\n        let body = {};\r\n        let params = {};\r\n        if (request) {\r\n            if (method === \"GET\" /* HttpMethod.GET */) {\r\n                params = request;\r\n            }\r\n            else {\r\n                body = {\r\n                    body: JSON.stringify(request)\r\n                };\r\n            }\r\n        }\r\n        const query = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(Object.assign({ key: auth.config.apiKey }, params)).slice(1);\r\n        const headers = await auth._getAdditionalHeaders();\r\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */] = 'application/json';\r\n        if (auth.languageCode) {\r\n            headers[\"X-Firebase-Locale\" /* HttpHeader.X_FIREBASE_LOCALE */] = auth.languageCode;\r\n        }\r\n        return FetchProvider.fetch()(_getFinalTarget(auth, auth.config.apiHost, path, query), Object.assign({ method,\r\n            headers, referrerPolicy: 'no-referrer' }, body));\r\n    });\r\n}\r\nasync function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {\r\n    auth._canInitEmulator = false;\r\n    const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);\r\n    try {\r\n        const networkTimeout = new NetworkTimeout(auth);\r\n        const response = await Promise.race([\r\n            fetchFn(),\r\n            networkTimeout.promise\r\n        ]);\r\n        // If we've reached this point, the fetch succeeded and the networkTimeout\r\n        // didn't throw; clear the network timeout delay so that Node won't hang\r\n        networkTimeout.clearNetworkTimeout();\r\n        const json = await response.json();\r\n        if ('needConfirmation' in json) {\r\n            throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */, json);\r\n        }\r\n        if (response.ok && !('errorMessage' in json)) {\r\n            return json;\r\n        }\r\n        else {\r\n            const errorMessage = response.ok ? json.errorMessage : json.error.message;\r\n            const [serverErrorCode, serverErrorMessage] = errorMessage.split(' : ');\r\n            if (serverErrorCode === \"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */) {\r\n                throw _makeTaggedError(auth, \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */, json);\r\n            }\r\n            else if (serverErrorCode === \"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */) {\r\n                throw _makeTaggedError(auth, \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */, json);\r\n            }\r\n            else if (serverErrorCode === \"USER_DISABLED\" /* ServerError.USER_DISABLED */) {\r\n                throw _makeTaggedError(auth, \"user-disabled\" /* AuthErrorCode.USER_DISABLED */, json);\r\n            }\r\n            const authError = errorMap[serverErrorCode] ||\r\n                serverErrorCode\r\n                    .toLowerCase()\r\n                    .replace(/[_\\s]+/g, '-');\r\n            if (serverErrorMessage) {\r\n                throw _errorWithCustomMessage(auth, authError, serverErrorMessage);\r\n            }\r\n            else {\r\n                _fail(auth, authError);\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError) {\r\n            throw e;\r\n        }\r\n        // Changing this to a different error code will log user out when there is a network error\r\n        // because we treat any error other than NETWORK_REQUEST_FAILED as token is invalid.\r\n        // https://github.com/firebase/firebase-js-sdk/blob/4fbc73610d70be4e0852e7de63a39cb7897e8546/packages/auth/src/core/auth/auth_impl.ts#L309-L316\r\n        _fail(auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */, { 'message': String(e) });\r\n    }\r\n}\r\nasync function _performSignInRequest(auth, method, path, request, customErrorMap = {}) {\r\n    const serverResponse = (await _performApiRequest(auth, method, path, request, customErrorMap));\r\n    if ('mfaPendingCredential' in serverResponse) {\r\n        _fail(auth, \"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */, {\r\n            _serverResponse: serverResponse\r\n        });\r\n    }\r\n    return serverResponse;\r\n}\r\nfunction _getFinalTarget(auth, host, path, query) {\r\n    const base = `${host}${path}?${query}`;\r\n    if (!auth.config.emulator) {\r\n        return `${auth.config.apiScheme}://${base}`;\r\n    }\r\n    return _emulatorUrl(auth.config, base);\r\n}\r\nfunction _parseEnforcementState(enforcementStateStr) {\r\n    switch (enforcementStateStr) {\r\n        case 'ENFORCE':\r\n            return \"ENFORCE\" /* EnforcementState.ENFORCE */;\r\n        case 'AUDIT':\r\n            return \"AUDIT\" /* EnforcementState.AUDIT */;\r\n        case 'OFF':\r\n            return \"OFF\" /* EnforcementState.OFF */;\r\n        default:\r\n            return \"ENFORCEMENT_STATE_UNSPECIFIED\" /* EnforcementState.ENFORCEMENT_STATE_UNSPECIFIED */;\r\n    }\r\n}\r\nclass NetworkTimeout {\r\n    constructor(auth) {\r\n        this.auth = auth;\r\n        // Node timers and browser timers are fundamentally incompatible, but we\r\n        // don't care about the value here\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        this.timer = null;\r\n        this.promise = new Promise((_, reject) => {\r\n            this.timer = setTimeout(() => {\r\n                return reject(_createError(this.auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));\r\n            }, DEFAULT_API_TIMEOUT_MS.get());\r\n        });\r\n    }\r\n    clearNetworkTimeout() {\r\n        clearTimeout(this.timer);\r\n    }\r\n}\r\nfunction _makeTaggedError(auth, code, response) {\r\n    const errorParams = {\r\n        appName: auth.name\r\n    };\r\n    if (response.email) {\r\n        errorParams.email = response.email;\r\n    }\r\n    if (response.phoneNumber) {\r\n        errorParams.phoneNumber = response.phoneNumber;\r\n    }\r\n    const error = _createError(auth, code, errorParams);\r\n    // We know customData is defined on error because errorParams is defined\r\n    error.customData._tokenResponse = response;\r\n    return error;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction isEnterprise(grecaptcha) {\r\n    return (grecaptcha !== undefined &&\r\n        grecaptcha.enterprise !== undefined);\r\n}\r\nclass RecaptchaConfig {\r\n    constructor(response) {\r\n        /**\r\n         * The reCAPTCHA site key.\r\n         */\r\n        this.siteKey = '';\r\n        /**\r\n         * The list of providers and their enablement status for reCAPTCHA Enterprise.\r\n         */\r\n        this.recaptchaEnforcementState = [];\r\n        if (response.recaptchaKey === undefined) {\r\n            throw new Error('recaptchaKey undefined');\r\n        }\r\n        // Example response.recaptchaKey: \"projects/proj123/keys/sitekey123\"\r\n        this.siteKey = response.recaptchaKey.split('/')[3];\r\n        this.recaptchaEnforcementState = response.recaptchaEnforcementState;\r\n    }\r\n    /**\r\n     * Returns the reCAPTCHA Enterprise enforcement state for the given provider.\r\n     *\r\n     * @param providerStr - The provider whose enforcement state is to be returned.\r\n     * @returns The reCAPTCHA Enterprise enforcement state for the given provider.\r\n     */\r\n    getProviderEnforcementState(providerStr) {\r\n        if (!this.recaptchaEnforcementState ||\r\n            this.recaptchaEnforcementState.length === 0) {\r\n            return null;\r\n        }\r\n        for (const recaptchaEnforcementState of this.recaptchaEnforcementState) {\r\n            if (recaptchaEnforcementState.provider &&\r\n                recaptchaEnforcementState.provider === providerStr) {\r\n                return _parseEnforcementState(recaptchaEnforcementState.enforcementState);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Returns true if the reCAPTCHA Enterprise enforcement state for the provider is set to ENFORCE or AUDIT.\r\n     *\r\n     * @param providerStr - The provider whose enablement state is to be returned.\r\n     * @returns Whether or not reCAPTCHA Enterprise protection is enabled for the given provider.\r\n     */\r\n    isProviderEnabled(providerStr) {\r\n        return (this.getProviderEnforcementState(providerStr) ===\r\n            \"ENFORCE\" /* EnforcementState.ENFORCE */ ||\r\n            this.getProviderEnforcementState(providerStr) === \"AUDIT\" /* EnforcementState.AUDIT */);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function getRecaptchaConfig(auth, request) {\r\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */, \"/v2/recaptchaConfig\" /* Endpoint.GET_RECAPTCHA_CONFIG */, _addTidIfNecessary(auth, request));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function deleteAccount(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:delete\" /* Endpoint.DELETE_ACCOUNT */, request);\r\n}\r\nasync function deleteLinkedAccounts(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\r\n}\r\nasync function getAccountInfo(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:lookup\" /* Endpoint.GET_ACCOUNT_INFO */, request);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction utcTimestampToDateString(utcTimestamp) {\r\n    if (!utcTimestamp) {\r\n        return undefined;\r\n    }\r\n    try {\r\n        // Convert to date object.\r\n        const date = new Date(Number(utcTimestamp));\r\n        // Test date is valid.\r\n        if (!isNaN(date.getTime())) {\r\n            // Convert to UTC date string.\r\n            return date.toUTCString();\r\n        }\r\n    }\r\n    catch (e) {\r\n        // Do nothing. undefined will be returned.\r\n    }\r\n    return undefined;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a JSON Web Token (JWT) used to identify the user to a Firebase service.\r\n *\r\n * @remarks\r\n * Returns the current token if it has not expired or if it will not expire in the next five\r\n * minutes. Otherwise, this will refresh the token and return a new one.\r\n *\r\n * @param user - The user.\r\n * @param forceRefresh - Force refresh regardless of token expiration.\r\n *\r\n * @public\r\n */\r\nfunction getIdToken(user, forceRefresh = false) {\r\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user).getIdToken(forceRefresh);\r\n}\r\n/**\r\n * Returns a deserialized JSON Web Token (JWT) used to identify the user to a Firebase service.\r\n *\r\n * @remarks\r\n * Returns the current token if it has not expired or if it will not expire in the next five\r\n * minutes. Otherwise, this will refresh the token and return a new one.\r\n *\r\n * @param user - The user.\r\n * @param forceRefresh - Force refresh regardless of token expiration.\r\n *\r\n * @public\r\n */\r\nasync function getIdTokenResult(user, forceRefresh = false) {\r\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\r\n    const token = await userInternal.getIdToken(forceRefresh);\r\n    const claims = _parseToken(token);\r\n    _assert(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n    const firebase = typeof claims.firebase === 'object' ? claims.firebase : undefined;\r\n    const signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_provider'];\r\n    return {\r\n        claims,\r\n        token,\r\n        authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),\r\n        issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),\r\n        expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),\r\n        signInProvider: signInProvider || null,\r\n        signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_second_factor']) || null\r\n    };\r\n}\r\nfunction secondsStringToMilliseconds(seconds) {\r\n    return Number(seconds) * 1000;\r\n}\r\nfunction _parseToken(token) {\r\n    const [algorithm, payload, signature] = token.split('.');\r\n    if (algorithm === undefined ||\r\n        payload === undefined ||\r\n        signature === undefined) {\r\n        _logError('JWT malformed, contained fewer than 3 sections');\r\n        return null;\r\n    }\r\n    try {\r\n        const decoded = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.base64Decode)(payload);\r\n        if (!decoded) {\r\n            _logError('Failed to decode base64 JWT payload');\r\n            return null;\r\n        }\r\n        return JSON.parse(decoded);\r\n    }\r\n    catch (e) {\r\n        _logError('Caught error parsing JWT payload as JSON', e === null || e === void 0 ? void 0 : e.toString());\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * Extract expiresIn TTL from a token by subtracting the expiration from the issuance.\r\n */\r\nfunction _tokenExpiresIn(token) {\r\n    const parsedToken = _parseToken(token);\r\n    _assert(parsedToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n    _assert(typeof parsedToken.exp !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n    _assert(typeof parsedToken.iat !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n    return Number(parsedToken.exp) - Number(parsedToken.iat);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function _logoutIfInvalidated(user, promise, bypassAuthState = false) {\r\n    if (bypassAuthState) {\r\n        return promise;\r\n    }\r\n    try {\r\n        return await promise;\r\n    }\r\n    catch (e) {\r\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError && isUserInvalidated(e)) {\r\n            if (user.auth.currentUser === user) {\r\n                await user.auth.signOut();\r\n            }\r\n        }\r\n        throw e;\r\n    }\r\n}\r\nfunction isUserInvalidated({ code }) {\r\n    return (code === `auth/${\"user-disabled\" /* AuthErrorCode.USER_DISABLED */}` ||\r\n        code === `auth/${\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */}`);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass ProactiveRefresh {\r\n    constructor(user) {\r\n        this.user = user;\r\n        this.isRunning = false;\r\n        // Node timers and browser timers return fundamentally different types.\r\n        // We don't actually care what the value is but TS won't accept unknown and\r\n        // we can't cast properly in both environments.\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        this.timerId = null;\r\n        this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;\r\n    }\r\n    _start() {\r\n        if (this.isRunning) {\r\n            return;\r\n        }\r\n        this.isRunning = true;\r\n        this.schedule();\r\n    }\r\n    _stop() {\r\n        if (!this.isRunning) {\r\n            return;\r\n        }\r\n        this.isRunning = false;\r\n        if (this.timerId !== null) {\r\n            clearTimeout(this.timerId);\r\n        }\r\n    }\r\n    getInterval(wasError) {\r\n        var _a;\r\n        if (wasError) {\r\n            const interval = this.errorBackoff;\r\n            this.errorBackoff = Math.min(this.errorBackoff * 2, 960000 /* Duration.RETRY_BACKOFF_MAX */);\r\n            return interval;\r\n        }\r\n        else {\r\n            // Reset the error backoff\r\n            this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;\r\n            const expTime = (_a = this.user.stsTokenManager.expirationTime) !== null && _a !== void 0 ? _a : 0;\r\n            const interval = expTime - Date.now() - 300000 /* Duration.OFFSET */;\r\n            return Math.max(0, interval);\r\n        }\r\n    }\r\n    schedule(wasError = false) {\r\n        if (!this.isRunning) {\r\n            // Just in case...\r\n            return;\r\n        }\r\n        const interval = this.getInterval(wasError);\r\n        this.timerId = setTimeout(async () => {\r\n            await this.iteration();\r\n        }, interval);\r\n    }\r\n    async iteration() {\r\n        try {\r\n            await this.user.getIdToken(true);\r\n        }\r\n        catch (e) {\r\n            // Only retry on network errors\r\n            if ((e === null || e === void 0 ? void 0 : e.code) ===\r\n                `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {\r\n                this.schedule(/* wasError */ true);\r\n            }\r\n            return;\r\n        }\r\n        this.schedule();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass UserMetadata {\r\n    constructor(createdAt, lastLoginAt) {\r\n        this.createdAt = createdAt;\r\n        this.lastLoginAt = lastLoginAt;\r\n        this._initializeTime();\r\n    }\r\n    _initializeTime() {\r\n        this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);\r\n        this.creationTime = utcTimestampToDateString(this.createdAt);\r\n    }\r\n    _copy(metadata) {\r\n        this.createdAt = metadata.createdAt;\r\n        this.lastLoginAt = metadata.lastLoginAt;\r\n        this._initializeTime();\r\n    }\r\n    toJSON() {\r\n        return {\r\n            createdAt: this.createdAt,\r\n            lastLoginAt: this.lastLoginAt\r\n        };\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function _reloadWithoutSaving(user) {\r\n    var _a;\r\n    const auth = user.auth;\r\n    const idToken = await user.getIdToken();\r\n    const response = await _logoutIfInvalidated(user, getAccountInfo(auth, { idToken }));\r\n    _assert(response === null || response === void 0 ? void 0 : response.users.length, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n    const coreAccount = response.users[0];\r\n    user._notifyReloadListener(coreAccount);\r\n    const newProviderData = ((_a = coreAccount.providerUserInfo) === null || _a === void 0 ? void 0 : _a.length)\r\n        ? extractProviderData(coreAccount.providerUserInfo)\r\n        : [];\r\n    const providerData = mergeProviderData(user.providerData, newProviderData);\r\n    // Preserves the non-nonymous status of the stored user, even if no more\r\n    // credentials (federated or email/password) are linked to the user. If\r\n    // the user was previously anonymous, then use provider data to update.\r\n    // On the other hand, if it was not anonymous before, it should never be\r\n    // considered anonymous now.\r\n    const oldIsAnonymous = user.isAnonymous;\r\n    const newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\r\n    const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;\r\n    const updates = {\r\n        uid: coreAccount.localId,\r\n        displayName: coreAccount.displayName || null,\r\n        photoURL: coreAccount.photoUrl || null,\r\n        email: coreAccount.email || null,\r\n        emailVerified: coreAccount.emailVerified || false,\r\n        phoneNumber: coreAccount.phoneNumber || null,\r\n        tenantId: coreAccount.tenantId || null,\r\n        providerData,\r\n        metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\r\n        isAnonymous\r\n    };\r\n    Object.assign(user, updates);\r\n}\r\n/**\r\n * Reloads user account data, if signed in.\r\n *\r\n * @param user - The user.\r\n *\r\n * @public\r\n */\r\nasync function reload(user) {\r\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\r\n    await _reloadWithoutSaving(userInternal);\r\n    // Even though the current user hasn't changed, update\r\n    // current user will trigger a persistence update w/ the\r\n    // new info.\r\n    await userInternal.auth._persistUserIfCurrent(userInternal);\r\n    userInternal.auth._notifyListenersIfCurrent(userInternal);\r\n}\r\nfunction mergeProviderData(original, newData) {\r\n    const deduped = original.filter(o => !newData.some(n => n.providerId === o.providerId));\r\n    return [...deduped, ...newData];\r\n}\r\nfunction extractProviderData(providers) {\r\n    return providers.map((_a) => {\r\n        var { providerId } = _a, provider = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__rest)(_a, [\"providerId\"]);\r\n        return {\r\n            providerId,\r\n            uid: provider.rawId || '',\r\n            displayName: provider.displayName || null,\r\n            email: provider.email || null,\r\n            phoneNumber: provider.phoneNumber || null,\r\n            photoURL: provider.photoUrl || null\r\n        };\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function requestStsToken(auth, refreshToken) {\r\n    const response = await _performFetchWithErrorHandling(auth, {}, async () => {\r\n        const body = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)({\r\n            'grant_type': 'refresh_token',\r\n            'refresh_token': refreshToken\r\n        }).slice(1);\r\n        const { tokenApiHost, apiKey } = auth.config;\r\n        const url = _getFinalTarget(auth, tokenApiHost, \"/v1/token\" /* Endpoint.TOKEN */, `key=${apiKey}`);\r\n        const headers = await auth._getAdditionalHeaders();\r\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */] = 'application/x-www-form-urlencoded';\r\n        return FetchProvider.fetch()(url, {\r\n            method: \"POST\" /* HttpMethod.POST */,\r\n            headers,\r\n            body\r\n        });\r\n    });\r\n    // The response comes back in snake_case. Convert to camel:\r\n    return {\r\n        accessToken: response.access_token,\r\n        expiresIn: response.expires_in,\r\n        refreshToken: response.refresh_token\r\n    };\r\n}\r\nasync function revokeToken(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts:revokeToken\" /* Endpoint.REVOKE_TOKEN */, _addTidIfNecessary(auth, request));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * We need to mark this class as internal explicitly to exclude it in the public typings, because\r\n * it references AuthInternal which has a circular dependency with UserInternal.\r\n *\r\n * @internal\r\n */\r\nclass StsTokenManager {\r\n    constructor() {\r\n        this.refreshToken = null;\r\n        this.accessToken = null;\r\n        this.expirationTime = null;\r\n    }\r\n    get isExpired() {\r\n        return (!this.expirationTime ||\r\n            Date.now() > this.expirationTime - 30000 /* Buffer.TOKEN_REFRESH */);\r\n    }\r\n    updateFromServerResponse(response) {\r\n        _assert(response.idToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        _assert(typeof response.idToken !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        _assert(typeof response.refreshToken !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        const expiresIn = 'expiresIn' in response && typeof response.expiresIn !== 'undefined'\r\n            ? Number(response.expiresIn)\r\n            : _tokenExpiresIn(response.idToken);\r\n        this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);\r\n    }\r\n    updateFromIdToken(idToken) {\r\n        _assert(idToken.length !== 0, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        const expiresIn = _tokenExpiresIn(idToken);\r\n        this.updateTokensAndExpiration(idToken, null, expiresIn);\r\n    }\r\n    async getToken(auth, forceRefresh = false) {\r\n        if (!forceRefresh && this.accessToken && !this.isExpired) {\r\n            return this.accessToken;\r\n        }\r\n        _assert(this.refreshToken, auth, \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */);\r\n        if (this.refreshToken) {\r\n            await this.refresh(auth, this.refreshToken);\r\n            return this.accessToken;\r\n        }\r\n        return null;\r\n    }\r\n    clearRefreshToken() {\r\n        this.refreshToken = null;\r\n    }\r\n    async refresh(auth, oldToken) {\r\n        const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth, oldToken);\r\n        this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));\r\n    }\r\n    updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {\r\n        this.refreshToken = refreshToken || null;\r\n        this.accessToken = accessToken || null;\r\n        this.expirationTime = Date.now() + expiresInSec * 1000;\r\n    }\r\n    static fromJSON(appName, object) {\r\n        const { refreshToken, accessToken, expirationTime } = object;\r\n        const manager = new StsTokenManager();\r\n        if (refreshToken) {\r\n            _assert(typeof refreshToken === 'string', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\r\n                appName\r\n            });\r\n            manager.refreshToken = refreshToken;\r\n        }\r\n        if (accessToken) {\r\n            _assert(typeof accessToken === 'string', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\r\n                appName\r\n            });\r\n            manager.accessToken = accessToken;\r\n        }\r\n        if (expirationTime) {\r\n            _assert(typeof expirationTime === 'number', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\r\n                appName\r\n            });\r\n            manager.expirationTime = expirationTime;\r\n        }\r\n        return manager;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            refreshToken: this.refreshToken,\r\n            accessToken: this.accessToken,\r\n            expirationTime: this.expirationTime\r\n        };\r\n    }\r\n    _assign(stsTokenManager) {\r\n        this.accessToken = stsTokenManager.accessToken;\r\n        this.refreshToken = stsTokenManager.refreshToken;\r\n        this.expirationTime = stsTokenManager.expirationTime;\r\n    }\r\n    _clone() {\r\n        return Object.assign(new StsTokenManager(), this.toJSON());\r\n    }\r\n    _performRefresh() {\r\n        return debugFail('not implemented');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction assertStringOrUndefined(assertion, appName) {\r\n    _assert(typeof assertion === 'string' || typeof assertion === 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, { appName });\r\n}\r\nclass UserImpl {\r\n    constructor(_a) {\r\n        var { uid, auth, stsTokenManager } = _a, opt = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__rest)(_a, [\"uid\", \"auth\", \"stsTokenManager\"]);\r\n        // For the user object, provider is always Firebase.\r\n        this.providerId = \"firebase\" /* ProviderId.FIREBASE */;\r\n        this.proactiveRefresh = new ProactiveRefresh(this);\r\n        this.reloadUserInfo = null;\r\n        this.reloadListener = null;\r\n        this.uid = uid;\r\n        this.auth = auth;\r\n        this.stsTokenManager = stsTokenManager;\r\n        this.accessToken = stsTokenManager.accessToken;\r\n        this.displayName = opt.displayName || null;\r\n        this.email = opt.email || null;\r\n        this.emailVerified = opt.emailVerified || false;\r\n        this.phoneNumber = opt.phoneNumber || null;\r\n        this.photoURL = opt.photoURL || null;\r\n        this.isAnonymous = opt.isAnonymous || false;\r\n        this.tenantId = opt.tenantId || null;\r\n        this.providerData = opt.providerData ? [...opt.providerData] : [];\r\n        this.metadata = new UserMetadata(opt.createdAt || undefined, opt.lastLoginAt || undefined);\r\n    }\r\n    async getIdToken(forceRefresh) {\r\n        const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));\r\n        _assert(accessToken, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        if (this.accessToken !== accessToken) {\r\n            this.accessToken = accessToken;\r\n            await this.auth._persistUserIfCurrent(this);\r\n            this.auth._notifyListenersIfCurrent(this);\r\n        }\r\n        return accessToken;\r\n    }\r\n    getIdTokenResult(forceRefresh) {\r\n        return getIdTokenResult(this, forceRefresh);\r\n    }\r\n    reload() {\r\n        return reload(this);\r\n    }\r\n    _assign(user) {\r\n        if (this === user) {\r\n            return;\r\n        }\r\n        _assert(this.uid === user.uid, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        this.displayName = user.displayName;\r\n        this.photoURL = user.photoURL;\r\n        this.email = user.email;\r\n        this.emailVerified = user.emailVerified;\r\n        this.phoneNumber = user.phoneNumber;\r\n        this.isAnonymous = user.isAnonymous;\r\n        this.tenantId = user.tenantId;\r\n        this.providerData = user.providerData.map(userInfo => (Object.assign({}, userInfo)));\r\n        this.metadata._copy(user.metadata);\r\n        this.stsTokenManager._assign(user.stsTokenManager);\r\n    }\r\n    _clone(auth) {\r\n        const newUser = new UserImpl(Object.assign(Object.assign({}, this), { auth, stsTokenManager: this.stsTokenManager._clone() }));\r\n        newUser.metadata._copy(this.metadata);\r\n        return newUser;\r\n    }\r\n    _onReload(callback) {\r\n        // There should only ever be one listener, and that is a single instance of MultiFactorUser\r\n        _assert(!this.reloadListener, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        this.reloadListener = callback;\r\n        if (this.reloadUserInfo) {\r\n            this._notifyReloadListener(this.reloadUserInfo);\r\n            this.reloadUserInfo = null;\r\n        }\r\n    }\r\n    _notifyReloadListener(userInfo) {\r\n        if (this.reloadListener) {\r\n            this.reloadListener(userInfo);\r\n        }\r\n        else {\r\n            // If no listener is subscribed yet, save the result so it's available when they do subscribe\r\n            this.reloadUserInfo = userInfo;\r\n        }\r\n    }\r\n    _startProactiveRefresh() {\r\n        this.proactiveRefresh._start();\r\n    }\r\n    _stopProactiveRefresh() {\r\n        this.proactiveRefresh._stop();\r\n    }\r\n    async _updateTokensIfNecessary(response, reload = false) {\r\n        let tokensRefreshed = false;\r\n        if (response.idToken &&\r\n            response.idToken !== this.stsTokenManager.accessToken) {\r\n            this.stsTokenManager.updateFromServerResponse(response);\r\n            tokensRefreshed = true;\r\n        }\r\n        if (reload) {\r\n            await _reloadWithoutSaving(this);\r\n        }\r\n        await this.auth._persistUserIfCurrent(this);\r\n        if (tokensRefreshed) {\r\n            this.auth._notifyListenersIfCurrent(this);\r\n        }\r\n    }\r\n    async delete() {\r\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.auth.app)) {\r\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this.auth));\r\n        }\r\n        const idToken = await this.getIdToken();\r\n        await _logoutIfInvalidated(this, deleteAccount(this.auth, { idToken }));\r\n        this.stsTokenManager.clearRefreshToken();\r\n        // TODO: Determine if cancellable-promises are necessary to use in this class so that delete()\r\n        //       cancels pending actions...\r\n        return this.auth.signOut();\r\n    }\r\n    toJSON() {\r\n        return Object.assign(Object.assign({ uid: this.uid, email: this.email || undefined, emailVerified: this.emailVerified, displayName: this.displayName || undefined, isAnonymous: this.isAnonymous, photoURL: this.photoURL || undefined, phoneNumber: this.phoneNumber || undefined, tenantId: this.tenantId || undefined, providerData: this.providerData.map(userInfo => (Object.assign({}, userInfo))), stsTokenManager: this.stsTokenManager.toJSON(), \r\n            // Redirect event ID must be maintained in case there is a pending\r\n            // redirect event.\r\n            _redirectEventId: this._redirectEventId }, this.metadata.toJSON()), { \r\n            // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):\r\n            apiKey: this.auth.config.apiKey, appName: this.auth.name });\r\n    }\r\n    get refreshToken() {\r\n        return this.stsTokenManager.refreshToken || '';\r\n    }\r\n    static _fromJSON(auth, object) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h;\r\n        const displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : undefined;\r\n        const email = (_b = object.email) !== null && _b !== void 0 ? _b : undefined;\r\n        const phoneNumber = (_c = object.phoneNumber) !== null && _c !== void 0 ? _c : undefined;\r\n        const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : undefined;\r\n        const tenantId = (_e = object.tenantId) !== null && _e !== void 0 ? _e : undefined;\r\n        const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : undefined;\r\n        const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : undefined;\r\n        const lastLoginAt = (_h = object.lastLoginAt) !== null && _h !== void 0 ? _h : undefined;\r\n        const { uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;\r\n        _assert(uid && plainObjectTokenManager, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);\r\n        _assert(typeof uid === 'string', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        assertStringOrUndefined(displayName, auth.name);\r\n        assertStringOrUndefined(email, auth.name);\r\n        _assert(typeof emailVerified === 'boolean', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        _assert(typeof isAnonymous === 'boolean', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        assertStringOrUndefined(phoneNumber, auth.name);\r\n        assertStringOrUndefined(photoURL, auth.name);\r\n        assertStringOrUndefined(tenantId, auth.name);\r\n        assertStringOrUndefined(_redirectEventId, auth.name);\r\n        assertStringOrUndefined(createdAt, auth.name);\r\n        assertStringOrUndefined(lastLoginAt, auth.name);\r\n        const user = new UserImpl({\r\n            uid,\r\n            auth,\r\n            email,\r\n            emailVerified,\r\n            displayName,\r\n            isAnonymous,\r\n            photoURL,\r\n            phoneNumber,\r\n            tenantId,\r\n            stsTokenManager,\r\n            createdAt,\r\n            lastLoginAt\r\n        });\r\n        if (providerData && Array.isArray(providerData)) {\r\n            user.providerData = providerData.map(userInfo => (Object.assign({}, userInfo)));\r\n        }\r\n        if (_redirectEventId) {\r\n            user._redirectEventId = _redirectEventId;\r\n        }\r\n        return user;\r\n    }\r\n    /**\r\n     * Initialize a User from an idToken server response\r\n     * @param auth\r\n     * @param idTokenResponse\r\n     */\r\n    static async _fromIdTokenResponse(auth, idTokenResponse, isAnonymous = false) {\r\n        const stsTokenManager = new StsTokenManager();\r\n        stsTokenManager.updateFromServerResponse(idTokenResponse);\r\n        // Initialize the Firebase Auth user.\r\n        const user = new UserImpl({\r\n            uid: idTokenResponse.localId,\r\n            auth,\r\n            stsTokenManager,\r\n            isAnonymous\r\n        });\r\n        // Updates the user info and data and resolves with a user instance.\r\n        await _reloadWithoutSaving(user);\r\n        return user;\r\n    }\r\n    /**\r\n     * Initialize a User from an idToken server response\r\n     * @param auth\r\n     * @param idTokenResponse\r\n     */\r\n    static async _fromGetAccountInfoResponse(auth, response, idToken) {\r\n        const coreAccount = response.users[0];\r\n        _assert(coreAccount.localId !== undefined, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        const providerData = coreAccount.providerUserInfo !== undefined\r\n            ? extractProviderData(coreAccount.providerUserInfo)\r\n            : [];\r\n        const isAnonymous = !(coreAccount.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\r\n        const stsTokenManager = new StsTokenManager();\r\n        stsTokenManager.updateFromIdToken(idToken);\r\n        // Initialize the Firebase Auth user.\r\n        const user = new UserImpl({\r\n            uid: coreAccount.localId,\r\n            auth,\r\n            stsTokenManager,\r\n            isAnonymous\r\n        });\r\n        // update the user with data from the GetAccountInfo response.\r\n        const updates = {\r\n            uid: coreAccount.localId,\r\n            displayName: coreAccount.displayName || null,\r\n            photoURL: coreAccount.photoUrl || null,\r\n            email: coreAccount.email || null,\r\n            emailVerified: coreAccount.emailVerified || false,\r\n            phoneNumber: coreAccount.phoneNumber || null,\r\n            tenantId: coreAccount.tenantId || null,\r\n            providerData,\r\n            metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\r\n            isAnonymous: !(coreAccount.email && coreAccount.passwordHash) &&\r\n                !(providerData === null || providerData === void 0 ? void 0 : providerData.length)\r\n        };\r\n        Object.assign(user, updates);\r\n        return user;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst instanceCache = new Map();\r\nfunction _getInstance(cls) {\r\n    debugAssert(cls instanceof Function, 'Expected a class definition');\r\n    let instance = instanceCache.get(cls);\r\n    if (instance) {\r\n        debugAssert(instance instanceof cls, 'Instance stored in cache mismatched with class');\r\n        return instance;\r\n    }\r\n    instance = new cls();\r\n    instanceCache.set(cls, instance);\r\n    return instance;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass InMemoryPersistence {\r\n    constructor() {\r\n        this.type = \"NONE\" /* PersistenceType.NONE */;\r\n        this.storage = {};\r\n    }\r\n    async _isAvailable() {\r\n        return true;\r\n    }\r\n    async _set(key, value) {\r\n        this.storage[key] = value;\r\n    }\r\n    async _get(key) {\r\n        const value = this.storage[key];\r\n        return value === undefined ? null : value;\r\n    }\r\n    async _remove(key) {\r\n        delete this.storage[key];\r\n    }\r\n    _addListener(_key, _listener) {\r\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\r\n        return;\r\n    }\r\n    _removeListener(_key, _listener) {\r\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\r\n        return;\r\n    }\r\n}\r\nInMemoryPersistence.type = 'NONE';\r\n/**\r\n * An implementation of {@link Persistence} of type 'NONE'.\r\n *\r\n * @public\r\n */\r\nconst inMemoryPersistence = InMemoryPersistence;\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction _persistenceKeyName(key, apiKey, appName) {\r\n    return `${\"firebase\" /* Namespace.PERSISTENCE */}:${key}:${apiKey}:${appName}`;\r\n}\r\nclass PersistenceUserManager {\r\n    constructor(persistence, auth, userKey) {\r\n        this.persistence = persistence;\r\n        this.auth = auth;\r\n        this.userKey = userKey;\r\n        const { config, name } = this.auth;\r\n        this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name);\r\n        this.fullPersistenceKey = _persistenceKeyName(\"persistence\" /* KeyName.PERSISTENCE_USER */, config.apiKey, name);\r\n        this.boundEventHandler = auth._onStorageEvent.bind(auth);\r\n        this.persistence._addListener(this.fullUserKey, this.boundEventHandler);\r\n    }\r\n    setCurrentUser(user) {\r\n        return this.persistence._set(this.fullUserKey, user.toJSON());\r\n    }\r\n    async getCurrentUser() {\r\n        const blob = await this.persistence._get(this.fullUserKey);\r\n        return blob ? UserImpl._fromJSON(this.auth, blob) : null;\r\n    }\r\n    removeCurrentUser() {\r\n        return this.persistence._remove(this.fullUserKey);\r\n    }\r\n    savePersistenceForRedirect() {\r\n        return this.persistence._set(this.fullPersistenceKey, this.persistence.type);\r\n    }\r\n    async setPersistence(newPersistence) {\r\n        if (this.persistence === newPersistence) {\r\n            return;\r\n        }\r\n        const currentUser = await this.getCurrentUser();\r\n        await this.removeCurrentUser();\r\n        this.persistence = newPersistence;\r\n        if (currentUser) {\r\n            return this.setCurrentUser(currentUser);\r\n        }\r\n    }\r\n    delete() {\r\n        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);\r\n    }\r\n    static async create(auth, persistenceHierarchy, userKey = \"authUser\" /* KeyName.AUTH_USER */) {\r\n        if (!persistenceHierarchy.length) {\r\n            return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey);\r\n        }\r\n        // Eliminate any persistences that are not available\r\n        const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence) => {\r\n            if (await persistence._isAvailable()) {\r\n                return persistence;\r\n            }\r\n            return undefined;\r\n        }))).filter(persistence => persistence);\r\n        // Fall back to the first persistence listed, or in memory if none available\r\n        let selectedPersistence = availablePersistences[0] ||\r\n            _getInstance(inMemoryPersistence);\r\n        const key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);\r\n        // Pull out the existing user, setting the chosen persistence to that\r\n        // persistence if the user exists.\r\n        let userToMigrate = null;\r\n        // Note, here we check for a user in _all_ persistences, not just the\r\n        // ones deemed available. If we can migrate a user out of a broken\r\n        // persistence, we will (but only if that persistence supports migration).\r\n        for (const persistence of persistenceHierarchy) {\r\n            try {\r\n                const blob = await persistence._get(key);\r\n                if (blob) {\r\n                    const user = UserImpl._fromJSON(auth, blob); // throws for unparsable blob (wrong format)\r\n                    if (persistence !== selectedPersistence) {\r\n                        userToMigrate = user;\r\n                    }\r\n                    selectedPersistence = persistence;\r\n                    break;\r\n                }\r\n            }\r\n            catch (_a) { }\r\n        }\r\n        // If we find the user in a persistence that does support migration, use\r\n        // that migration path (of only persistences that support migration)\r\n        const migrationHierarchy = availablePersistences.filter(p => p._shouldAllowMigration);\r\n        // If the persistence does _not_ allow migration, just finish off here\r\n        if (!selectedPersistence._shouldAllowMigration ||\r\n            !migrationHierarchy.length) {\r\n            return new PersistenceUserManager(selectedPersistence, auth, userKey);\r\n        }\r\n        selectedPersistence = migrationHierarchy[0];\r\n        if (userToMigrate) {\r\n            // This normally shouldn't throw since chosenPersistence.isAvailable() is true, but if it does\r\n            // we'll just let it bubble to surface the error.\r\n            await selectedPersistence._set(key, userToMigrate.toJSON());\r\n        }\r\n        // Attempt to clear the key in other persistences but ignore errors. This helps prevent issues\r\n        // such as users getting stuck with a previous account after signing out and refreshing the tab.\r\n        await Promise.all(persistenceHierarchy.map(async (persistence) => {\r\n            if (persistence !== selectedPersistence) {\r\n                try {\r\n                    await persistence._remove(key);\r\n                }\r\n                catch (_a) { }\r\n            }\r\n        }));\r\n        return new PersistenceUserManager(selectedPersistence, auth, userKey);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Determine the browser for the purposes of reporting usage to the API\r\n */\r\nfunction _getBrowserName(userAgent) {\r\n    const ua = userAgent.toLowerCase();\r\n    if (ua.includes('opera/') || ua.includes('opr/') || ua.includes('opios/')) {\r\n        return \"Opera\" /* BrowserName.OPERA */;\r\n    }\r\n    else if (_isIEMobile(ua)) {\r\n        // Windows phone IEMobile browser.\r\n        return \"IEMobile\" /* BrowserName.IEMOBILE */;\r\n    }\r\n    else if (ua.includes('msie') || ua.includes('trident/')) {\r\n        return \"IE\" /* BrowserName.IE */;\r\n    }\r\n    else if (ua.includes('edge/')) {\r\n        return \"Edge\" /* BrowserName.EDGE */;\r\n    }\r\n    else if (_isFirefox(ua)) {\r\n        return \"Firefox\" /* BrowserName.FIREFOX */;\r\n    }\r\n    else if (ua.includes('silk/')) {\r\n        return \"Silk\" /* BrowserName.SILK */;\r\n    }\r\n    else if (_isBlackBerry(ua)) {\r\n        // Blackberry browser.\r\n        return \"Blackberry\" /* BrowserName.BLACKBERRY */;\r\n    }\r\n    else if (_isWebOS(ua)) {\r\n        // WebOS default browser.\r\n        return \"Webos\" /* BrowserName.WEBOS */;\r\n    }\r\n    else if (_isSafari(ua)) {\r\n        return \"Safari\" /* BrowserName.SAFARI */;\r\n    }\r\n    else if ((ua.includes('chrome/') || _isChromeIOS(ua)) &&\r\n        !ua.includes('edge/')) {\r\n        return \"Chrome\" /* BrowserName.CHROME */;\r\n    }\r\n    else if (_isAndroid(ua)) {\r\n        // Android stock browser.\r\n        return \"Android\" /* BrowserName.ANDROID */;\r\n    }\r\n    else {\r\n        // Most modern browsers have name/version at end of user agent string.\r\n        const re = /([a-zA-Z\\d\\.]+)\\/[a-zA-Z\\d\\.]*$/;\r\n        const matches = userAgent.match(re);\r\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {\r\n            return matches[1];\r\n        }\r\n    }\r\n    return \"Other\" /* BrowserName.OTHER */;\r\n}\r\nfunction _isFirefox(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\r\n    return /firefox\\//i.test(ua);\r\n}\r\nfunction _isSafari(userAgent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\r\n    const ua = userAgent.toLowerCase();\r\n    return (ua.includes('safari/') &&\r\n        !ua.includes('chrome/') &&\r\n        !ua.includes('crios/') &&\r\n        !ua.includes('android'));\r\n}\r\nfunction _isChromeIOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\r\n    return /crios\\//i.test(ua);\r\n}\r\nfunction _isIEMobile(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\r\n    return /iemobile/i.test(ua);\r\n}\r\nfunction _isAndroid(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\r\n    return /android/i.test(ua);\r\n}\r\nfunction _isBlackBerry(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\r\n    return /blackberry/i.test(ua);\r\n}\r\nfunction _isWebOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\r\n    return /webos/i.test(ua);\r\n}\r\nfunction _isIOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\r\n    return (/iphone|ipad|ipod/i.test(ua) ||\r\n        (/macintosh/i.test(ua) && /mobile/i.test(ua)));\r\n}\r\nfunction _isIOS7Or8(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\r\n    return (/(iPad|iPhone|iPod).*OS 7_\\d/i.test(ua) ||\r\n        /(iPad|iPhone|iPod).*OS 8_\\d/i.test(ua));\r\n}\r\nfunction _isIE10() {\r\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isIE)() && document.documentMode === 10;\r\n}\r\nfunction _isMobileBrowser(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\r\n    // TODO: implement getBrowserName equivalent for OS.\r\n    return (_isIOS(ua) ||\r\n        _isAndroid(ua) ||\r\n        _isWebOS(ua) ||\r\n        _isBlackBerry(ua) ||\r\n        /windows phone/i.test(ua) ||\r\n        _isIEMobile(ua));\r\n}\r\nfunction _isIframe() {\r\n    try {\r\n        // Check that the current window is not the top window.\r\n        // If so, return true.\r\n        return !!(window && window !== window.top);\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/*\r\n * Determine the SDK version string\r\n */\r\nfunction _getClientVersion(clientPlatform, frameworks = []) {\r\n    let reportedPlatform;\r\n    switch (clientPlatform) {\r\n        case \"Browser\" /* ClientPlatform.BROWSER */:\r\n            // In a browser environment, report the browser name.\r\n            reportedPlatform = _getBrowserName((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)());\r\n            break;\r\n        case \"Worker\" /* ClientPlatform.WORKER */:\r\n            // Technically a worker runs from a browser but we need to differentiate a\r\n            // worker from a browser.\r\n            // For example: Chrome-Worker/JsCore/4.9.1/FirebaseCore-web.\r\n            reportedPlatform = `${_getBrowserName((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)())}-${clientPlatform}`;\r\n            break;\r\n        default:\r\n            reportedPlatform = clientPlatform;\r\n    }\r\n    const reportedFrameworks = frameworks.length\r\n        ? frameworks.join(',')\r\n        : 'FirebaseCore-web'; /* default value if no other framework is used */\r\n    return `${reportedPlatform}/${\"JsCore\" /* ClientImplementation.CORE */}/${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}/${reportedFrameworks}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass AuthMiddlewareQueue {\r\n    constructor(auth) {\r\n        this.auth = auth;\r\n        this.queue = [];\r\n    }\r\n    pushCallback(callback, onAbort) {\r\n        // The callback could be sync or async. Wrap it into a\r\n        // function that is always async.\r\n        const wrappedCallback = (user) => new Promise((resolve, reject) => {\r\n            try {\r\n                const result = callback(user);\r\n                // Either resolve with existing promise or wrap a non-promise\r\n                // return value into a promise.\r\n                resolve(result);\r\n            }\r\n            catch (e) {\r\n                // Sync callback throws.\r\n                reject(e);\r\n            }\r\n        });\r\n        // Attach the onAbort if present\r\n        wrappedCallback.onAbort = onAbort;\r\n        this.queue.push(wrappedCallback);\r\n        const index = this.queue.length - 1;\r\n        return () => {\r\n            // Unsubscribe. Replace with no-op. Do not remove from array, or it will disturb\r\n            // indexing of other elements.\r\n            this.queue[index] = () => Promise.resolve();\r\n        };\r\n    }\r\n    async runMiddleware(nextUser) {\r\n        if (this.auth.currentUser === nextUser) {\r\n            return;\r\n        }\r\n        // While running the middleware, build a temporary stack of onAbort\r\n        // callbacks to call if one middleware callback rejects.\r\n        const onAbortStack = [];\r\n        try {\r\n            for (const beforeStateCallback of this.queue) {\r\n                await beforeStateCallback(nextUser);\r\n                // Only push the onAbort if the callback succeeds\r\n                if (beforeStateCallback.onAbort) {\r\n                    onAbortStack.push(beforeStateCallback.onAbort);\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            // Run all onAbort, with separate try/catch to ignore any errors and\r\n            // continue\r\n            onAbortStack.reverse();\r\n            for (const onAbort of onAbortStack) {\r\n                try {\r\n                    onAbort();\r\n                }\r\n                catch (_) {\r\n                    /* swallow error */\r\n                }\r\n            }\r\n            throw this.auth._errorFactory.create(\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */, {\r\n                originalMessage: e === null || e === void 0 ? void 0 : e.message\r\n            });\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Fetches the password policy for the currently set tenant or the project if no tenant is set.\r\n *\r\n * @param auth Auth object.\r\n * @param request Password policy request.\r\n * @returns Password policy response.\r\n */\r\nasync function _getPasswordPolicy(auth, request = {}) {\r\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */, \"/v2/passwordPolicy\" /* Endpoint.GET_PASSWORD_POLICY */, _addTidIfNecessary(auth, request));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Minimum min password length enforced by the backend, even if no minimum length is set.\r\nconst MINIMUM_MIN_PASSWORD_LENGTH = 6;\r\n/**\r\n * Stores password policy requirements and provides password validation against the policy.\r\n *\r\n * @internal\r\n */\r\nclass PasswordPolicyImpl {\r\n    constructor(response) {\r\n        var _a, _b, _c, _d;\r\n        // Only include custom strength options defined in the response.\r\n        const responseOptions = response.customStrengthOptions;\r\n        this.customStrengthOptions = {};\r\n        // TODO: Remove once the backend is updated to include the minimum min password length instead of undefined when there is no minimum length set.\r\n        this.customStrengthOptions.minPasswordLength =\r\n            (_a = responseOptions.minPasswordLength) !== null && _a !== void 0 ? _a : MINIMUM_MIN_PASSWORD_LENGTH;\r\n        if (responseOptions.maxPasswordLength) {\r\n            this.customStrengthOptions.maxPasswordLength =\r\n                responseOptions.maxPasswordLength;\r\n        }\r\n        if (responseOptions.containsLowercaseCharacter !== undefined) {\r\n            this.customStrengthOptions.containsLowercaseLetter =\r\n                responseOptions.containsLowercaseCharacter;\r\n        }\r\n        if (responseOptions.containsUppercaseCharacter !== undefined) {\r\n            this.customStrengthOptions.containsUppercaseLetter =\r\n                responseOptions.containsUppercaseCharacter;\r\n        }\r\n        if (responseOptions.containsNumericCharacter !== undefined) {\r\n            this.customStrengthOptions.containsNumericCharacter =\r\n                responseOptions.containsNumericCharacter;\r\n        }\r\n        if (responseOptions.containsNonAlphanumericCharacter !== undefined) {\r\n            this.customStrengthOptions.containsNonAlphanumericCharacter =\r\n                responseOptions.containsNonAlphanumericCharacter;\r\n        }\r\n        this.enforcementState = response.enforcementState;\r\n        if (this.enforcementState === 'ENFORCEMENT_STATE_UNSPECIFIED') {\r\n            this.enforcementState = 'OFF';\r\n        }\r\n        // Use an empty string if no non-alphanumeric characters are specified in the response.\r\n        this.allowedNonAlphanumericCharacters =\r\n            (_c = (_b = response.allowedNonAlphanumericCharacters) === null || _b === void 0 ? void 0 : _b.join('')) !== null && _c !== void 0 ? _c : '';\r\n        this.forceUpgradeOnSignin = (_d = response.forceUpgradeOnSignin) !== null && _d !== void 0 ? _d : false;\r\n        this.schemaVersion = response.schemaVersion;\r\n    }\r\n    validatePassword(password) {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        const status = {\r\n            isValid: true,\r\n            passwordPolicy: this\r\n        };\r\n        // Check the password length and character options.\r\n        this.validatePasswordLengthOptions(password, status);\r\n        this.validatePasswordCharacterOptions(password, status);\r\n        // Combine the status into single isValid property.\r\n        status.isValid && (status.isValid = (_a = status.meetsMinPasswordLength) !== null && _a !== void 0 ? _a : true);\r\n        status.isValid && (status.isValid = (_b = status.meetsMaxPasswordLength) !== null && _b !== void 0 ? _b : true);\r\n        status.isValid && (status.isValid = (_c = status.containsLowercaseLetter) !== null && _c !== void 0 ? _c : true);\r\n        status.isValid && (status.isValid = (_d = status.containsUppercaseLetter) !== null && _d !== void 0 ? _d : true);\r\n        status.isValid && (status.isValid = (_e = status.containsNumericCharacter) !== null && _e !== void 0 ? _e : true);\r\n        status.isValid && (status.isValid = (_f = status.containsNonAlphanumericCharacter) !== null && _f !== void 0 ? _f : true);\r\n        return status;\r\n    }\r\n    /**\r\n     * Validates that the password meets the length options for the policy.\r\n     *\r\n     * @param password Password to validate.\r\n     * @param status Validation status.\r\n     */\r\n    validatePasswordLengthOptions(password, status) {\r\n        const minPasswordLength = this.customStrengthOptions.minPasswordLength;\r\n        const maxPasswordLength = this.customStrengthOptions.maxPasswordLength;\r\n        if (minPasswordLength) {\r\n            status.meetsMinPasswordLength = password.length >= minPasswordLength;\r\n        }\r\n        if (maxPasswordLength) {\r\n            status.meetsMaxPasswordLength = password.length <= maxPasswordLength;\r\n        }\r\n    }\r\n    /**\r\n     * Validates that the password meets the character options for the policy.\r\n     *\r\n     * @param password Password to validate.\r\n     * @param status Validation status.\r\n     */\r\n    validatePasswordCharacterOptions(password, status) {\r\n        // Assign statuses for requirements even if the password is an empty string.\r\n        this.updatePasswordCharacterOptionsStatuses(status, \r\n        /* containsLowercaseCharacter= */ false, \r\n        /* containsUppercaseCharacter= */ false, \r\n        /* containsNumericCharacter= */ false, \r\n        /* containsNonAlphanumericCharacter= */ false);\r\n        let passwordChar;\r\n        for (let i = 0; i < password.length; i++) {\r\n            passwordChar = password.charAt(i);\r\n            this.updatePasswordCharacterOptionsStatuses(status, \r\n            /* containsLowercaseCharacter= */ passwordChar >= 'a' &&\r\n                passwordChar <= 'z', \r\n            /* containsUppercaseCharacter= */ passwordChar >= 'A' &&\r\n                passwordChar <= 'Z', \r\n            /* containsNumericCharacter= */ passwordChar >= '0' &&\r\n                passwordChar <= '9', \r\n            /* containsNonAlphanumericCharacter= */ this.allowedNonAlphanumericCharacters.includes(passwordChar));\r\n        }\r\n    }\r\n    /**\r\n     * Updates the running validation status with the statuses for the character options.\r\n     * Expected to be called each time a character is processed to update each option status\r\n     * based on the current character.\r\n     *\r\n     * @param status Validation status.\r\n     * @param containsLowercaseCharacter Whether the character is a lowercase letter.\r\n     * @param containsUppercaseCharacter Whether the character is an uppercase letter.\r\n     * @param containsNumericCharacter Whether the character is a numeric character.\r\n     * @param containsNonAlphanumericCharacter Whether the character is a non-alphanumeric character.\r\n     */\r\n    updatePasswordCharacterOptionsStatuses(status, containsLowercaseCharacter, containsUppercaseCharacter, containsNumericCharacter, containsNonAlphanumericCharacter) {\r\n        if (this.customStrengthOptions.containsLowercaseLetter) {\r\n            status.containsLowercaseLetter || (status.containsLowercaseLetter = containsLowercaseCharacter);\r\n        }\r\n        if (this.customStrengthOptions.containsUppercaseLetter) {\r\n            status.containsUppercaseLetter || (status.containsUppercaseLetter = containsUppercaseCharacter);\r\n        }\r\n        if (this.customStrengthOptions.containsNumericCharacter) {\r\n            status.containsNumericCharacter || (status.containsNumericCharacter = containsNumericCharacter);\r\n        }\r\n        if (this.customStrengthOptions.containsNonAlphanumericCharacter) {\r\n            status.containsNonAlphanumericCharacter || (status.containsNonAlphanumericCharacter = containsNonAlphanumericCharacter);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass AuthImpl {\r\n    constructor(app, heartbeatServiceProvider, appCheckServiceProvider, config) {\r\n        this.app = app;\r\n        this.heartbeatServiceProvider = heartbeatServiceProvider;\r\n        this.appCheckServiceProvider = appCheckServiceProvider;\r\n        this.config = config;\r\n        this.currentUser = null;\r\n        this.emulatorConfig = null;\r\n        this.operations = Promise.resolve();\r\n        this.authStateSubscription = new Subscription(this);\r\n        this.idTokenSubscription = new Subscription(this);\r\n        this.beforeStateQueue = new AuthMiddlewareQueue(this);\r\n        this.redirectUser = null;\r\n        this.isProactiveRefreshEnabled = false;\r\n        this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1;\r\n        // Any network calls will set this to true and prevent subsequent emulator\r\n        // initialization\r\n        this._canInitEmulator = true;\r\n        this._isInitialized = false;\r\n        this._deleted = false;\r\n        this._initializationPromise = null;\r\n        this._popupRedirectResolver = null;\r\n        this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;\r\n        this._agentRecaptchaConfig = null;\r\n        this._tenantRecaptchaConfigs = {};\r\n        this._projectPasswordPolicy = null;\r\n        this._tenantPasswordPolicies = {};\r\n        // Tracks the last notified UID for state change listeners to prevent\r\n        // repeated calls to the callbacks. Undefined means it's never been\r\n        // called, whereas null means it's been called with a signed out user\r\n        this.lastNotifiedUid = undefined;\r\n        this.languageCode = null;\r\n        this.tenantId = null;\r\n        this.settings = { appVerificationDisabledForTesting: false };\r\n        this.frameworks = [];\r\n        this.name = app.name;\r\n        this.clientVersion = config.sdkClientVersion;\r\n    }\r\n    _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {\r\n        if (popupRedirectResolver) {\r\n            this._popupRedirectResolver = _getInstance(popupRedirectResolver);\r\n        }\r\n        // Have to check for app deletion throughout initialization (after each\r\n        // promise resolution)\r\n        this._initializationPromise = this.queue(async () => {\r\n            var _a, _b;\r\n            if (this._deleted) {\r\n                return;\r\n            }\r\n            this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);\r\n            if (this._deleted) {\r\n                return;\r\n            }\r\n            // Initialize the resolver early if necessary (only applicable to web:\r\n            // this will cause the iframe to load immediately in certain cases)\r\n            if ((_a = this._popupRedirectResolver) === null || _a === void 0 ? void 0 : _a._shouldInitProactively) {\r\n                // If this fails, don't halt auth loading\r\n                try {\r\n                    await this._popupRedirectResolver._initialize(this);\r\n                }\r\n                catch (e) {\r\n                    /* Ignore the error */\r\n                }\r\n            }\r\n            await this.initializeCurrentUser(popupRedirectResolver);\r\n            this.lastNotifiedUid = ((_b = this.currentUser) === null || _b === void 0 ? void 0 : _b.uid) || null;\r\n            if (this._deleted) {\r\n                return;\r\n            }\r\n            this._isInitialized = true;\r\n        });\r\n        return this._initializationPromise;\r\n    }\r\n    /**\r\n     * If the persistence is changed in another window, the user manager will let us know\r\n     */\r\n    async _onStorageEvent() {\r\n        if (this._deleted) {\r\n            return;\r\n        }\r\n        const user = await this.assertedPersistence.getCurrentUser();\r\n        if (!this.currentUser && !user) {\r\n            // No change, do nothing (was signed out and remained signed out).\r\n            return;\r\n        }\r\n        // If the same user is to be synchronized.\r\n        if (this.currentUser && user && this.currentUser.uid === user.uid) {\r\n            // Data update, simply copy data changes.\r\n            this._currentUser._assign(user);\r\n            // If tokens changed from previous user tokens, this will trigger\r\n            // notifyAuthListeners_.\r\n            await this.currentUser.getIdToken();\r\n            return;\r\n        }\r\n        // Update current Auth state. Either a new login or logout.\r\n        // Skip blocking callbacks, they should not apply to a change in another tab.\r\n        await this._updateCurrentUser(user, /* skipBeforeStateCallbacks */ true);\r\n    }\r\n    async initializeCurrentUserFromIdToken(idToken) {\r\n        try {\r\n            const response = await getAccountInfo(this, { idToken });\r\n            const user = await UserImpl._fromGetAccountInfoResponse(this, response, idToken);\r\n            await this.directlySetCurrentUser(user);\r\n        }\r\n        catch (err) {\r\n            console.warn('FirebaseServerApp could not login user with provided authIdToken: ', err);\r\n            await this.directlySetCurrentUser(null);\r\n        }\r\n    }\r\n    async initializeCurrentUser(popupRedirectResolver) {\r\n        var _a;\r\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\r\n            const idToken = this.app.settings.authIdToken;\r\n            if (idToken) {\r\n                // Start the auth operation in the next tick to allow a moment for the customer's app to\r\n                // attach an emulator, if desired.\r\n                return new Promise(resolve => {\r\n                    setTimeout(() => this.initializeCurrentUserFromIdToken(idToken).then(resolve, resolve));\r\n                });\r\n            }\r\n            else {\r\n                return this.directlySetCurrentUser(null);\r\n            }\r\n        }\r\n        // First check to see if we have a pending redirect event.\r\n        const previouslyStoredUser = (await this.assertedPersistence.getCurrentUser());\r\n        let futureCurrentUser = previouslyStoredUser;\r\n        let needsTocheckMiddleware = false;\r\n        if (popupRedirectResolver && this.config.authDomain) {\r\n            await this.getOrInitRedirectPersistenceManager();\r\n            const redirectUserEventId = (_a = this.redirectUser) === null || _a === void 0 ? void 0 : _a._redirectEventId;\r\n            const storedUserEventId = futureCurrentUser === null || futureCurrentUser === void 0 ? void 0 : futureCurrentUser._redirectEventId;\r\n            const result = await this.tryRedirectSignIn(popupRedirectResolver);\r\n            // If the stored user (i.e. the old \"currentUser\") has a redirectId that\r\n            // matches the redirect user, then we want to initially sign in with the\r\n            // new user object from result.\r\n            // TODO(samgho): More thoroughly test all of this\r\n            if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) &&\r\n                (result === null || result === void 0 ? void 0 : result.user)) {\r\n                futureCurrentUser = result.user;\r\n                needsTocheckMiddleware = true;\r\n            }\r\n        }\r\n        // If no user in persistence, there is no current user. Set to null.\r\n        if (!futureCurrentUser) {\r\n            return this.directlySetCurrentUser(null);\r\n        }\r\n        if (!futureCurrentUser._redirectEventId) {\r\n            // This isn't a redirect link operation, we can reload and bail.\r\n            // First though, ensure that we check the middleware is happy.\r\n            if (needsTocheckMiddleware) {\r\n                try {\r\n                    await this.beforeStateQueue.runMiddleware(futureCurrentUser);\r\n                }\r\n                catch (e) {\r\n                    futureCurrentUser = previouslyStoredUser;\r\n                    // We know this is available since the bit is only set when the\r\n                    // resolver is available\r\n                    this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(e));\r\n                }\r\n            }\r\n            if (futureCurrentUser) {\r\n                return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\r\n            }\r\n            else {\r\n                return this.directlySetCurrentUser(null);\r\n            }\r\n        }\r\n        _assert(this._popupRedirectResolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n        await this.getOrInitRedirectPersistenceManager();\r\n        // If the redirect user's event ID matches the current user's event ID,\r\n        // DO NOT reload the current user, otherwise they'll be cleared from storage.\r\n        // This is important for the reauthenticateWithRedirect() flow.\r\n        if (this.redirectUser &&\r\n            this.redirectUser._redirectEventId === futureCurrentUser._redirectEventId) {\r\n            return this.directlySetCurrentUser(futureCurrentUser);\r\n        }\r\n        return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\r\n    }\r\n    async tryRedirectSignIn(redirectResolver) {\r\n        // The redirect user needs to be checked (and signed in if available)\r\n        // during auth initialization. All of the normal sign in and link/reauth\r\n        // flows call back into auth and push things onto the promise queue. We\r\n        // need to await the result of the redirect sign in *inside the promise\r\n        // queue*. This presents a problem: we run into deadlock. See:\r\n        //    ┌> [Initialization] ─────┐\r\n        //    ┌> [<other queue tasks>] │\r\n        //    └─ [getRedirectResult] <─┘\r\n        //    where [] are tasks on the queue and arrows denote awaits\r\n        // Initialization will never complete because it's waiting on something\r\n        // that's waiting for initialization to complete!\r\n        //\r\n        // Instead, this method calls getRedirectResult() (stored in\r\n        // _completeRedirectFn) with an optional parameter that instructs all of\r\n        // the underlying auth operations to skip anything that mutates auth state.\r\n        let result = null;\r\n        try {\r\n            // We know this._popupRedirectResolver is set since redirectResolver\r\n            // is passed in. The _completeRedirectFn expects the unwrapped extern.\r\n            result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);\r\n        }\r\n        catch (e) {\r\n            // Swallow any errors here; the code can retrieve them in\r\n            // getRedirectResult().\r\n            await this._setRedirectUser(null);\r\n        }\r\n        return result;\r\n    }\r\n    async reloadAndSetCurrentUserOrClear(user) {\r\n        try {\r\n            await _reloadWithoutSaving(user);\r\n        }\r\n        catch (e) {\r\n            if ((e === null || e === void 0 ? void 0 : e.code) !==\r\n                `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {\r\n                // Something's wrong with the user's token. Log them out and remove\r\n                // them from storage\r\n                return this.directlySetCurrentUser(null);\r\n            }\r\n        }\r\n        return this.directlySetCurrentUser(user);\r\n    }\r\n    useDeviceLanguage() {\r\n        this.languageCode = _getUserLanguage();\r\n    }\r\n    async _delete() {\r\n        this._deleted = true;\r\n    }\r\n    async updateCurrentUser(userExtern) {\r\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\r\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\r\n        }\r\n        // The public updateCurrentUser method needs to make a copy of the user,\r\n        // and also check that the project matches\r\n        const user = userExtern\r\n            ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(userExtern)\r\n            : null;\r\n        if (user) {\r\n            _assert(user.auth.config.apiKey === this.config.apiKey, this, \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */);\r\n        }\r\n        return this._updateCurrentUser(user && user._clone(this));\r\n    }\r\n    async _updateCurrentUser(user, skipBeforeStateCallbacks = false) {\r\n        if (this._deleted) {\r\n            return;\r\n        }\r\n        if (user) {\r\n            _assert(this.tenantId === user.tenantId, this, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */);\r\n        }\r\n        if (!skipBeforeStateCallbacks) {\r\n            await this.beforeStateQueue.runMiddleware(user);\r\n        }\r\n        return this.queue(async () => {\r\n            await this.directlySetCurrentUser(user);\r\n            this.notifyAuthListeners();\r\n        });\r\n    }\r\n    async signOut() {\r\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\r\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\r\n        }\r\n        // Run first, to block _setRedirectUser() if any callbacks fail.\r\n        await this.beforeStateQueue.runMiddleware(null);\r\n        // Clear the redirect user when signOut is called\r\n        if (this.redirectPersistenceManager || this._popupRedirectResolver) {\r\n            await this._setRedirectUser(null);\r\n        }\r\n        // Prevent callbacks from being called again in _updateCurrentUser, as\r\n        // they were already called in the first line.\r\n        return this._updateCurrentUser(null, /* skipBeforeStateCallbacks */ true);\r\n    }\r\n    setPersistence(persistence) {\r\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\r\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\r\n        }\r\n        return this.queue(async () => {\r\n            await this.assertedPersistence.setPersistence(_getInstance(persistence));\r\n        });\r\n    }\r\n    _getRecaptchaConfig() {\r\n        if (this.tenantId == null) {\r\n            return this._agentRecaptchaConfig;\r\n        }\r\n        else {\r\n            return this._tenantRecaptchaConfigs[this.tenantId];\r\n        }\r\n    }\r\n    async validatePassword(password) {\r\n        if (!this._getPasswordPolicyInternal()) {\r\n            await this._updatePasswordPolicy();\r\n        }\r\n        // Password policy will be defined after fetching.\r\n        const passwordPolicy = this._getPasswordPolicyInternal();\r\n        // Check that the policy schema version is supported by the SDK.\r\n        // TODO: Update this logic to use a max supported policy schema version once we have multiple schema versions.\r\n        if (passwordPolicy.schemaVersion !==\r\n            this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION) {\r\n            return Promise.reject(this._errorFactory.create(\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */, {}));\r\n        }\r\n        return passwordPolicy.validatePassword(password);\r\n    }\r\n    _getPasswordPolicyInternal() {\r\n        if (this.tenantId === null) {\r\n            return this._projectPasswordPolicy;\r\n        }\r\n        else {\r\n            return this._tenantPasswordPolicies[this.tenantId];\r\n        }\r\n    }\r\n    async _updatePasswordPolicy() {\r\n        const response = await _getPasswordPolicy(this);\r\n        const passwordPolicy = new PasswordPolicyImpl(response);\r\n        if (this.tenantId === null) {\r\n            this._projectPasswordPolicy = passwordPolicy;\r\n        }\r\n        else {\r\n            this._tenantPasswordPolicies[this.tenantId] = passwordPolicy;\r\n        }\r\n    }\r\n    _getPersistence() {\r\n        return this.assertedPersistence.persistence.type;\r\n    }\r\n    _updateErrorMap(errorMap) {\r\n        this._errorFactory = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory('auth', 'Firebase', errorMap());\r\n    }\r\n    onAuthStateChanged(nextOrObserver, error, completed) {\r\n        return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);\r\n    }\r\n    beforeAuthStateChanged(callback, onAbort) {\r\n        return this.beforeStateQueue.pushCallback(callback, onAbort);\r\n    }\r\n    onIdTokenChanged(nextOrObserver, error, completed) {\r\n        return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);\r\n    }\r\n    authStateReady() {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.currentUser) {\r\n                resolve();\r\n            }\r\n            else {\r\n                const unsubscribe = this.onAuthStateChanged(() => {\r\n                    unsubscribe();\r\n                    resolve();\r\n                }, reject);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Revokes the given access token. Currently only supports Apple OAuth access tokens.\r\n     */\r\n    async revokeAccessToken(token) {\r\n        if (this.currentUser) {\r\n            const idToken = await this.currentUser.getIdToken();\r\n            // Generalize this to accept other providers once supported.\r\n            const request = {\r\n                providerId: 'apple.com',\r\n                tokenType: \"ACCESS_TOKEN\" /* TokenType.ACCESS_TOKEN */,\r\n                token,\r\n                idToken\r\n            };\r\n            if (this.tenantId != null) {\r\n                request.tenantId = this.tenantId;\r\n            }\r\n            await revokeToken(this, request);\r\n        }\r\n    }\r\n    toJSON() {\r\n        var _a;\r\n        return {\r\n            apiKey: this.config.apiKey,\r\n            authDomain: this.config.authDomain,\r\n            appName: this.name,\r\n            currentUser: (_a = this._currentUser) === null || _a === void 0 ? void 0 : _a.toJSON()\r\n        };\r\n    }\r\n    async _setRedirectUser(user, popupRedirectResolver) {\r\n        const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);\r\n        return user === null\r\n            ? redirectManager.removeCurrentUser()\r\n            : redirectManager.setCurrentUser(user);\r\n    }\r\n    async getOrInitRedirectPersistenceManager(popupRedirectResolver) {\r\n        if (!this.redirectPersistenceManager) {\r\n            const resolver = (popupRedirectResolver && _getInstance(popupRedirectResolver)) ||\r\n                this._popupRedirectResolver;\r\n            _assert(resolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n            this.redirectPersistenceManager = await PersistenceUserManager.create(this, [_getInstance(resolver._redirectPersistence)], \"redirectUser\" /* KeyName.REDIRECT_USER */);\r\n            this.redirectUser =\r\n                await this.redirectPersistenceManager.getCurrentUser();\r\n        }\r\n        return this.redirectPersistenceManager;\r\n    }\r\n    async _redirectUserForId(id) {\r\n        var _a, _b;\r\n        // Make sure we've cleared any pending persistence actions if we're not in\r\n        // the initializer\r\n        if (this._isInitialized) {\r\n            await this.queue(async () => { });\r\n        }\r\n        if (((_a = this._currentUser) === null || _a === void 0 ? void 0 : _a._redirectEventId) === id) {\r\n            return this._currentUser;\r\n        }\r\n        if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id) {\r\n            return this.redirectUser;\r\n        }\r\n        return null;\r\n    }\r\n    async _persistUserIfCurrent(user) {\r\n        if (user === this.currentUser) {\r\n            return this.queue(async () => this.directlySetCurrentUser(user));\r\n        }\r\n    }\r\n    /** Notifies listeners only if the user is current */\r\n    _notifyListenersIfCurrent(user) {\r\n        if (user === this.currentUser) {\r\n            this.notifyAuthListeners();\r\n        }\r\n    }\r\n    _key() {\r\n        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;\r\n    }\r\n    _startProactiveRefresh() {\r\n        this.isProactiveRefreshEnabled = true;\r\n        if (this.currentUser) {\r\n            this._currentUser._startProactiveRefresh();\r\n        }\r\n    }\r\n    _stopProactiveRefresh() {\r\n        this.isProactiveRefreshEnabled = false;\r\n        if (this.currentUser) {\r\n            this._currentUser._stopProactiveRefresh();\r\n        }\r\n    }\r\n    /** Returns the current user cast as the internal type */\r\n    get _currentUser() {\r\n        return this.currentUser;\r\n    }\r\n    notifyAuthListeners() {\r\n        var _a, _b;\r\n        if (!this._isInitialized) {\r\n            return;\r\n        }\r\n        this.idTokenSubscription.next(this.currentUser);\r\n        const currentUid = (_b = (_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.uid) !== null && _b !== void 0 ? _b : null;\r\n        if (this.lastNotifiedUid !== currentUid) {\r\n            this.lastNotifiedUid = currentUid;\r\n            this.authStateSubscription.next(this.currentUser);\r\n        }\r\n    }\r\n    registerStateListener(subscription, nextOrObserver, error, completed) {\r\n        if (this._deleted) {\r\n            return () => { };\r\n        }\r\n        const cb = typeof nextOrObserver === 'function'\r\n            ? nextOrObserver\r\n            : nextOrObserver.next.bind(nextOrObserver);\r\n        let isUnsubscribed = false;\r\n        const promise = this._isInitialized\r\n            ? Promise.resolve()\r\n            : this._initializationPromise;\r\n        _assert(promise, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        // The callback needs to be called asynchronously per the spec.\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        promise.then(() => {\r\n            if (isUnsubscribed) {\r\n                return;\r\n            }\r\n            cb(this.currentUser);\r\n        });\r\n        if (typeof nextOrObserver === 'function') {\r\n            const unsubscribe = subscription.addObserver(nextOrObserver, error, completed);\r\n            return () => {\r\n                isUnsubscribed = true;\r\n                unsubscribe();\r\n            };\r\n        }\r\n        else {\r\n            const unsubscribe = subscription.addObserver(nextOrObserver);\r\n            return () => {\r\n                isUnsubscribed = true;\r\n                unsubscribe();\r\n            };\r\n        }\r\n    }\r\n    /**\r\n     * Unprotected (from race conditions) method to set the current user. This\r\n     * should only be called from within a queued callback. This is necessary\r\n     * because the queue shouldn't rely on another queued callback.\r\n     */\r\n    async directlySetCurrentUser(user) {\r\n        if (this.currentUser && this.currentUser !== user) {\r\n            this._currentUser._stopProactiveRefresh();\r\n        }\r\n        if (user && this.isProactiveRefreshEnabled) {\r\n            user._startProactiveRefresh();\r\n        }\r\n        this.currentUser = user;\r\n        if (user) {\r\n            await this.assertedPersistence.setCurrentUser(user);\r\n        }\r\n        else {\r\n            await this.assertedPersistence.removeCurrentUser();\r\n        }\r\n    }\r\n    queue(action) {\r\n        // In case something errors, the callback still should be called in order\r\n        // to keep the promise chain alive\r\n        this.operations = this.operations.then(action, action);\r\n        return this.operations;\r\n    }\r\n    get assertedPersistence() {\r\n        _assert(this.persistenceManager, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        return this.persistenceManager;\r\n    }\r\n    _logFramework(framework) {\r\n        if (!framework || this.frameworks.includes(framework)) {\r\n            return;\r\n        }\r\n        this.frameworks.push(framework);\r\n        // Sort alphabetically so that \"FirebaseCore-web,FirebaseUI-web\" and\r\n        // \"FirebaseUI-web,FirebaseCore-web\" aren't viewed as different.\r\n        this.frameworks.sort();\r\n        this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());\r\n    }\r\n    _getFrameworks() {\r\n        return this.frameworks;\r\n    }\r\n    async _getAdditionalHeaders() {\r\n        var _a;\r\n        // Additional headers on every request\r\n        const headers = {\r\n            [\"X-Client-Version\" /* HttpHeader.X_CLIENT_VERSION */]: this.clientVersion\r\n        };\r\n        if (this.app.options.appId) {\r\n            headers[\"X-Firebase-gmpid\" /* HttpHeader.X_FIREBASE_GMPID */] = this.app.options.appId;\r\n        }\r\n        // If the heartbeat service exists, add the heartbeat string\r\n        const heartbeatsHeader = await ((_a = this.heartbeatServiceProvider\r\n            .getImmediate({\r\n            optional: true\r\n        })) === null || _a === void 0 ? void 0 : _a.getHeartbeatsHeader());\r\n        if (heartbeatsHeader) {\r\n            headers[\"X-Firebase-Client\" /* HttpHeader.X_FIREBASE_CLIENT */] = heartbeatsHeader;\r\n        }\r\n        // If the App Check service exists, add the App Check token in the headers\r\n        const appCheckToken = await this._getAppCheckToken();\r\n        if (appCheckToken) {\r\n            headers[\"X-Firebase-AppCheck\" /* HttpHeader.X_FIREBASE_APP_CHECK */] = appCheckToken;\r\n        }\r\n        return headers;\r\n    }\r\n    async _getAppCheckToken() {\r\n        var _a;\r\n        const appCheckTokenResult = await ((_a = this.appCheckServiceProvider\r\n            .getImmediate({ optional: true })) === null || _a === void 0 ? void 0 : _a.getToken());\r\n        if (appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.error) {\r\n            // Context: appCheck.getToken() will never throw even if an error happened.\r\n            // In the error case, a dummy token will be returned along with an error field describing\r\n            // the error. In general, we shouldn't care about the error condition and just use\r\n            // the token (actual or dummy) to send requests.\r\n            _logWarn(`Error while retrieving App Check token: ${appCheckTokenResult.error}`);\r\n        }\r\n        return appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.token;\r\n    }\r\n}\r\n/**\r\n * Method to be used to cast down to our private implmentation of Auth.\r\n * It will also handle unwrapping from the compat type if necessary\r\n *\r\n * @param auth Auth object passed in from developer\r\n */\r\nfunction _castAuth(auth) {\r\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\r\n}\r\n/** Helper class to wrap subscriber logic */\r\nclass Subscription {\r\n    constructor(auth) {\r\n        this.auth = auth;\r\n        this.observer = null;\r\n        this.addObserver = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createSubscribe)(observer => (this.observer = observer));\r\n    }\r\n    get next() {\r\n        _assert(this.observer, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        return this.observer.next.bind(this.observer);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet externalJSProvider = {\r\n    async loadJS() {\r\n        throw new Error('Unable to load external scripts');\r\n    },\r\n    recaptchaV2Script: '',\r\n    recaptchaEnterpriseScript: '',\r\n    gapiScript: ''\r\n};\r\nfunction _loadJS(url) {\r\n    return externalJSProvider.loadJS(url);\r\n}\r\nfunction _recaptchaEnterpriseScriptUrl() {\r\n    return externalJSProvider.recaptchaEnterpriseScript;\r\n}\n\n/* eslint-disable @typescript-eslint/no-require-imports */\r\nconst RECAPTCHA_ENTERPRISE_VERIFIER_TYPE = 'recaptcha-enterprise';\r\nconst FAKE_TOKEN = 'NO_RECAPTCHA';\r\nclass RecaptchaEnterpriseVerifier {\r\n    /**\r\n     *\r\n     * @param authExtern - The corresponding Firebase {@link Auth} instance.\r\n     *\r\n     */\r\n    constructor(authExtern) {\r\n        /**\r\n         * Identifies the type of application verifier (e.g. \"recaptcha-enterprise\").\r\n         */\r\n        this.type = RECAPTCHA_ENTERPRISE_VERIFIER_TYPE;\r\n        this.auth = _castAuth(authExtern);\r\n    }\r\n    /**\r\n     * Executes the verification process.\r\n     *\r\n     * @returns A Promise for a token that can be used to assert the validity of a request.\r\n     */\r\n    async verify(action = 'verify', forceRefresh = false) {\r\n        async function retrieveSiteKey(auth) {\r\n            if (!forceRefresh) {\r\n                if (auth.tenantId == null && auth._agentRecaptchaConfig != null) {\r\n                    return auth._agentRecaptchaConfig.siteKey;\r\n                }\r\n                if (auth.tenantId != null &&\r\n                    auth._tenantRecaptchaConfigs[auth.tenantId] !== undefined) {\r\n                    return auth._tenantRecaptchaConfigs[auth.tenantId].siteKey;\r\n                }\r\n            }\r\n            return new Promise(async (resolve, reject) => {\r\n                getRecaptchaConfig(auth, {\r\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\r\n                    version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\r\n                })\r\n                    .then(response => {\r\n                    if (response.recaptchaKey === undefined) {\r\n                        reject(new Error('recaptcha Enterprise site key undefined'));\r\n                    }\r\n                    else {\r\n                        const config = new RecaptchaConfig(response);\r\n                        if (auth.tenantId == null) {\r\n                            auth._agentRecaptchaConfig = config;\r\n                        }\r\n                        else {\r\n                            auth._tenantRecaptchaConfigs[auth.tenantId] = config;\r\n                        }\r\n                        return resolve(config.siteKey);\r\n                    }\r\n                })\r\n                    .catch(error => {\r\n                    reject(error);\r\n                });\r\n            });\r\n        }\r\n        function retrieveRecaptchaToken(siteKey, resolve, reject) {\r\n            const grecaptcha = window.grecaptcha;\r\n            if (isEnterprise(grecaptcha)) {\r\n                grecaptcha.enterprise.ready(() => {\r\n                    grecaptcha.enterprise\r\n                        .execute(siteKey, { action })\r\n                        .then(token => {\r\n                        resolve(token);\r\n                    })\r\n                        .catch(() => {\r\n                        resolve(FAKE_TOKEN);\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                reject(Error('No reCAPTCHA enterprise script loaded.'));\r\n            }\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            retrieveSiteKey(this.auth)\r\n                .then(siteKey => {\r\n                if (!forceRefresh && isEnterprise(window.grecaptcha)) {\r\n                    retrieveRecaptchaToken(siteKey, resolve, reject);\r\n                }\r\n                else {\r\n                    if (typeof window === 'undefined') {\r\n                        reject(new Error('RecaptchaVerifier is only supported in browser'));\r\n                        return;\r\n                    }\r\n                    let url = _recaptchaEnterpriseScriptUrl();\r\n                    if (url.length !== 0) {\r\n                        url += siteKey;\r\n                    }\r\n                    _loadJS(url)\r\n                        .then(() => {\r\n                        retrieveRecaptchaToken(siteKey, resolve, reject);\r\n                    })\r\n                        .catch(error => {\r\n                        reject(error);\r\n                    });\r\n                }\r\n            })\r\n                .catch(error => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n}\r\nasync function injectRecaptchaFields(auth, request, action, captchaResp = false) {\r\n    const verifier = new RecaptchaEnterpriseVerifier(auth);\r\n    let captchaResponse;\r\n    try {\r\n        captchaResponse = await verifier.verify(action);\r\n    }\r\n    catch (error) {\r\n        captchaResponse = await verifier.verify(action, true);\r\n    }\r\n    const newRequest = Object.assign({}, request);\r\n    if (!captchaResp) {\r\n        Object.assign(newRequest, { captchaResponse });\r\n    }\r\n    else {\r\n        Object.assign(newRequest, { 'captchaResp': captchaResponse });\r\n    }\r\n    Object.assign(newRequest, { 'clientType': \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ });\r\n    Object.assign(newRequest, {\r\n        'recaptchaVersion': \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\r\n    });\r\n    return newRequest;\r\n}\r\nasync function handleRecaptchaFlow(authInstance, request, actionName, actionMethod) {\r\n    var _a;\r\n    if ((_a = authInstance\r\n        ._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaProvider.EMAIL_PASSWORD_PROVIDER */)) {\r\n        const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */);\r\n        return actionMethod(authInstance, requestWithRecaptcha);\r\n    }\r\n    else {\r\n        return actionMethod(authInstance, request).catch(async (error) => {\r\n            if (error.code === `auth/${\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}`) {\r\n                console.log(`${actionName} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);\r\n                const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */);\r\n                return actionMethod(authInstance, requestWithRecaptcha);\r\n            }\r\n            else {\r\n                return Promise.reject(error);\r\n            }\r\n        });\r\n    }\r\n}\r\nasync function _initializeRecaptchaConfig(auth) {\r\n    const authInternal = _castAuth(auth);\r\n    const response = await getRecaptchaConfig(authInternal, {\r\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\r\n        version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\r\n    });\r\n    const config = new RecaptchaConfig(response);\r\n    if (authInternal.tenantId == null) {\r\n        authInternal._agentRecaptchaConfig = config;\r\n    }\r\n    else {\r\n        authInternal._tenantRecaptchaConfigs[authInternal.tenantId] = config;\r\n    }\r\n    if (config.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaProvider.EMAIL_PASSWORD_PROVIDER */)) {\r\n        const verifier = new RecaptchaEnterpriseVerifier(authInternal);\r\n        void verifier.verify();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Initializes an {@link Auth} instance with fine-grained control over\r\n * {@link Dependencies}.\r\n *\r\n * @remarks\r\n *\r\n * This function allows more control over the {@link Auth} instance than\r\n * {@link getAuth}. `getAuth` uses platform-specific defaults to supply\r\n * the {@link Dependencies}. In general, `getAuth` is the easiest way to\r\n * initialize Auth and works for most use cases. Use `initializeAuth` if you\r\n * need control over which persistence layer is used, or to minimize bundle\r\n * size if you're not using either `signInWithPopup` or `signInWithRedirect`.\r\n *\r\n * For example, if your app only uses anonymous accounts and you only want\r\n * accounts saved for the current session, initialize `Auth` with:\r\n *\r\n * ```js\r\n * const auth = initializeAuth(app, {\r\n *   persistence: browserSessionPersistence,\r\n *   popupRedirectResolver: undefined,\r\n * });\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction initializeAuth(app, deps) {\r\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'auth');\r\n    if (provider.isInitialized()) {\r\n        const auth = provider.getImmediate();\r\n        const initialOptions = provider.getOptions();\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {\r\n            return auth;\r\n        }\r\n        else {\r\n            _fail(auth, \"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */);\r\n        }\r\n    }\r\n    const auth = provider.initialize({ options: deps });\r\n    return auth;\r\n}\r\nfunction _initializeAuthInstance(auth, deps) {\r\n    const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];\r\n    const hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);\r\n    if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {\r\n        auth._updateErrorMap(deps.errorMap);\r\n    }\r\n    // This promise is intended to float; auth initialization happens in the\r\n    // background, meanwhile the auth object may be used by the app.\r\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n    auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);\r\n}\n\n/**\r\n * Changes the {@link Auth} instance to communicate with the Firebase Auth Emulator, instead of production\r\n * Firebase Auth services.\r\n *\r\n * @remarks\r\n * This must be called synchronously immediately following the first call to\r\n * {@link initializeAuth}.  Do not use with production credentials as emulator\r\n * traffic is not encrypted.\r\n *\r\n *\r\n * @example\r\n * ```javascript\r\n * connectAuthEmulator(auth, 'http://127.0.0.1:9099', { disableWarnings: true });\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param url - The URL at which the emulator is running (eg, 'http://localhost:9099').\r\n * @param options - Optional. `options.disableWarnings` defaults to `false`. Set it to\r\n * `true` to disable the warning banner attached to the DOM.\r\n *\r\n * @public\r\n */\r\nfunction connectAuthEmulator(auth, url, options) {\r\n    const authInternal = _castAuth(auth);\r\n    _assert(authInternal._canInitEmulator, authInternal, \"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */);\r\n    _assert(/^https?:\\/\\//.test(url), authInternal, \"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */);\r\n    const disableWarnings = !!(options === null || options === void 0 ? void 0 : options.disableWarnings);\r\n    const protocol = extractProtocol(url);\r\n    const { host, port } = extractHostAndPort(url);\r\n    const portStr = port === null ? '' : `:${port}`;\r\n    // Always replace path with \"/\" (even if input url had no path at all, or had a different one).\r\n    authInternal.config.emulator = { url: `${protocol}//${host}${portStr}/` };\r\n    authInternal.settings.appVerificationDisabledForTesting = true;\r\n    authInternal.emulatorConfig = Object.freeze({\r\n        host,\r\n        port,\r\n        protocol: protocol.replace(':', ''),\r\n        options: Object.freeze({ disableWarnings })\r\n    });\r\n    if (!disableWarnings) {\r\n        emitEmulatorWarning();\r\n    }\r\n}\r\nfunction extractProtocol(url) {\r\n    const protocolEnd = url.indexOf(':');\r\n    return protocolEnd < 0 ? '' : url.substr(0, protocolEnd + 1);\r\n}\r\nfunction extractHostAndPort(url) {\r\n    const protocol = extractProtocol(url);\r\n    const authority = /(\\/\\/)?([^?#/]+)/.exec(url.substr(protocol.length)); // Between // and /, ? or #.\r\n    if (!authority) {\r\n        return { host: '', port: null };\r\n    }\r\n    const hostAndPort = authority[2].split('@').pop() || ''; // Strip out \"username:password@\".\r\n    const bracketedIPv6 = /^(\\[[^\\]]+\\])(:|$)/.exec(hostAndPort);\r\n    if (bracketedIPv6) {\r\n        const host = bracketedIPv6[1];\r\n        return { host, port: parsePort(hostAndPort.substr(host.length + 1)) };\r\n    }\r\n    else {\r\n        const [host, port] = hostAndPort.split(':');\r\n        return { host, port: parsePort(port) };\r\n    }\r\n}\r\nfunction parsePort(portStr) {\r\n    if (!portStr) {\r\n        return null;\r\n    }\r\n    const port = Number(portStr);\r\n    if (isNaN(port)) {\r\n        return null;\r\n    }\r\n    return port;\r\n}\r\nfunction emitEmulatorWarning() {\r\n    function attachBanner() {\r\n        const el = document.createElement('p');\r\n        const sty = el.style;\r\n        el.innerText =\r\n            'Running in emulator mode. Do not use with production credentials.';\r\n        sty.position = 'fixed';\r\n        sty.width = '100%';\r\n        sty.backgroundColor = '#ffffff';\r\n        sty.border = '.1em solid #000000';\r\n        sty.color = '#b50000';\r\n        sty.bottom = '0px';\r\n        sty.left = '0px';\r\n        sty.margin = '0px';\r\n        sty.zIndex = '10000';\r\n        sty.textAlign = 'center';\r\n        el.classList.add('firebase-emulator-warning');\r\n        document.body.appendChild(el);\r\n    }\r\n    if (typeof console !== 'undefined' && typeof console.info === 'function') {\r\n        console.info('WARNING: You are using the Auth Emulator,' +\r\n            ' which is intended for local testing only.  Do not use with' +\r\n            ' production credentials.');\r\n    }\r\n    if (typeof window !== 'undefined' && typeof document !== 'undefined') {\r\n        if (document.readyState === 'loading') {\r\n            window.addEventListener('DOMContentLoaded', attachBanner);\r\n        }\r\n        else {\r\n            attachBanner();\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Interface that represents the credentials returned by an {@link AuthProvider}.\r\n *\r\n * @remarks\r\n * Implementations specify the details about each auth provider's credential requirements.\r\n *\r\n * @public\r\n */\r\nclass AuthCredential {\r\n    /** @internal */\r\n    constructor(\r\n    /**\r\n     * The authentication provider ID for the credential.\r\n     *\r\n     * @remarks\r\n     * For example, 'facebook.com', or 'google.com'.\r\n     */\r\n    providerId, \r\n    /**\r\n     * The authentication sign in method for the credential.\r\n     *\r\n     * @remarks\r\n     * For example, {@link SignInMethod}.EMAIL_PASSWORD, or\r\n     * {@link SignInMethod}.EMAIL_LINK. This corresponds to the sign-in method\r\n     * identifier as returned in {@link fetchSignInMethodsForEmail}.\r\n     */\r\n    signInMethod) {\r\n        this.providerId = providerId;\r\n        this.signInMethod = signInMethod;\r\n    }\r\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     *\r\n     * @returns a JSON-serializable representation of this object.\r\n     */\r\n    toJSON() {\r\n        return debugFail('not implemented');\r\n    }\r\n    /** @internal */\r\n    _getIdTokenResponse(_auth) {\r\n        return debugFail('not implemented');\r\n    }\r\n    /** @internal */\r\n    _linkToIdToken(_auth, _idToken) {\r\n        return debugFail('not implemented');\r\n    }\r\n    /** @internal */\r\n    _getReauthenticationResolver(_auth) {\r\n        return debugFail('not implemented');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function resetPassword(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:resetPassword\" /* Endpoint.RESET_PASSWORD */, _addTidIfNecessary(auth, request));\r\n}\r\nasync function updateEmailPassword(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\r\n}\r\n// Used for linking an email/password account to an existing idToken. Uses the same request/response\r\n// format as updateEmailPassword.\r\nasync function linkEmailPassword(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */, request);\r\n}\r\nasync function applyActionCode$1(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, _addTidIfNecessary(auth, request));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function signInWithPassword(auth, request) {\r\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPassword\" /* Endpoint.SIGN_IN_WITH_PASSWORD */, _addTidIfNecessary(auth, request));\r\n}\r\nasync function sendOobCode(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:sendOobCode\" /* Endpoint.SEND_OOB_CODE */, _addTidIfNecessary(auth, request));\r\n}\r\nasync function sendEmailVerification$1(auth, request) {\r\n    return sendOobCode(auth, request);\r\n}\r\nasync function sendPasswordResetEmail$1(auth, request) {\r\n    return sendOobCode(auth, request);\r\n}\r\nasync function sendSignInLinkToEmail$1(auth, request) {\r\n    return sendOobCode(auth, request);\r\n}\r\nasync function verifyAndChangeEmail(auth, request) {\r\n    return sendOobCode(auth, request);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function signInWithEmailLink$1(auth, request) {\r\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));\r\n}\r\nasync function signInWithEmailLinkForLinking(auth, request) {\r\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Interface that represents the credentials returned by {@link EmailAuthProvider} for\r\n * {@link ProviderId}.PASSWORD\r\n *\r\n * @remarks\r\n * Covers both {@link SignInMethod}.EMAIL_PASSWORD and\r\n * {@link SignInMethod}.EMAIL_LINK.\r\n *\r\n * @public\r\n */\r\nclass EmailAuthCredential extends AuthCredential {\r\n    /** @internal */\r\n    constructor(\r\n    /** @internal */\r\n    _email, \r\n    /** @internal */\r\n    _password, signInMethod, \r\n    /** @internal */\r\n    _tenantId = null) {\r\n        super(\"password\" /* ProviderId.PASSWORD */, signInMethod);\r\n        this._email = _email;\r\n        this._password = _password;\r\n        this._tenantId = _tenantId;\r\n    }\r\n    /** @internal */\r\n    static _fromEmailAndPassword(email, password) {\r\n        return new EmailAuthCredential(email, password, \"password\" /* SignInMethod.EMAIL_PASSWORD */);\r\n    }\r\n    /** @internal */\r\n    static _fromEmailAndCode(email, oobCode, tenantId = null) {\r\n        return new EmailAuthCredential(email, oobCode, \"emailLink\" /* SignInMethod.EMAIL_LINK */, tenantId);\r\n    }\r\n    /** {@inheritdoc AuthCredential.toJSON} */\r\n    toJSON() {\r\n        return {\r\n            email: this._email,\r\n            password: this._password,\r\n            signInMethod: this.signInMethod,\r\n            tenantId: this._tenantId\r\n        };\r\n    }\r\n    /**\r\n     * Static method to deserialize a JSON representation of an object into an {@link  AuthCredential}.\r\n     *\r\n     * @param json - Either `object` or the stringified representation of the object. When string is\r\n     * provided, `JSON.parse` would be called first.\r\n     *\r\n     * @returns If the JSON input does not represent an {@link AuthCredential}, null is returned.\r\n     */\r\n    static fromJSON(json) {\r\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\r\n        if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {\r\n            if (obj.signInMethod === \"password\" /* SignInMethod.EMAIL_PASSWORD */) {\r\n                return this._fromEmailAndPassword(obj.email, obj.password);\r\n            }\r\n            else if (obj.signInMethod === \"emailLink\" /* SignInMethod.EMAIL_LINK */) {\r\n                return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /** @internal */\r\n    async _getIdTokenResponse(auth) {\r\n        switch (this.signInMethod) {\r\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */:\r\n                const request = {\r\n                    returnSecureToken: true,\r\n                    email: this._email,\r\n                    password: this._password,\r\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\r\n                };\r\n                return handleRecaptchaFlow(auth, request, \"signInWithPassword\" /* RecaptchaActionName.SIGN_IN_WITH_PASSWORD */, signInWithPassword);\r\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */:\r\n                return signInWithEmailLink$1(auth, {\r\n                    email: this._email,\r\n                    oobCode: this._password\r\n                });\r\n            default:\r\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        }\r\n    }\r\n    /** @internal */\r\n    async _linkToIdToken(auth, idToken) {\r\n        switch (this.signInMethod) {\r\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */:\r\n                const request = {\r\n                    idToken,\r\n                    returnSecureToken: true,\r\n                    email: this._email,\r\n                    password: this._password,\r\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\r\n                };\r\n                return handleRecaptchaFlow(auth, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */, linkEmailPassword);\r\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */:\r\n                return signInWithEmailLinkForLinking(auth, {\r\n                    idToken,\r\n                    email: this._email,\r\n                    oobCode: this._password\r\n                });\r\n            default:\r\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        }\r\n    }\r\n    /** @internal */\r\n    _getReauthenticationResolver(auth) {\r\n        return this._getIdTokenResponse(auth);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function signInWithIdp(auth, request) {\r\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithIdp\" /* Endpoint.SIGN_IN_WITH_IDP */, _addTidIfNecessary(auth, request));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst IDP_REQUEST_URI$1 = 'http://localhost';\r\n/**\r\n * Represents the OAuth credentials returned by an {@link OAuthProvider}.\r\n *\r\n * @remarks\r\n * Implementations specify the details about each auth provider's credential requirements.\r\n *\r\n * @public\r\n */\r\nclass OAuthCredential extends AuthCredential {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.pendingToken = null;\r\n    }\r\n    /** @internal */\r\n    static _fromParams(params) {\r\n        const cred = new OAuthCredential(params.providerId, params.signInMethod);\r\n        if (params.idToken || params.accessToken) {\r\n            // OAuth 2 and either ID token or access token.\r\n            if (params.idToken) {\r\n                cred.idToken = params.idToken;\r\n            }\r\n            if (params.accessToken) {\r\n                cred.accessToken = params.accessToken;\r\n            }\r\n            // Add nonce if available and no pendingToken is present.\r\n            if (params.nonce && !params.pendingToken) {\r\n                cred.nonce = params.nonce;\r\n            }\r\n            if (params.pendingToken) {\r\n                cred.pendingToken = params.pendingToken;\r\n            }\r\n        }\r\n        else if (params.oauthToken && params.oauthTokenSecret) {\r\n            // OAuth 1 and OAuth token with token secret\r\n            cred.accessToken = params.oauthToken;\r\n            cred.secret = params.oauthTokenSecret;\r\n        }\r\n        else {\r\n            _fail(\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n        }\r\n        return cred;\r\n    }\r\n    /** {@inheritdoc AuthCredential.toJSON}  */\r\n    toJSON() {\r\n        return {\r\n            idToken: this.idToken,\r\n            accessToken: this.accessToken,\r\n            secret: this.secret,\r\n            nonce: this.nonce,\r\n            pendingToken: this.pendingToken,\r\n            providerId: this.providerId,\r\n            signInMethod: this.signInMethod\r\n        };\r\n    }\r\n    /**\r\n     * Static method to deserialize a JSON representation of an object into an\r\n     * {@link  AuthCredential}.\r\n     *\r\n     * @param json - Input can be either Object or the stringified representation of the object.\r\n     * When string is provided, JSON.parse would be called first.\r\n     *\r\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\r\n     */\r\n    static fromJSON(json) {\r\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\r\n        const { providerId, signInMethod } = obj, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__rest)(obj, [\"providerId\", \"signInMethod\"]);\r\n        if (!providerId || !signInMethod) {\r\n            return null;\r\n        }\r\n        const cred = new OAuthCredential(providerId, signInMethod);\r\n        cred.idToken = rest.idToken || undefined;\r\n        cred.accessToken = rest.accessToken || undefined;\r\n        cred.secret = rest.secret;\r\n        cred.nonce = rest.nonce;\r\n        cred.pendingToken = rest.pendingToken || null;\r\n        return cred;\r\n    }\r\n    /** @internal */\r\n    _getIdTokenResponse(auth) {\r\n        const request = this.buildRequest();\r\n        return signInWithIdp(auth, request);\r\n    }\r\n    /** @internal */\r\n    _linkToIdToken(auth, idToken) {\r\n        const request = this.buildRequest();\r\n        request.idToken = idToken;\r\n        return signInWithIdp(auth, request);\r\n    }\r\n    /** @internal */\r\n    _getReauthenticationResolver(auth) {\r\n        const request = this.buildRequest();\r\n        request.autoCreate = false;\r\n        return signInWithIdp(auth, request);\r\n    }\r\n    buildRequest() {\r\n        const request = {\r\n            requestUri: IDP_REQUEST_URI$1,\r\n            returnSecureToken: true\r\n        };\r\n        if (this.pendingToken) {\r\n            request.pendingToken = this.pendingToken;\r\n        }\r\n        else {\r\n            const postBody = {};\r\n            if (this.idToken) {\r\n                postBody['id_token'] = this.idToken;\r\n            }\r\n            if (this.accessToken) {\r\n                postBody['access_token'] = this.accessToken;\r\n            }\r\n            if (this.secret) {\r\n                postBody['oauth_token_secret'] = this.secret;\r\n            }\r\n            postBody['providerId'] = this.providerId;\r\n            if (this.nonce && !this.pendingToken) {\r\n                postBody['nonce'] = this.nonce;\r\n            }\r\n            request.postBody = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(postBody);\r\n        }\r\n        return request;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function signInWithPhoneNumber$1(auth, request) {\r\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));\r\n}\r\nasync function linkWithPhoneNumber$1(auth, request) {\r\n    const response = await _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));\r\n    if (response.temporaryProof) {\r\n        throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */, response);\r\n    }\r\n    return response;\r\n}\r\nconst VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_ = {\r\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */\r\n};\r\nasync function verifyPhoneNumberForExisting(auth, request) {\r\n    const apiRequest = Object.assign(Object.assign({}, request), { operation: 'REAUTH' });\r\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, apiRequest), VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents the credentials returned by {@link PhoneAuthProvider}.\r\n *\r\n * @public\r\n */\r\nclass PhoneAuthCredential extends AuthCredential {\r\n    constructor(params) {\r\n        super(\"phone\" /* ProviderId.PHONE */, \"phone\" /* SignInMethod.PHONE */);\r\n        this.params = params;\r\n    }\r\n    /** @internal */\r\n    static _fromVerification(verificationId, verificationCode) {\r\n        return new PhoneAuthCredential({ verificationId, verificationCode });\r\n    }\r\n    /** @internal */\r\n    static _fromTokenResponse(phoneNumber, temporaryProof) {\r\n        return new PhoneAuthCredential({ phoneNumber, temporaryProof });\r\n    }\r\n    /** @internal */\r\n    _getIdTokenResponse(auth) {\r\n        return signInWithPhoneNumber$1(auth, this._makeVerificationRequest());\r\n    }\r\n    /** @internal */\r\n    _linkToIdToken(auth, idToken) {\r\n        return linkWithPhoneNumber$1(auth, Object.assign({ idToken }, this._makeVerificationRequest()));\r\n    }\r\n    /** @internal */\r\n    _getReauthenticationResolver(auth) {\r\n        return verifyPhoneNumberForExisting(auth, this._makeVerificationRequest());\r\n    }\r\n    /** @internal */\r\n    _makeVerificationRequest() {\r\n        const { temporaryProof, phoneNumber, verificationId, verificationCode } = this.params;\r\n        if (temporaryProof && phoneNumber) {\r\n            return { temporaryProof, phoneNumber };\r\n        }\r\n        return {\r\n            sessionInfo: verificationId,\r\n            code: verificationCode\r\n        };\r\n    }\r\n    /** {@inheritdoc AuthCredential.toJSON} */\r\n    toJSON() {\r\n        const obj = {\r\n            providerId: this.providerId\r\n        };\r\n        if (this.params.phoneNumber) {\r\n            obj.phoneNumber = this.params.phoneNumber;\r\n        }\r\n        if (this.params.temporaryProof) {\r\n            obj.temporaryProof = this.params.temporaryProof;\r\n        }\r\n        if (this.params.verificationCode) {\r\n            obj.verificationCode = this.params.verificationCode;\r\n        }\r\n        if (this.params.verificationId) {\r\n            obj.verificationId = this.params.verificationId;\r\n        }\r\n        return obj;\r\n    }\r\n    /** Generates a phone credential based on a plain object or a JSON string. */\r\n    static fromJSON(json) {\r\n        if (typeof json === 'string') {\r\n            json = JSON.parse(json);\r\n        }\r\n        const { verificationId, verificationCode, phoneNumber, temporaryProof } = json;\r\n        if (!verificationCode &&\r\n            !verificationId &&\r\n            !phoneNumber &&\r\n            !temporaryProof) {\r\n            return null;\r\n        }\r\n        return new PhoneAuthCredential({\r\n            verificationId,\r\n            verificationCode,\r\n            phoneNumber,\r\n            temporaryProof\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Maps the mode string in action code URL to Action Code Info operation.\r\n *\r\n * @param mode\r\n */\r\nfunction parseMode(mode) {\r\n    switch (mode) {\r\n        case 'recoverEmail':\r\n            return \"RECOVER_EMAIL\" /* ActionCodeOperation.RECOVER_EMAIL */;\r\n        case 'resetPassword':\r\n            return \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */;\r\n        case 'signIn':\r\n            return \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */;\r\n        case 'verifyEmail':\r\n            return \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */;\r\n        case 'verifyAndChangeEmail':\r\n            return \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */;\r\n        case 'revertSecondFactorAddition':\r\n            return \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */;\r\n        default:\r\n            return null;\r\n    }\r\n}\r\n/**\r\n * Helper to parse FDL links\r\n *\r\n * @param url\r\n */\r\nfunction parseDeepLink(url) {\r\n    const link = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(url))['link'];\r\n    // Double link case (automatic redirect).\r\n    const doubleDeepLink = link\r\n        ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(link))['deep_link_id']\r\n        : null;\r\n    // iOS custom scheme links.\r\n    const iOSDeepLink = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(url))['deep_link_id'];\r\n    const iOSDoubleDeepLink = iOSDeepLink\r\n        ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(iOSDeepLink))['link']\r\n        : null;\r\n    return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;\r\n}\r\n/**\r\n * A utility class to parse email action URLs such as password reset, email verification,\r\n * email link sign in, etc.\r\n *\r\n * @public\r\n */\r\nclass ActionCodeURL {\r\n    /**\r\n     * @param actionLink - The link from which to extract the URL.\r\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\r\n     *\r\n     * @internal\r\n     */\r\n    constructor(actionLink) {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        const searchParams = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(actionLink));\r\n        const apiKey = (_a = searchParams[\"apiKey\" /* QueryField.API_KEY */]) !== null && _a !== void 0 ? _a : null;\r\n        const code = (_b = searchParams[\"oobCode\" /* QueryField.CODE */]) !== null && _b !== void 0 ? _b : null;\r\n        const operation = parseMode((_c = searchParams[\"mode\" /* QueryField.MODE */]) !== null && _c !== void 0 ? _c : null);\r\n        // Validate API key, code and mode.\r\n        _assert(apiKey && code && operation, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n        this.apiKey = apiKey;\r\n        this.operation = operation;\r\n        this.code = code;\r\n        this.continueUrl = (_d = searchParams[\"continueUrl\" /* QueryField.CONTINUE_URL */]) !== null && _d !== void 0 ? _d : null;\r\n        this.languageCode = (_e = searchParams[\"languageCode\" /* QueryField.LANGUAGE_CODE */]) !== null && _e !== void 0 ? _e : null;\r\n        this.tenantId = (_f = searchParams[\"tenantId\" /* QueryField.TENANT_ID */]) !== null && _f !== void 0 ? _f : null;\r\n    }\r\n    /**\r\n     * Parses the email action link string and returns an {@link ActionCodeURL} if the link is valid,\r\n     * otherwise returns null.\r\n     *\r\n     * @param link  - The email action link string.\r\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\r\n     *\r\n     * @public\r\n     */\r\n    static parseLink(link) {\r\n        const actionLink = parseDeepLink(link);\r\n        try {\r\n            return new ActionCodeURL(actionLink);\r\n        }\r\n        catch (_a) {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Parses the email action link string and returns an {@link ActionCodeURL} if\r\n * the link is valid, otherwise returns null.\r\n *\r\n * @public\r\n */\r\nfunction parseActionCodeURL(link) {\r\n    return ActionCodeURL.parseLink(link);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for generating {@link EmailAuthCredential}.\r\n *\r\n * @public\r\n */\r\nclass EmailAuthProvider {\r\n    constructor() {\r\n        /**\r\n         * Always set to {@link ProviderId}.PASSWORD, even for email link.\r\n         */\r\n        this.providerId = EmailAuthProvider.PROVIDER_ID;\r\n    }\r\n    /**\r\n     * Initialize an {@link AuthCredential} using an email and password.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const authCredential = EmailAuthProvider.credential(email, password);\r\n     * const userCredential = await signInWithCredential(auth, authCredential);\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const userCredential = await signInWithEmailAndPassword(auth, email, password);\r\n     * ```\r\n     *\r\n     * @param email - Email address.\r\n     * @param password - User account password.\r\n     * @returns The auth provider credential.\r\n     */\r\n    static credential(email, password) {\r\n        return EmailAuthCredential._fromEmailAndPassword(email, password);\r\n    }\r\n    /**\r\n     * Initialize an {@link AuthCredential} using an email and an email link after a sign in with\r\n     * email link operation.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const authCredential = EmailAuthProvider.credentialWithLink(auth, email, emailLink);\r\n     * const userCredential = await signInWithCredential(auth, authCredential);\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * await sendSignInLinkToEmail(auth, email);\r\n     * // Obtain emailLink from user.\r\n     * const userCredential = await signInWithEmailLink(auth, email, emailLink);\r\n     * ```\r\n     *\r\n     * @param auth - The {@link Auth} instance used to verify the link.\r\n     * @param email - Email address.\r\n     * @param emailLink - Sign-in email link.\r\n     * @returns - The auth provider credential.\r\n     */\r\n    static credentialWithLink(email, emailLink) {\r\n        const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\r\n        _assert(actionCodeUrl, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n        return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);\r\n    }\r\n}\r\n/**\r\n * Always set to {@link ProviderId}.PASSWORD, even for email link.\r\n */\r\nEmailAuthProvider.PROVIDER_ID = \"password\" /* ProviderId.PASSWORD */;\r\n/**\r\n * Always set to {@link SignInMethod}.EMAIL_PASSWORD.\r\n */\r\nEmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = \"password\" /* SignInMethod.EMAIL_PASSWORD */;\r\n/**\r\n * Always set to {@link SignInMethod}.EMAIL_LINK.\r\n */\r\nEmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = \"emailLink\" /* SignInMethod.EMAIL_LINK */;\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The base class for all Federated providers (OAuth (including OIDC), SAML).\r\n *\r\n * This class is not meant to be instantiated directly.\r\n *\r\n * @public\r\n */\r\nclass FederatedAuthProvider {\r\n    /**\r\n     * Constructor for generic OAuth providers.\r\n     *\r\n     * @param providerId - Provider for which credentials should be generated.\r\n     */\r\n    constructor(providerId) {\r\n        this.providerId = providerId;\r\n        /** @internal */\r\n        this.defaultLanguageCode = null;\r\n        /** @internal */\r\n        this.customParameters = {};\r\n    }\r\n    /**\r\n     * Set the language gode.\r\n     *\r\n     * @param languageCode - language code\r\n     */\r\n    setDefaultLanguage(languageCode) {\r\n        this.defaultLanguageCode = languageCode;\r\n    }\r\n    /**\r\n     * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in\r\n     * operations.\r\n     *\r\n     * @remarks\r\n     * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,\r\n     * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.\r\n     *\r\n     * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.\r\n     */\r\n    setCustomParameters(customOAuthParameters) {\r\n        this.customParameters = customOAuthParameters;\r\n        return this;\r\n    }\r\n    /**\r\n     * Retrieve the current list of {@link CustomParameters}.\r\n     */\r\n    getCustomParameters() {\r\n        return this.customParameters;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Common code to all OAuth providers. This is separate from the\r\n * {@link OAuthProvider} so that child providers (like\r\n * {@link GoogleAuthProvider}) don't inherit the `credential` instance method.\r\n * Instead, they rely on a static `credential` method.\r\n */\r\nclass BaseOAuthProvider extends FederatedAuthProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** @internal */\r\n        this.scopes = [];\r\n    }\r\n    /**\r\n     * Add an OAuth scope to the credential.\r\n     *\r\n     * @param scope - Provider OAuth scope to add.\r\n     */\r\n    addScope(scope) {\r\n        // If not already added, add scope to list.\r\n        if (!this.scopes.includes(scope)) {\r\n            this.scopes.push(scope);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Retrieve the current list of OAuth scopes.\r\n     */\r\n    getScopes() {\r\n        return [...this.scopes];\r\n    }\r\n}\r\n/**\r\n * Provider for generating generic {@link OAuthCredential}.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new OAuthProvider('google.com');\r\n * // Start a sign in process for an unauthenticated user.\r\n * provider.addScope('profile');\r\n * provider.addScope('email');\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a OAuth Access Token for the provider.\r\n *   const credential = provider.credentialFromResult(auth, result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new OAuthProvider('google.com');\r\n * provider.addScope('profile');\r\n * provider.addScope('email');\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a OAuth Access Token for the provider.\r\n * const credential = provider.credentialFromResult(auth, result);\r\n * const token = credential.accessToken;\r\n * ```\r\n * @public\r\n */\r\nclass OAuthProvider extends BaseOAuthProvider {\r\n    /**\r\n     * Creates an {@link OAuthCredential} from a JSON string or a plain object.\r\n     * @param json - A plain object or a JSON string\r\n     */\r\n    static credentialFromJSON(json) {\r\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\r\n        _assert('providerId' in obj && 'signInMethod' in obj, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n        return OAuthCredential._fromParams(obj);\r\n    }\r\n    /**\r\n     * Creates a {@link OAuthCredential} from a generic OAuth provider's access token or ID token.\r\n     *\r\n     * @remarks\r\n     * The raw nonce is required when an ID token with a nonce field is provided. The SHA-256 hash of\r\n     * the raw nonce must match the nonce field in the ID token.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // `googleUser` from the onsuccess Google Sign In callback.\r\n     * // Initialize a generate OAuth provider with a `google.com` providerId.\r\n     * const provider = new OAuthProvider('google.com');\r\n     * const credential = provider.credential({\r\n     *   idToken: googleUser.getAuthResponse().id_token,\r\n     * });\r\n     * const result = await signInWithCredential(credential);\r\n     * ```\r\n     *\r\n     * @param params - Either the options object containing the ID token, access token and raw nonce\r\n     * or the ID token string.\r\n     */\r\n    credential(params) {\r\n        return this._credential(Object.assign(Object.assign({}, params), { nonce: params.rawNonce }));\r\n    }\r\n    /** An internal credential method that accepts more permissive options */\r\n    _credential(params) {\r\n        _assert(params.idToken || params.accessToken, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n        // For OAuthCredential, sign in method is same as providerId.\r\n        return OAuthCredential._fromParams(Object.assign(Object.assign({}, params), { providerId: this.providerId, signInMethod: this.providerId }));\r\n    }\r\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */\r\n    static credentialFromResult(userCredential) {\r\n        return OAuthProvider.oauthCredentialFromTaggedObject(userCredential);\r\n    }\r\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */\r\n    static credentialFromError(error) {\r\n        return OAuthProvider.oauthCredentialFromTaggedObject((error.customData || {}));\r\n    }\r\n    static oauthCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\r\n        if (!tokenResponse) {\r\n            return null;\r\n        }\r\n        const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce, providerId } = tokenResponse;\r\n        if (!oauthAccessToken &&\r\n            !oauthTokenSecret &&\r\n            !oauthIdToken &&\r\n            !pendingToken) {\r\n            return null;\r\n        }\r\n        if (!providerId) {\r\n            return null;\r\n        }\r\n        try {\r\n            return new OAuthProvider(providerId)._credential({\r\n                idToken: oauthIdToken,\r\n                accessToken: oauthAccessToken,\r\n                nonce,\r\n                pendingToken\r\n            });\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.FACEBOOK.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new FacebookAuthProvider();\r\n * // Start a sign in process for an unauthenticated user.\r\n * provider.addScope('user_birthday');\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Facebook Access Token.\r\n *   const credential = FacebookAuthProvider.credentialFromResult(result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new FacebookAuthProvider();\r\n * provider.addScope('user_birthday');\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a Facebook Access Token.\r\n * const credential = FacebookAuthProvider.credentialFromResult(result);\r\n * const token = credential.accessToken;\r\n * ```\r\n *\r\n * @public\r\n */\r\nclass FacebookAuthProvider extends BaseOAuthProvider {\r\n    constructor() {\r\n        super(\"facebook.com\" /* ProviderId.FACEBOOK */);\r\n    }\r\n    /**\r\n     * Creates a credential for Facebook.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // `event` from the Facebook auth.authResponseChange callback.\r\n     * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);\r\n     * const result = await signInWithCredential(credential);\r\n     * ```\r\n     *\r\n     * @param accessToken - Facebook access token.\r\n     */\r\n    static credential(accessToken) {\r\n        return OAuthCredential._fromParams({\r\n            providerId: FacebookAuthProvider.PROVIDER_ID,\r\n            signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,\r\n            accessToken\r\n        });\r\n    }\r\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */\r\n    static credentialFromResult(userCredential) {\r\n        return FacebookAuthProvider.credentialFromTaggedObject(userCredential);\r\n    }\r\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */\r\n    static credentialFromError(error) {\r\n        return FacebookAuthProvider.credentialFromTaggedObject((error.customData || {}));\r\n    }\r\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\r\n        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {\r\n            return null;\r\n        }\r\n        if (!tokenResponse.oauthAccessToken) {\r\n            return null;\r\n        }\r\n        try {\r\n            return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);\r\n        }\r\n        catch (_a) {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/** Always set to {@link SignInMethod}.FACEBOOK. */\r\nFacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = \"facebook.com\" /* SignInMethod.FACEBOOK */;\r\n/** Always set to {@link ProviderId}.FACEBOOK. */\r\nFacebookAuthProvider.PROVIDER_ID = \"facebook.com\" /* ProviderId.FACEBOOK */;\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GOOGLE.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new GoogleAuthProvider();\r\n * // Start a sign in process for an unauthenticated user.\r\n * provider.addScope('profile');\r\n * provider.addScope('email');\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Google Access Token.\r\n *   const credential = GoogleAuthProvider.credentialFromResult(result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new GoogleAuthProvider();\r\n * provider.addScope('profile');\r\n * provider.addScope('email');\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a Google Access Token.\r\n * const credential = GoogleAuthProvider.credentialFromResult(result);\r\n * const token = credential.accessToken;\r\n * ```\r\n *\r\n * @public\r\n */\r\nclass GoogleAuthProvider extends BaseOAuthProvider {\r\n    constructor() {\r\n        super(\"google.com\" /* ProviderId.GOOGLE */);\r\n        this.addScope('profile');\r\n    }\r\n    /**\r\n     * Creates a credential for Google. At least one of ID token and access token is required.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // \\`googleUser\\` from the onsuccess Google Sign In callback.\r\n     * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);\r\n     * const result = await signInWithCredential(credential);\r\n     * ```\r\n     *\r\n     * @param idToken - Google ID token.\r\n     * @param accessToken - Google access token.\r\n     */\r\n    static credential(idToken, accessToken) {\r\n        return OAuthCredential._fromParams({\r\n            providerId: GoogleAuthProvider.PROVIDER_ID,\r\n            signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,\r\n            idToken,\r\n            accessToken\r\n        });\r\n    }\r\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */\r\n    static credentialFromResult(userCredential) {\r\n        return GoogleAuthProvider.credentialFromTaggedObject(userCredential);\r\n    }\r\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */\r\n    static credentialFromError(error) {\r\n        return GoogleAuthProvider.credentialFromTaggedObject((error.customData || {}));\r\n    }\r\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\r\n        if (!tokenResponse) {\r\n            return null;\r\n        }\r\n        const { oauthIdToken, oauthAccessToken } = tokenResponse;\r\n        if (!oauthIdToken && !oauthAccessToken) {\r\n            // This could be an oauth 1 credential or a phone credential\r\n            return null;\r\n        }\r\n        try {\r\n            return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);\r\n        }\r\n        catch (_a) {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/** Always set to {@link SignInMethod}.GOOGLE. */\r\nGoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = \"google.com\" /* SignInMethod.GOOGLE */;\r\n/** Always set to {@link ProviderId}.GOOGLE. */\r\nGoogleAuthProvider.PROVIDER_ID = \"google.com\" /* ProviderId.GOOGLE */;\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GITHUB.\r\n *\r\n * @remarks\r\n * GitHub requires an OAuth 2.0 redirect, so you can either handle the redirect directly, or use\r\n * the {@link signInWithPopup} handler:\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new GithubAuthProvider();\r\n * // Start a sign in process for an unauthenticated user.\r\n * provider.addScope('repo');\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Github Access Token.\r\n *   const credential = GithubAuthProvider.credentialFromResult(result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new GithubAuthProvider();\r\n * provider.addScope('repo');\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a Github Access Token.\r\n * const credential = GithubAuthProvider.credentialFromResult(result);\r\n * const token = credential.accessToken;\r\n * ```\r\n * @public\r\n */\r\nclass GithubAuthProvider extends BaseOAuthProvider {\r\n    constructor() {\r\n        super(\"github.com\" /* ProviderId.GITHUB */);\r\n    }\r\n    /**\r\n     * Creates a credential for Github.\r\n     *\r\n     * @param accessToken - Github access token.\r\n     */\r\n    static credential(accessToken) {\r\n        return OAuthCredential._fromParams({\r\n            providerId: GithubAuthProvider.PROVIDER_ID,\r\n            signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,\r\n            accessToken\r\n        });\r\n    }\r\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */\r\n    static credentialFromResult(userCredential) {\r\n        return GithubAuthProvider.credentialFromTaggedObject(userCredential);\r\n    }\r\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */\r\n    static credentialFromError(error) {\r\n        return GithubAuthProvider.credentialFromTaggedObject((error.customData || {}));\r\n    }\r\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\r\n        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {\r\n            return null;\r\n        }\r\n        if (!tokenResponse.oauthAccessToken) {\r\n            return null;\r\n        }\r\n        try {\r\n            return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);\r\n        }\r\n        catch (_a) {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/** Always set to {@link SignInMethod}.GITHUB. */\r\nGithubAuthProvider.GITHUB_SIGN_IN_METHOD = \"github.com\" /* SignInMethod.GITHUB */;\r\n/** Always set to {@link ProviderId}.GITHUB. */\r\nGithubAuthProvider.PROVIDER_ID = \"github.com\" /* ProviderId.GITHUB */;\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst IDP_REQUEST_URI = 'http://localhost';\r\n/**\r\n * @public\r\n */\r\nclass SAMLAuthCredential extends AuthCredential {\r\n    /** @internal */\r\n    constructor(providerId, pendingToken) {\r\n        super(providerId, providerId);\r\n        this.pendingToken = pendingToken;\r\n    }\r\n    /** @internal */\r\n    _getIdTokenResponse(auth) {\r\n        const request = this.buildRequest();\r\n        return signInWithIdp(auth, request);\r\n    }\r\n    /** @internal */\r\n    _linkToIdToken(auth, idToken) {\r\n        const request = this.buildRequest();\r\n        request.idToken = idToken;\r\n        return signInWithIdp(auth, request);\r\n    }\r\n    /** @internal */\r\n    _getReauthenticationResolver(auth) {\r\n        const request = this.buildRequest();\r\n        request.autoCreate = false;\r\n        return signInWithIdp(auth, request);\r\n    }\r\n    /** {@inheritdoc AuthCredential.toJSON}  */\r\n    toJSON() {\r\n        return {\r\n            signInMethod: this.signInMethod,\r\n            providerId: this.providerId,\r\n            pendingToken: this.pendingToken\r\n        };\r\n    }\r\n    /**\r\n     * Static method to deserialize a JSON representation of an object into an\r\n     * {@link  AuthCredential}.\r\n     *\r\n     * @param json - Input can be either Object or the stringified representation of the object.\r\n     * When string is provided, JSON.parse would be called first.\r\n     *\r\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\r\n     */\r\n    static fromJSON(json) {\r\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\r\n        const { providerId, signInMethod, pendingToken } = obj;\r\n        if (!providerId ||\r\n            !signInMethod ||\r\n            !pendingToken ||\r\n            providerId !== signInMethod) {\r\n            return null;\r\n        }\r\n        return new SAMLAuthCredential(providerId, pendingToken);\r\n    }\r\n    /**\r\n     * Helper static method to avoid exposing the constructor to end users.\r\n     *\r\n     * @internal\r\n     */\r\n    static _create(providerId, pendingToken) {\r\n        return new SAMLAuthCredential(providerId, pendingToken);\r\n    }\r\n    buildRequest() {\r\n        return {\r\n            requestUri: IDP_REQUEST_URI,\r\n            returnSecureToken: true,\r\n            pendingToken: this.pendingToken\r\n        };\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst SAML_PROVIDER_PREFIX = 'saml.';\r\n/**\r\n * An {@link AuthProvider} for SAML.\r\n *\r\n * @public\r\n */\r\nclass SAMLAuthProvider extends FederatedAuthProvider {\r\n    /**\r\n     * Constructor. The providerId must start with \"saml.\"\r\n     * @param providerId - SAML provider ID.\r\n     */\r\n    constructor(providerId) {\r\n        _assert(providerId.startsWith(SAML_PROVIDER_PREFIX), \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n        super(providerId);\r\n    }\r\n    /**\r\n     * Generates an {@link AuthCredential} from a {@link UserCredential} after a\r\n     * successful SAML flow completes.\r\n     *\r\n     * @remarks\r\n     *\r\n     * For example, to get an {@link AuthCredential}, you could write the\r\n     * following code:\r\n     *\r\n     * ```js\r\n     * const userCredential = await signInWithPopup(auth, samlProvider);\r\n     * const credential = SAMLAuthProvider.credentialFromResult(userCredential);\r\n     * ```\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */\r\n    static credentialFromResult(userCredential) {\r\n        return SAMLAuthProvider.samlCredentialFromTaggedObject(userCredential);\r\n    }\r\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */\r\n    static credentialFromError(error) {\r\n        return SAMLAuthProvider.samlCredentialFromTaggedObject((error.customData || {}));\r\n    }\r\n    /**\r\n     * Creates an {@link AuthCredential} from a JSON string or a plain object.\r\n     * @param json - A plain object or a JSON string\r\n     */\r\n    static credentialFromJSON(json) {\r\n        const credential = SAMLAuthCredential.fromJSON(json);\r\n        _assert(credential, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n        return credential;\r\n    }\r\n    static samlCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\r\n        if (!tokenResponse) {\r\n            return null;\r\n        }\r\n        const { pendingToken, providerId } = tokenResponse;\r\n        if (!pendingToken || !providerId) {\r\n            return null;\r\n        }\r\n        try {\r\n            return SAMLAuthCredential._create(providerId, pendingToken);\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.TWITTER.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new TwitterAuthProvider();\r\n * // Start a sign in process for an unauthenticated user.\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Twitter Access Token and Secret.\r\n *   const credential = TwitterAuthProvider.credentialFromResult(result);\r\n *   const token = credential.accessToken;\r\n *   const secret = credential.secret;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new TwitterAuthProvider();\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a Twitter Access Token and Secret.\r\n * const credential = TwitterAuthProvider.credentialFromResult(result);\r\n * const token = credential.accessToken;\r\n * const secret = credential.secret;\r\n * ```\r\n *\r\n * @public\r\n */\r\nclass TwitterAuthProvider extends BaseOAuthProvider {\r\n    constructor() {\r\n        super(\"twitter.com\" /* ProviderId.TWITTER */);\r\n    }\r\n    /**\r\n     * Creates a credential for Twitter.\r\n     *\r\n     * @param token - Twitter access token.\r\n     * @param secret - Twitter secret.\r\n     */\r\n    static credential(token, secret) {\r\n        return OAuthCredential._fromParams({\r\n            providerId: TwitterAuthProvider.PROVIDER_ID,\r\n            signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,\r\n            oauthToken: token,\r\n            oauthTokenSecret: secret\r\n        });\r\n    }\r\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */\r\n    static credentialFromResult(userCredential) {\r\n        return TwitterAuthProvider.credentialFromTaggedObject(userCredential);\r\n    }\r\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */\r\n    static credentialFromError(error) {\r\n        return TwitterAuthProvider.credentialFromTaggedObject((error.customData || {}));\r\n    }\r\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\r\n        if (!tokenResponse) {\r\n            return null;\r\n        }\r\n        const { oauthAccessToken, oauthTokenSecret } = tokenResponse;\r\n        if (!oauthAccessToken || !oauthTokenSecret) {\r\n            return null;\r\n        }\r\n        try {\r\n            return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);\r\n        }\r\n        catch (_a) {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/** Always set to {@link SignInMethod}.TWITTER. */\r\nTwitterAuthProvider.TWITTER_SIGN_IN_METHOD = \"twitter.com\" /* SignInMethod.TWITTER */;\r\n/** Always set to {@link ProviderId}.TWITTER. */\r\nTwitterAuthProvider.PROVIDER_ID = \"twitter.com\" /* ProviderId.TWITTER */;\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function signUp(auth, request) {\r\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */, _addTidIfNecessary(auth, request));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass UserCredentialImpl {\r\n    constructor(params) {\r\n        this.user = params.user;\r\n        this.providerId = params.providerId;\r\n        this._tokenResponse = params._tokenResponse;\r\n        this.operationType = params.operationType;\r\n    }\r\n    static async _fromIdTokenResponse(auth, operationType, idTokenResponse, isAnonymous = false) {\r\n        const user = await UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous);\r\n        const providerId = providerIdForResponse(idTokenResponse);\r\n        const userCred = new UserCredentialImpl({\r\n            user,\r\n            providerId,\r\n            _tokenResponse: idTokenResponse,\r\n            operationType\r\n        });\r\n        return userCred;\r\n    }\r\n    static async _forOperation(user, operationType, response) {\r\n        await user._updateTokensIfNecessary(response, /* reload */ true);\r\n        const providerId = providerIdForResponse(response);\r\n        return new UserCredentialImpl({\r\n            user,\r\n            providerId,\r\n            _tokenResponse: response,\r\n            operationType\r\n        });\r\n    }\r\n}\r\nfunction providerIdForResponse(response) {\r\n    if (response.providerId) {\r\n        return response.providerId;\r\n    }\r\n    if ('phoneNumber' in response) {\r\n        return \"phone\" /* ProviderId.PHONE */;\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Asynchronously signs in as an anonymous user.\r\n *\r\n * @remarks\r\n * If there is already an anonymous user signed in, that user will be returned; otherwise, a\r\n * new anonymous user identity will be created and returned.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @public\r\n */\r\nasync function signInAnonymously(auth) {\r\n    var _a;\r\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\r\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\r\n    }\r\n    const authInternal = _castAuth(auth);\r\n    await authInternal._initializationPromise;\r\n    if ((_a = authInternal.currentUser) === null || _a === void 0 ? void 0 : _a.isAnonymous) {\r\n        // If an anonymous user is already signed in, no need to sign them in again.\r\n        return new UserCredentialImpl({\r\n            user: authInternal.currentUser,\r\n            providerId: null,\r\n            operationType: \"signIn\" /* OperationType.SIGN_IN */\r\n        });\r\n    }\r\n    const response = await signUp(authInternal, {\r\n        returnSecureToken: true\r\n    });\r\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response, true);\r\n    await authInternal._updateCurrentUser(userCredential.user);\r\n    return userCredential;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MultiFactorError extends _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError {\r\n    constructor(auth, error, operationType, user) {\r\n        var _a;\r\n        super(error.code, error.message);\r\n        this.operationType = operationType;\r\n        this.user = user;\r\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MultiFactorError.prototype);\r\n        this.customData = {\r\n            appName: auth.name,\r\n            tenantId: (_a = auth.tenantId) !== null && _a !== void 0 ? _a : undefined,\r\n            _serverResponse: error.customData._serverResponse,\r\n            operationType\r\n        };\r\n    }\r\n    static _fromErrorAndOperation(auth, error, operationType, user) {\r\n        return new MultiFactorError(auth, error, operationType, user);\r\n    }\r\n}\r\nfunction _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {\r\n    const idTokenProvider = operationType === \"reauthenticate\" /* OperationType.REAUTHENTICATE */\r\n        ? credential._getReauthenticationResolver(auth)\r\n        : credential._getIdTokenResponse(auth);\r\n    return idTokenProvider.catch(error => {\r\n        if (error.code === `auth/${\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */}`) {\r\n            throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);\r\n        }\r\n        throw error;\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Takes a set of UserInfo provider data and converts it to a set of names\r\n */\r\nfunction providerDataAsNames(providerData) {\r\n    return new Set(providerData\r\n        .map(({ providerId }) => providerId)\r\n        .filter(pid => !!pid));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Unlinks a provider from a user account.\r\n *\r\n * @param user - The user.\r\n * @param providerId - The provider to unlink.\r\n *\r\n * @public\r\n */\r\nasync function unlink(user, providerId) {\r\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\r\n    await _assertLinkedStatus(true, userInternal, providerId);\r\n    const { providerUserInfo } = await deleteLinkedAccounts(userInternal.auth, {\r\n        idToken: await userInternal.getIdToken(),\r\n        deleteProvider: [providerId]\r\n    });\r\n    const providersLeft = providerDataAsNames(providerUserInfo || []);\r\n    userInternal.providerData = userInternal.providerData.filter(pd => providersLeft.has(pd.providerId));\r\n    if (!providersLeft.has(\"phone\" /* ProviderId.PHONE */)) {\r\n        userInternal.phoneNumber = null;\r\n    }\r\n    await userInternal.auth._persistUserIfCurrent(userInternal);\r\n    return userInternal;\r\n}\r\nasync function _link(user, credential, bypassAuthState = false) {\r\n    const response = await _logoutIfInvalidated(user, credential._linkToIdToken(user.auth, await user.getIdToken()), bypassAuthState);\r\n    return UserCredentialImpl._forOperation(user, \"link\" /* OperationType.LINK */, response);\r\n}\r\nasync function _assertLinkedStatus(expected, user, provider) {\r\n    await _reloadWithoutSaving(user);\r\n    const providerIds = providerDataAsNames(user.providerData);\r\n    const code = expected === false\r\n        ? \"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */\r\n        : \"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */;\r\n    _assert(providerIds.has(provider) === expected, user.auth, code);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function _reauthenticate(user, credential, bypassAuthState = false) {\r\n    const { auth } = user;\r\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\r\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\r\n    }\r\n    const operationType = \"reauthenticate\" /* OperationType.REAUTHENTICATE */;\r\n    try {\r\n        const response = await _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState);\r\n        _assert(response.idToken, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        const parsed = _parseToken(response.idToken);\r\n        _assert(parsed, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        const { sub: localId } = parsed;\r\n        _assert(user.uid === localId, auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */);\r\n        return UserCredentialImpl._forOperation(user, operationType, response);\r\n    }\r\n    catch (e) {\r\n        // Convert user deleted error into user mismatch\r\n        if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${\"user-not-found\" /* AuthErrorCode.USER_DELETED */}`) {\r\n            _fail(auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */);\r\n        }\r\n        throw e;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function _signInWithCredential(auth, credential, bypassAuthState = false) {\r\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\r\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\r\n    }\r\n    const operationType = \"signIn\" /* OperationType.SIGN_IN */;\r\n    const response = await _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential);\r\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, operationType, response);\r\n    if (!bypassAuthState) {\r\n        await auth._updateCurrentUser(userCredential.user);\r\n    }\r\n    return userCredential;\r\n}\r\n/**\r\n * Asynchronously signs in with the given credentials.\r\n *\r\n * @remarks\r\n * An {@link AuthProvider} can be used to generate the credential.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param credential - The auth credential.\r\n *\r\n * @public\r\n */\r\nasync function signInWithCredential(auth, credential) {\r\n    return _signInWithCredential(_castAuth(auth), credential);\r\n}\r\n/**\r\n * Links the user account with the given credentials.\r\n *\r\n * @remarks\r\n * An {@link AuthProvider} can be used to generate the credential.\r\n *\r\n * @param user - The user.\r\n * @param credential - The auth credential.\r\n *\r\n * @public\r\n */\r\nasync function linkWithCredential(user, credential) {\r\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\r\n    await _assertLinkedStatus(false, userInternal, credential.providerId);\r\n    return _link(userInternal, credential);\r\n}\r\n/**\r\n * Re-authenticates a user using a fresh credential.\r\n *\r\n * @remarks\r\n * Use before operations such as {@link updatePassword} that require tokens from recent sign-in\r\n * attempts. This method can be used to recover from a `CREDENTIAL_TOO_OLD_LOGIN_AGAIN` error\r\n * or a `TOKEN_EXPIRED` error.\r\n *\r\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\r\n * created with a {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param user - The user.\r\n * @param credential - The auth credential.\r\n *\r\n * @public\r\n */\r\nasync function reauthenticateWithCredential(user, credential) {\r\n    return _reauthenticate((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user), credential);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function signInWithCustomToken$1(auth, request) {\r\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithCustomToken\" /* Endpoint.SIGN_IN_WITH_CUSTOM_TOKEN */, _addTidIfNecessary(auth, request));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Asynchronously signs in using a custom token.\r\n *\r\n * @remarks\r\n * Custom tokens are used to integrate Firebase Auth with existing auth systems, and must\r\n * be generated by an auth backend using the\r\n * {@link https://firebase.google.com/docs/reference/admin/node/admin.auth.Auth#createcustomtoken | createCustomToken}\r\n * method in the {@link https://firebase.google.com/docs/auth/admin | Admin SDK} .\r\n *\r\n * Fails with an error if the token is invalid, expired, or not accepted by the Firebase Auth service.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param customToken - The custom token to sign in with.\r\n *\r\n * @public\r\n */\r\nasync function signInWithCustomToken(auth, customToken) {\r\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\r\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\r\n    }\r\n    const authInternal = _castAuth(auth);\r\n    const response = await signInWithCustomToken$1(authInternal, {\r\n        token: customToken,\r\n        returnSecureToken: true\r\n    });\r\n    const cred = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response);\r\n    await authInternal._updateCurrentUser(cred.user);\r\n    return cred;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MultiFactorInfoImpl {\r\n    constructor(factorId, response) {\r\n        this.factorId = factorId;\r\n        this.uid = response.mfaEnrollmentId;\r\n        this.enrollmentTime = new Date(response.enrolledAt).toUTCString();\r\n        this.displayName = response.displayName;\r\n    }\r\n    static _fromServerResponse(auth, enrollment) {\r\n        if ('phoneInfo' in enrollment) {\r\n            return PhoneMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\r\n        }\r\n        else if ('totpInfo' in enrollment) {\r\n            return TotpMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\r\n        }\r\n        return _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n    }\r\n}\r\nclass PhoneMultiFactorInfoImpl extends MultiFactorInfoImpl {\r\n    constructor(response) {\r\n        super(\"phone\" /* FactorId.PHONE */, response);\r\n        this.phoneNumber = response.phoneInfo;\r\n    }\r\n    static _fromServerResponse(_auth, enrollment) {\r\n        return new PhoneMultiFactorInfoImpl(enrollment);\r\n    }\r\n}\r\nclass TotpMultiFactorInfoImpl extends MultiFactorInfoImpl {\r\n    constructor(response) {\r\n        super(\"totp\" /* FactorId.TOTP */, response);\r\n    }\r\n    static _fromServerResponse(_auth, enrollment) {\r\n        return new TotpMultiFactorInfoImpl(enrollment);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction _setActionCodeSettingsOnRequest(auth, request, actionCodeSettings) {\r\n    var _a;\r\n    _assert(((_a = actionCodeSettings.url) === null || _a === void 0 ? void 0 : _a.length) > 0, auth, \"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */);\r\n    _assert(typeof actionCodeSettings.dynamicLinkDomain === 'undefined' ||\r\n        actionCodeSettings.dynamicLinkDomain.length > 0, auth, \"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */);\r\n    request.continueUrl = actionCodeSettings.url;\r\n    request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;\r\n    request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;\r\n    if (actionCodeSettings.iOS) {\r\n        _assert(actionCodeSettings.iOS.bundleId.length > 0, auth, \"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */);\r\n        request.iOSBundleId = actionCodeSettings.iOS.bundleId;\r\n    }\r\n    if (actionCodeSettings.android) {\r\n        _assert(actionCodeSettings.android.packageName.length > 0, auth, \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */);\r\n        request.androidInstallApp = actionCodeSettings.android.installApp;\r\n        request.androidMinimumVersionCode =\r\n            actionCodeSettings.android.minimumVersion;\r\n        request.androidPackageName = actionCodeSettings.android.packageName;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Updates the password policy cached in the {@link Auth} instance if a policy is already\r\n * cached for the project or tenant.\r\n *\r\n * @remarks\r\n * We only fetch the password policy if the password did not meet policy requirements and\r\n * there is an existing policy cached. A developer must call validatePassword at least\r\n * once for the cache to be automatically updated.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @private\r\n */\r\nasync function recachePasswordPolicy(auth) {\r\n    const authInternal = _castAuth(auth);\r\n    if (authInternal._getPasswordPolicyInternal()) {\r\n        await authInternal._updatePasswordPolicy();\r\n    }\r\n}\r\n/**\r\n * Sends a password reset email to the given email address. This method does not throw an error when\r\n * there's no user account with the given email address and\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\r\n * is enabled.\r\n *\r\n * @remarks\r\n * To complete the password reset, call {@link confirmPasswordReset} with the code supplied in\r\n * the email sent to the user, along with the new password specified by the user.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await sendPasswordResetEmail(auth, 'user@example.com', actionCodeSettings);\r\n * // Obtain code from user.\r\n * await confirmPasswordReset('user@example.com', code);\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\r\n *\r\n * @public\r\n */\r\nasync function sendPasswordResetEmail(auth, email, actionCodeSettings) {\r\n    const authInternal = _castAuth(auth);\r\n    const request = {\r\n        requestType: \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */,\r\n        email,\r\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\r\n    };\r\n    if (actionCodeSettings) {\r\n        _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\r\n    }\r\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */, sendPasswordResetEmail$1);\r\n}\r\n/**\r\n * Completes the password reset process, given a confirmation code and new password.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param oobCode - A confirmation code sent to the user.\r\n * @param newPassword - The new password.\r\n *\r\n * @public\r\n */\r\nasync function confirmPasswordReset(auth, oobCode, newPassword) {\r\n    await resetPassword((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), {\r\n        oobCode,\r\n        newPassword\r\n    })\r\n        .catch(async (error) => {\r\n        if (error.code ===\r\n            `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\r\n            void recachePasswordPolicy(auth);\r\n        }\r\n        throw error;\r\n    });\r\n    // Do not return the email.\r\n}\r\n/**\r\n * Applies a verification code sent to the user by email or other out-of-band mechanism.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param oobCode - A verification code sent to the user.\r\n *\r\n * @public\r\n */\r\nasync function applyActionCode(auth, oobCode) {\r\n    await applyActionCode$1((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), { oobCode });\r\n}\r\n/**\r\n * Checks a verification code sent to the user by email or other out-of-band mechanism.\r\n *\r\n * @returns metadata about the code.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param oobCode - A verification code sent to the user.\r\n *\r\n * @public\r\n */\r\nasync function checkActionCode(auth, oobCode) {\r\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\r\n    const response = await resetPassword(authModular, { oobCode });\r\n    // Email could be empty only if the request type is EMAIL_SIGNIN or\r\n    // VERIFY_AND_CHANGE_EMAIL.\r\n    // New email should not be empty if the request type is\r\n    // VERIFY_AND_CHANGE_EMAIL.\r\n    // Multi-factor info could not be empty if the request type is\r\n    // REVERT_SECOND_FACTOR_ADDITION.\r\n    const operation = response.requestType;\r\n    _assert(operation, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n    switch (operation) {\r\n        case \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */:\r\n            break;\r\n        case \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */:\r\n            _assert(response.newEmail, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n            break;\r\n        case \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */:\r\n            _assert(response.mfaInfo, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        // fall through\r\n        default:\r\n            _assert(response.email, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n    }\r\n    // The multi-factor info for revert second factor addition\r\n    let multiFactorInfo = null;\r\n    if (response.mfaInfo) {\r\n        multiFactorInfo = MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular), response.mfaInfo);\r\n    }\r\n    return {\r\n        data: {\r\n            email: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */\r\n                ? response.newEmail\r\n                : response.email) || null,\r\n            previousEmail: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */\r\n                ? response.email\r\n                : response.newEmail) || null,\r\n            multiFactorInfo\r\n        },\r\n        operation\r\n    };\r\n}\r\n/**\r\n * Checks a password reset code sent to the user by email or other out-of-band mechanism.\r\n *\r\n * @returns the user's email address if valid.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param code - A verification code sent to the user.\r\n *\r\n * @public\r\n */\r\nasync function verifyPasswordResetCode(auth, code) {\r\n    const { data } = await checkActionCode((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), code);\r\n    // Email should always be present since a code was sent to it\r\n    return data.email;\r\n}\r\n/**\r\n * Creates a new user account associated with the specified email address and password.\r\n *\r\n * @remarks\r\n * On successful creation of the user account, this user will also be signed in to your application.\r\n *\r\n * User account creation can fail if the account already exists or the password is invalid.\r\n *\r\n * This method is not supported on {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * Note: The email address acts as a unique identifier for the user and enables an email-based\r\n * password reset. This function will create a new user account and set the initial user password.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n * @param password - The user's chosen password.\r\n *\r\n * @public\r\n */\r\nasync function createUserWithEmailAndPassword(auth, email, password) {\r\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\r\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\r\n    }\r\n    const authInternal = _castAuth(auth);\r\n    const request = {\r\n        returnSecureToken: true,\r\n        email,\r\n        password,\r\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\r\n    };\r\n    const signUpResponse = handleRecaptchaFlow(authInternal, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */, signUp);\r\n    const response = await signUpResponse.catch(error => {\r\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\r\n            void recachePasswordPolicy(auth);\r\n        }\r\n        throw error;\r\n    });\r\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response);\r\n    await authInternal._updateCurrentUser(userCredential.user);\r\n    return userCredential;\r\n}\r\n/**\r\n * Asynchronously signs in using an email and password.\r\n *\r\n * @remarks\r\n * Fails with an error if the email address and password do not match. When\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\r\n * is enabled, this method fails with \"auth/invalid-credential\" in case of an invalid\r\n * email/password.\r\n *\r\n * This method is not supported on {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * Note: The user's password is NOT the password used to access the user's email account. The\r\n * email address serves as a unique identifier for the user, and the password is used to access\r\n * the user's account in your Firebase project. See also: {@link createUserWithEmailAndPassword}.\r\n *\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The users email address.\r\n * @param password - The users password.\r\n *\r\n * @public\r\n */\r\nfunction signInWithEmailAndPassword(auth, email, password) {\r\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\r\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\r\n    }\r\n    return signInWithCredential((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), EmailAuthProvider.credential(email, password)).catch(async (error) => {\r\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\r\n            void recachePasswordPolicy(auth);\r\n        }\r\n        throw error;\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Sends a sign-in email link to the user with the specified email.\r\n *\r\n * @remarks\r\n * The sign-in operation has to always be completed in the app unlike other out of band email\r\n * actions (password reset and email verifications). This is because, at the end of the flow,\r\n * the user is expected to be signed in and their Auth state persisted within the app.\r\n *\r\n * To complete sign in with the email link, call {@link signInWithEmailLink} with the email\r\n * address and the email link supplied in the email sent to the user.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\r\n * // Obtain emailLink from the user.\r\n * if(isSignInWithEmailLink(auth, emailLink)) {\r\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\r\n * }\r\n * ```\r\n *\r\n * @param authInternal - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\r\n *\r\n * @public\r\n */\r\nasync function sendSignInLinkToEmail(auth, email, actionCodeSettings) {\r\n    const authInternal = _castAuth(auth);\r\n    const request = {\r\n        requestType: \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */,\r\n        email,\r\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\r\n    };\r\n    function setActionCodeSettings(request, actionCodeSettings) {\r\n        _assert(actionCodeSettings.handleCodeInApp, authInternal, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n        if (actionCodeSettings) {\r\n            _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\r\n        }\r\n    }\r\n    setActionCodeSettings(request, actionCodeSettings);\r\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */, sendSignInLinkToEmail$1);\r\n}\r\n/**\r\n * Checks if an incoming link is a sign-in with email link suitable for {@link signInWithEmailLink}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param emailLink - The link sent to the user's email address.\r\n *\r\n * @public\r\n */\r\nfunction isSignInWithEmailLink(auth, emailLink) {\r\n    const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\r\n    return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */;\r\n}\r\n/**\r\n * Asynchronously signs in using an email and sign-in email link.\r\n *\r\n * @remarks\r\n * If no link is passed, the link is inferred from the current URL.\r\n *\r\n * Fails with an error if the email address is invalid or OTP in email link expires.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * Note: Confirm the link is a sign-in email link before calling this method firebase.auth.Auth.isSignInWithEmailLink.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\r\n * // Obtain emailLink from the user.\r\n * if(isSignInWithEmailLink(auth, emailLink)) {\r\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\r\n * }\r\n * ```\r\n *\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n * @param emailLink - The link sent to the user's email address.\r\n *\r\n * @public\r\n */\r\nasync function signInWithEmailLink(auth, email, emailLink) {\r\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\r\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\r\n    }\r\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\r\n    const credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl());\r\n    // Check if the tenant ID in the email link matches the tenant ID on Auth\r\n    // instance.\r\n    _assert(credential._tenantId === (authModular.tenantId || null), authModular, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */);\r\n    return signInWithCredential(authModular, credential);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function createAuthUri(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:createAuthUri\" /* Endpoint.CREATE_AUTH_URI */, _addTidIfNecessary(auth, request));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Gets the list of possible sign in methods for the given email address. This method returns an\r\n * empty list when\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\r\n * is enabled, irrespective of the number of authentication methods available for the given email.\r\n *\r\n * @remarks\r\n * This is useful to differentiate methods of sign-in for the same provider, eg.\r\n * {@link EmailAuthProvider} which has 2 methods of sign-in,\r\n * {@link SignInMethod}.EMAIL_PASSWORD and\r\n * {@link SignInMethod}.EMAIL_LINK.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n *\r\n * Deprecated. Migrating off of this method is recommended as a security best-practice.\r\n * Learn more in the Identity Platform documentation for\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}.\r\n * @public\r\n */\r\nasync function fetchSignInMethodsForEmail(auth, email) {\r\n    // createAuthUri returns an error if continue URI is not http or https.\r\n    // For environments like Cordova, Chrome extensions, native frameworks, file\r\n    // systems, etc, use http://localhost as continue URL.\r\n    const continueUri = _isHttpOrHttps() ? _getCurrentUrl() : 'http://localhost';\r\n    const request = {\r\n        identifier: email,\r\n        continueUri\r\n    };\r\n    const { signinMethods } = await createAuthUri((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), request);\r\n    return signinMethods || [];\r\n}\r\n/**\r\n * Sends a verification email to a user.\r\n *\r\n * @remarks\r\n * The verification process is completed by calling {@link applyActionCode}.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await sendEmailVerification(user, actionCodeSettings);\r\n * // Obtain code from the user.\r\n * await applyActionCode(auth, code);\r\n * ```\r\n *\r\n * @param user - The user.\r\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\r\n *\r\n * @public\r\n */\r\nasync function sendEmailVerification(user, actionCodeSettings) {\r\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\r\n    const idToken = await user.getIdToken();\r\n    const request = {\r\n        requestType: \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */,\r\n        idToken\r\n    };\r\n    if (actionCodeSettings) {\r\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\r\n    }\r\n    const { email } = await sendEmailVerification$1(userInternal.auth, request);\r\n    if (email !== user.email) {\r\n        await user.reload();\r\n    }\r\n}\r\n/**\r\n * Sends a verification email to a new email address.\r\n *\r\n * @remarks\r\n * The user's email will be updated to the new one after being verified.\r\n *\r\n * If you have a custom email action handler, you can complete the verification process by calling\r\n * {@link applyActionCode}.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await verifyBeforeUpdateEmail(user, 'newemail@example.com', actionCodeSettings);\r\n * // Obtain code from the user.\r\n * await applyActionCode(auth, code);\r\n * ```\r\n *\r\n * @param user - The user.\r\n * @param newEmail - The new email address to be verified before update.\r\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\r\n *\r\n * @public\r\n */\r\nasync function verifyBeforeUpdateEmail(user, newEmail, actionCodeSettings) {\r\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\r\n    const idToken = await user.getIdToken();\r\n    const request = {\r\n        requestType: \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */,\r\n        idToken,\r\n        newEmail\r\n    };\r\n    if (actionCodeSettings) {\r\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\r\n    }\r\n    const { email } = await verifyAndChangeEmail(userInternal.auth, request);\r\n    if (email !== user.email) {\r\n        // If the local copy of the email on user is outdated, reload the\r\n        // user.\r\n        await user.reload();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function updateProfile$1(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Updates a user's profile data.\r\n *\r\n * @param user - The user.\r\n * @param profile - The profile's `displayName` and `photoURL` to update.\r\n *\r\n * @public\r\n */\r\nasync function updateProfile(user, { displayName, photoURL: photoUrl }) {\r\n    if (displayName === undefined && photoUrl === undefined) {\r\n        return;\r\n    }\r\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\r\n    const idToken = await userInternal.getIdToken();\r\n    const profileRequest = {\r\n        idToken,\r\n        displayName,\r\n        photoUrl,\r\n        returnSecureToken: true\r\n    };\r\n    const response = await _logoutIfInvalidated(userInternal, updateProfile$1(userInternal.auth, profileRequest));\r\n    userInternal.displayName = response.displayName || null;\r\n    userInternal.photoURL = response.photoUrl || null;\r\n    // Update the password provider as well\r\n    const passwordProvider = userInternal.providerData.find(({ providerId }) => providerId === \"password\" /* ProviderId.PASSWORD */);\r\n    if (passwordProvider) {\r\n        passwordProvider.displayName = userInternal.displayName;\r\n        passwordProvider.photoURL = userInternal.photoURL;\r\n    }\r\n    await userInternal._updateTokensIfNecessary(response);\r\n}\r\n/**\r\n * Updates the user's email address.\r\n *\r\n * @remarks\r\n * An email will be sent to the original email address (if it was set) that allows to revoke the\r\n * email address change, in order to protect them from account hijacking.\r\n *\r\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\r\n * created with a {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * Important: this is a security sensitive operation that requires the user to have recently signed\r\n * in. If this requirement isn't met, ask the user to authenticate again and then call\r\n * {@link reauthenticateWithCredential}.\r\n *\r\n * @param user - The user.\r\n * @param newEmail - The new email address.\r\n *\r\n * Throws \"auth/operation-not-allowed\" error when\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\r\n * is enabled.\r\n * Deprecated - Use {@link verifyBeforeUpdateEmail} instead.\r\n *\r\n * @public\r\n */\r\nfunction updateEmail(user, newEmail) {\r\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\r\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(userInternal.auth.app)) {\r\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(userInternal.auth));\r\n    }\r\n    return updateEmailOrPassword(userInternal, newEmail, null);\r\n}\r\n/**\r\n * Updates the user's password.\r\n *\r\n * @remarks\r\n * Important: this is a security sensitive operation that requires the user to have recently signed\r\n * in. If this requirement isn't met, ask the user to authenticate again and then call\r\n * {@link reauthenticateWithCredential}.\r\n *\r\n * @param user - The user.\r\n * @param newPassword - The new password.\r\n *\r\n * @public\r\n */\r\nfunction updatePassword(user, newPassword) {\r\n    return updateEmailOrPassword((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user), null, newPassword);\r\n}\r\nasync function updateEmailOrPassword(user, email, password) {\r\n    const { auth } = user;\r\n    const idToken = await user.getIdToken();\r\n    const request = {\r\n        idToken,\r\n        returnSecureToken: true\r\n    };\r\n    if (email) {\r\n        request.email = email;\r\n    }\r\n    if (password) {\r\n        request.password = password;\r\n    }\r\n    const response = await _logoutIfInvalidated(user, updateEmailPassword(auth, request));\r\n    await user._updateTokensIfNecessary(response, /* reload */ true);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Parse the `AdditionalUserInfo` from the ID token response.\r\n *\r\n */\r\nfunction _fromIdTokenResponse(idTokenResponse) {\r\n    var _a, _b;\r\n    if (!idTokenResponse) {\r\n        return null;\r\n    }\r\n    const { providerId } = idTokenResponse;\r\n    const profile = idTokenResponse.rawUserInfo\r\n        ? JSON.parse(idTokenResponse.rawUserInfo)\r\n        : {};\r\n    const isNewUser = idTokenResponse.isNewUser ||\r\n        idTokenResponse.kind === \"identitytoolkit#SignupNewUserResponse\" /* IdTokenResponseKind.SignupNewUser */;\r\n    if (!providerId && (idTokenResponse === null || idTokenResponse === void 0 ? void 0 : idTokenResponse.idToken)) {\r\n        const signInProvider = (_b = (_a = _parseToken(idTokenResponse.idToken)) === null || _a === void 0 ? void 0 : _a.firebase) === null || _b === void 0 ? void 0 : _b['sign_in_provider'];\r\n        if (signInProvider) {\r\n            const filteredProviderId = signInProvider !== \"anonymous\" /* ProviderId.ANONYMOUS */ &&\r\n                signInProvider !== \"custom\" /* ProviderId.CUSTOM */\r\n                ? signInProvider\r\n                : null;\r\n            // Uses generic class in accordance with the legacy SDK.\r\n            return new GenericAdditionalUserInfo(isNewUser, filteredProviderId);\r\n        }\r\n    }\r\n    if (!providerId) {\r\n        return null;\r\n    }\r\n    switch (providerId) {\r\n        case \"facebook.com\" /* ProviderId.FACEBOOK */:\r\n            return new FacebookAdditionalUserInfo(isNewUser, profile);\r\n        case \"github.com\" /* ProviderId.GITHUB */:\r\n            return new GithubAdditionalUserInfo(isNewUser, profile);\r\n        case \"google.com\" /* ProviderId.GOOGLE */:\r\n            return new GoogleAdditionalUserInfo(isNewUser, profile);\r\n        case \"twitter.com\" /* ProviderId.TWITTER */:\r\n            return new TwitterAdditionalUserInfo(isNewUser, profile, idTokenResponse.screenName || null);\r\n        case \"custom\" /* ProviderId.CUSTOM */:\r\n        case \"anonymous\" /* ProviderId.ANONYMOUS */:\r\n            return new GenericAdditionalUserInfo(isNewUser, null);\r\n        default:\r\n            return new GenericAdditionalUserInfo(isNewUser, providerId, profile);\r\n    }\r\n}\r\nclass GenericAdditionalUserInfo {\r\n    constructor(isNewUser, providerId, profile = {}) {\r\n        this.isNewUser = isNewUser;\r\n        this.providerId = providerId;\r\n        this.profile = profile;\r\n    }\r\n}\r\nclass FederatedAdditionalUserInfoWithUsername extends GenericAdditionalUserInfo {\r\n    constructor(isNewUser, providerId, profile, username) {\r\n        super(isNewUser, providerId, profile);\r\n        this.username = username;\r\n    }\r\n}\r\nclass FacebookAdditionalUserInfo extends GenericAdditionalUserInfo {\r\n    constructor(isNewUser, profile) {\r\n        super(isNewUser, \"facebook.com\" /* ProviderId.FACEBOOK */, profile);\r\n    }\r\n}\r\nclass GithubAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\r\n    constructor(isNewUser, profile) {\r\n        super(isNewUser, \"github.com\" /* ProviderId.GITHUB */, profile, typeof (profile === null || profile === void 0 ? void 0 : profile.login) === 'string' ? profile === null || profile === void 0 ? void 0 : profile.login : null);\r\n    }\r\n}\r\nclass GoogleAdditionalUserInfo extends GenericAdditionalUserInfo {\r\n    constructor(isNewUser, profile) {\r\n        super(isNewUser, \"google.com\" /* ProviderId.GOOGLE */, profile);\r\n    }\r\n}\r\nclass TwitterAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\r\n    constructor(isNewUser, profile, screenName) {\r\n        super(isNewUser, \"twitter.com\" /* ProviderId.TWITTER */, profile, screenName);\r\n    }\r\n}\r\n/**\r\n * Extracts provider specific {@link AdditionalUserInfo} for the given credential.\r\n *\r\n * @param userCredential - The user credential.\r\n *\r\n * @public\r\n */\r\nfunction getAdditionalUserInfo(userCredential) {\r\n    const { user, _tokenResponse } = userCredential;\r\n    if (user.isAnonymous && !_tokenResponse) {\r\n        // Handle the special case where signInAnonymously() gets called twice.\r\n        // No network call is made so there's nothing to actually fill this in\r\n        return {\r\n            providerId: null,\r\n            isNewUser: false,\r\n            profile: null\r\n        };\r\n    }\r\n    return _fromIdTokenResponse(_tokenResponse);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Non-optional auth methods.\r\n/**\r\n * Changes the type of persistence on the {@link Auth} instance for the currently saved\r\n * `Auth` session and applies this type of persistence for future sign-in requests, including\r\n * sign-in with redirect requests.\r\n *\r\n * @remarks\r\n * This makes it easy for a user signing in to specify whether their session should be\r\n * remembered or not. It also makes it easier to never persist the `Auth` state for applications\r\n * that are shared by other users or have sensitive data.\r\n *\r\n * This method does not work in a Node.js environment or with {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @example\r\n * ```javascript\r\n * setPersistence(auth, browserSessionPersistence);\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param persistence - The {@link Persistence} to use.\r\n * @returns A `Promise` that resolves once the persistence change has completed\r\n *\r\n * @public\r\n */\r\nfunction setPersistence(auth, persistence) {\r\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).setPersistence(persistence);\r\n}\r\n/**\r\n * Loads the reCAPTCHA configuration into the `Auth` instance.\r\n *\r\n * @remarks\r\n * This will load the reCAPTCHA config, which indicates whether the reCAPTCHA\r\n * verification flow should be triggered for each auth provider, into the\r\n * current Auth session.\r\n *\r\n * If initializeRecaptchaConfig() is not invoked, the auth flow will always start\r\n * without reCAPTCHA verification. If the provider is configured to require reCAPTCHA\r\n * verification, the SDK will transparently load the reCAPTCHA config and restart the\r\n * auth flows.\r\n *\r\n * Thus, by calling this optional method, you will reduce the latency of future auth flows.\r\n * Loading the reCAPTCHA config early will also enhance the signal collected by reCAPTCHA.\r\n *\r\n * This method does not work in a Node.js environment.\r\n *\r\n * @example\r\n * ```javascript\r\n * initializeRecaptchaConfig(auth);\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @public\r\n */\r\nfunction initializeRecaptchaConfig(auth) {\r\n    return _initializeRecaptchaConfig(auth);\r\n}\r\n/**\r\n * Validates the password against the password policy configured for the project or tenant.\r\n *\r\n * @remarks\r\n * If no tenant ID is set on the `Auth` instance, then this method will use the password\r\n * policy configured for the project. Otherwise, this method will use the policy configured\r\n * for the tenant. If a password policy has not been configured, then the default policy\r\n * configured for all projects will be used.\r\n *\r\n * If an auth flow fails because a submitted password does not meet the password policy\r\n * requirements and this method has previously been called, then this method will use the\r\n * most recent policy available when called again.\r\n *\r\n * @example\r\n * ```javascript\r\n * validatePassword(auth, 'some-password');\r\n * ```\r\n *\r\n * @param auth The {@link Auth} instance.\r\n * @param password The password to validate.\r\n *\r\n * @public\r\n */\r\nasync function validatePassword(auth, password) {\r\n    const authInternal = _castAuth(auth);\r\n    return authInternal.validatePassword(password);\r\n}\r\n/**\r\n * Adds an observer for changes to the signed-in user's ID token.\r\n *\r\n * @remarks\r\n * This includes sign-in, sign-out, and token refresh events.\r\n * This will not be triggered automatically upon ID token expiration. Use {@link User.getIdToken} to refresh the ID token.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param nextOrObserver - callback triggered on change.\r\n * @param error - Deprecated. This callback is never triggered. Errors\r\n * on signing in/out can be caught in promises returned from\r\n * sign-in/sign-out functions.\r\n * @param completed - Deprecated. This callback is never triggered.\r\n *\r\n * @public\r\n */\r\nfunction onIdTokenChanged(auth, nextOrObserver, error, completed) {\r\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).onIdTokenChanged(nextOrObserver, error, completed);\r\n}\r\n/**\r\n * Adds a blocking callback that runs before an auth state change\r\n * sets a new user.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param callback - callback triggered before new user value is set.\r\n *   If this throws, it blocks the user from being set.\r\n * @param onAbort - callback triggered if a later `beforeAuthStateChanged()`\r\n *   callback throws, allowing you to undo any side effects.\r\n */\r\nfunction beforeAuthStateChanged(auth, callback, onAbort) {\r\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).beforeAuthStateChanged(callback, onAbort);\r\n}\r\n/**\r\n * Adds an observer for changes to the user's sign-in state.\r\n *\r\n * @remarks\r\n * To keep the old behavior, see {@link onIdTokenChanged}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param nextOrObserver - callback triggered on change.\r\n * @param error - Deprecated. This callback is never triggered. Errors\r\n * on signing in/out can be caught in promises returned from\r\n * sign-in/sign-out functions.\r\n * @param completed - Deprecated. This callback is never triggered.\r\n *\r\n * @public\r\n */\r\nfunction onAuthStateChanged(auth, nextOrObserver, error, completed) {\r\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).onAuthStateChanged(nextOrObserver, error, completed);\r\n}\r\n/**\r\n * Sets the current language to the default device/browser preference.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @public\r\n */\r\nfunction useDeviceLanguage(auth) {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).useDeviceLanguage();\r\n}\r\n/**\r\n * Asynchronously sets the provided user as {@link Auth.currentUser} on the\r\n * {@link Auth} instance.\r\n *\r\n * @remarks\r\n * A new instance copy of the user provided will be made and set as currentUser.\r\n *\r\n * This will trigger {@link onAuthStateChanged} and {@link onIdTokenChanged} listeners\r\n * like other sign in methods.\r\n *\r\n * The operation fails with an error if the user to be updated belongs to a different Firebase\r\n * project.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param user - The new {@link User}.\r\n *\r\n * @public\r\n */\r\nfunction updateCurrentUser(auth, user) {\r\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).updateCurrentUser(user);\r\n}\r\n/**\r\n * Signs out the current user.\r\n *\r\n * @remarks\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @public\r\n */\r\nfunction signOut(auth) {\r\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).signOut();\r\n}\r\n/**\r\n * Revokes the given access token. Currently only supports Apple OAuth access tokens.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param token - The Apple OAuth access token.\r\n *\r\n * @public\r\n */\r\nfunction revokeAccessToken(auth, token) {\r\n    const authInternal = _castAuth(auth);\r\n    return authInternal.revokeAccessToken(token);\r\n}\r\n/**\r\n * Deletes and signs out the user.\r\n *\r\n * @remarks\r\n * Important: this is a security-sensitive operation that requires the user to have recently\r\n * signed in. If this requirement isn't met, ask the user to authenticate again and then call\r\n * {@link reauthenticateWithCredential}.\r\n *\r\n * @param user - The user.\r\n *\r\n * @public\r\n */\r\nasync function deleteUser(user) {\r\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user).delete();\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MultiFactorSessionImpl {\r\n    constructor(type, credential, user) {\r\n        this.type = type;\r\n        this.credential = credential;\r\n        this.user = user;\r\n    }\r\n    static _fromIdtoken(idToken, user) {\r\n        return new MultiFactorSessionImpl(\"enroll\" /* MultiFactorSessionType.ENROLL */, idToken, user);\r\n    }\r\n    static _fromMfaPendingCredential(mfaPendingCredential) {\r\n        return new MultiFactorSessionImpl(\"signin\" /* MultiFactorSessionType.SIGN_IN */, mfaPendingCredential);\r\n    }\r\n    toJSON() {\r\n        const key = this.type === \"enroll\" /* MultiFactorSessionType.ENROLL */\r\n            ? 'idToken'\r\n            : 'pendingCredential';\r\n        return {\r\n            multiFactorSession: {\r\n                [key]: this.credential\r\n            }\r\n        };\r\n    }\r\n    static fromJSON(obj) {\r\n        var _a, _b;\r\n        if (obj === null || obj === void 0 ? void 0 : obj.multiFactorSession) {\r\n            if ((_a = obj.multiFactorSession) === null || _a === void 0 ? void 0 : _a.pendingCredential) {\r\n                return MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);\r\n            }\r\n            else if ((_b = obj.multiFactorSession) === null || _b === void 0 ? void 0 : _b.idToken) {\r\n                return MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MultiFactorResolverImpl {\r\n    constructor(session, hints, signInResolver) {\r\n        this.session = session;\r\n        this.hints = hints;\r\n        this.signInResolver = signInResolver;\r\n    }\r\n    /** @internal */\r\n    static _fromError(authExtern, error) {\r\n        const auth = _castAuth(authExtern);\r\n        const serverResponse = error.customData._serverResponse;\r\n        const hints = (serverResponse.mfaInfo || []).map(enrollment => MultiFactorInfoImpl._fromServerResponse(auth, enrollment));\r\n        _assert(serverResponse.mfaPendingCredential, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        const session = MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);\r\n        return new MultiFactorResolverImpl(session, hints, async (assertion) => {\r\n            const mfaResponse = await assertion._process(auth, session);\r\n            // Clear out the unneeded fields from the old login response\r\n            delete serverResponse.mfaInfo;\r\n            delete serverResponse.mfaPendingCredential;\r\n            // Use in the new token & refresh token in the old response\r\n            const idTokenResponse = Object.assign(Object.assign({}, serverResponse), { idToken: mfaResponse.idToken, refreshToken: mfaResponse.refreshToken });\r\n            // TODO: we should collapse this switch statement into UserCredentialImpl._forOperation and have it support the SIGN_IN case\r\n            switch (error.operationType) {\r\n                case \"signIn\" /* OperationType.SIGN_IN */:\r\n                    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, error.operationType, idTokenResponse);\r\n                    await auth._updateCurrentUser(userCredential.user);\r\n                    return userCredential;\r\n                case \"reauthenticate\" /* OperationType.REAUTHENTICATE */:\r\n                    _assert(error.user, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n                    return UserCredentialImpl._forOperation(error.user, error.operationType, idTokenResponse);\r\n                default:\r\n                    _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n            }\r\n        });\r\n    }\r\n    async resolveSignIn(assertionExtern) {\r\n        const assertion = assertionExtern;\r\n        return this.signInResolver(assertion);\r\n    }\r\n}\r\n/**\r\n * Provides a {@link MultiFactorResolver} suitable for completion of a\r\n * multi-factor flow.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param error - The {@link MultiFactorError} raised during a sign-in, or\r\n * reauthentication operation.\r\n *\r\n * @public\r\n */\r\nfunction getMultiFactorResolver(auth, error) {\r\n    var _a;\r\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\r\n    const errorInternal = error;\r\n    _assert(error.customData.operationType, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n    _assert((_a = errorInternal.customData._serverResponse) === null || _a === void 0 ? void 0 : _a.mfaPendingCredential, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n    return MultiFactorResolverImpl._fromError(authModular, errorInternal);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction startEnrollTotpMfa(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:start\" /* Endpoint.START_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));\r\n}\r\nfunction finalizeEnrollTotpMfa(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:finalize\" /* Endpoint.FINALIZE_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));\r\n}\r\nfunction withdrawMfa(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:withdraw\" /* Endpoint.WITHDRAW_MFA */, _addTidIfNecessary(auth, request));\r\n}\n\nclass MultiFactorUserImpl {\r\n    constructor(user) {\r\n        this.user = user;\r\n        this.enrolledFactors = [];\r\n        user._onReload(userInfo => {\r\n            if (userInfo.mfaInfo) {\r\n                this.enrolledFactors = userInfo.mfaInfo.map(enrollment => MultiFactorInfoImpl._fromServerResponse(user.auth, enrollment));\r\n            }\r\n        });\r\n    }\r\n    static _fromUser(user) {\r\n        return new MultiFactorUserImpl(user);\r\n    }\r\n    async getSession() {\r\n        return MultiFactorSessionImpl._fromIdtoken(await this.user.getIdToken(), this.user);\r\n    }\r\n    async enroll(assertionExtern, displayName) {\r\n        const assertion = assertionExtern;\r\n        const session = (await this.getSession());\r\n        const finalizeMfaResponse = await _logoutIfInvalidated(this.user, assertion._process(this.user.auth, session, displayName));\r\n        // New tokens will be issued after enrollment of the new second factors.\r\n        // They need to be updated on the user.\r\n        await this.user._updateTokensIfNecessary(finalizeMfaResponse);\r\n        // The user needs to be reloaded to get the new multi-factor information\r\n        // from server. USER_RELOADED event will be triggered and `enrolledFactors`\r\n        // will be updated.\r\n        return this.user.reload();\r\n    }\r\n    async unenroll(infoOrUid) {\r\n        const mfaEnrollmentId = typeof infoOrUid === 'string' ? infoOrUid : infoOrUid.uid;\r\n        const idToken = await this.user.getIdToken();\r\n        try {\r\n            const idTokenResponse = await _logoutIfInvalidated(this.user, withdrawMfa(this.user.auth, {\r\n                idToken,\r\n                mfaEnrollmentId\r\n            }));\r\n            // Remove the second factor from the user's list.\r\n            this.enrolledFactors = this.enrolledFactors.filter(({ uid }) => uid !== mfaEnrollmentId);\r\n            // Depending on whether the backend decided to revoke the user's session,\r\n            // the tokenResponse may be empty. If the tokens were not updated (and they\r\n            // are now invalid), reloading the user will discover this and invalidate\r\n            // the user's state accordingly.\r\n            await this.user._updateTokensIfNecessary(idTokenResponse);\r\n            await this.user.reload();\r\n        }\r\n        catch (e) {\r\n            throw e;\r\n        }\r\n    }\r\n}\r\nconst multiFactorUserCache = new WeakMap();\r\n/**\r\n * The {@link MultiFactorUser} corresponding to the user.\r\n *\r\n * @remarks\r\n * This is used to access all multi-factor properties and operations related to the user.\r\n *\r\n * @param user - The user.\r\n *\r\n * @public\r\n */\r\nfunction multiFactor(user) {\r\n    const userModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\r\n    if (!multiFactorUserCache.has(userModular)) {\r\n        multiFactorUserCache.set(userModular, MultiFactorUserImpl._fromUser(userModular));\r\n    }\r\n    return multiFactorUserCache.get(userModular);\r\n}\n\nvar name = \"@firebase/auth\";\nvar version = \"1.7.2\";\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass AuthInterop {\r\n    constructor(auth) {\r\n        this.auth = auth;\r\n        this.internalListeners = new Map();\r\n    }\r\n    getUid() {\r\n        var _a;\r\n        this.assertAuthConfigured();\r\n        return ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.uid) || null;\r\n    }\r\n    async getToken(forceRefresh) {\r\n        this.assertAuthConfigured();\r\n        await this.auth._initializationPromise;\r\n        if (!this.auth.currentUser) {\r\n            return null;\r\n        }\r\n        const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);\r\n        return { accessToken };\r\n    }\r\n    addAuthTokenListener(listener) {\r\n        this.assertAuthConfigured();\r\n        if (this.internalListeners.has(listener)) {\r\n            return;\r\n        }\r\n        const unsubscribe = this.auth.onIdTokenChanged(user => {\r\n            listener((user === null || user === void 0 ? void 0 : user.stsTokenManager.accessToken) || null);\r\n        });\r\n        this.internalListeners.set(listener, unsubscribe);\r\n        this.updateProactiveRefresh();\r\n    }\r\n    removeAuthTokenListener(listener) {\r\n        this.assertAuthConfigured();\r\n        const unsubscribe = this.internalListeners.get(listener);\r\n        if (!unsubscribe) {\r\n            return;\r\n        }\r\n        this.internalListeners.delete(listener);\r\n        unsubscribe();\r\n        this.updateProactiveRefresh();\r\n    }\r\n    assertAuthConfigured() {\r\n        _assert(this.auth._initializationPromise, \"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */);\r\n    }\r\n    updateProactiveRefresh() {\r\n        if (this.internalListeners.size > 0) {\r\n            this.auth._startProactiveRefresh();\r\n        }\r\n        else {\r\n            this.auth._stopProactiveRefresh();\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getVersionForPlatform(clientPlatform) {\r\n    switch (clientPlatform) {\r\n        case \"Node\" /* ClientPlatform.NODE */:\r\n            return 'node';\r\n        case \"ReactNative\" /* ClientPlatform.REACT_NATIVE */:\r\n            return 'rn';\r\n        case \"Worker\" /* ClientPlatform.WORKER */:\r\n            return 'webworker';\r\n        case \"Cordova\" /* ClientPlatform.CORDOVA */:\r\n            return 'cordova';\r\n        case \"WebExtension\" /* ClientPlatform.WEB_EXTENSION */:\r\n            return 'web-extension';\r\n        default:\r\n            return undefined;\r\n    }\r\n}\r\n/** @internal */\r\nfunction registerAuth(clientPlatform) {\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(\"auth\" /* _ComponentName.AUTH */, (container, { options: deps }) => {\r\n        const app = container.getProvider('app').getImmediate();\r\n        const heartbeatServiceProvider = container.getProvider('heartbeat');\r\n        const appCheckServiceProvider = container.getProvider('app-check-internal');\r\n        const { apiKey, authDomain } = app.options;\r\n        _assert(apiKey && !apiKey.includes(':'), \"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */, { appName: app.name });\r\n        const config = {\r\n            apiKey,\r\n            authDomain,\r\n            clientPlatform,\r\n            apiHost: \"identitytoolkit.googleapis.com\" /* DefaultConfig.API_HOST */,\r\n            tokenApiHost: \"securetoken.googleapis.com\" /* DefaultConfig.TOKEN_API_HOST */,\r\n            apiScheme: \"https\" /* DefaultConfig.API_SCHEME */,\r\n            sdkClientVersion: _getClientVersion(clientPlatform)\r\n        };\r\n        const authInstance = new AuthImpl(app, heartbeatServiceProvider, appCheckServiceProvider, config);\r\n        _initializeAuthInstance(authInstance, deps);\r\n        return authInstance;\r\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */)\r\n        /**\r\n         * Auth can only be initialized by explicitly calling getAuth() or initializeAuth()\r\n         * For why we do this, See go/firebase-next-auth-init\r\n         */\r\n        .setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */)\r\n        /**\r\n         * Because all firebase products that depend on auth depend on auth-internal directly,\r\n         * we need to initialize auth-internal after auth is initialized to make it available to other firebase products.\r\n         */\r\n        .setInstanceCreatedCallback((container, _instanceIdentifier, _instance) => {\r\n        const authInternalProvider = container.getProvider(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */);\r\n        authInternalProvider.initialize();\r\n    }));\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */, container => {\r\n        const auth = _castAuth(container.getProvider(\"auth\" /* _ComponentName.AUTH */).getImmediate());\r\n        return (auth => new AuthInterop(auth))(auth);\r\n    }, \"PRIVATE\" /* ComponentType.PRIVATE */).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */));\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, getVersionForPlatform(clientPlatform));\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'esm2017');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Initialize the fetch polyfill, the types are slightly off so just cast and hope for the best\r\nFetchProvider.initialize(undici__WEBPACK_IMPORTED_MODULE_3__.fetch, undici__WEBPACK_IMPORTED_MODULE_3__.Headers, undici__WEBPACK_IMPORTED_MODULE_3__.Response);\r\n// First, we set up the various platform-specific features for Node (register\r\n// the version and declare the Node getAuth function)\r\nfunction getAuth(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)()) {\r\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'auth');\r\n    if (provider.isInitialized()) {\r\n        return provider.getImmediate();\r\n    }\r\n    const auth = initializeAuth(app);\r\n    const authEmulatorHost = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHost)('auth');\r\n    if (authEmulatorHost) {\r\n        connectAuthEmulator(auth, `http://${authEmulatorHost}`);\r\n    }\r\n    return auth;\r\n}\r\nregisterAuth(\"Node\" /* ClientPlatform.NODE */);\r\n// The rest of this file contains no-ops and errors for browser-specific\r\n// methods. We keep the browser and Node entry points the same, but features\r\n// that only work in browsers are set to either do nothing (setPersistence) or\r\n// to reject with an auth/operation-not-supported-in-this-environment error.\r\n// The below exports are pulled into the main entry point by a rollup alias\r\n// plugin (overwriting the default browser imports).\r\n/** auth/operation-not-supported-in-this-environment */\r\nconst NOT_AVAILABLE_ERROR = _createError(\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);\r\n/** Reject with auth/operation-not-supported-in-this-environment */\r\nasync function fail() {\r\n    throw NOT_AVAILABLE_ERROR;\r\n}\r\n/**\r\n * A class which will throw with\r\n * auth/operation-not-supported-in-this-environment if instantiated\r\n */\r\nclass FailClass {\r\n    constructor() {\r\n        throw NOT_AVAILABLE_ERROR;\r\n    }\r\n}\r\nconst browserLocalPersistence = inMemoryPersistence;\r\nconst browserSessionPersistence = inMemoryPersistence;\r\nconst indexedDBLocalPersistence = inMemoryPersistence;\r\nconst browserPopupRedirectResolver = NOT_AVAILABLE_ERROR;\r\nconst PhoneAuthProvider = FailClass;\r\nconst signInWithPhoneNumber = fail;\r\nconst linkWithPhoneNumber = fail;\r\nconst reauthenticateWithPhoneNumber = fail;\r\nconst updatePhoneNumber = fail;\r\nconst signInWithPopup = fail;\r\nconst linkWithPopup = fail;\r\nconst reauthenticateWithPopup = fail;\r\nconst signInWithRedirect = fail;\r\nconst linkWithRedirect = fail;\r\nconst reauthenticateWithRedirect = fail;\r\nconst getRedirectResult = fail;\r\nconst RecaptchaVerifier = FailClass;\r\nclass PhoneMultiFactorGenerator {\r\n    static assertion() {\r\n        throw NOT_AVAILABLE_ERROR;\r\n    }\r\n}\r\n// Set persistence should no-op instead of fail. Changing the prototype will\r\n// make sure both setPersistence(auth, persistence) and\r\n// auth.setPersistence(persistence) are covered.\r\nAuthImpl.prototype.setPersistence = async () => { };\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction finalizeSignInTotpMfa(auth, request) {\r\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaSignIn:finalize\" /* Endpoint.FINALIZE_MFA_SIGN_IN */, _addTidIfNecessary(auth, request));\r\n}\n\nclass MultiFactorAssertionImpl {\r\n    constructor(factorId) {\r\n        this.factorId = factorId;\r\n    }\r\n    _process(auth, session, displayName) {\r\n        switch (session.type) {\r\n            case \"enroll\" /* MultiFactorSessionType.ENROLL */:\r\n                return this._finalizeEnroll(auth, session.credential, displayName);\r\n            case \"signin\" /* MultiFactorSessionType.SIGN_IN */:\r\n                return this._finalizeSignIn(auth, session.credential);\r\n            default:\r\n                return debugFail('unexpected MultiFactorSessionType');\r\n        }\r\n    }\r\n}\n\n/**\r\n * Provider for generating a {@link TotpMultiFactorAssertion}.\r\n *\r\n * @public\r\n */\r\nclass TotpMultiFactorGenerator {\r\n    /**\r\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of\r\n     * the TOTP (time-based one-time password) second factor.\r\n     * This assertion is used to complete enrollment in TOTP second factor.\r\n     *\r\n     * @param secret A {@link TotpSecret} containing the shared secret key and other TOTP parameters.\r\n     * @param oneTimePassword One-time password from TOTP App.\r\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\r\n     * {@link MultiFactorUser.enroll}.\r\n     */\r\n    static assertionForEnrollment(secret, oneTimePassword) {\r\n        return TotpMultiFactorAssertionImpl._fromSecret(secret, oneTimePassword);\r\n    }\r\n    /**\r\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of the TOTP second factor.\r\n     * This assertion is used to complete signIn with TOTP as the second factor.\r\n     *\r\n     * @param enrollmentId identifies the enrolled TOTP second factor.\r\n     * @param oneTimePassword One-time password from TOTP App.\r\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\r\n     * {@link MultiFactorResolver.resolveSignIn}.\r\n     */\r\n    static assertionForSignIn(enrollmentId, oneTimePassword) {\r\n        return TotpMultiFactorAssertionImpl._fromEnrollmentId(enrollmentId, oneTimePassword);\r\n    }\r\n    /**\r\n     * Returns a promise to {@link TotpSecret} which contains the TOTP shared secret key and other parameters.\r\n     * Creates a TOTP secret as part of enrolling a TOTP second factor.\r\n     * Used for generating a QR code URL or inputting into a TOTP app.\r\n     * This method uses the auth instance corresponding to the user in the multiFactorSession.\r\n     *\r\n     * @param session The {@link MultiFactorSession} that the user is part of.\r\n     * @returns A promise to {@link TotpSecret}.\r\n     */\r\n    static async generateSecret(session) {\r\n        var _a;\r\n        const mfaSession = session;\r\n        _assert(typeof ((_a = mfaSession.user) === null || _a === void 0 ? void 0 : _a.auth) !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\r\n        const response = await startEnrollTotpMfa(mfaSession.user.auth, {\r\n            idToken: mfaSession.credential,\r\n            totpEnrollmentInfo: {}\r\n        });\r\n        return TotpSecret._fromStartTotpMfaEnrollmentResponse(response, mfaSession.user.auth);\r\n    }\r\n}\r\n/**\r\n * The identifier of the TOTP second factor: `totp`.\r\n */\r\nTotpMultiFactorGenerator.FACTOR_ID = \"totp\" /* FactorId.TOTP */;\r\nclass TotpMultiFactorAssertionImpl extends MultiFactorAssertionImpl {\r\n    constructor(otp, enrollmentId, secret) {\r\n        super(\"totp\" /* FactorId.TOTP */);\r\n        this.otp = otp;\r\n        this.enrollmentId = enrollmentId;\r\n        this.secret = secret;\r\n    }\r\n    /** @internal */\r\n    static _fromSecret(secret, otp) {\r\n        return new TotpMultiFactorAssertionImpl(otp, undefined, secret);\r\n    }\r\n    /** @internal */\r\n    static _fromEnrollmentId(enrollmentId, otp) {\r\n        return new TotpMultiFactorAssertionImpl(otp, enrollmentId);\r\n    }\r\n    /** @internal */\r\n    async _finalizeEnroll(auth, idToken, displayName) {\r\n        _assert(typeof this.secret !== 'undefined', auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n        return finalizeEnrollTotpMfa(auth, {\r\n            idToken,\r\n            displayName,\r\n            totpVerificationInfo: this.secret._makeTotpVerificationInfo(this.otp)\r\n        });\r\n    }\r\n    /** @internal */\r\n    async _finalizeSignIn(auth, mfaPendingCredential) {\r\n        _assert(this.enrollmentId !== undefined && this.otp !== undefined, auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\r\n        const totpVerificationInfo = { verificationCode: this.otp };\r\n        return finalizeSignInTotpMfa(auth, {\r\n            mfaPendingCredential,\r\n            mfaEnrollmentId: this.enrollmentId,\r\n            totpVerificationInfo\r\n        });\r\n    }\r\n}\r\n/**\r\n * Provider for generating a {@link TotpMultiFactorAssertion}.\r\n *\r\n * Stores the shared secret key and other parameters to generate time-based OTPs.\r\n * Implements methods to retrieve the shared secret key and generate a QR code URL.\r\n * @public\r\n */\r\nclass TotpSecret {\r\n    // The public members are declared outside the constructor so the docs can be generated.\r\n    constructor(secretKey, hashingAlgorithm, codeLength, codeIntervalSeconds, enrollmentCompletionDeadline, sessionInfo, auth) {\r\n        this.sessionInfo = sessionInfo;\r\n        this.auth = auth;\r\n        this.secretKey = secretKey;\r\n        this.hashingAlgorithm = hashingAlgorithm;\r\n        this.codeLength = codeLength;\r\n        this.codeIntervalSeconds = codeIntervalSeconds;\r\n        this.enrollmentCompletionDeadline = enrollmentCompletionDeadline;\r\n    }\r\n    /** @internal */\r\n    static _fromStartTotpMfaEnrollmentResponse(response, auth) {\r\n        return new TotpSecret(response.totpSessionInfo.sharedSecretKey, response.totpSessionInfo.hashingAlgorithm, response.totpSessionInfo.verificationCodeLength, response.totpSessionInfo.periodSec, new Date(response.totpSessionInfo.finalizeEnrollmentTime).toUTCString(), response.totpSessionInfo.sessionInfo, auth);\r\n    }\r\n    /** @internal */\r\n    _makeTotpVerificationInfo(otp) {\r\n        return { sessionInfo: this.sessionInfo, verificationCode: otp };\r\n    }\r\n    /**\r\n     * Returns a QR code URL as described in\r\n     * https://github.com/google/google-authenticator/wiki/Key-Uri-Format\r\n     * This can be displayed to the user as a QR code to be scanned into a TOTP app like Google Authenticator.\r\n     * If the optional parameters are unspecified, an accountName of <userEmail> and issuer of <firebaseAppName> are used.\r\n     *\r\n     * @param accountName the name of the account/app along with a user identifier.\r\n     * @param issuer issuer of the TOTP (likely the app name).\r\n     * @returns A QR code URL string.\r\n     */\r\n    generateQrCodeUrl(accountName, issuer) {\r\n        var _a;\r\n        let useDefaults = false;\r\n        if (_isEmptyString(accountName) || _isEmptyString(issuer)) {\r\n            useDefaults = true;\r\n        }\r\n        if (useDefaults) {\r\n            if (_isEmptyString(accountName)) {\r\n                accountName = ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.email) || 'unknownuser';\r\n            }\r\n            if (_isEmptyString(issuer)) {\r\n                issuer = this.auth.name;\r\n            }\r\n        }\r\n        return `otpauth://totp/${issuer}:${accountName}?secret=${this.secretKey}&issuer=${issuer}&algorithm=${this.hashingAlgorithm}&digits=${this.codeLength}`;\r\n    }\r\n}\r\n/** @internal */\r\nfunction _isEmptyString(input) {\r\n    return typeof input === 'undefined' || (input === null || input === void 0 ? void 0 : input.length) === 0;\r\n}\n\n\n//# sourceMappingURL=totp-cb6285c7.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvZGlzdC9ub2RlLWVzbS90b3RwLWNiNjI4NWM3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkg7QUFDMkk7QUFDek87QUFDaUI7QUFDd0M7QUFDcEM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLGlCQUFpQjtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3REFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQU07QUFDNUI7QUFDQSw4QkFBOEIsc0RBQVE7QUFDdEMsZ0NBQWdDLHNEQUFXLENBQUMsS0FBSyxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBUTtBQUN0QyxpQ0FBaUMsc0RBQVcsQ0FBQyxLQUFLLElBQUk7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHFCQUFxQixpQkFBaUI7QUFDekYsd0JBQXdCLHdEQUFZO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtFQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0RBQWUsTUFBTSw2REFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJLEVBQUUsNENBQTRDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyx5QkFBeUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFXLGlCQUFpQix5QkFBeUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RztBQUM5RyxvREFBb0Q7QUFDcEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseURBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixzQkFBc0I7QUFDakg7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLLEVBQUUsS0FBSyxHQUFHLE1BQU07QUFDekM7QUFDQSxrQkFBa0Isc0JBQXNCLEtBQUssS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNERBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DLDZCQUE2QixrREFBa0Q7QUFDL0UseUJBQXlCLHVEQUF1RDtBQUNoRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvRUFBb0U7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFNBQVM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0VBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLGlCQUFpQiw2Q0FBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUscUJBQXFCLDJEQUFXO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLHVCQUF1QjtBQUN2QyxpR0FBaUcsT0FBTztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUE0QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJLFNBQVM7QUFDL0k7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsWUFBWSw2Q0FBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFdBQVcsc0RBQXNEO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRUFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNWQUFzVjtBQUNuWTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEZBQTBGO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUNBQXVDLEdBQUcsSUFBSSxHQUFHLE9BQU8sR0FBRyxRQUFRO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBSztBQUM5QjtBQUNBO0FBQ0EsK0JBQStCLHFEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxREFBSztBQUNoQztBQUNBO0FBQ0EsMEJBQTBCLHFEQUFLO0FBQy9CO0FBQ0E7QUFDQSx5QkFBeUIscURBQUs7QUFDOUI7QUFDQTtBQUNBLDRCQUE0QixxREFBSztBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLHFEQUFLO0FBQzVCO0FBQ0E7QUFDQSxxQkFBcUIscURBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBSTtBQUNmO0FBQ0EsK0JBQStCLHFEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscURBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0IscURBQUssSUFBSSxHQUFHLGVBQWU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGNBQWMsaUJBQWlCLEdBQUcseUNBQXlDLEdBQUcsc0RBQVcsQ0FBQyxHQUFHLG1CQUFtQjtBQUNoSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUVBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0VBQW9FO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1FQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrRUFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVksbUVBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRUFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyS0FBMks7QUFDM0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0RBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUIsR0FBRyxtQkFBbUIsR0FBRyxVQUFVO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDBCQUEwQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtEQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBLG9DQUFvQyxnQ0FBZ0M7QUFDcEU7QUFDQSxnQ0FBZ0MsK0RBQStEO0FBQy9GO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzRUFBc0U7QUFDN0csK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0IsSUFBSSxtQkFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0QsSUFBSSxjQUFjO0FBQ2xCLFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyREFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFTLDZEQUE2RDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHVCQUF1QjtBQUMvRTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0EscUNBQXFDLFFBQVEsU0FBUyxJQUFJLEtBQUssRUFBRSxRQUFRO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELG1CQUFtQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QyxRQUFRLG1CQUFtQjtBQUMzQixrQ0FBa0MsaUNBQWlDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQseUJBQXlCO0FBQ25GLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DLElBQUksbUJBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQ0FBbUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLHNCQUFzQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxxQkFBcUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsb0JBQW9CO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvQ0FBb0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNCQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQixjQUFjLDZDQUFNO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyREFBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYyxxQkFBcUI7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdCQUF3QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQ0FBa0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDZCQUE2QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdFQUFnRTtBQUNoRjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1DQUFtQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdFQUFnRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlFQUFpQixDQUFDLGtFQUFrQjtBQUNyRDtBQUNBO0FBQ0EsVUFBVSxpRUFBaUIsQ0FBQyxrRUFBa0I7QUFDOUM7QUFDQTtBQUNBLHdCQUF3QixpRUFBaUIsQ0FBQyxrRUFBa0I7QUFDNUQ7QUFDQSxVQUFVLGlFQUFpQixDQUFDLGtFQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQWlCLENBQUMsa0VBQWtCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHFCQUFxQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQscUJBQXFCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUJBQXVCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekIsSUFBSSx5QkFBeUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsYUFBYSx3QkFBd0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxhQUFhLDREQUE0RDtBQUNsSjtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLHFCQUFxQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxpQkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLDZDQUE2QywrQkFBK0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9GQUFvRjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCLEtBQUssaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEscUJBQXFCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLGlCQUFpQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUIsS0FBSyxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEscUJBQXFCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLGlCQUFpQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCLEtBQUssaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxxQkFBcUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0NBQW9DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHNCQUFzQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG9CQUFvQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0IsUUFBUSxzQkFBc0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLGlCQUFpQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLCtCQUErQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUIsS0FBSyxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLHFCQUFxQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxpQkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFDQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCxJQUFJLHNDQUFzQztBQUMxQztBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseURBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4REFBOEQ7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0VBQWtCO0FBQzNDO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsUUFBUSxtRUFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsa0RBQWtEO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUVBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG9CQUFvQjtBQUMzQjtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELElBQUksc0NBQXNDO0FBQzFDO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sb0JBQW9CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVksY0FBYyxZQUFZO0FBQzlFLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0VBQWtCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtCQUFrQiwrREFBK0Q7QUFDakY7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtRUFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNEJBQTRCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrQjtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IsOEZBQThGO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBa0IsVUFBVSxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPLHdCQUF3QixrRUFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELElBQUksc0NBQXNDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtRUFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4RkFBOEY7QUFDakk7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCxJQUFJLHNDQUFzQztBQUMxQztBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUNBQXFDO0FBQ2hHO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFvQjtBQUM1QjtBQUNBO0FBQ0EsZ0NBQWdDLGtFQUFrQjtBQUNsRCxtQ0FBbUMsOEZBQThGO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMkJBQTJCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsMEJBQTBCO0FBQ25HO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCxJQUFJLHNDQUFzQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFvQjtBQUM1QjtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlCQUF5QjtBQUM3QixJQUFJLG1CQUFtQjtBQUN2QixJQUFJLG1CQUFtQjtBQUN2QjtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3SEFBd0g7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCLHNCQUFzQixrRUFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHNCQUFzQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrRUFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzQkFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrRUFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrRUFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxZQUFZO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVksY0FBYyxZQUFZO0FBQzlFLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQ0FBbUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0VBQWtCO0FBQzNDLFFBQVEsbUVBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQ0FBbUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0VBQWtCO0FBQ25EO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0UsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsdUJBQXVCO0FBQ2xHO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pEO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0VBQWtCO0FBQ3RCO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCO0FBQ3JFLElBQUksWUFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEIsS0FBSyx3QkFBd0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELElBQUksc0NBQXNDO0FBQzFDO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUNBQW1DO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHFCQUFxQixzRUFBc0U7QUFDN0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtFQUFrRSxLQUFLO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUVBQWtCLEtBQUssMERBQVMsaURBQWlELGVBQWU7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQywwR0FBMEcsbUJBQW1CO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxpRUFBa0IsS0FBSywwREFBUztBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksOERBQWU7QUFDbkI7QUFDQSxJQUFJLDhEQUFlO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUNBQU8sRUFBRSwyQ0FBUyxFQUFFLDRDQUFVO0FBQ3ZEO0FBQ0E7QUFDQSx1QkFBdUIscURBQU07QUFDN0IscUJBQXFCLDJEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNFQUFzQjtBQUNuRDtBQUNBLDRDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQsUUFBUSw2QkFBNkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0NBQWdDO0FBQ25ELFFBQVEsd0NBQXdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRCw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0JBQStCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sR0FBRyxZQUFZLFVBQVUsZUFBZSxVQUFVLE9BQU8sYUFBYSxzQkFBc0IsVUFBVSxnQkFBZ0I7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpckY7QUFDanJGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhcm50dWJlLTEuMC8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9kaXN0L25vZGUtZXNtL3RvdHAtY2I2Mjg1YzcuanM/NTUxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTREtfVkVSU0lPTiwgX2lzRmlyZWJhc2VTZXJ2ZXJBcHAsIF9nZXRQcm92aWRlciwgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24sIGdldEFwcCB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5LCBpc0Jyb3dzZXJFeHRlbnNpb24sIGlzTW9iaWxlQ29yZG92YSwgaXNSZWFjdE5hdGl2ZSwgRmlyZWJhc2VFcnJvciwgcXVlcnlzdHJpbmcsIGdldE1vZHVsYXJJbnN0YW5jZSwgYmFzZTY0RGVjb2RlLCBnZXRVQSwgaXNJRSwgY3JlYXRlU3Vic2NyaWJlLCBkZWVwRXF1YWwsIHF1ZXJ5c3RyaW5nRGVjb2RlLCBleHRyYWN0UXVlcnlzdHJpbmcsIGdldERlZmF1bHRFbXVsYXRvckhvc3QgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBfX3Jlc3QgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IGZldGNoIGFzIGZldGNoJDEsIEhlYWRlcnMgYXMgSGVhZGVycyQxLCBSZXNwb25zZSBhcyBSZXNwb25zZSQxIH0gZnJvbSAndW5kaWNpJztcbmltcG9ydCB7IExvZ2dlciwgTG9nTGV2ZWwgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGVudW0gb2YgZmFjdG9ycyB0aGF0IG1heSBiZSB1c2VkIGZvciBtdWx0aWZhY3RvciBhdXRoZW50aWNhdGlvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgRmFjdG9ySWQgPSB7XHJcbiAgICAvKiogUGhvbmUgYXMgc2Vjb25kIGZhY3RvciAqL1xyXG4gICAgUEhPTkU6ICdwaG9uZScsXHJcbiAgICBUT1RQOiAndG90cCdcclxufTtcclxuLyoqXHJcbiAqIEVudW1lcmF0aW9uIG9mIHN1cHBvcnRlZCBwcm92aWRlcnMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IFByb3ZpZGVySWQgPSB7XHJcbiAgICAvKiogRmFjZWJvb2sgcHJvdmlkZXIgSUQgKi9cclxuICAgIEZBQ0VCT09LOiAnZmFjZWJvb2suY29tJyxcclxuICAgIC8qKiBHaXRIdWIgcHJvdmlkZXIgSUQgKi9cclxuICAgIEdJVEhVQjogJ2dpdGh1Yi5jb20nLFxyXG4gICAgLyoqIEdvb2dsZSBwcm92aWRlciBJRCAqL1xyXG4gICAgR09PR0xFOiAnZ29vZ2xlLmNvbScsXHJcbiAgICAvKiogUGFzc3dvcmQgcHJvdmlkZXIgKi9cclxuICAgIFBBU1NXT1JEOiAncGFzc3dvcmQnLFxyXG4gICAgLyoqIFBob25lIHByb3ZpZGVyICovXHJcbiAgICBQSE9ORTogJ3Bob25lJyxcclxuICAgIC8qKiBUd2l0dGVyIHByb3ZpZGVyIElEICovXHJcbiAgICBUV0lUVEVSOiAndHdpdHRlci5jb20nXHJcbn07XHJcbi8qKlxyXG4gKiBFbnVtZXJhdGlvbiBvZiBzdXBwb3J0ZWQgc2lnbi1pbiBtZXRob2RzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBTaWduSW5NZXRob2QgPSB7XHJcbiAgICAvKiogRW1haWwgbGluayBzaWduIGluIG1ldGhvZCAqL1xyXG4gICAgRU1BSUxfTElOSzogJ2VtYWlsTGluaycsXHJcbiAgICAvKiogRW1haWwvcGFzc3dvcmQgc2lnbiBpbiBtZXRob2QgKi9cclxuICAgIEVNQUlMX1BBU1NXT1JEOiAncGFzc3dvcmQnLFxyXG4gICAgLyoqIEZhY2Vib29rIHNpZ24gaW4gbWV0aG9kICovXHJcbiAgICBGQUNFQk9PSzogJ2ZhY2Vib29rLmNvbScsXHJcbiAgICAvKiogR2l0SHViIHNpZ24gaW4gbWV0aG9kICovXHJcbiAgICBHSVRIVUI6ICdnaXRodWIuY29tJyxcclxuICAgIC8qKiBHb29nbGUgc2lnbiBpbiBtZXRob2QgKi9cclxuICAgIEdPT0dMRTogJ2dvb2dsZS5jb20nLFxyXG4gICAgLyoqIFBob25lIHNpZ24gaW4gbWV0aG9kICovXHJcbiAgICBQSE9ORTogJ3Bob25lJyxcclxuICAgIC8qKiBUd2l0dGVyIHNpZ24gaW4gbWV0aG9kICovXHJcbiAgICBUV0lUVEVSOiAndHdpdHRlci5jb20nXHJcbn07XHJcbi8qKlxyXG4gKiBFbnVtZXJhdGlvbiBvZiBzdXBwb3J0ZWQgb3BlcmF0aW9uIHR5cGVzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBPcGVyYXRpb25UeXBlID0ge1xyXG4gICAgLyoqIE9wZXJhdGlvbiBpbnZvbHZpbmcgbGlua2luZyBhbiBhZGRpdGlvbmFsIHByb3ZpZGVyIHRvIGFuIGFscmVhZHkgc2lnbmVkLWluIHVzZXIuICovXHJcbiAgICBMSU5LOiAnbGluaycsXHJcbiAgICAvKiogT3BlcmF0aW9uIGludm9sdmluZyB1c2luZyBhIHByb3ZpZGVyIHRvIHJlYXV0aGVudGljYXRlIGFuIGFscmVhZHkgc2lnbmVkLWluIHVzZXIuICovXHJcbiAgICBSRUFVVEhFTlRJQ0FURTogJ3JlYXV0aGVudGljYXRlJyxcclxuICAgIC8qKiBPcGVyYXRpb24gaW52b2x2aW5nIHNpZ25pbmcgaW4gYSB1c2VyLiAqL1xyXG4gICAgU0lHTl9JTjogJ3NpZ25JbidcclxufTtcclxuLyoqXHJcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHRoZSBwb3NzaWJsZSBlbWFpbCBhY3Rpb24gdHlwZXMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IEFjdGlvbkNvZGVPcGVyYXRpb24gPSB7XHJcbiAgICAvKiogVGhlIGVtYWlsIGxpbmsgc2lnbi1pbiBhY3Rpb24uICovXHJcbiAgICBFTUFJTF9TSUdOSU46ICdFTUFJTF9TSUdOSU4nLFxyXG4gICAgLyoqIFRoZSBwYXNzd29yZCByZXNldCBhY3Rpb24uICovXHJcbiAgICBQQVNTV09SRF9SRVNFVDogJ1BBU1NXT1JEX1JFU0VUJyxcclxuICAgIC8qKiBUaGUgZW1haWwgcmV2b2NhdGlvbiBhY3Rpb24uICovXHJcbiAgICBSRUNPVkVSX0VNQUlMOiAnUkVDT1ZFUl9FTUFJTCcsXHJcbiAgICAvKiogVGhlIHJldmVydCBzZWNvbmQgZmFjdG9yIGFkZGl0aW9uIGVtYWlsIGFjdGlvbi4gKi9cclxuICAgIFJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OOiAnUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT04nLFxyXG4gICAgLyoqIFRoZSByZXZlcnQgc2Vjb25kIGZhY3RvciBhZGRpdGlvbiBlbWFpbCBhY3Rpb24uICovXHJcbiAgICBWRVJJRllfQU5EX0NIQU5HRV9FTUFJTDogJ1ZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMJyxcclxuICAgIC8qKiBUaGUgZW1haWwgdmVyaWZpY2F0aW9uIGFjdGlvbi4gKi9cclxuICAgIFZFUklGWV9FTUFJTDogJ1ZFUklGWV9FTUFJTCdcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gX2RlYnVnRXJyb3JNYXAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIFtcImFkbWluLXJlc3RyaWN0ZWQtb3BlcmF0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5BRE1JTl9PTkxZX09QRVJBVElPTiAqL106ICdUaGlzIG9wZXJhdGlvbiBpcyByZXN0cmljdGVkIHRvIGFkbWluaXN0cmF0b3JzIG9ubHkuJyxcclxuICAgICAgICBbXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi9dOiAnJyxcclxuICAgICAgICBbXCJhcHAtbm90LWF1dGhvcml6ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkFQUF9OT1RfQVVUSE9SSVpFRCAqL106IFwiVGhpcyBhcHAsIGlkZW50aWZpZWQgYnkgdGhlIGRvbWFpbiB3aGVyZSBpdCdzIGhvc3RlZCwgaXMgbm90IFwiICtcclxuICAgICAgICAgICAgJ2F1dGhvcml6ZWQgdG8gdXNlIEZpcmViYXNlIEF1dGhlbnRpY2F0aW9uIHdpdGggdGhlIHByb3ZpZGVkIEFQSSBrZXkuICcgK1xyXG4gICAgICAgICAgICAnUmV2aWV3IHlvdXIga2V5IGNvbmZpZ3VyYXRpb24gaW4gdGhlIEdvb2dsZSBBUEkgY29uc29sZS4nLFxyXG4gICAgICAgIFtcImFwcC1ub3QtaW5zdGFsbGVkXCIgLyogQXV0aEVycm9yQ29kZS5BUFBfTk9UX0lOU1RBTExFRCAqL106ICdUaGUgcmVxdWVzdGVkIG1vYmlsZSBhcHBsaWNhdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBpZGVudGlmaWVyICgnICtcclxuICAgICAgICAgICAgJ0FuZHJvaWQgcGFja2FnZSBuYW1lIG9yIGlPUyBidW5kbGUgSUQpIHByb3ZpZGVkIGlzIG5vdCBpbnN0YWxsZWQgb24gJyArXHJcbiAgICAgICAgICAgICd0aGlzIGRldmljZS4nLFxyXG4gICAgICAgIFtcImNhcHRjaGEtY2hlY2stZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5DQVBUQ0hBX0NIRUNLX0ZBSUxFRCAqL106ICdUaGUgcmVDQVBUQ0hBIHJlc3BvbnNlIHRva2VuIHByb3ZpZGVkIGlzIGVpdGhlciBpbnZhbGlkLCBleHBpcmVkLCAnICtcclxuICAgICAgICAgICAgJ2FscmVhZHkgdXNlZCBvciB0aGUgZG9tYWluIGFzc29jaWF0ZWQgd2l0aCBpdCBkb2VzIG5vdCBtYXRjaCB0aGUgbGlzdCAnICtcclxuICAgICAgICAgICAgJ29mIHdoaXRlbGlzdGVkIGRvbWFpbnMuJyxcclxuICAgICAgICBbXCJjb2RlLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkNPREVfRVhQSVJFRCAqL106ICdUaGUgU01TIGNvZGUgaGFzIGV4cGlyZWQuIFBsZWFzZSByZS1zZW5kIHRoZSB2ZXJpZmljYXRpb24gY29kZSB0byB0cnkgJyArXHJcbiAgICAgICAgICAgICdhZ2Fpbi4nLFxyXG4gICAgICAgIFtcImNvcmRvdmEtbm90LXJlYWR5XCIgLyogQXV0aEVycm9yQ29kZS5DT1JET1ZBX05PVF9SRUFEWSAqL106ICdDb3Jkb3ZhIGZyYW1ld29yayBpcyBub3QgcmVhZHkuJyxcclxuICAgICAgICBbXCJjb3JzLXVuc3VwcG9ydGVkXCIgLyogQXV0aEVycm9yQ29kZS5DT1JTX1VOU1VQUE9SVEVEICovXTogJ1RoaXMgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkLicsXHJcbiAgICAgICAgW1wiY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9BTFJFQURZX0lOX1VTRSAqL106ICdUaGlzIGNyZWRlbnRpYWwgaXMgYWxyZWFkeSBhc3NvY2lhdGVkIHdpdGggYSBkaWZmZXJlbnQgdXNlciBhY2NvdW50LicsXHJcbiAgICAgICAgW1wiY3VzdG9tLXRva2VuLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX01JU01BVENIICovXTogJ1RoZSBjdXN0b20gdG9rZW4gY29ycmVzcG9uZHMgdG8gYSBkaWZmZXJlbnQgYXVkaWVuY2UuJyxcclxuICAgICAgICBbXCJyZXF1aXJlcy1yZWNlbnQtbG9naW5cIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTiAqL106ICdUaGlzIG9wZXJhdGlvbiBpcyBzZW5zaXRpdmUgYW5kIHJlcXVpcmVzIHJlY2VudCBhdXRoZW50aWNhdGlvbi4gTG9nIGluICcgK1xyXG4gICAgICAgICAgICAnYWdhaW4gYmVmb3JlIHJldHJ5aW5nIHRoaXMgcmVxdWVzdC4nLFxyXG4gICAgICAgIFtcImRlcGVuZGVudC1zZGstaW5pdGlhbGl6ZWQtYmVmb3JlLWF1dGhcIiAvKiBBdXRoRXJyb3JDb2RlLkRFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSCAqL106ICdBbm90aGVyIEZpcmViYXNlIFNESyB3YXMgaW5pdGlhbGl6ZWQgYW5kIGlzIHRyeWluZyB0byB1c2UgQXV0aCBiZWZvcmUgQXV0aCBpcyAnICtcclxuICAgICAgICAgICAgJ2luaXRpYWxpemVkLiBQbGVhc2UgYmUgc3VyZSB0byBjYWxsIGBpbml0aWFsaXplQXV0aGAgb3IgYGdldEF1dGhgIGJlZm9yZSAnICtcclxuICAgICAgICAgICAgJ3N0YXJ0aW5nIGFueSBvdGhlciBGaXJlYmFzZSBTREsuJyxcclxuICAgICAgICBbXCJkeW5hbWljLWxpbmstbm90LWFjdGl2YXRlZFwiIC8qIEF1dGhFcnJvckNvZGUuRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURUQgKi9dOiAnUGxlYXNlIGFjdGl2YXRlIER5bmFtaWMgTGlua3MgaW4gdGhlIEZpcmViYXNlIENvbnNvbGUgYW5kIGFncmVlIHRvIHRoZSB0ZXJtcyBhbmQgJyArXHJcbiAgICAgICAgICAgICdjb25kaXRpb25zLicsXHJcbiAgICAgICAgW1wiZW1haWwtY2hhbmdlLW5lZWRzLXZlcmlmaWNhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuRU1BSUxfQ0hBTkdFX05FRURTX1ZFUklGSUNBVElPTiAqL106ICdNdWx0aS1mYWN0b3IgdXNlcnMgbXVzdCBhbHdheXMgaGF2ZSBhIHZlcmlmaWVkIGVtYWlsLicsXHJcbiAgICAgICAgW1wiZW1haWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkVNQUlMX0VYSVNUUyAqL106ICdUaGUgZW1haWwgYWRkcmVzcyBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyIGFjY291bnQuJyxcclxuICAgICAgICBbXCJlbXVsYXRvci1jb25maWctZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5FTVVMQVRPUl9DT05GSUdfRkFJTEVEICovXTogJ0F1dGggaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkIHRvIG1ha2UgYSBuZXR3b3JrIGNhbGwuIEF1dGggY2FuICcgK1xyXG4gICAgICAgICAgICAnbm8gbG9uZ2VyIGJlIGNvbmZpZ3VyZWQgdG8gdXNlIHRoZSBlbXVsYXRvci4gVHJ5IGNhbGxpbmcgJyArXHJcbiAgICAgICAgICAgICdcImNvbm5lY3RBdXRoRW11bGF0b3IoKVwiIHNvb25lci4nLFxyXG4gICAgICAgIFtcImV4cGlyZWQtYWN0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLkVYUElSRURfT09CX0NPREUgKi9dOiAnVGhlIGFjdGlvbiBjb2RlIGhhcyBleHBpcmVkLicsXHJcbiAgICAgICAgW1wiY2FuY2VsbGVkLXBvcHVwLXJlcXVlc3RcIiAvKiBBdXRoRXJyb3JDb2RlLkVYUElSRURfUE9QVVBfUkVRVUVTVCAqL106ICdUaGlzIG9wZXJhdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgZHVlIHRvIGFub3RoZXIgY29uZmxpY3RpbmcgcG9wdXAgYmVpbmcgb3BlbmVkLicsXHJcbiAgICAgICAgW1wiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWFwcC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQUF9DUkVERU5USUFMICovXTogJ1RoZSBwaG9uZSB2ZXJpZmljYXRpb24gcmVxdWVzdCBjb250YWlucyBhbiBpbnZhbGlkIGFwcGxpY2F0aW9uIHZlcmlmaWVyLicgK1xyXG4gICAgICAgICAgICAnIFRoZSByZUNBUFRDSEEgdG9rZW4gcmVzcG9uc2UgaXMgZWl0aGVyIGludmFsaWQgb3IgZXhwaXJlZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtYXBwLWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQUF9JRCAqL106ICdUaGUgbW9iaWxlIGFwcCBpZGVudGlmaWVyIGlzIG5vdCByZWdpc3RlZCBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtdXNlci10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIICovXTogXCJUaGlzIHVzZXIncyBjcmVkZW50aWFsIGlzbid0IHZhbGlkIGZvciB0aGlzIHByb2plY3QuIFRoaXMgY2FuIGhhcHBlbiBcIiArXHJcbiAgICAgICAgICAgIFwiaWYgdGhlIHVzZXIncyB0b2tlbiBoYXMgYmVlbiB0YW1wZXJlZCB3aXRoLCBvciBpZiB0aGUgdXNlciBpc24ndCBmb3IgXCIgK1xyXG4gICAgICAgICAgICAndGhlIHByb2plY3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQVBJIGtleS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtYXV0aC1ldmVudFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIX0VWRU5UICovXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLXZlcmlmaWNhdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPREUgKi9dOiAnVGhlIFNNUyB2ZXJpZmljYXRpb24gY29kZSB1c2VkIHRvIGNyZWF0ZSB0aGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIGlzICcgK1xyXG4gICAgICAgICAgICAnaW52YWxpZC4gUGxlYXNlIHJlc2VuZCB0aGUgdmVyaWZpY2F0aW9uIGNvZGUgc21zIGFuZCBiZSBzdXJlIHRvIHVzZSB0aGUgJyArXHJcbiAgICAgICAgICAgICd2ZXJpZmljYXRpb24gY29kZSBwcm92aWRlZCBieSB0aGUgdXNlci4nLFxyXG4gICAgICAgIFtcImludmFsaWQtY29udGludWUtdXJpXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPTlRJTlVFX1VSSSAqL106ICdUaGUgY29udGludWUgVVJMIHByb3ZpZGVkIGluIHRoZSByZXF1ZXN0IGlzIGludmFsaWQuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWNvcmRvdmEtY29uZmlndXJhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT1JET1ZBX0NPTkZJR1VSQVRJT04gKi9dOiAnVGhlIGZvbGxvd2luZyBDb3Jkb3ZhIHBsdWdpbnMgbXVzdCBiZSBpbnN0YWxsZWQgdG8gZW5hYmxlIE9BdXRoIHNpZ24taW46ICcgK1xyXG4gICAgICAgICAgICAnY29yZG92YS1wbHVnaW4tYnVpbGRpbmZvLCBjb3Jkb3ZhLXVuaXZlcnNhbC1saW5rcy1wbHVnaW4sICcgK1xyXG4gICAgICAgICAgICAnY29yZG92YS1wbHVnaW4tYnJvd3NlcnRhYiwgY29yZG92YS1wbHVnaW4taW5hcHBicm93c2VyIGFuZCAnICtcclxuICAgICAgICAgICAgJ2NvcmRvdmEtcGx1Z2luLWN1c3RvbXVybHNjaGVtZS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtY3VzdG9tLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NVU1RPTV9UT0tFTiAqL106ICdUaGUgY3VzdG9tIHRva2VuIGZvcm1hdCBpcyBpbmNvcnJlY3QuIFBsZWFzZSBjaGVjayB0aGUgZG9jdW1lbnRhdGlvbi4nLFxyXG4gICAgICAgIFtcImludmFsaWQtZHluYW1pYy1saW5rLWRvbWFpblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9EWU5BTUlDX0xJTktfRE9NQUlOICovXTogJ1RoZSBwcm92aWRlZCBkeW5hbWljIGxpbmsgZG9tYWluIGlzIG5vdCBjb25maWd1cmVkIG9yIGF1dGhvcml6ZWQgZm9yIHRoZSBjdXJyZW50IHByb2plY3QuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWVtYWlsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNQUlMICovXTogJ1RoZSBlbWFpbCBhZGRyZXNzIGlzIGJhZGx5IGZvcm1hdHRlZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtZW11bGF0b3Itc2NoZW1lXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNVUxBVE9SX1NDSEVNRSAqL106ICdFbXVsYXRvciBVUkwgbXVzdCBzdGFydCB3aXRoIGEgdmFsaWQgc2NoZW1lIChodHRwOi8vIG9yIGh0dHBzOi8vKS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtYXBpLWtleVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BUElfS0VZICovXTogJ1lvdXIgQVBJIGtleSBpcyBpbnZhbGlkLCBwbGVhc2UgY2hlY2sgeW91IGhhdmUgY29waWVkIGl0IGNvcnJlY3RseS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtY2VydC1oYXNoXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NFUlRfSEFTSCAqL106ICdUaGUgU0hBLTEgY2VydGlmaWNhdGUgaGFzaCBwcm92aWRlZCBpcyBpbnZhbGlkLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NSRURFTlRJQUwgKi9dOiAnVGhlIHN1cHBsaWVkIGF1dGggY3JlZGVudGlhbCBpcyBpbmNvcnJlY3QsIG1hbGZvcm1lZCBvciBoYXMgZXhwaXJlZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtbWVzc2FnZS1wYXlsb2FkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0VfUEFZTE9BRCAqL106ICdUaGUgZW1haWwgdGVtcGxhdGUgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgaW4gaXRzIG1lc3NhZ2UuICcgK1xyXG4gICAgICAgICAgICAnUGxlYXNlIGZpeCBieSBnb2luZyB0byB0aGUgQXV0aCBlbWFpbCB0ZW1wbGF0ZXMgc2VjdGlvbiBpbiB0aGUgRmlyZWJhc2UgQ29uc29sZS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtbXVsdGktZmFjdG9yLXNlc3Npb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfTUZBX1NFU1NJT04gKi9dOiAnVGhlIHJlcXVlc3QgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIHByb29mIG9mIGZpcnN0IGZhY3RvciBzdWNjZXNzZnVsIHNpZ24taW4uJyxcclxuICAgICAgICBbXCJpbnZhbGlkLW9hdXRoLXByb3ZpZGVyXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09BVVRIX1BST1ZJREVSICovXTogJ0VtYWlsQXV0aFByb3ZpZGVyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgb3BlcmF0aW9uLiBUaGlzIG9wZXJhdGlvbiAnICtcclxuICAgICAgICAgICAgJ29ubHkgc3VwcG9ydHMgT0F1dGggcHJvdmlkZXJzLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1vYXV0aC1jbGllbnQtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT0FVVEhfQ0xJRU5UX0lEICovXTogJ1RoZSBPQXV0aCBjbGllbnQgSUQgcHJvdmlkZWQgaXMgZWl0aGVyIGludmFsaWQgb3IgZG9lcyBub3QgbWF0Y2ggdGhlICcgK1xyXG4gICAgICAgICAgICAnc3BlY2lmaWVkIEFQSSBrZXkuJyxcclxuICAgICAgICBbXCJ1bmF1dGhvcml6ZWQtZG9tYWluXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09SSUdJTiAqL106ICdUaGlzIGRvbWFpbiBpcyBub3QgYXV0aG9yaXplZCBmb3IgT0F1dGggb3BlcmF0aW9ucyBmb3IgeW91ciBGaXJlYmFzZSAnICtcclxuICAgICAgICAgICAgJ3Byb2plY3QuIEVkaXQgdGhlIGxpc3Qgb2YgYXV0aG9yaXplZCBkb21haW5zIGZyb20gdGhlIEZpcmViYXNlIGNvbnNvbGUuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWFjdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09PQl9DT0RFICovXTogJ1RoZSBhY3Rpb24gY29kZSBpcyBpbnZhbGlkLiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIGNvZGUgaXMgbWFsZm9ybWVkLCAnICtcclxuICAgICAgICAgICAgJ2V4cGlyZWQsIG9yIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC4nLFxyXG4gICAgICAgIFtcIndyb25nLXBhc3N3b3JkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1BBU1NXT1JEICovXTogJ1RoZSBwYXNzd29yZCBpcyBpbnZhbGlkIG9yIHRoZSB1c2VyIGRvZXMgbm90IGhhdmUgYSBwYXNzd29yZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtcGVyc2lzdGVuY2UtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9QRVJTSVNURU5DRSAqL106ICdUaGUgc3BlY2lmaWVkIHBlcnNpc3RlbmNlIHR5cGUgaXMgaW52YWxpZC4gSXQgY2FuIG9ubHkgYmUgbG9jYWwsIHNlc3Npb24gb3Igbm9uZS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtcGhvbmUtbnVtYmVyXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1BIT05FX05VTUJFUiAqL106ICdUaGUgZm9ybWF0IG9mIHRoZSBwaG9uZSBudW1iZXIgcHJvdmlkZWQgaXMgaW5jb3JyZWN0LiBQbGVhc2UgZW50ZXIgdGhlICcgK1xyXG4gICAgICAgICAgICAncGhvbmUgbnVtYmVyIGluIGEgZm9ybWF0IHRoYXQgY2FuIGJlIHBhcnNlZCBpbnRvIEUuMTY0IGZvcm1hdC4gRS4xNjQgJyArXHJcbiAgICAgICAgICAgICdwaG9uZSBudW1iZXJzIGFyZSB3cml0dGVuIGluIHRoZSBmb3JtYXQgWytdW2NvdW50cnkgY29kZV1bc3Vic2NyaWJlciAnICtcclxuICAgICAgICAgICAgJ251bWJlciBpbmNsdWRpbmcgYXJlYSBjb2RlXS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtcHJvdmlkZXItaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUFJPVklERVJfSUQgKi9dOiAnVGhlIHNwZWNpZmllZCBwcm92aWRlciBJRCBpcyBpbnZhbGlkLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1yZWNpcGllbnQtZW1haWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDSVBJRU5UX0VNQUlMICovXTogJ1RoZSBlbWFpbCBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYWN0aW9uIGZhaWxlZCB0byBzZW5kIGFzIHRoZSBwcm92aWRlZCAnICtcclxuICAgICAgICAgICAgJ3JlY2lwaWVudCBlbWFpbCBhZGRyZXNzIGlzIGludmFsaWQuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLXNlbmRlclwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9TRU5ERVIgKi9dOiAnVGhlIGVtYWlsIHRlbXBsYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3Rpb24gY29udGFpbnMgYW4gaW52YWxpZCBzZW5kZXIgZW1haWwgb3IgbmFtZS4gJyArXHJcbiAgICAgICAgICAgICdQbGVhc2UgZml4IGJ5IGdvaW5nIHRvIHRoZSBBdXRoIGVtYWlsIHRlbXBsYXRlcyBzZWN0aW9uIGluIHRoZSBGaXJlYmFzZSBDb25zb2xlLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC12ZXJpZmljYXRpb24taWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfU0VTU0lPTl9JTkZPICovXTogJ1RoZSB2ZXJpZmljYXRpb24gSUQgdXNlZCB0byBjcmVhdGUgdGhlIHBob25lIGF1dGggY3JlZGVudGlhbCBpcyBpbnZhbGlkLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC10ZW5hbnQtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfVEVOQU5UX0lEICovXTogXCJUaGUgQXV0aCBpbnN0YW5jZSdzIHRlbmFudCBJRCBpcyBpbnZhbGlkLlwiLFxyXG4gICAgICAgIFtcImxvZ2luLWJsb2NrZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkxPR0lOX0JMT0NLRUQgKi9dOiAnTG9naW4gYmxvY2tlZCBieSB1c2VyLXByb3ZpZGVkIG1ldGhvZDogeyRvcmlnaW5hbE1lc3NhZ2V9JyxcclxuICAgICAgICBbXCJtaXNzaW5nLWFuZHJvaWQtcGtnLW5hbWVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUUgKi9dOiAnQW4gQW5kcm9pZCBQYWNrYWdlIE5hbWUgbXVzdCBiZSBwcm92aWRlZCBpZiB0aGUgQW5kcm9pZCBBcHAgaXMgcmVxdWlyZWQgdG8gYmUgaW5zdGFsbGVkLicsXHJcbiAgICAgICAgW1wiYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FVVEhfRE9NQUlOICovXTogJ0JlIHN1cmUgdG8gaW5jbHVkZSBhdXRoRG9tYWluIHdoZW4gY2FsbGluZyBmaXJlYmFzZS5pbml0aWFsaXplQXBwKCksICcgK1xyXG4gICAgICAgICAgICAnYnkgZm9sbG93aW5nIHRoZSBpbnN0cnVjdGlvbnMgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLWFwcC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FQUF9DUkVERU5USUFMICovXTogJ1RoZSBwaG9uZSB2ZXJpZmljYXRpb24gcmVxdWVzdCBpcyBtaXNzaW5nIGFuIGFwcGxpY2F0aW9uIHZlcmlmaWVyICcgK1xyXG4gICAgICAgICAgICAnYXNzZXJ0aW9uLiBBIHJlQ0FQVENIQSByZXNwb25zZSB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC4nLFxyXG4gICAgICAgIFtcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQ09ERSAqL106ICdUaGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIHdhcyBjcmVhdGVkIHdpdGggYW4gZW1wdHkgU01TIHZlcmlmaWNhdGlvbiBjb2RlLicsXHJcbiAgICAgICAgW1wibWlzc2luZy1jb250aW51ZS11cmlcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQ09OVElOVUVfVVJJICovXTogJ0EgY29udGludWUgVVJMIG11c3QgYmUgcHJvdmlkZWQgaW4gdGhlIHJlcXVlc3QuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLWlmcmFtZS1zdGFydFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19JRlJBTUVfU1RBUlQgKi9dOiAnQW4gaW50ZXJuYWwgQXV0aEVycm9yIGhhcyBvY2N1cnJlZC4nLFxyXG4gICAgICAgIFtcIm1pc3NpbmctaW9zLWJ1bmRsZS1pZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19JT1NfQlVORExFX0lEICovXTogJ0FuIGlPUyBCdW5kbGUgSUQgbXVzdCBiZSBwcm92aWRlZCBpZiBhbiBBcHAgU3RvcmUgSUQgaXMgcHJvdmlkZWQuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLW9yLWludmFsaWQtbm9uY2VcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfT1JfSU5WQUxJRF9OT05DRSAqL106ICdUaGUgcmVxdWVzdCBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgbm9uY2UuIFRoaXMgY2FuIG9jY3VyIGlmIHRoZSAnICtcclxuICAgICAgICAgICAgJ1NIQS0yNTYgaGFzaCBvZiB0aGUgcHJvdmlkZWQgcmF3IG5vbmNlIGRvZXMgbm90IG1hdGNoIHRoZSBoYXNoZWQgbm9uY2UgJyArXHJcbiAgICAgICAgICAgICdpbiB0aGUgSUQgdG9rZW4gcGF5bG9hZC4nLFxyXG4gICAgICAgIFtcIm1pc3NpbmctcGFzc3dvcmRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUEFTU1dPUkQgKi9dOiAnQSBub24tZW1wdHkgcGFzc3dvcmQgbXVzdCBiZSBwcm92aWRlZCcsXHJcbiAgICAgICAgW1wibWlzc2luZy1tdWx0aS1mYWN0b3ItaW5mb1wiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19NRkFfSU5GTyAqL106ICdObyBzZWNvbmQgZmFjdG9yIGlkZW50aWZpZXIgaXMgcHJvdmlkZWQuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLW11bHRpLWZhY3Rvci1zZXNzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX01GQV9TRVNTSU9OICovXTogJ1RoZSByZXF1ZXN0IGlzIG1pc3NpbmcgcHJvb2Ygb2YgZmlyc3QgZmFjdG9yIHN1Y2Nlc3NmdWwgc2lnbi1pbi4nLFxyXG4gICAgICAgIFtcIm1pc3NpbmctcGhvbmUtbnVtYmVyXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1BIT05FX05VTUJFUiAqL106ICdUbyBzZW5kIHZlcmlmaWNhdGlvbiBjb2RlcywgcHJvdmlkZSBhIHBob25lIG51bWJlciBmb3IgdGhlIHJlY2lwaWVudC4nLFxyXG4gICAgICAgIFtcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWlkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1NFU1NJT05fSU5GTyAqL106ICdUaGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIHdhcyBjcmVhdGVkIHdpdGggYW4gZW1wdHkgdmVyaWZpY2F0aW9uIElELicsXHJcbiAgICAgICAgW1wiYXBwLWRlbGV0ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1PRFVMRV9ERVNUUk9ZRUQgKi9dOiAnVGhpcyBpbnN0YW5jZSBvZiBGaXJlYmFzZUFwcCBoYXMgYmVlbiBkZWxldGVkLicsXHJcbiAgICAgICAgW1wibXVsdGktZmFjdG9yLWluZm8tbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5NRkFfSU5GT19OT1RfRk9VTkQgKi9dOiAnVGhlIHVzZXIgZG9lcyBub3QgaGF2ZSBhIHNlY29uZCBmYWN0b3IgbWF0Y2hpbmcgdGhlIGlkZW50aWZpZXIgcHJvdmlkZWQuJyxcclxuICAgICAgICBbXCJtdWx0aS1mYWN0b3ItYXV0aC1yZXF1aXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVEICovXTogJ1Byb29mIG9mIG93bmVyc2hpcCBvZiBhIHNlY29uZCBmYWN0b3IgaXMgcmVxdWlyZWQgdG8gY29tcGxldGUgc2lnbi1pbi4nLFxyXG4gICAgICAgIFtcImFjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLk5FRURfQ09ORklSTUFUSU9OICovXTogJ0FuIGFjY291bnQgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGUgc2FtZSBlbWFpbCBhZGRyZXNzIGJ1dCBkaWZmZXJlbnQgJyArXHJcbiAgICAgICAgICAgICdzaWduLWluIGNyZWRlbnRpYWxzLiBTaWduIGluIHVzaW5nIGEgcHJvdmlkZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgJyArXHJcbiAgICAgICAgICAgICdlbWFpbCBhZGRyZXNzLicsXHJcbiAgICAgICAgW1wibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqL106ICdBIG5ldHdvcmsgQXV0aEVycm9yIChzdWNoIGFzIHRpbWVvdXQsIGludGVycnVwdGVkIGNvbm5lY3Rpb24gb3IgdW5yZWFjaGFibGUgaG9zdCkgaGFzIG9jY3VycmVkLicsXHJcbiAgICAgICAgW1wibm8tYXV0aC1ldmVudFwiIC8qIEF1dGhFcnJvckNvZGUuTk9fQVVUSF9FVkVOVCAqL106ICdBbiBpbnRlcm5hbCBBdXRoRXJyb3IgaGFzIG9jY3VycmVkLicsXHJcbiAgICAgICAgW1wibm8tc3VjaC1wcm92aWRlclwiIC8qIEF1dGhFcnJvckNvZGUuTk9fU1VDSF9QUk9WSURFUiAqL106ICdVc2VyIHdhcyBub3QgbGlua2VkIHRvIGFuIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gcHJvdmlkZXIuJyxcclxuICAgICAgICBbXCJudWxsLXVzZXJcIiAvKiBBdXRoRXJyb3JDb2RlLk5VTExfVVNFUiAqL106ICdBIG51bGwgdXNlciBvYmplY3Qgd2FzIHByb3ZpZGVkIGFzIHRoZSBhcmd1bWVudCBmb3IgYW4gb3BlcmF0aW9uIHdoaWNoICcgK1xyXG4gICAgICAgICAgICAncmVxdWlyZXMgYSBub24tbnVsbCB1c2VyIG9iamVjdC4nLFxyXG4gICAgICAgIFtcIm9wZXJhdGlvbi1ub3QtYWxsb3dlZFwiIC8qIEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9BTExPV0VEICovXTogJ1RoZSBnaXZlbiBzaWduLWluIHByb3ZpZGVyIGlzIGRpc2FibGVkIGZvciB0aGlzIEZpcmViYXNlIHByb2plY3QuICcgK1xyXG4gICAgICAgICAgICAnRW5hYmxlIGl0IGluIHRoZSBGaXJlYmFzZSBjb25zb2xlLCB1bmRlciB0aGUgc2lnbi1pbiBtZXRob2QgdGFiIG9mIHRoZSAnICtcclxuICAgICAgICAgICAgJ0F1dGggc2VjdGlvbi4nLFxyXG4gICAgICAgIFtcIm9wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnRcIiAvKiBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfU1VQUE9SVEVEICovXTogJ1RoaXMgb3BlcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGVudmlyb25tZW50IHRoaXMgYXBwbGljYXRpb24gaXMgJyArXHJcbiAgICAgICAgICAgICdydW5uaW5nIG9uLiBcImxvY2F0aW9uLnByb3RvY29sXCIgbXVzdCBiZSBodHRwLCBodHRwcyBvciBjaHJvbWUtZXh0ZW5zaW9uJyArXHJcbiAgICAgICAgICAgICcgYW5kIHdlYiBzdG9yYWdlIG11c3QgYmUgZW5hYmxlZC4nLFxyXG4gICAgICAgIFtcInBvcHVwLWJsb2NrZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlBPUFVQX0JMT0NLRUQgKi9dOiAnVW5hYmxlIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgcG9wdXAuIEl0IG1heSBoYXZlIGJlZW4gYmxvY2tlZCBieSB0aGUgYnJvd3Nlci4nLFxyXG4gICAgICAgIFtcInBvcHVwLWNsb3NlZC1ieS11c2VyXCIgLyogQXV0aEVycm9yQ29kZS5QT1BVUF9DTE9TRURfQllfVVNFUiAqL106ICdUaGUgcG9wdXAgaGFzIGJlZW4gY2xvc2VkIGJ5IHRoZSB1c2VyIGJlZm9yZSBmaW5hbGl6aW5nIHRoZSBvcGVyYXRpb24uJyxcclxuICAgICAgICBbXCJwcm92aWRlci1hbHJlYWR5LWxpbmtlZFwiIC8qIEF1dGhFcnJvckNvZGUuUFJPVklERVJfQUxSRUFEWV9MSU5LRUQgKi9dOiAnVXNlciBjYW4gb25seSBiZSBsaW5rZWQgdG8gb25lIGlkZW50aXR5IGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuJyxcclxuICAgICAgICBbXCJxdW90YS1leGNlZWRlZFwiIC8qIEF1dGhFcnJvckNvZGUuUVVPVEFfRVhDRUVERUQgKi9dOiBcIlRoZSBwcm9qZWN0J3MgcXVvdGEgZm9yIHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIGV4Y2VlZGVkLlwiLFxyXG4gICAgICAgIFtcInJlZGlyZWN0LWNhbmNlbGxlZC1ieS11c2VyXCIgLyogQXV0aEVycm9yQ29kZS5SRURJUkVDVF9DQU5DRUxMRURfQllfVVNFUiAqL106ICdUaGUgcmVkaXJlY3Qgb3BlcmF0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCBieSB0aGUgdXNlciBiZWZvcmUgZmluYWxpemluZy4nLFxyXG4gICAgICAgIFtcInJlZGlyZWN0LW9wZXJhdGlvbi1wZW5kaW5nXCIgLyogQXV0aEVycm9yQ29kZS5SRURJUkVDVF9PUEVSQVRJT05fUEVORElORyAqL106ICdBIHJlZGlyZWN0IHNpZ24taW4gb3BlcmF0aW9uIGlzIGFscmVhZHkgcGVuZGluZy4nLFxyXG4gICAgICAgIFtcInJlamVjdGVkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLlJFSkVDVEVEX0NSRURFTlRJQUwgKi9dOiAnVGhlIHJlcXVlc3QgY29udGFpbnMgbWFsZm9ybWVkIG9yIG1pc21hdGNoaW5nIGNyZWRlbnRpYWxzLicsXHJcbiAgICAgICAgW1wic2Vjb25kLWZhY3Rvci1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuU0VDT05EX0ZBQ1RPUl9BTFJFQURZX0VOUk9MTEVEICovXTogJ1RoZSBzZWNvbmQgZmFjdG9yIGlzIGFscmVhZHkgZW5yb2xsZWQgb24gdGhpcyBhY2NvdW50LicsXHJcbiAgICAgICAgW1wibWF4aW11bS1zZWNvbmQtZmFjdG9yLWNvdW50LWV4Y2VlZGVkXCIgLyogQXV0aEVycm9yQ29kZS5TRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEICovXTogJ1RoZSBtYXhpbXVtIGFsbG93ZWQgbnVtYmVyIG9mIHNlY29uZCBmYWN0b3JzIG9uIGEgdXNlciBoYXMgYmVlbiBleGNlZWRlZC4nLFxyXG4gICAgICAgIFtcInRlbmFudC1pZC1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuVEVOQU5UX0lEX01JU01BVENIICovXTogXCJUaGUgcHJvdmlkZWQgdGVuYW50IElEIGRvZXMgbm90IG1hdGNoIHRoZSBBdXRoIGluc3RhbmNlJ3MgdGVuYW50IElEXCIsXHJcbiAgICAgICAgW1widGltZW91dFwiIC8qIEF1dGhFcnJvckNvZGUuVElNRU9VVCAqL106ICdUaGUgb3BlcmF0aW9uIGhhcyB0aW1lZCBvdXQuJyxcclxuICAgICAgICBbXCJ1c2VyLXRva2VuLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUQgKi9dOiBcIlRoZSB1c2VyJ3MgY3JlZGVudGlhbCBpcyBubyBsb25nZXIgdmFsaWQuIFRoZSB1c2VyIG11c3Qgc2lnbiBpbiBhZ2Fpbi5cIixcclxuICAgICAgICBbXCJ0b28tbWFueS1yZXF1ZXN0c1wiIC8qIEF1dGhFcnJvckNvZGUuVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSICovXTogJ1dlIGhhdmUgYmxvY2tlZCBhbGwgcmVxdWVzdHMgZnJvbSB0aGlzIGRldmljZSBkdWUgdG8gdW51c3VhbCBhY3Rpdml0eS4gJyArXHJcbiAgICAgICAgICAgICdUcnkgYWdhaW4gbGF0ZXIuJyxcclxuICAgICAgICBbXCJ1bmF1dGhvcml6ZWQtY29udGludWUtdXJpXCIgLyogQXV0aEVycm9yQ29kZS5VTkFVVEhPUklaRURfRE9NQUlOICovXTogJ1RoZSBkb21haW4gb2YgdGhlIGNvbnRpbnVlIFVSTCBpcyBub3Qgd2hpdGVsaXN0ZWQuICBQbGVhc2Ugd2hpdGVsaXN0ICcgK1xyXG4gICAgICAgICAgICAndGhlIGRvbWFpbiBpbiB0aGUgRmlyZWJhc2UgY29uc29sZS4nLFxyXG4gICAgICAgIFtcInVuc3VwcG9ydGVkLWZpcnN0LWZhY3RvclwiIC8qIEF1dGhFcnJvckNvZGUuVU5TVVBQT1JURURfRklSU1RfRkFDVE9SICovXTogJ0Vucm9sbGluZyBhIHNlY29uZCBmYWN0b3Igb3Igc2lnbmluZyBpbiB3aXRoIGEgbXVsdGktZmFjdG9yIGFjY291bnQgcmVxdWlyZXMgc2lnbi1pbiB3aXRoIGEgc3VwcG9ydGVkIGZpcnN0IGZhY3Rvci4nLFxyXG4gICAgICAgIFtcInVuc3VwcG9ydGVkLXBlcnNpc3RlbmNlLXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX1BFUlNJU1RFTkNFICovXTogJ1RoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgdGhlIHNwZWNpZmllZCBwZXJzaXN0ZW5jZSB0eXBlLicsXHJcbiAgICAgICAgW1widW5zdXBwb3J0ZWQtdGVuYW50LW9wZXJhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuVU5TVVBQT1JURURfVEVOQU5UX09QRVJBVElPTiAqL106ICdUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIGEgbXVsdGktdGVuYW50IGNvbnRleHQuJyxcclxuICAgICAgICBbXCJ1bnZlcmlmaWVkLWVtYWlsXCIgLyogQXV0aEVycm9yQ29kZS5VTlZFUklGSUVEX0VNQUlMICovXTogJ1RoZSBvcGVyYXRpb24gcmVxdWlyZXMgYSB2ZXJpZmllZCBlbWFpbC4nLFxyXG4gICAgICAgIFtcInVzZXItY2FuY2VsbGVkXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0NBTkNFTExFRCAqL106ICdUaGUgdXNlciBkaWQgbm90IGdyYW50IHlvdXIgYXBwbGljYXRpb24gdGhlIHBlcm1pc3Npb25zIGl0IHJlcXVlc3RlZC4nLFxyXG4gICAgICAgIFtcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi9dOiAnVGhlcmUgaXMgbm8gdXNlciByZWNvcmQgY29ycmVzcG9uZGluZyB0byB0aGlzIGlkZW50aWZpZXIuIFRoZSB1c2VyIG1heSAnICtcclxuICAgICAgICAgICAgJ2hhdmUgYmVlbiBkZWxldGVkLicsXHJcbiAgICAgICAgW1widXNlci1kaXNhYmxlZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ESVNBQkxFRCAqL106ICdUaGUgdXNlciBhY2NvdW50IGhhcyBiZWVuIGRpc2FibGVkIGJ5IGFuIGFkbWluaXN0cmF0b3IuJyxcclxuICAgICAgICBbXCJ1c2VyLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX01JU01BVENIICovXTogJ1RoZSBzdXBwbGllZCBjcmVkZW50aWFscyBkbyBub3QgY29ycmVzcG9uZCB0byB0aGUgcHJldmlvdXNseSBzaWduZWQgaW4gdXNlci4nLFxyXG4gICAgICAgIFtcInVzZXItc2lnbmVkLW91dFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9TSUdORURfT1VUICovXTogJycsXHJcbiAgICAgICAgW1wid2Vhay1wYXNzd29yZFwiIC8qIEF1dGhFcnJvckNvZGUuV0VBS19QQVNTV09SRCAqL106ICdUaGUgcGFzc3dvcmQgbXVzdCBiZSA2IGNoYXJhY3RlcnMgbG9uZyBvciBtb3JlLicsXHJcbiAgICAgICAgW1wid2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLldFQl9TVE9SQUdFX1VOU1VQUE9SVEVEICovXTogJ1RoaXMgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkIG9yIDNyZCBwYXJ0eSBjb29raWVzIGFuZCBkYXRhIG1heSBiZSBkaXNhYmxlZC4nLFxyXG4gICAgICAgIFtcImFscmVhZHktaW5pdGlhbGl6ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkFMUkVBRFlfSU5JVElBTElaRUQgKi9dOiAnaW5pdGlhbGl6ZUF1dGgoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCB3aXRoICcgK1xyXG4gICAgICAgICAgICAnZGlmZmVyZW50IG9wdGlvbnMuIFRvIGF2b2lkIHRoaXMgZXJyb3IsIGNhbGwgaW5pdGlhbGl6ZUF1dGgoKSB3aXRoIHRoZSAnICtcclxuICAgICAgICAgICAgJ3NhbWUgb3B0aW9ucyBhcyB3aGVuIGl0IHdhcyBvcmlnaW5hbGx5IGNhbGxlZCwgb3IgY2FsbCBnZXRBdXRoKCkgdG8gcmV0dXJuIHRoZScgK1xyXG4gICAgICAgICAgICAnIGFscmVhZHkgaW5pdGlhbGl6ZWQgaW5zdGFuY2UuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLXJlY2FwdGNoYS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4gKi9dOiAnVGhlIHJlQ0FQVENIQSB0b2tlbiBpcyBtaXNzaW5nIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1yZWNhcHRjaGEtdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1RPS0VOICovXTogJ1RoZSByZUNBUFRDSEEgdG9rZW4gaXMgaW52YWxpZCB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtcmVjYXB0Y2hhLWFjdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OICovXTogJ1RoZSByZUNBUFRDSEEgYWN0aW9uIGlzIGludmFsaWQgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcclxuICAgICAgICBbXCJyZWNhcHRjaGEtbm90LWVuYWJsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlJFQ0FQVENIQV9OT1RfRU5BQkxFRCAqL106ICdyZUNBUFRDSEEgRW50ZXJwcmlzZSBpbnRlZ3JhdGlvbiBpcyBub3QgZW5hYmxlZCBmb3IgdGhpcyBwcm9qZWN0LicsXHJcbiAgICAgICAgW1wibWlzc2luZy1jbGllbnQtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19DTElFTlRfVFlQRSAqL106ICdUaGUgcmVDQVBUQ0hBIGNsaWVudCB0eXBlIGlzIG1pc3Npbmcgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLXJlY2FwdGNoYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OICovXTogJ1RoZSByZUNBUFRDSEEgdmVyc2lvbiBpcyBtaXNzaW5nIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1yZXEtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRVFfVFlQRSAqL106ICdJbnZhbGlkIHJlcXVlc3QgcGFyYW1ldGVycy4nLFxyXG4gICAgICAgIFtcImludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04gKi9dOiAnVGhlIHJlQ0FQVENIQSB2ZXJzaW9uIGlzIGludmFsaWQgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcclxuICAgICAgICBbXCJ1bnN1cHBvcnRlZC1wYXNzd29yZC1wb2xpY3ktc2NoZW1hLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX1BBU1NXT1JEX1BPTElDWV9TQ0hFTUFfVkVSU0lPTiAqL106ICdUaGUgcGFzc3dvcmQgcG9saWN5IHJlY2VpdmVkIGZyb20gdGhlIGJhY2tlbmQgdXNlcyBhIHNjaGVtYSB2ZXJzaW9uIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHZlcnNpb24gb2YgdGhlIEZpcmViYXNlIFNESy4nLFxyXG4gICAgICAgIFtcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL106ICdUaGUgcGFzc3dvcmQgZG9lcyBub3QgbWVldCB0aGUgcmVxdWlyZW1lbnRzLidcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gX3Byb2RFcnJvck1hcCgpIHtcclxuICAgIC8vIFdlIHdpbGwgaW5jbHVkZSB0aGlzIG9uZSBtZXNzYWdlIGluIHRoZSBwcm9kIGVycm9yIG1hcCBzaW5jZSBieSB0aGUgdmVyeVxyXG4gICAgLy8gbmF0dXJlIG9mIHRoaXMgZXJyb3IsIGRldmVsb3BlcnMgd2lsbCBuZXZlciBiZSBhYmxlIHRvIHNlZSB0aGUgbWVzc2FnZVxyXG4gICAgLy8gdXNpbmcgdGhlIGRlYnVnRXJyb3JNYXAgKHdoaWNoIGlzIGluc3RhbGxlZCBkdXJpbmcgYXV0aCBpbml0aWFsaXphdGlvbikuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIFtcImRlcGVuZGVudC1zZGstaW5pdGlhbGl6ZWQtYmVmb3JlLWF1dGhcIiAvKiBBdXRoRXJyb3JDb2RlLkRFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSCAqL106ICdBbm90aGVyIEZpcmViYXNlIFNESyB3YXMgaW5pdGlhbGl6ZWQgYW5kIGlzIHRyeWluZyB0byB1c2UgQXV0aCBiZWZvcmUgQXV0aCBpcyAnICtcclxuICAgICAgICAgICAgJ2luaXRpYWxpemVkLiBQbGVhc2UgYmUgc3VyZSB0byBjYWxsIGBpbml0aWFsaXplQXV0aGAgb3IgYGdldEF1dGhgIGJlZm9yZSAnICtcclxuICAgICAgICAgICAgJ3N0YXJ0aW5nIGFueSBvdGhlciBGaXJlYmFzZSBTREsuJ1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQSB2ZXJib3NlIGVycm9yIG1hcCB3aXRoIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBmb3IgbW9zdCBlcnJvciBjb2Rlcy5cclxuICpcclxuICogU2VlIGRpc2N1c3Npb24gYXQge0BsaW5rIEF1dGhFcnJvck1hcH1cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZGVidWdFcnJvck1hcCA9IF9kZWJ1Z0Vycm9yTWFwO1xyXG4vKipcclxuICogQSBtaW5pbWFsIGVycm9yIG1hcCB3aXRoIGFsbCB2ZXJib3NlIGVycm9yIG1lc3NhZ2VzIHN0cmlwcGVkLlxyXG4gKlxyXG4gKiBTZWUgZGlzY3Vzc2lvbiBhdCB7QGxpbmsgQXV0aEVycm9yTWFwfVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBwcm9kRXJyb3JNYXAgPSBfcHJvZEVycm9yTWFwO1xyXG5jb25zdCBfREVGQVVMVF9BVVRIX0VSUk9SX0ZBQ1RPUlkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhdXRoJywgJ0ZpcmViYXNlJywgX3Byb2RFcnJvck1hcCgpKTtcclxuLyoqXHJcbiAqIEEgbWFwIG9mIHBvdGVudGlhbCBgQXV0aGAgZXJyb3IgY29kZXMsIGZvciBlYXNpZXIgY29tcGFyaXNvbiB3aXRoIGVycm9yc1xyXG4gKiB0aHJvd24gYnkgdGhlIFNESy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogTm90ZSB0aGF0IHlvdSBjYW4ndCB0cmVlLXNoYWtlIGluZGl2aWR1YWwga2V5c1xyXG4gKiBpbiB0aGUgbWFwLCBzbyBieSB1c2luZyB0aGUgbWFwIHlvdSBtaWdodCBzdWJzdGFudGlhbGx5IGluY3JlYXNlIHlvdXJcclxuICogYnVuZGxlIHNpemUuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IEFVVEhfRVJST1JfQ09ERVNfTUFQX0RPX05PVF9VU0VfSU5URVJOQUxMWSA9IHtcclxuICAgIEFETUlOX09OTFlfT1BFUkFUSU9OOiAnYXV0aC9hZG1pbi1yZXN0cmljdGVkLW9wZXJhdGlvbicsXHJcbiAgICBBUkdVTUVOVF9FUlJPUjogJ2F1dGgvYXJndW1lbnQtZXJyb3InLFxyXG4gICAgQVBQX05PVF9BVVRIT1JJWkVEOiAnYXV0aC9hcHAtbm90LWF1dGhvcml6ZWQnLFxyXG4gICAgQVBQX05PVF9JTlNUQUxMRUQ6ICdhdXRoL2FwcC1ub3QtaW5zdGFsbGVkJyxcclxuICAgIENBUFRDSEFfQ0hFQ0tfRkFJTEVEOiAnYXV0aC9jYXB0Y2hhLWNoZWNrLWZhaWxlZCcsXHJcbiAgICBDT0RFX0VYUElSRUQ6ICdhdXRoL2NvZGUtZXhwaXJlZCcsXHJcbiAgICBDT1JET1ZBX05PVF9SRUFEWTogJ2F1dGgvY29yZG92YS1ub3QtcmVhZHknLFxyXG4gICAgQ09SU19VTlNVUFBPUlRFRDogJ2F1dGgvY29ycy11bnN1cHBvcnRlZCcsXHJcbiAgICBDUkVERU5USUFMX0FMUkVBRFlfSU5fVVNFOiAnYXV0aC9jcmVkZW50aWFsLWFscmVhZHktaW4tdXNlJyxcclxuICAgIENSRURFTlRJQUxfTUlTTUFUQ0g6ICdhdXRoL2N1c3RvbS10b2tlbi1taXNtYXRjaCcsXHJcbiAgICBDUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU46ICdhdXRoL3JlcXVpcmVzLXJlY2VudC1sb2dpbicsXHJcbiAgICBERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEg6ICdhdXRoL2RlcGVuZGVudC1zZGstaW5pdGlhbGl6ZWQtYmVmb3JlLWF1dGgnLFxyXG4gICAgRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURUQ6ICdhdXRoL2R5bmFtaWMtbGluay1ub3QtYWN0aXZhdGVkJyxcclxuICAgIEVNQUlMX0NIQU5HRV9ORUVEU19WRVJJRklDQVRJT046ICdhdXRoL2VtYWlsLWNoYW5nZS1uZWVkcy12ZXJpZmljYXRpb24nLFxyXG4gICAgRU1BSUxfRVhJU1RTOiAnYXV0aC9lbWFpbC1hbHJlYWR5LWluLXVzZScsXHJcbiAgICBFTVVMQVRPUl9DT05GSUdfRkFJTEVEOiAnYXV0aC9lbXVsYXRvci1jb25maWctZmFpbGVkJyxcclxuICAgIEVYUElSRURfT09CX0NPREU6ICdhdXRoL2V4cGlyZWQtYWN0aW9uLWNvZGUnLFxyXG4gICAgRVhQSVJFRF9QT1BVUF9SRVFVRVNUOiAnYXV0aC9jYW5jZWxsZWQtcG9wdXAtcmVxdWVzdCcsXHJcbiAgICBJTlRFUk5BTF9FUlJPUjogJ2F1dGgvaW50ZXJuYWwtZXJyb3InLFxyXG4gICAgSU5WQUxJRF9BUElfS0VZOiAnYXV0aC9pbnZhbGlkLWFwaS1rZXknLFxyXG4gICAgSU5WQUxJRF9BUFBfQ1JFREVOVElBTDogJ2F1dGgvaW52YWxpZC1hcHAtY3JlZGVudGlhbCcsXHJcbiAgICBJTlZBTElEX0FQUF9JRDogJ2F1dGgvaW52YWxpZC1hcHAtaWQnLFxyXG4gICAgSU5WQUxJRF9BVVRIOiAnYXV0aC9pbnZhbGlkLXVzZXItdG9rZW4nLFxyXG4gICAgSU5WQUxJRF9BVVRIX0VWRU5UOiAnYXV0aC9pbnZhbGlkLWF1dGgtZXZlbnQnLFxyXG4gICAgSU5WQUxJRF9DRVJUX0hBU0g6ICdhdXRoL2ludmFsaWQtY2VydC1oYXNoJyxcclxuICAgIElOVkFMSURfQ09ERTogJ2F1dGgvaW52YWxpZC12ZXJpZmljYXRpb24tY29kZScsXHJcbiAgICBJTlZBTElEX0NPTlRJTlVFX1VSSTogJ2F1dGgvaW52YWxpZC1jb250aW51ZS11cmknLFxyXG4gICAgSU5WQUxJRF9DT1JET1ZBX0NPTkZJR1VSQVRJT046ICdhdXRoL2ludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uJyxcclxuICAgIElOVkFMSURfQ1VTVE9NX1RPS0VOOiAnYXV0aC9pbnZhbGlkLWN1c3RvbS10b2tlbicsXHJcbiAgICBJTlZBTElEX0RZTkFNSUNfTElOS19ET01BSU46ICdhdXRoL2ludmFsaWQtZHluYW1pYy1saW5rLWRvbWFpbicsXHJcbiAgICBJTlZBTElEX0VNQUlMOiAnYXV0aC9pbnZhbGlkLWVtYWlsJyxcclxuICAgIElOVkFMSURfRU1VTEFUT1JfU0NIRU1FOiAnYXV0aC9pbnZhbGlkLWVtdWxhdG9yLXNjaGVtZScsXHJcbiAgICBJTlZBTElEX0lEUF9SRVNQT05TRTogJ2F1dGgvaW52YWxpZC1jcmVkZW50aWFsJyxcclxuICAgIElOVkFMSURfTE9HSU5fQ1JFREVOVElBTFM6ICdhdXRoL2ludmFsaWQtY3JlZGVudGlhbCcsXHJcbiAgICBJTlZBTElEX01FU1NBR0VfUEFZTE9BRDogJ2F1dGgvaW52YWxpZC1tZXNzYWdlLXBheWxvYWQnLFxyXG4gICAgSU5WQUxJRF9NRkFfU0VTU0lPTjogJ2F1dGgvaW52YWxpZC1tdWx0aS1mYWN0b3Itc2Vzc2lvbicsXHJcbiAgICBJTlZBTElEX09BVVRIX0NMSUVOVF9JRDogJ2F1dGgvaW52YWxpZC1vYXV0aC1jbGllbnQtaWQnLFxyXG4gICAgSU5WQUxJRF9PQVVUSF9QUk9WSURFUjogJ2F1dGgvaW52YWxpZC1vYXV0aC1wcm92aWRlcicsXHJcbiAgICBJTlZBTElEX09PQl9DT0RFOiAnYXV0aC9pbnZhbGlkLWFjdGlvbi1jb2RlJyxcclxuICAgIElOVkFMSURfT1JJR0lOOiAnYXV0aC91bmF1dGhvcml6ZWQtZG9tYWluJyxcclxuICAgIElOVkFMSURfUEFTU1dPUkQ6ICdhdXRoL3dyb25nLXBhc3N3b3JkJyxcclxuICAgIElOVkFMSURfUEVSU0lTVEVOQ0U6ICdhdXRoL2ludmFsaWQtcGVyc2lzdGVuY2UtdHlwZScsXHJcbiAgICBJTlZBTElEX1BIT05FX05VTUJFUjogJ2F1dGgvaW52YWxpZC1waG9uZS1udW1iZXInLFxyXG4gICAgSU5WQUxJRF9QUk9WSURFUl9JRDogJ2F1dGgvaW52YWxpZC1wcm92aWRlci1pZCcsXHJcbiAgICBJTlZBTElEX1JFQ0lQSUVOVF9FTUFJTDogJ2F1dGgvaW52YWxpZC1yZWNpcGllbnQtZW1haWwnLFxyXG4gICAgSU5WQUxJRF9TRU5ERVI6ICdhdXRoL2ludmFsaWQtc2VuZGVyJyxcclxuICAgIElOVkFMSURfU0VTU0lPTl9JTkZPOiAnYXV0aC9pbnZhbGlkLXZlcmlmaWNhdGlvbi1pZCcsXHJcbiAgICBJTlZBTElEX1RFTkFOVF9JRDogJ2F1dGgvaW52YWxpZC10ZW5hbnQtaWQnLFxyXG4gICAgTUZBX0lORk9fTk9UX0ZPVU5EOiAnYXV0aC9tdWx0aS1mYWN0b3ItaW5mby1ub3QtZm91bmQnLFxyXG4gICAgTUZBX1JFUVVJUkVEOiAnYXV0aC9tdWx0aS1mYWN0b3ItYXV0aC1yZXF1aXJlZCcsXHJcbiAgICBNSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FOiAnYXV0aC9taXNzaW5nLWFuZHJvaWQtcGtnLW5hbWUnLFxyXG4gICAgTUlTU0lOR19BUFBfQ1JFREVOVElBTDogJ2F1dGgvbWlzc2luZy1hcHAtY3JlZGVudGlhbCcsXHJcbiAgICBNSVNTSU5HX0FVVEhfRE9NQUlOOiAnYXV0aC9hdXRoLWRvbWFpbi1jb25maWctcmVxdWlyZWQnLFxyXG4gICAgTUlTU0lOR19DT0RFOiAnYXV0aC9taXNzaW5nLXZlcmlmaWNhdGlvbi1jb2RlJyxcclxuICAgIE1JU1NJTkdfQ09OVElOVUVfVVJJOiAnYXV0aC9taXNzaW5nLWNvbnRpbnVlLXVyaScsXHJcbiAgICBNSVNTSU5HX0lGUkFNRV9TVEFSVDogJ2F1dGgvbWlzc2luZy1pZnJhbWUtc3RhcnQnLFxyXG4gICAgTUlTU0lOR19JT1NfQlVORExFX0lEOiAnYXV0aC9taXNzaW5nLWlvcy1idW5kbGUtaWQnLFxyXG4gICAgTUlTU0lOR19PUl9JTlZBTElEX05PTkNFOiAnYXV0aC9taXNzaW5nLW9yLWludmFsaWQtbm9uY2UnLFxyXG4gICAgTUlTU0lOR19NRkFfSU5GTzogJ2F1dGgvbWlzc2luZy1tdWx0aS1mYWN0b3ItaW5mbycsXHJcbiAgICBNSVNTSU5HX01GQV9TRVNTSU9OOiAnYXV0aC9taXNzaW5nLW11bHRpLWZhY3Rvci1zZXNzaW9uJyxcclxuICAgIE1JU1NJTkdfUEhPTkVfTlVNQkVSOiAnYXV0aC9taXNzaW5nLXBob25lLW51bWJlcicsXHJcbiAgICBNSVNTSU5HX1NFU1NJT05fSU5GTzogJ2F1dGgvbWlzc2luZy12ZXJpZmljYXRpb24taWQnLFxyXG4gICAgTU9EVUxFX0RFU1RST1lFRDogJ2F1dGgvYXBwLWRlbGV0ZWQnLFxyXG4gICAgTkVFRF9DT05GSVJNQVRJT046ICdhdXRoL2FjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWwnLFxyXG4gICAgTkVUV09SS19SRVFVRVNUX0ZBSUxFRDogJ2F1dGgvbmV0d29yay1yZXF1ZXN0LWZhaWxlZCcsXHJcbiAgICBOVUxMX1VTRVI6ICdhdXRoL251bGwtdXNlcicsXHJcbiAgICBOT19BVVRIX0VWRU5UOiAnYXV0aC9uby1hdXRoLWV2ZW50JyxcclxuICAgIE5PX1NVQ0hfUFJPVklERVI6ICdhdXRoL25vLXN1Y2gtcHJvdmlkZXInLFxyXG4gICAgT1BFUkFUSU9OX05PVF9BTExPV0VEOiAnYXV0aC9vcGVyYXRpb24tbm90LWFsbG93ZWQnLFxyXG4gICAgT1BFUkFUSU9OX05PVF9TVVBQT1JURUQ6ICdhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQnLFxyXG4gICAgUE9QVVBfQkxPQ0tFRDogJ2F1dGgvcG9wdXAtYmxvY2tlZCcsXHJcbiAgICBQT1BVUF9DTE9TRURfQllfVVNFUjogJ2F1dGgvcG9wdXAtY2xvc2VkLWJ5LXVzZXInLFxyXG4gICAgUFJPVklERVJfQUxSRUFEWV9MSU5LRUQ6ICdhdXRoL3Byb3ZpZGVyLWFscmVhZHktbGlua2VkJyxcclxuICAgIFFVT1RBX0VYQ0VFREVEOiAnYXV0aC9xdW90YS1leGNlZWRlZCcsXHJcbiAgICBSRURJUkVDVF9DQU5DRUxMRURfQllfVVNFUjogJ2F1dGgvcmVkaXJlY3QtY2FuY2VsbGVkLWJ5LXVzZXInLFxyXG4gICAgUkVESVJFQ1RfT1BFUkFUSU9OX1BFTkRJTkc6ICdhdXRoL3JlZGlyZWN0LW9wZXJhdGlvbi1wZW5kaW5nJyxcclxuICAgIFJFSkVDVEVEX0NSRURFTlRJQUw6ICdhdXRoL3JlamVjdGVkLWNyZWRlbnRpYWwnLFxyXG4gICAgU0VDT05EX0ZBQ1RPUl9BTFJFQURZX0VOUk9MTEVEOiAnYXV0aC9zZWNvbmQtZmFjdG9yLWFscmVhZHktaW4tdXNlJyxcclxuICAgIFNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQ6ICdhdXRoL21heGltdW0tc2Vjb25kLWZhY3Rvci1jb3VudC1leGNlZWRlZCcsXHJcbiAgICBURU5BTlRfSURfTUlTTUFUQ0g6ICdhdXRoL3RlbmFudC1pZC1taXNtYXRjaCcsXHJcbiAgICBUSU1FT1VUOiAnYXV0aC90aW1lb3V0JyxcclxuICAgIFRPS0VOX0VYUElSRUQ6ICdhdXRoL3VzZXItdG9rZW4tZXhwaXJlZCcsXHJcbiAgICBUT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVI6ICdhdXRoL3Rvby1tYW55LXJlcXVlc3RzJyxcclxuICAgIFVOQVVUSE9SSVpFRF9ET01BSU46ICdhdXRoL3VuYXV0aG9yaXplZC1jb250aW51ZS11cmknLFxyXG4gICAgVU5TVVBQT1JURURfRklSU1RfRkFDVE9SOiAnYXV0aC91bnN1cHBvcnRlZC1maXJzdC1mYWN0b3InLFxyXG4gICAgVU5TVVBQT1JURURfUEVSU0lTVEVOQ0U6ICdhdXRoL3Vuc3VwcG9ydGVkLXBlcnNpc3RlbmNlLXR5cGUnLFxyXG4gICAgVU5TVVBQT1JURURfVEVOQU5UX09QRVJBVElPTjogJ2F1dGgvdW5zdXBwb3J0ZWQtdGVuYW50LW9wZXJhdGlvbicsXHJcbiAgICBVTlZFUklGSUVEX0VNQUlMOiAnYXV0aC91bnZlcmlmaWVkLWVtYWlsJyxcclxuICAgIFVTRVJfQ0FOQ0VMTEVEOiAnYXV0aC91c2VyLWNhbmNlbGxlZCcsXHJcbiAgICBVU0VSX0RFTEVURUQ6ICdhdXRoL3VzZXItbm90LWZvdW5kJyxcclxuICAgIFVTRVJfRElTQUJMRUQ6ICdhdXRoL3VzZXItZGlzYWJsZWQnLFxyXG4gICAgVVNFUl9NSVNNQVRDSDogJ2F1dGgvdXNlci1taXNtYXRjaCcsXHJcbiAgICBVU0VSX1NJR05FRF9PVVQ6ICdhdXRoL3VzZXItc2lnbmVkLW91dCcsXHJcbiAgICBXRUFLX1BBU1NXT1JEOiAnYXV0aC93ZWFrLXBhc3N3b3JkJyxcclxuICAgIFdFQl9TVE9SQUdFX1VOU1VQUE9SVEVEOiAnYXV0aC93ZWItc3RvcmFnZS11bnN1cHBvcnRlZCcsXHJcbiAgICBBTFJFQURZX0lOSVRJQUxJWkVEOiAnYXV0aC9hbHJlYWR5LWluaXRpYWxpemVkJyxcclxuICAgIFJFQ0FQVENIQV9OT1RfRU5BQkxFRDogJ2F1dGgvcmVjYXB0Y2hhLW5vdC1lbmFibGVkJyxcclxuICAgIE1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOOiAnYXV0aC9taXNzaW5nLXJlY2FwdGNoYS10b2tlbicsXHJcbiAgICBJTlZBTElEX1JFQ0FQVENIQV9UT0tFTjogJ2F1dGgvaW52YWxpZC1yZWNhcHRjaGEtdG9rZW4nLFxyXG4gICAgSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OOiAnYXV0aC9pbnZhbGlkLXJlY2FwdGNoYS1hY3Rpb24nLFxyXG4gICAgTUlTU0lOR19DTElFTlRfVFlQRTogJ2F1dGgvbWlzc2luZy1jbGllbnQtdHlwZScsXHJcbiAgICBNSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OOiAnYXV0aC9taXNzaW5nLXJlY2FwdGNoYS12ZXJzaW9uJyxcclxuICAgIElOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT046ICdhdXRoL2ludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb24nLFxyXG4gICAgSU5WQUxJRF9SRVFfVFlQRTogJ2F1dGgvaW52YWxpZC1yZXEtdHlwZSdcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgbG9nQ2xpZW50ID0gbmV3IExvZ2dlcignQGZpcmViYXNlL2F1dGgnKTtcclxuZnVuY3Rpb24gX2xvZ1dhcm4obXNnLCAuLi5hcmdzKSB7XHJcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLldBUk4pIHtcclxuICAgICAgICBsb2dDbGllbnQud2FybihgQXV0aCAoJHtTREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfbG9nRXJyb3IobXNnLCAuLi5hcmdzKSB7XHJcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLkVSUk9SKSB7XHJcbiAgICAgICAgbG9nQ2xpZW50LmVycm9yKGBBdXRoICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIF9mYWlsKGF1dGhPckNvZGUsIC4uLnJlc3QpIHtcclxuICAgIHRocm93IGNyZWF0ZUVycm9ySW50ZXJuYWwoYXV0aE9yQ29kZSwgLi4ucmVzdCk7XHJcbn1cclxuZnVuY3Rpb24gX2NyZWF0ZUVycm9yKGF1dGhPckNvZGUsIC4uLnJlc3QpIHtcclxuICAgIHJldHVybiBjcmVhdGVFcnJvckludGVybmFsKGF1dGhPckNvZGUsIC4uLnJlc3QpO1xyXG59XHJcbmZ1bmN0aW9uIF9lcnJvcldpdGhDdXN0b21NZXNzYWdlKGF1dGgsIGNvZGUsIG1lc3NhZ2UpIHtcclxuICAgIGNvbnN0IGVycm9yTWFwID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9kRXJyb3JNYXAoKSksIHsgW2NvZGVdOiBtZXNzYWdlIH0pO1xyXG4gICAgY29uc3QgZmFjdG9yeSA9IG5ldyBFcnJvckZhY3RvcnkoJ2F1dGgnLCAnRmlyZWJhc2UnLCBlcnJvck1hcCk7XHJcbiAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGUoY29kZSwge1xyXG4gICAgICAgIGFwcE5hbWU6IGF1dGgubmFtZVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkge1xyXG4gICAgcmV0dXJuIF9lcnJvcldpdGhDdXN0b21NZXNzYWdlKGF1dGgsIFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiIC8qIEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9TVVBQT1JURUQgKi8sICdPcGVyYXRpb25zIHRoYXQgYWx0ZXIgdGhlIGN1cnJlbnQgdXNlciBhcmUgbm90IHN1cHBvcnRlZCBpbiBjb25qdW5jdGlvbiB3aXRoIEZpcmViYXNlU2VydmVyQXBwJyk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRXJyb3JJbnRlcm5hbChhdXRoT3JDb2RlLCAuLi5yZXN0KSB7XHJcbiAgICBpZiAodHlwZW9mIGF1dGhPckNvZGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHJlc3RbMF07XHJcbiAgICAgICAgY29uc3QgZnVsbFBhcmFtcyA9IFsuLi5yZXN0LnNsaWNlKDEpXTtcclxuICAgICAgICBpZiAoZnVsbFBhcmFtc1swXSkge1xyXG4gICAgICAgICAgICBmdWxsUGFyYW1zWzBdLmFwcE5hbWUgPSBhdXRoT3JDb2RlLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhdXRoT3JDb2RlLl9lcnJvckZhY3RvcnkuY3JlYXRlKGNvZGUsIC4uLmZ1bGxQYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWS5jcmVhdGUoYXV0aE9yQ29kZSwgLi4ucmVzdCk7XHJcbn1cclxuZnVuY3Rpb24gX2Fzc2VydChhc3NlcnRpb24sIGF1dGhPckNvZGUsIC4uLnJlc3QpIHtcclxuICAgIGlmICghYXNzZXJ0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3JJbnRlcm5hbChhdXRoT3JDb2RlLCAuLi5yZXN0KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVW5jb25kaXRpb25hbGx5IGZhaWxzLCB0aHJvd2luZyBhbiBpbnRlcm5hbCBlcnJvciB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZmFpbHVyZSB0eXBlIG9mIGZhaWx1cmUgZW5jb3VudGVyZWRcclxuICogQHRocm93cyBFcnJvclxyXG4gKi9cclxuZnVuY3Rpb24gZGVidWdGYWlsKGZhaWx1cmUpIHtcclxuICAgIC8vIExvZyB0aGUgZmFpbHVyZSBpbiBhZGRpdGlvbiB0byB0aHJvdyBhbiBleGNlcHRpb24sIGp1c3QgaW4gY2FzZSB0aGVcclxuICAgIC8vIGV4Y2VwdGlvbiBpcyBzd2FsbG93ZWQuXHJcbiAgICBjb25zdCBtZXNzYWdlID0gYElOVEVSTkFMIEFTU0VSVElPTiBGQUlMRUQ6IGAgKyBmYWlsdXJlO1xyXG4gICAgX2xvZ0Vycm9yKG1lc3NhZ2UpO1xyXG4gICAgLy8gTk9URTogV2UgZG9uJ3QgdXNlIEZpcmViYXNlRXJyb3IgaGVyZSBiZWNhdXNlIHRoZXNlIGFyZSBpbnRlcm5hbCBmYWlsdXJlc1xyXG4gICAgLy8gdGhhdCBjYW5ub3QgYmUgaGFuZGxlZCBieSB0aGUgdXNlci4gKEFsc28gaXQgd291bGQgY3JlYXRlIGEgY2lyY3VsYXJcclxuICAgIC8vIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGUgZXJyb3IgYW5kIGFzc2VydCBtb2R1bGVzIHdoaWNoIGRvZXNuJ3Qgd29yay4pXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbn1cclxuLyoqXHJcbiAqIEZhaWxzIGlmIHRoZSBnaXZlbiBhc3NlcnRpb24gY29uZGl0aW9uIGlzIGZhbHNlLCB0aHJvd2luZyBhbiBFcnJvciB3aXRoIHRoZVxyXG4gKiBnaXZlbiBtZXNzYWdlIGlmIGl0IGRpZC5cclxuICpcclxuICogQHBhcmFtIGFzc2VydGlvblxyXG4gKiBAcGFyYW0gbWVzc2FnZVxyXG4gKi9cclxuZnVuY3Rpb24gZGVidWdBc3NlcnQoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIWFzc2VydGlvbikge1xyXG4gICAgICAgIGRlYnVnRmFpbChtZXNzYWdlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0Q3VycmVudFVybCgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICgoX2EgPSBzZWxmLmxvY2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHJlZikpIHx8ICcnO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0h0dHBPckh0dHBzKCkge1xyXG4gICAgcmV0dXJuIF9nZXRDdXJyZW50U2NoZW1lKCkgPT09ICdodHRwOicgfHwgX2dldEN1cnJlbnRTY2hlbWUoKSA9PT0gJ2h0dHBzOic7XHJcbn1cclxuZnVuY3Rpb24gX2dldEN1cnJlbnRTY2hlbWUoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gc2VsZi5sb2NhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3RvY29sKSkgfHwgbnVsbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgd29ya2luZyBvbmxpbmVcclxuICovXHJcbmZ1bmN0aW9uIF9pc09ubGluZSgpIHtcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIG5hdmlnYXRvciAmJlxyXG4gICAgICAgICdvbkxpbmUnIGluIG5hdmlnYXRvciAmJlxyXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3Iub25MaW5lID09PSAnYm9vbGVhbicgJiZcclxuICAgICAgICAvLyBBcHBseSBvbmx5IGZvciB0cmFkaXRpb25hbCB3ZWIgYXBwcyBhbmQgQ2hyb21lIGV4dGVuc2lvbnMuXHJcbiAgICAgICAgLy8gVGhpcyBpcyBlc3BlY2lhbGx5IHRydWUgZm9yIENvcmRvdmEgYXBwcyB3aGljaCBoYXZlIHVucmVsaWFibGVcclxuICAgICAgICAvLyBuYXZpZ2F0b3Iub25MaW5lIGJlaGF2aW9yIHVubGVzcyBjb3Jkb3ZhLXBsdWdpbi1uZXR3b3JrLWluZm9ybWF0aW9uIGlzXHJcbiAgICAgICAgLy8gaW5zdGFsbGVkIHdoaWNoIG92ZXJ3cml0ZXMgdGhlIG5hdGl2ZSBuYXZpZ2F0b3Iub25MaW5lIHZhbHVlIGFuZFxyXG4gICAgICAgIC8vIGRlZmluZXMgbmF2aWdhdG9yLmNvbm5lY3Rpb24uXHJcbiAgICAgICAgKF9pc0h0dHBPckh0dHBzKCkgfHwgaXNCcm93c2VyRXh0ZW5zaW9uKCkgfHwgJ2Nvbm5lY3Rpb24nIGluIG5hdmlnYXRvcikpIHtcclxuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm9uTGluZTtcclxuICAgIH1cclxuICAgIC8vIElmIHdlIGNhbid0IGRldGVybWluZSB0aGUgc3RhdGUsIGFzc3VtZSBpdCBpcyBvbmxpbmUuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBfZ2V0VXNlckxhbmd1YWdlKCkge1xyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuYXZpZ2F0b3JMYW5ndWFnZSA9IG5hdmlnYXRvcjtcclxuICAgIHJldHVybiAoXHJcbiAgICAvLyBNb3N0IHJlbGlhYmxlLCBidXQgb25seSBzdXBwb3J0ZWQgaW4gQ2hyb21lL0ZpcmVmb3guXHJcbiAgICAobmF2aWdhdG9yTGFuZ3VhZ2UubGFuZ3VhZ2VzICYmIG5hdmlnYXRvckxhbmd1YWdlLmxhbmd1YWdlc1swXSkgfHxcclxuICAgICAgICAvLyBTdXBwb3J0ZWQgaW4gbW9zdCBicm93c2VycywgYnV0IHJldHVybnMgdGhlIGxhbmd1YWdlIG9mIHRoZSBicm93c2VyXHJcbiAgICAgICAgLy8gVUksIG5vdCB0aGUgbGFuZ3VhZ2Ugc2V0IGluIGJyb3dzZXIgc2V0dGluZ3MuXHJcbiAgICAgICAgbmF2aWdhdG9yTGFuZ3VhZ2UubGFuZ3VhZ2UgfHxcclxuICAgICAgICAvLyBDb3VsZG4ndCBkZXRlcm1pbmUgbGFuZ3VhZ2UuXHJcbiAgICAgICAgbnVsbCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgc3RydWN0dXJlIHRvIGhlbHAgcGljayBiZXR3ZWVuIGEgcmFuZ2Ugb2YgbG9uZyBhbmQgc2hvcnQgZGVsYXkgZHVyYXRpb25zXHJcbiAqIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gSW4gZ2VuZXJhbCwgdGhlIGxvbmcgZGVsYXkgaXMgdXNlZCBmb3JcclxuICogbW9iaWxlIGVudmlyb25tZW50cyB3aGVyZWFzIHNob3J0IGRlbGF5cyBhcmUgdXNlZCBmb3IgZGVza3RvcCBlbnZpcm9ubWVudHMuXHJcbiAqL1xyXG5jbGFzcyBEZWxheSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzaG9ydERlbGF5LCBsb25nRGVsYXkpIHtcclxuICAgICAgICB0aGlzLnNob3J0RGVsYXkgPSBzaG9ydERlbGF5O1xyXG4gICAgICAgIHRoaXMubG9uZ0RlbGF5ID0gbG9uZ0RlbGF5O1xyXG4gICAgICAgIC8vIEludGVybmFsIGVycm9yIHdoZW4gaW1wcm9wZXJseSBpbml0aWFsaXplZC5cclxuICAgICAgICBkZWJ1Z0Fzc2VydChsb25nRGVsYXkgPiBzaG9ydERlbGF5LCAnU2hvcnQgZGVsYXkgc2hvdWxkIGJlIGxlc3MgdGhhbiBsb25nIGRlbGF5IScpO1xyXG4gICAgICAgIHRoaXMuaXNNb2JpbGUgPSBpc01vYmlsZUNvcmRvdmEoKSB8fCBpc1JlYWN0TmF0aXZlKCk7XHJcbiAgICB9XHJcbiAgICBnZXQoKSB7XHJcbiAgICAgICAgaWYgKCFfaXNPbmxpbmUoKSkge1xyXG4gICAgICAgICAgICAvLyBQaWNrIHRoZSBzaG9ydGVyIHRpbWVvdXQuXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbig1MDAwIC8qIERlbGF5TWluLk9GRkxJTkUgKi8sIHRoaXMuc2hvcnREZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZW52aXJvbm1lbnQsIHJldHVybiB0aGUgbG9uZyBkZWxheSwgb3RoZXJ3aXNlXHJcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBzaG9ydCBkZWxheS5cclxuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGltcHJvdmVkIGluIHRoZSBmdXR1cmUgdG8gZHluYW1pY2FsbHkgY2hhbmdlIGJhc2VkIG9uIG90aGVyXHJcbiAgICAgICAgLy8gdmFyaWFibGVzIGluc3RlYWQgb2YganVzdCByZWFkaW5nIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gICAgICAgIHJldHVybiB0aGlzLmlzTW9iaWxlID8gdGhpcy5sb25nRGVsYXkgOiB0aGlzLnNob3J0RGVsYXk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gX2VtdWxhdG9yVXJsKGNvbmZpZywgcGF0aCkge1xyXG4gICAgZGVidWdBc3NlcnQoY29uZmlnLmVtdWxhdG9yLCAnRW11bGF0b3Igc2hvdWxkIGFsd2F5cyBiZSBzZXQgaGVyZScpO1xyXG4gICAgY29uc3QgeyB1cmwgfSA9IGNvbmZpZy5lbXVsYXRvcjtcclxuICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYCR7dXJsfSR7cGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoLnNsaWNlKDEpIDogcGF0aH1gO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEZldGNoUHJvdmlkZXIge1xyXG4gICAgc3RhdGljIGluaXRpYWxpemUoZmV0Y2hJbXBsLCBoZWFkZXJzSW1wbCwgcmVzcG9uc2VJbXBsKSB7XHJcbiAgICAgICAgdGhpcy5mZXRjaEltcGwgPSBmZXRjaEltcGw7XHJcbiAgICAgICAgaWYgKGhlYWRlcnNJbXBsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc0ltcGwgPSBoZWFkZXJzSW1wbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlSW1wbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlSW1wbCA9IHJlc3BvbnNlSW1wbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZmV0Y2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hJbXBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoSW1wbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAnZmV0Y2gnIGluIHNlbGYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmV0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5mZXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5mZXRjaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZldGNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWJ1Z0ZhaWwoJ0NvdWxkIG5vdCBmaW5kIGZldGNoIGltcGxlbWVudGF0aW9uLCBtYWtlIHN1cmUgeW91IGNhbGwgRmV0Y2hQcm92aWRlci5pbml0aWFsaXplKCkgd2l0aCBhbiBhcHByb3ByaWF0ZSBwb2x5ZmlsbCcpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGhlYWRlcnMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc0ltcGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc0ltcGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ0hlYWRlcnMnIGluIHNlbGYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuSGVhZGVycztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLkhlYWRlcnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuSGVhZGVycztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBIZWFkZXJzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gSGVhZGVycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVidWdGYWlsKCdDb3VsZCBub3QgZmluZCBIZWFkZXJzIGltcGxlbWVudGF0aW9uLCBtYWtlIHN1cmUgeW91IGNhbGwgRmV0Y2hQcm92aWRlci5pbml0aWFsaXplKCkgd2l0aCBhbiBhcHByb3ByaWF0ZSBwb2x5ZmlsbCcpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHJlc3BvbnNlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlSW1wbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUltcGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ1Jlc3BvbnNlJyBpbiBzZWxmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLlJlc3BvbnNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuUmVzcG9uc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgUmVzcG9uc2UgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZXNwb25zZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVidWdGYWlsKCdDb3VsZCBub3QgZmluZCBSZXNwb25zZSBpbXBsZW1lbnRhdGlvbiwgbWFrZSBzdXJlIHlvdSBjYWxsIEZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZSgpIHdpdGggYW4gYXBwcm9wcmlhdGUgcG9seWZpbGwnKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogTWFwIGZyb20gZXJyb3JzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIgdG8gZXJyb3JzIHRvIGRldmVsb3BlciB2aXNpYmxlIGVycm9yc1xyXG4gKi9cclxuY29uc3QgU0VSVkVSX0VSUk9SX01BUCA9IHtcclxuICAgIC8vIEN1c3RvbSB0b2tlbiBlcnJvcnMuXHJcbiAgICBbXCJDUkVERU5USUFMX01JU01BVENIXCIgLyogU2VydmVyRXJyb3IuQ1JFREVOVElBTF9NSVNNQVRDSCAqL106IFwiY3VzdG9tLXRva2VuLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX01JU01BVENIICovLFxyXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxyXG4gICAgW1wiTUlTU0lOR19DVVNUT01fVE9LRU5cIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX0NVU1RPTV9UT0tFTiAqL106IFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLFxyXG4gICAgLy8gQ3JlYXRlIEF1dGggVVJJIGVycm9ycy5cclxuICAgIFtcIklOVkFMSURfSURFTlRJRklFUlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfSURFTlRJRklFUiAqL106IFwiaW52YWxpZC1lbWFpbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9FTUFJTCAqLyxcclxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cclxuICAgIFtcIk1JU1NJTkdfQ09OVElOVUVfVVJJXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19DT05USU5VRV9VUkkgKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcclxuICAgIC8vIFNpZ24gaW4gd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmQgZXJyb3JzIChzb21lIGFwcGx5IHRvIHNpZ24gdXAgdG9vKS5cclxuICAgIFtcIklOVkFMSURfUEFTU1dPUkRcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1BBU1NXT1JEICovXTogXCJ3cm9uZy1wYXNzd29yZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9QQVNTV09SRCAqLyxcclxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cclxuICAgIFtcIk1JU1NJTkdfUEFTU1dPUkRcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX1BBU1NXT1JEICovXTogXCJtaXNzaW5nLXBhc3N3b3JkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1BBU1NXT1JEICovLFxyXG4gICAgLy8gVGhyb3duIGlmIEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb24gaXMgZW5hYmxlZCBpbiB0aGUgcHJvamVjdCBhbmQgdGhlIGVtYWlsIG9yIHBhc3N3b3JkIGlzXHJcbiAgICAvLyBpbnZhbGlkLlxyXG4gICAgW1wiSU5WQUxJRF9MT0dJTl9DUkVERU5USUFMU1wiIC8qIFNlcnZlckVycm9yLklOVkFMSURfTE9HSU5fQ1JFREVOVElBTFMgKi9dOiBcImludmFsaWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DUkVERU5USUFMICovLFxyXG4gICAgLy8gU2lnbiB1cCB3aXRoIGVtYWlsIGFuZCBwYXNzd29yZCBlcnJvcnMuXHJcbiAgICBbXCJFTUFJTF9FWElTVFNcIiAvKiBTZXJ2ZXJFcnJvci5FTUFJTF9FWElTVFMgKi9dOiBcImVtYWlsLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5FTUFJTF9FWElTVFMgKi8sXHJcbiAgICBbXCJQQVNTV09SRF9MT0dJTl9ESVNBQkxFRFwiIC8qIFNlcnZlckVycm9yLlBBU1NXT1JEX0xPR0lOX0RJU0FCTEVEICovXTogXCJvcGVyYXRpb24tbm90LWFsbG93ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfQUxMT1dFRCAqLyxcclxuICAgIC8vIFZlcmlmeSBhc3NlcnRpb24gZm9yIHNpZ24gaW4gd2l0aCBjcmVkZW50aWFsIGVycm9yczpcclxuICAgIFtcIklOVkFMSURfSURQX1JFU1BPTlNFXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9JRFBfUkVTUE9OU0UgKi9dOiBcImludmFsaWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DUkVERU5USUFMICovLFxyXG4gICAgW1wiSU5WQUxJRF9QRU5ESU5HX1RPS0VOXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9QRU5ESU5HX1RPS0VOICovXTogXCJpbnZhbGlkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ1JFREVOVElBTCAqLyxcclxuICAgIFtcIkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEXCIgLyogU2VydmVyRXJyb3IuRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRUQgKi9dOiBcImNyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0UgKi8sXHJcbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXHJcbiAgICBbXCJNSVNTSU5HX1JFUV9UWVBFXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19SRVFfVFlQRSAqL106IFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLFxyXG4gICAgLy8gU2VuZCBQYXNzd29yZCByZXNldCBlbWFpbCBlcnJvcnM6XHJcbiAgICBbXCJFTUFJTF9OT1RfRk9VTkRcIiAvKiBTZXJ2ZXJFcnJvci5FTUFJTF9OT1RfRk9VTkQgKi9dOiBcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi8sXHJcbiAgICBbXCJSRVNFVF9QQVNTV09SRF9FWENFRURfTElNSVRcIiAvKiBTZXJ2ZXJFcnJvci5SRVNFVF9QQVNTV09SRF9FWENFRURfTElNSVQgKi9dOiBcInRvby1tYW55LXJlcXVlc3RzXCIgLyogQXV0aEVycm9yQ29kZS5UT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVIgKi8sXHJcbiAgICBbXCJFWFBJUkVEX09PQl9DT0RFXCIgLyogU2VydmVyRXJyb3IuRVhQSVJFRF9PT0JfQ09ERSAqL106IFwiZXhwaXJlZC1hY3Rpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuRVhQSVJFRF9PT0JfQ09ERSAqLyxcclxuICAgIFtcIklOVkFMSURfT09CX0NPREVcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX09PQl9DT0RFICovXTogXCJpbnZhbGlkLWFjdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09PQl9DT0RFICovLFxyXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxyXG4gICAgW1wiTUlTU0lOR19PT0JfQ09ERVwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfT09CX0NPREUgKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcclxuICAgIC8vIE9wZXJhdGlvbnMgdGhhdCByZXF1aXJlIElEIHRva2VuIGluIHJlcXVlc3Q6XHJcbiAgICBbXCJDUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU5cIiAvKiBTZXJ2ZXJFcnJvci5DUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU4gKi9dOiBcInJlcXVpcmVzLXJlY2VudC1sb2dpblwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOICovLFxyXG4gICAgW1wiSU5WQUxJRF9JRF9UT0tFTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfSURfVE9LRU4gKi9dOiBcImludmFsaWQtdXNlci10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIICovLFxyXG4gICAgW1wiVE9LRU5fRVhQSVJFRFwiIC8qIFNlcnZlckVycm9yLlRPS0VOX0VYUElSRUQgKi9dOiBcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqLyxcclxuICAgIFtcIlVTRVJfTk9UX0ZPVU5EXCIgLyogU2VydmVyRXJyb3IuVVNFUl9OT1RfRk9VTkQgKi9dOiBcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqLyxcclxuICAgIC8vIE90aGVyIGVycm9ycy5cclxuICAgIFtcIlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUlwiIC8qIFNlcnZlckVycm9yLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUiAqL106IFwidG9vLW1hbnktcmVxdWVzdHNcIiAvKiBBdXRoRXJyb3JDb2RlLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUiAqLyxcclxuICAgIFtcIlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTXCIgLyogU2VydmVyRXJyb3IuUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFMgKi9dOiBcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqLyxcclxuICAgIC8vIFBob25lIEF1dGggcmVsYXRlZCBlcnJvcnMuXHJcbiAgICBbXCJJTlZBTElEX0NPREVcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX0NPREUgKi9dOiBcImludmFsaWQtdmVyaWZpY2F0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09ERSAqLyxcclxuICAgIFtcIklOVkFMSURfU0VTU0lPTl9JTkZPXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9TRVNTSU9OX0lORk8gKi9dOiBcImludmFsaWQtdmVyaWZpY2F0aW9uLWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1NFU1NJT05fSU5GTyAqLyxcclxuICAgIFtcIklOVkFMSURfVEVNUE9SQVJZX1BST09GXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9URU1QT1JBUllfUFJPT0YgKi9dOiBcImludmFsaWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DUkVERU5USUFMICovLFxyXG4gICAgW1wiTUlTU0lOR19TRVNTSU9OX0lORk9cIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX1NFU1NJT05fSU5GTyAqL106IFwibWlzc2luZy12ZXJpZmljYXRpb24taWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfU0VTU0lPTl9JTkZPICovLFxyXG4gICAgW1wiU0VTU0lPTl9FWFBJUkVEXCIgLyogU2VydmVyRXJyb3IuU0VTU0lPTl9FWFBJUkVEICovXTogXCJjb2RlLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkNPREVfRVhQSVJFRCAqLyxcclxuICAgIC8vIE90aGVyIGFjdGlvbiBjb2RlIGVycm9ycyB3aGVuIGFkZGl0aW9uYWwgc2V0dGluZ3MgcGFzc2VkLlxyXG4gICAgLy8gTUlTU0lOR19DT05USU5VRV9VUkkgaXMgZ2V0dGluZyBtYXBwZWQgdG8gSU5URVJOQUxfRVJST1IgYWJvdmUuXHJcbiAgICAvLyBUaGlzIGlzIE9LIGFzIHRoaXMgZXJyb3Igd2lsbCBiZSBjYXVnaHQgYnkgY2xpZW50IHNpZGUgdmFsaWRhdGlvbi5cclxuICAgIFtcIk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUVcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FICovXTogXCJtaXNzaW5nLWFuZHJvaWQtcGtnLW5hbWVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUUgKi8sXHJcbiAgICBbXCJVTkFVVEhPUklaRURfRE9NQUlOXCIgLyogU2VydmVyRXJyb3IuVU5BVVRIT1JJWkVEX0RPTUFJTiAqL106IFwidW5hdXRob3JpemVkLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuVU5BVVRIT1JJWkVEX0RPTUFJTiAqLyxcclxuICAgIC8vIGdldFByb2plY3RDb25maWcgZXJyb3JzIHdoZW4gY2xpZW50SWQgaXMgcGFzc2VkLlxyXG4gICAgW1wiSU5WQUxJRF9PQVVUSF9DTElFTlRfSURcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX09BVVRIX0NMSUVOVF9JRCAqL106IFwiaW52YWxpZC1vYXV0aC1jbGllbnQtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT0FVVEhfQ0xJRU5UX0lEICovLFxyXG4gICAgLy8gVXNlciBhY3Rpb25zIChzaWduLXVwIG9yIGRlbGV0aW9uKSBkaXNhYmxlZCBlcnJvcnMuXHJcbiAgICBbXCJBRE1JTl9PTkxZX09QRVJBVElPTlwiIC8qIFNlcnZlckVycm9yLkFETUlOX09OTFlfT1BFUkFUSU9OICovXTogXCJhZG1pbi1yZXN0cmljdGVkLW9wZXJhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuQURNSU5fT05MWV9PUEVSQVRJT04gKi8sXHJcbiAgICAvLyBNdWx0aSBmYWN0b3IgcmVsYXRlZCBlcnJvcnMuXHJcbiAgICBbXCJJTlZBTElEX01GQV9QRU5ESU5HX0NSRURFTlRJQUxcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX01GQV9QRU5ESU5HX0NSRURFTlRJQUwgKi9dOiBcImludmFsaWQtbXVsdGktZmFjdG9yLXNlc3Npb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfTUZBX1NFU1NJT04gKi8sXHJcbiAgICBbXCJNRkFfRU5ST0xMTUVOVF9OT1RfRk9VTkRcIiAvKiBTZXJ2ZXJFcnJvci5NRkFfRU5ST0xMTUVOVF9OT1RfRk9VTkQgKi9dOiBcIm11bHRpLWZhY3Rvci1pbmZvLW5vdC1mb3VuZFwiIC8qIEF1dGhFcnJvckNvZGUuTUZBX0lORk9fTk9UX0ZPVU5EICovLFxyXG4gICAgW1wiTUlTU0lOR19NRkFfRU5ST0xMTUVOVF9JRFwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfTUZBX0VOUk9MTE1FTlRfSUQgKi9dOiBcIm1pc3NpbmctbXVsdGktZmFjdG9yLWluZm9cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX0lORk8gKi8sXHJcbiAgICBbXCJNSVNTSU5HX01GQV9QRU5ESU5HX0NSRURFTlRJQUxcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX01GQV9QRU5ESU5HX0NSRURFTlRJQUwgKi9dOiBcIm1pc3NpbmctbXVsdGktZmFjdG9yLXNlc3Npb25cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX1NFU1NJT04gKi8sXHJcbiAgICBbXCJTRUNPTkRfRkFDVE9SX0VYSVNUU1wiIC8qIFNlcnZlckVycm9yLlNFQ09ORF9GQUNUT1JfRVhJU1RTICovXTogXCJzZWNvbmQtZmFjdG9yLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5TRUNPTkRfRkFDVE9SX0FMUkVBRFlfRU5ST0xMRUQgKi8sXHJcbiAgICBbXCJTRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEXCIgLyogU2VydmVyRXJyb3IuU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRCAqL106IFwibWF4aW11bS1zZWNvbmQtZmFjdG9yLWNvdW50LWV4Y2VlZGVkXCIgLyogQXV0aEVycm9yQ29kZS5TRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEICovLFxyXG4gICAgLy8gQmxvY2tpbmcgZnVuY3Rpb25zIHJlbGF0ZWQgZXJyb3JzLlxyXG4gICAgW1wiQkxPQ0tJTkdfRlVOQ1RJT05fRVJST1JfUkVTUE9OU0VcIiAvKiBTZXJ2ZXJFcnJvci5CTE9DS0lOR19GVU5DVElPTl9FUlJPUl9SRVNQT05TRSAqL106IFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLFxyXG4gICAgLy8gUmVjYXB0Y2hhIHJlbGF0ZWQgZXJyb3JzLlxyXG4gICAgW1wiUkVDQVBUQ0hBX05PVF9FTkFCTEVEXCIgLyogU2VydmVyRXJyb3IuUkVDQVBUQ0hBX05PVF9FTkFCTEVEICovXTogXCJyZWNhcHRjaGEtbm90LWVuYWJsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlJFQ0FQVENIQV9OT1RfRU5BQkxFRCAqLyxcclxuICAgIFtcIk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4gKi9dOiBcIm1pc3NpbmctcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9UT0tFTiAqLyxcclxuICAgIFtcIklOVkFMSURfUkVDQVBUQ0hBX1RPS0VOXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU4gKi9dOiBcImludmFsaWQtcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9UT0tFTiAqLyxcclxuICAgIFtcIklOVkFMSURfUkVDQVBUQ0hBX0FDVElPTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUkVDQVBUQ0hBX0FDVElPTiAqL106IFwiaW52YWxpZC1yZWNhcHRjaGEtYWN0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9BQ1RJT04gKi8sXHJcbiAgICBbXCJNSVNTSU5HX0NMSUVOVF9UWVBFXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19DTElFTlRfVFlQRSAqL106IFwibWlzc2luZy1jbGllbnQtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19DTElFTlRfVFlQRSAqLyxcclxuICAgIFtcIk1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT05cIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OICovXTogXCJtaXNzaW5nLXJlY2FwdGNoYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OICovLFxyXG4gICAgW1wiSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04gKi9dOiBcImludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04gKi8sXHJcbiAgICBbXCJJTlZBTElEX1JFUV9UWVBFXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9SRVFfVFlQRSAqL106IFwiaW52YWxpZC1yZXEtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRVFfVFlQRSAqL1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0FQSV9USU1FT1VUX01TID0gbmV3IERlbGF5KDMwMDAwLCA2MDAwMCk7XHJcbmZ1bmN0aW9uIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICBpZiAoYXV0aC50ZW5hbnRJZCAmJiAhcmVxdWVzdC50ZW5hbnRJZCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IHRlbmFudElkOiBhdXRoLnRlbmFudElkIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcXVlc3Q7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIG1ldGhvZCwgcGF0aCwgcmVxdWVzdCwgY3VzdG9tRXJyb3JNYXAgPSB7fSkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtRmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhhdXRoLCBjdXN0b21FcnJvck1hcCwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGxldCBib2R5ID0ge307XHJcbiAgICAgICAgbGV0IHBhcmFtcyA9IHt9O1xyXG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiR0VUXCIgLyogSHR0cE1ldGhvZC5HRVQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHJlcXVlc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBib2R5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gcXVlcnlzdHJpbmcoT2JqZWN0LmFzc2lnbih7IGtleTogYXV0aC5jb25maWcuYXBpS2V5IH0sIHBhcmFtcykpLnNsaWNlKDEpO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCBhdXRoLl9nZXRBZGRpdGlvbmFsSGVhZGVycygpO1xyXG4gICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIiAvKiBIdHRwSGVhZGVyLkNPTlRFTlRfVFlQRSAqL10gPSAnYXBwbGljYXRpb24vanNvbic7XHJcbiAgICAgICAgaWYgKGF1dGgubGFuZ3VhZ2VDb2RlKSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLUZpcmViYXNlLUxvY2FsZVwiIC8qIEh0dHBIZWFkZXIuWF9GSVJFQkFTRV9MT0NBTEUgKi9dID0gYXV0aC5sYW5ndWFnZUNvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBGZXRjaFByb3ZpZGVyLmZldGNoKCkoX2dldEZpbmFsVGFyZ2V0KGF1dGgsIGF1dGguY29uZmlnLmFwaUhvc3QsIHBhdGgsIHF1ZXJ5KSwgT2JqZWN0LmFzc2lnbih7IG1ldGhvZCxcclxuICAgICAgICAgICAgaGVhZGVycywgcmVmZXJyZXJQb2xpY3k6ICduby1yZWZlcnJlcicgfSwgYm9keSkpO1xyXG4gICAgfSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gX3BlcmZvcm1GZXRjaFdpdGhFcnJvckhhbmRsaW5nKGF1dGgsIGN1c3RvbUVycm9yTWFwLCBmZXRjaEZuKSB7XHJcbiAgICBhdXRoLl9jYW5Jbml0RW11bGF0b3IgPSBmYWxzZTtcclxuICAgIGNvbnN0IGVycm9yTWFwID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBTRVJWRVJfRVJST1JfTUFQKSwgY3VzdG9tRXJyb3JNYXApO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBuZXR3b3JrVGltZW91dCA9IG5ldyBOZXR3b3JrVGltZW91dChhdXRoKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFByb21pc2UucmFjZShbXHJcbiAgICAgICAgICAgIGZldGNoRm4oKSxcclxuICAgICAgICAgICAgbmV0d29ya1RpbWVvdXQucHJvbWlzZVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgdGhpcyBwb2ludCwgdGhlIGZldGNoIHN1Y2NlZWRlZCBhbmQgdGhlIG5ldHdvcmtUaW1lb3V0XHJcbiAgICAgICAgLy8gZGlkbid0IHRocm93OyBjbGVhciB0aGUgbmV0d29yayB0aW1lb3V0IGRlbGF5IHNvIHRoYXQgTm9kZSB3b24ndCBoYW5nXHJcbiAgICAgICAgbmV0d29ya1RpbWVvdXQuY2xlYXJOZXR3b3JrVGltZW91dCgpO1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgaWYgKCduZWVkQ29uZmlybWF0aW9uJyBpbiBqc29uKSB7XHJcbiAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJhY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5ORUVEX0NPTkZJUk1BVElPTiAqLywganNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXNwb25zZS5vayAmJiAhKCdlcnJvck1lc3NhZ2UnIGluIGpzb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gcmVzcG9uc2Uub2sgPyBqc29uLmVycm9yTWVzc2FnZSA6IGpzb24uZXJyb3IubWVzc2FnZTtcclxuICAgICAgICAgICAgY29uc3QgW3NlcnZlckVycm9yQ29kZSwgc2VydmVyRXJyb3JNZXNzYWdlXSA9IGVycm9yTWVzc2FnZS5zcGxpdCgnIDogJyk7XHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJFcnJvckNvZGUgPT09IFwiRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRURcIiAvKiBTZXJ2ZXJFcnJvci5GRURFUkFURURfVVNFUl9JRF9BTFJFQURZX0xJTktFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBcImNyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0UgKi8sIGpzb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNlcnZlckVycm9yQ29kZSA9PT0gXCJFTUFJTF9FWElTVFNcIiAvKiBTZXJ2ZXJFcnJvci5FTUFJTF9FWElTVFMgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJlbWFpbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuRU1BSUxfRVhJU1RTICovLCBqc29uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXJ2ZXJFcnJvckNvZGUgPT09IFwiVVNFUl9ESVNBQkxFRFwiIC8qIFNlcnZlckVycm9yLlVTRVJfRElTQUJMRUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJ1c2VyLWRpc2FibGVkXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RJU0FCTEVEICovLCBqc29uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBhdXRoRXJyb3IgPSBlcnJvck1hcFtzZXJ2ZXJFcnJvckNvZGVdIHx8XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvckNvZGVcclxuICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bX1xcc10rL2csICctJyk7XHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJFcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IF9lcnJvcldpdGhDdXN0b21NZXNzYWdlKGF1dGgsIGF1dGhFcnJvciwgc2VydmVyRXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9mYWlsKGF1dGgsIGF1dGhFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGFuZ2luZyB0aGlzIHRvIGEgZGlmZmVyZW50IGVycm9yIGNvZGUgd2lsbCBsb2cgdXNlciBvdXQgd2hlbiB0aGVyZSBpcyBhIG5ldHdvcmsgZXJyb3JcclxuICAgICAgICAvLyBiZWNhdXNlIHdlIHRyZWF0IGFueSBlcnJvciBvdGhlciB0aGFuIE5FVFdPUktfUkVRVUVTVF9GQUlMRUQgYXMgdG9rZW4gaXMgaW52YWxpZC5cclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtanMtc2RrL2Jsb2IvNGZiYzczNjEwZDcwYmU0ZTA4NTJlN2RlNjNhMzljYjc4OTdlODU0Ni9wYWNrYWdlcy9hdXRoL3NyYy9jb3JlL2F1dGgvYXV0aF9pbXBsLnRzI0wzMDktTDMxNlxyXG4gICAgICAgIF9mYWlsKGF1dGgsIFwibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqLywgeyAnbWVzc2FnZSc6IFN0cmluZyhlKSB9KTtcclxuICAgIH1cclxufVxyXG5hc3luYyBmdW5jdGlvbiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgbWV0aG9kLCBwYXRoLCByZXF1ZXN0LCBjdXN0b21FcnJvck1hcCA9IHt9KSB7XHJcbiAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IChhd2FpdCBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgbWV0aG9kLCBwYXRoLCByZXF1ZXN0LCBjdXN0b21FcnJvck1hcCkpO1xyXG4gICAgaWYgKCdtZmFQZW5kaW5nQ3JlZGVudGlhbCcgaW4gc2VydmVyUmVzcG9uc2UpIHtcclxuICAgICAgICBfZmFpbChhdXRoLCBcIm11bHRpLWZhY3Rvci1hdXRoLXJlcXVpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5NRkFfUkVRVUlSRUQgKi8sIHtcclxuICAgICAgICAgICAgX3NlcnZlclJlc3BvbnNlOiBzZXJ2ZXJSZXNwb25zZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlcnZlclJlc3BvbnNlO1xyXG59XHJcbmZ1bmN0aW9uIF9nZXRGaW5hbFRhcmdldChhdXRoLCBob3N0LCBwYXRoLCBxdWVyeSkge1xyXG4gICAgY29uc3QgYmFzZSA9IGAke2hvc3R9JHtwYXRofT8ke3F1ZXJ5fWA7XHJcbiAgICBpZiAoIWF1dGguY29uZmlnLmVtdWxhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2F1dGguY29uZmlnLmFwaVNjaGVtZX06Ly8ke2Jhc2V9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBfZW11bGF0b3JVcmwoYXV0aC5jb25maWcsIGJhc2UpO1xyXG59XHJcbmZ1bmN0aW9uIF9wYXJzZUVuZm9yY2VtZW50U3RhdGUoZW5mb3JjZW1lbnRTdGF0ZVN0cikge1xyXG4gICAgc3dpdGNoIChlbmZvcmNlbWVudFN0YXRlU3RyKSB7XHJcbiAgICAgICAgY2FzZSAnRU5GT1JDRSc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIkVORk9SQ0VcIiAvKiBFbmZvcmNlbWVudFN0YXRlLkVORk9SQ0UgKi87XHJcbiAgICAgICAgY2FzZSAnQVVESVQnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJBVURJVFwiIC8qIEVuZm9yY2VtZW50U3RhdGUuQVVESVQgKi87XHJcbiAgICAgICAgY2FzZSAnT0ZGJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiT0ZGXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5PRkYgKi87XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFwiRU5GT1JDRU1FTlRfU1RBVEVfVU5TUEVDSUZJRURcIiAvKiBFbmZvcmNlbWVudFN0YXRlLkVORk9SQ0VNRU5UX1NUQVRFX1VOU1BFQ0lGSUVEICovO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIE5ldHdvcmtUaW1lb3V0IHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGgpIHtcclxuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xyXG4gICAgICAgIC8vIE5vZGUgdGltZXJzIGFuZCBicm93c2VyIHRpbWVycyBhcmUgZnVuZGFtZW50YWxseSBpbmNvbXBhdGlibGUsIGJ1dCB3ZVxyXG4gICAgICAgIC8vIGRvbid0IGNhcmUgYWJvdXQgdGhlIHZhbHVlIGhlcmVcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChfY3JlYXRlRXJyb3IodGhpcy5hdXRoLCBcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQgKi8pKTtcclxuICAgICAgICAgICAgfSwgREVGQVVMVF9BUElfVElNRU9VVF9NUy5nZXQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjbGVhck5ldHdvcmtUaW1lb3V0KCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfbWFrZVRhZ2dlZEVycm9yKGF1dGgsIGNvZGUsIHJlc3BvbnNlKSB7XHJcbiAgICBjb25zdCBlcnJvclBhcmFtcyA9IHtcclxuICAgICAgICBhcHBOYW1lOiBhdXRoLm5hbWVcclxuICAgIH07XHJcbiAgICBpZiAocmVzcG9uc2UuZW1haWwpIHtcclxuICAgICAgICBlcnJvclBhcmFtcy5lbWFpbCA9IHJlc3BvbnNlLmVtYWlsO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlc3BvbnNlLnBob25lTnVtYmVyKSB7XHJcbiAgICAgICAgZXJyb3JQYXJhbXMucGhvbmVOdW1iZXIgPSByZXNwb25zZS5waG9uZU51bWJlcjtcclxuICAgIH1cclxuICAgIGNvbnN0IGVycm9yID0gX2NyZWF0ZUVycm9yKGF1dGgsIGNvZGUsIGVycm9yUGFyYW1zKTtcclxuICAgIC8vIFdlIGtub3cgY3VzdG9tRGF0YSBpcyBkZWZpbmVkIG9uIGVycm9yIGJlY2F1c2UgZXJyb3JQYXJhbXMgaXMgZGVmaW5lZFxyXG4gICAgZXJyb3IuY3VzdG9tRGF0YS5fdG9rZW5SZXNwb25zZSA9IHJlc3BvbnNlO1xyXG4gICAgcmV0dXJuIGVycm9yO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZShncmVjYXB0Y2hhKSB7XHJcbiAgICByZXR1cm4gKGdyZWNhcHRjaGEgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIGdyZWNhcHRjaGEuZW50ZXJwcmlzZSAhPT0gdW5kZWZpbmVkKTtcclxufVxyXG5jbGFzcyBSZWNhcHRjaGFDb25maWcge1xyXG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmVDQVBUQ0hBIHNpdGUga2V5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2l0ZUtleSA9ICcnO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsaXN0IG9mIHByb3ZpZGVycyBhbmQgdGhlaXIgZW5hYmxlbWVudCBzdGF0dXMgZm9yIHJlQ0FQVENIQSBFbnRlcnByaXNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSA9IFtdO1xyXG4gICAgICAgIGlmIChyZXNwb25zZS5yZWNhcHRjaGFLZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2FwdGNoYUtleSB1bmRlZmluZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRXhhbXBsZSByZXNwb25zZS5yZWNhcHRjaGFLZXk6IFwicHJvamVjdHMvcHJvajEyMy9rZXlzL3NpdGVrZXkxMjNcIlxyXG4gICAgICAgIHRoaXMuc2l0ZUtleSA9IHJlc3BvbnNlLnJlY2FwdGNoYUtleS5zcGxpdCgnLycpWzNdO1xyXG4gICAgICAgIHRoaXMucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSA9IHJlc3BvbnNlLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlQ0FQVENIQSBFbnRlcnByaXNlIGVuZm9yY2VtZW50IHN0YXRlIGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3ZpZGVyU3RyIC0gVGhlIHByb3ZpZGVyIHdob3NlIGVuZm9yY2VtZW50IHN0YXRlIGlzIHRvIGJlIHJldHVybmVkLlxyXG4gICAgICogQHJldHVybnMgVGhlIHJlQ0FQVENIQSBFbnRlcnByaXNlIGVuZm9yY2VtZW50IHN0YXRlIGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuXHJcbiAgICAgKi9cclxuICAgIGdldFByb3ZpZGVyRW5mb3JjZW1lbnRTdGF0ZShwcm92aWRlclN0cikge1xyXG4gICAgICAgIGlmICghdGhpcy5yZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlIHx8XHJcbiAgICAgICAgICAgIHRoaXMucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSBvZiB0aGlzLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUucHJvdmlkZXIgJiZcclxuICAgICAgICAgICAgICAgIHJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUucHJvdmlkZXIgPT09IHByb3ZpZGVyU3RyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhcnNlRW5mb3JjZW1lbnRTdGF0ZShyZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlLmVuZm9yY2VtZW50U3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlQ0FQVENIQSBFbnRlcnByaXNlIGVuZm9yY2VtZW50IHN0YXRlIGZvciB0aGUgcHJvdmlkZXIgaXMgc2V0IHRvIEVORk9SQ0Ugb3IgQVVESVQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3ZpZGVyU3RyIC0gVGhlIHByb3ZpZGVyIHdob3NlIGVuYWJsZW1lbnQgc3RhdGUgaXMgdG8gYmUgcmV0dXJuZWQuXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCByZUNBUFRDSEEgRW50ZXJwcmlzZSBwcm90ZWN0aW9uIGlzIGVuYWJsZWQgZm9yIHRoZSBnaXZlbiBwcm92aWRlci5cclxuICAgICAqL1xyXG4gICAgaXNQcm92aWRlckVuYWJsZWQocHJvdmlkZXJTdHIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0UHJvdmlkZXJFbmZvcmNlbWVudFN0YXRlKHByb3ZpZGVyU3RyKSA9PT1cclxuICAgICAgICAgICAgXCJFTkZPUkNFXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5FTkZPUkNFICovIHx8XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0UHJvdmlkZXJFbmZvcmNlbWVudFN0YXRlKHByb3ZpZGVyU3RyKSA9PT0gXCJBVURJVFwiIC8qIEVuZm9yY2VtZW50U3RhdGUuQVVESVQgKi8pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFJlY2FwdGNoYUNvbmZpZyhhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiR0VUXCIgLyogSHR0cE1ldGhvZC5HRVQgKi8sIFwiL3YyL3JlY2FwdGNoYUNvbmZpZ1wiIC8qIEVuZHBvaW50LkdFVF9SRUNBUFRDSEFfQ09ORklHICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFjY291bnQoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOmRlbGV0ZVwiIC8qIEVuZHBvaW50LkRFTEVURV9BQ0NPVU5UICovLCByZXF1ZXN0KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBkZWxldGVMaW5rZWRBY2NvdW50cyhhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6dXBkYXRlXCIgLyogRW5kcG9pbnQuU0VUX0FDQ09VTlRfSU5GTyAqLywgcmVxdWVzdCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudEluZm8oYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOmxvb2t1cFwiIC8qIEVuZHBvaW50LkdFVF9BQ0NPVU5UX0lORk8gKi8sIHJlcXVlc3QpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyh1dGNUaW1lc3RhbXApIHtcclxuICAgIGlmICghdXRjVGltZXN0YW1wKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gQ29udmVydCB0byBkYXRlIG9iamVjdC5cclxuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoTnVtYmVyKHV0Y1RpbWVzdGFtcCkpO1xyXG4gICAgICAgIC8vIFRlc3QgZGF0ZSBpcyB2YWxpZC5cclxuICAgICAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIFVUQyBkYXRlIHN0cmluZy5cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGUudG9VVENTdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcuIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhIEpTT04gV2ViIFRva2VuIChKV1QpIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHVzZXIgdG8gYSBGaXJlYmFzZSBzZXJ2aWNlLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRva2VuIGlmIGl0IGhhcyBub3QgZXhwaXJlZCBvciBpZiBpdCB3aWxsIG5vdCBleHBpcmUgaW4gdGhlIG5leHQgZml2ZVxyXG4gKiBtaW51dGVzLiBPdGhlcndpc2UsIHRoaXMgd2lsbCByZWZyZXNoIHRoZSB0b2tlbiBhbmQgcmV0dXJuIGEgbmV3IG9uZS5cclxuICpcclxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cclxuICogQHBhcmFtIGZvcmNlUmVmcmVzaCAtIEZvcmNlIHJlZnJlc2ggcmVnYXJkbGVzcyBvZiB0b2tlbiBleHBpcmF0aW9uLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRJZFRva2VuKHVzZXIsIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpLmdldElkVG9rZW4oZm9yY2VSZWZyZXNoKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGRlc2VyaWFsaXplZCBKU09OIFdlYiBUb2tlbiAoSldUKSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB1c2VyIHRvIGEgRmlyZWJhc2Ugc2VydmljZS5cclxuICpcclxuICogQHJlbWFya3NcclxuICogUmV0dXJucyB0aGUgY3VycmVudCB0b2tlbiBpZiBpdCBoYXMgbm90IGV4cGlyZWQgb3IgaWYgaXQgd2lsbCBub3QgZXhwaXJlIGluIHRoZSBuZXh0IGZpdmVcclxuICogbWludXRlcy4gT3RoZXJ3aXNlLCB0aGlzIHdpbGwgcmVmcmVzaCB0aGUgdG9rZW4gYW5kIHJldHVybiBhIG5ldyBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqIEBwYXJhbSBmb3JjZVJlZnJlc2ggLSBGb3JjZSByZWZyZXNoIHJlZ2FyZGxlc3Mgb2YgdG9rZW4gZXhwaXJhdGlvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0SWRUb2tlblJlc3VsdCh1c2VyLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xyXG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xyXG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCB1c2VySW50ZXJuYWwuZ2V0SWRUb2tlbihmb3JjZVJlZnJlc2gpO1xyXG4gICAgY29uc3QgY2xhaW1zID0gX3BhcnNlVG9rZW4odG9rZW4pO1xyXG4gICAgX2Fzc2VydChjbGFpbXMgJiYgY2xhaW1zLmV4cCAmJiBjbGFpbXMuYXV0aF90aW1lICYmIGNsYWltcy5pYXQsIHVzZXJJbnRlcm5hbC5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICBjb25zdCBmaXJlYmFzZSA9IHR5cGVvZiBjbGFpbXMuZmlyZWJhc2UgPT09ICdvYmplY3QnID8gY2xhaW1zLmZpcmViYXNlIDogdW5kZWZpbmVkO1xyXG4gICAgY29uc3Qgc2lnbkluUHJvdmlkZXIgPSBmaXJlYmFzZSA9PT0gbnVsbCB8fCBmaXJlYmFzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyZWJhc2VbJ3NpZ25faW5fcHJvdmlkZXInXTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2xhaW1zLFxyXG4gICAgICAgIHRva2VuLFxyXG4gICAgICAgIGF1dGhUaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5hdXRoX3RpbWUpKSxcclxuICAgICAgICBpc3N1ZWRBdFRpbWU6IHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyhzZWNvbmRzU3RyaW5nVG9NaWxsaXNlY29uZHMoY2xhaW1zLmlhdCkpLFxyXG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5leHApKSxcclxuICAgICAgICBzaWduSW5Qcm92aWRlcjogc2lnbkluUHJvdmlkZXIgfHwgbnVsbCxcclxuICAgICAgICBzaWduSW5TZWNvbmRGYWN0b3I6IChmaXJlYmFzZSA9PT0gbnVsbCB8fCBmaXJlYmFzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyZWJhc2VbJ3NpZ25faW5fc2Vjb25kX2ZhY3RvciddKSB8fCBudWxsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNlY29uZHNTdHJpbmdUb01pbGxpc2Vjb25kcyhzZWNvbmRzKSB7XHJcbiAgICByZXR1cm4gTnVtYmVyKHNlY29uZHMpICogMTAwMDtcclxufVxyXG5mdW5jdGlvbiBfcGFyc2VUb2tlbih0b2tlbikge1xyXG4gICAgY29uc3QgW2FsZ29yaXRobSwgcGF5bG9hZCwgc2lnbmF0dXJlXSA9IHRva2VuLnNwbGl0KCcuJyk7XHJcbiAgICBpZiAoYWxnb3JpdGhtID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICBwYXlsb2FkID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICBzaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIF9sb2dFcnJvcignSldUIG1hbGZvcm1lZCwgY29udGFpbmVkIGZld2VyIHRoYW4gMyBzZWN0aW9ucycpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkZWNvZGVkID0gYmFzZTY0RGVjb2RlKHBheWxvYWQpO1xyXG4gICAgICAgIGlmICghZGVjb2RlZCkge1xyXG4gICAgICAgICAgICBfbG9nRXJyb3IoJ0ZhaWxlZCB0byBkZWNvZGUgYmFzZTY0IEpXVCBwYXlsb2FkJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVkKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgX2xvZ0Vycm9yKCdDYXVnaHQgZXJyb3IgcGFyc2luZyBKV1QgcGF5bG9hZCBhcyBKU09OJywgZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0IGV4cGlyZXNJbiBUVEwgZnJvbSBhIHRva2VuIGJ5IHN1YnRyYWN0aW5nIHRoZSBleHBpcmF0aW9uIGZyb20gdGhlIGlzc3VhbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gX3Rva2VuRXhwaXJlc0luKHRva2VuKSB7XHJcbiAgICBjb25zdCBwYXJzZWRUb2tlbiA9IF9wYXJzZVRva2VuKHRva2VuKTtcclxuICAgIF9hc3NlcnQocGFyc2VkVG9rZW4sIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgIF9hc3NlcnQodHlwZW9mIHBhcnNlZFRva2VuLmV4cCAhPT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgIF9hc3NlcnQodHlwZW9mIHBhcnNlZFRva2VuLmlhdCAhPT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgIHJldHVybiBOdW1iZXIocGFyc2VkVG9rZW4uZXhwKSAtIE51bWJlcihwYXJzZWRUb2tlbi5pYXQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIF9sb2dvdXRJZkludmFsaWRhdGVkKHVzZXIsIHByb21pc2UsIGJ5cGFzc0F1dGhTdGF0ZSA9IGZhbHNlKSB7XHJcbiAgICBpZiAoYnlwYXNzQXV0aFN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IgJiYgaXNVc2VySW52YWxpZGF0ZWQoZSkpIHtcclxuICAgICAgICAgICAgaWYgKHVzZXIuYXV0aC5jdXJyZW50VXNlciA9PT0gdXNlcikge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdXNlci5hdXRoLnNpZ25PdXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzVXNlckludmFsaWRhdGVkKHsgY29kZSB9KSB7XHJcbiAgICByZXR1cm4gKGNvZGUgPT09IGBhdXRoLyR7XCJ1c2VyLWRpc2FibGVkXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RJU0FCTEVEICovfWAgfHxcclxuICAgICAgICBjb2RlID09PSBgYXV0aC8ke1widXNlci10b2tlbi1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5UT0tFTl9FWFBJUkVEICovfWApO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFByb2FjdGl2ZVJlZnJlc2gge1xyXG4gICAgY29uc3RydWN0b3IodXNlcikge1xyXG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAvLyBOb2RlIHRpbWVycyBhbmQgYnJvd3NlciB0aW1lcnMgcmV0dXJuIGZ1bmRhbWVudGFsbHkgZGlmZmVyZW50IHR5cGVzLlxyXG4gICAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGNhcmUgd2hhdCB0aGUgdmFsdWUgaXMgYnV0IFRTIHdvbid0IGFjY2VwdCB1bmtub3duIGFuZFxyXG4gICAgICAgIC8vIHdlIGNhbid0IGNhc3QgcHJvcGVybHkgaW4gYm90aCBlbnZpcm9ubWVudHMuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB0aGlzLnRpbWVySWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXJyb3JCYWNrb2ZmID0gMzAwMDAgLyogRHVyYXRpb24uUkVUUllfQkFDS09GRl9NSU4gKi87XHJcbiAgICB9XHJcbiAgICBfc3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcclxuICAgIH1cclxuICAgIF9zdG9wKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVySWQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0SW50ZXJ2YWwod2FzRXJyb3IpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHdhc0Vycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5lcnJvckJhY2tvZmY7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JCYWNrb2ZmID0gTWF0aC5taW4odGhpcy5lcnJvckJhY2tvZmYgKiAyLCA5NjAwMDAgLyogRHVyYXRpb24uUkVUUllfQkFDS09GRl9NQVggKi8pO1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZXJyb3IgYmFja29mZlxyXG4gICAgICAgICAgICB0aGlzLmVycm9yQmFja29mZiA9IDMwMDAwIC8qIER1cmF0aW9uLlJFVFJZX0JBQ0tPRkZfTUlOICovO1xyXG4gICAgICAgICAgICBjb25zdCBleHBUaW1lID0gKF9hID0gdGhpcy51c2VyLnN0c1Rva2VuTWFuYWdlci5leHBpcmF0aW9uVGltZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBleHBUaW1lIC0gRGF0ZS5ub3coKSAtIDMwMDAwMCAvKiBEdXJhdGlvbi5PRkZTRVQgKi87XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBpbnRlcnZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2NoZWR1bGUod2FzRXJyb3IgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcclxuICAgICAgICAgICAgLy8gSnVzdCBpbiBjYXNlLi4uXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSB0aGlzLmdldEludGVydmFsKHdhc0Vycm9yKTtcclxuICAgICAgICB0aGlzLnRpbWVySWQgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5pdGVyYXRpb24oKTtcclxuICAgICAgICB9LCBpbnRlcnZhbCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBpdGVyYXRpb24oKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy51c2VyLmdldElkVG9rZW4odHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgcmV0cnkgb24gbmV0d29yayBlcnJvcnNcclxuICAgICAgICAgICAgaWYgKChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuY29kZSkgPT09XHJcbiAgICAgICAgICAgICAgICBgYXV0aC8ke1wibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqL31gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlKC8qIHdhc0Vycm9yICovIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY2hlZHVsZSgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFVzZXJNZXRhZGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcihjcmVhdGVkQXQsIGxhc3RMb2dpbkF0KSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVkQXQgPSBjcmVhdGVkQXQ7XHJcbiAgICAgICAgdGhpcy5sYXN0TG9naW5BdCA9IGxhc3RMb2dpbkF0O1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVUaW1lKCk7XHJcbiAgICB9XHJcbiAgICBfaW5pdGlhbGl6ZVRpbWUoKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0U2lnbkluVGltZSA9IHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyh0aGlzLmxhc3RMb2dpbkF0KTtcclxuICAgICAgICB0aGlzLmNyZWF0aW9uVGltZSA9IHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyh0aGlzLmNyZWF0ZWRBdCk7XHJcbiAgICB9XHJcbiAgICBfY29weShtZXRhZGF0YSkge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gbWV0YWRhdGEuY3JlYXRlZEF0O1xyXG4gICAgICAgIHRoaXMubGFzdExvZ2luQXQgPSBtZXRhZGF0YS5sYXN0TG9naW5BdDtcclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplVGltZSgpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogdGhpcy5jcmVhdGVkQXQsXHJcbiAgICAgICAgICAgIGxhc3RMb2dpbkF0OiB0aGlzLmxhc3RMb2dpbkF0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBhdXRoID0gdXNlci5hdXRoO1xyXG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VyLCBnZXRBY2NvdW50SW5mbyhhdXRoLCB7IGlkVG9rZW4gfSkpO1xyXG4gICAgX2Fzc2VydChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UudXNlcnMubGVuZ3RoLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICBjb25zdCBjb3JlQWNjb3VudCA9IHJlc3BvbnNlLnVzZXJzWzBdO1xyXG4gICAgdXNlci5fbm90aWZ5UmVsb2FkTGlzdGVuZXIoY29yZUFjY291bnQpO1xyXG4gICAgY29uc3QgbmV3UHJvdmlkZXJEYXRhID0gKChfYSA9IGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpXHJcbiAgICAgICAgPyBleHRyYWN0UHJvdmlkZXJEYXRhKGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8pXHJcbiAgICAgICAgOiBbXTtcclxuICAgIGNvbnN0IHByb3ZpZGVyRGF0YSA9IG1lcmdlUHJvdmlkZXJEYXRhKHVzZXIucHJvdmlkZXJEYXRhLCBuZXdQcm92aWRlckRhdGEpO1xyXG4gICAgLy8gUHJlc2VydmVzIHRoZSBub24tbm9ueW1vdXMgc3RhdHVzIG9mIHRoZSBzdG9yZWQgdXNlciwgZXZlbiBpZiBubyBtb3JlXHJcbiAgICAvLyBjcmVkZW50aWFscyAoZmVkZXJhdGVkIG9yIGVtYWlsL3Bhc3N3b3JkKSBhcmUgbGlua2VkIHRvIHRoZSB1c2VyLiBJZlxyXG4gICAgLy8gdGhlIHVzZXIgd2FzIHByZXZpb3VzbHkgYW5vbnltb3VzLCB0aGVuIHVzZSBwcm92aWRlciBkYXRhIHRvIHVwZGF0ZS5cclxuICAgIC8vIE9uIHRoZSBvdGhlciBoYW5kLCBpZiBpdCB3YXMgbm90IGFub255bW91cyBiZWZvcmUsIGl0IHNob3VsZCBuZXZlciBiZVxyXG4gICAgLy8gY29uc2lkZXJlZCBhbm9ueW1vdXMgbm93LlxyXG4gICAgY29uc3Qgb2xkSXNBbm9ueW1vdXMgPSB1c2VyLmlzQW5vbnltb3VzO1xyXG4gICAgY29uc3QgbmV3SXNBbm9ueW1vdXMgPSAhKHVzZXIuZW1haWwgJiYgY29yZUFjY291bnQucGFzc3dvcmRIYXNoKSAmJiAhKHByb3ZpZGVyRGF0YSA9PT0gbnVsbCB8fCBwcm92aWRlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyRGF0YS5sZW5ndGgpO1xyXG4gICAgY29uc3QgaXNBbm9ueW1vdXMgPSAhb2xkSXNBbm9ueW1vdXMgPyBmYWxzZSA6IG5ld0lzQW5vbnltb3VzO1xyXG4gICAgY29uc3QgdXBkYXRlcyA9IHtcclxuICAgICAgICB1aWQ6IGNvcmVBY2NvdW50LmxvY2FsSWQsXHJcbiAgICAgICAgZGlzcGxheU5hbWU6IGNvcmVBY2NvdW50LmRpc3BsYXlOYW1lIHx8IG51bGwsXHJcbiAgICAgICAgcGhvdG9VUkw6IGNvcmVBY2NvdW50LnBob3RvVXJsIHx8IG51bGwsXHJcbiAgICAgICAgZW1haWw6IGNvcmVBY2NvdW50LmVtYWlsIHx8IG51bGwsXHJcbiAgICAgICAgZW1haWxWZXJpZmllZDogY29yZUFjY291bnQuZW1haWxWZXJpZmllZCB8fCBmYWxzZSxcclxuICAgICAgICBwaG9uZU51bWJlcjogY29yZUFjY291bnQucGhvbmVOdW1iZXIgfHwgbnVsbCxcclxuICAgICAgICB0ZW5hbnRJZDogY29yZUFjY291bnQudGVuYW50SWQgfHwgbnVsbCxcclxuICAgICAgICBwcm92aWRlckRhdGEsXHJcbiAgICAgICAgbWV0YWRhdGE6IG5ldyBVc2VyTWV0YWRhdGEoY29yZUFjY291bnQuY3JlYXRlZEF0LCBjb3JlQWNjb3VudC5sYXN0TG9naW5BdCksXHJcbiAgICAgICAgaXNBbm9ueW1vdXNcclxuICAgIH07XHJcbiAgICBPYmplY3QuYXNzaWduKHVzZXIsIHVwZGF0ZXMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZWxvYWRzIHVzZXIgYWNjb3VudCBkYXRhLCBpZiBzaWduZWQgaW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJlbG9hZCh1c2VyKSB7XHJcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XHJcbiAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VySW50ZXJuYWwpO1xyXG4gICAgLy8gRXZlbiB0aG91Z2ggdGhlIGN1cnJlbnQgdXNlciBoYXNuJ3QgY2hhbmdlZCwgdXBkYXRlXHJcbiAgICAvLyBjdXJyZW50IHVzZXIgd2lsbCB0cmlnZ2VyIGEgcGVyc2lzdGVuY2UgdXBkYXRlIHcvIHRoZVxyXG4gICAgLy8gbmV3IGluZm8uXHJcbiAgICBhd2FpdCB1c2VySW50ZXJuYWwuYXV0aC5fcGVyc2lzdFVzZXJJZkN1cnJlbnQodXNlckludGVybmFsKTtcclxuICAgIHVzZXJJbnRlcm5hbC5hdXRoLl9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodXNlckludGVybmFsKTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZVByb3ZpZGVyRGF0YShvcmlnaW5hbCwgbmV3RGF0YSkge1xyXG4gICAgY29uc3QgZGVkdXBlZCA9IG9yaWdpbmFsLmZpbHRlcihvID0+ICFuZXdEYXRhLnNvbWUobiA9PiBuLnByb3ZpZGVySWQgPT09IG8ucHJvdmlkZXJJZCkpO1xyXG4gICAgcmV0dXJuIFsuLi5kZWR1cGVkLCAuLi5uZXdEYXRhXTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0UHJvdmlkZXJEYXRhKHByb3ZpZGVycykge1xyXG4gICAgcmV0dXJuIHByb3ZpZGVycy5tYXAoKF9hKSA9PiB7XHJcbiAgICAgICAgdmFyIHsgcHJvdmlkZXJJZCB9ID0gX2EsIHByb3ZpZGVyID0gX19yZXN0KF9hLCBbXCJwcm92aWRlcklkXCJdKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcm92aWRlcklkLFxyXG4gICAgICAgICAgICB1aWQ6IHByb3ZpZGVyLnJhd0lkIHx8ICcnLFxyXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogcHJvdmlkZXIuZGlzcGxheU5hbWUgfHwgbnVsbCxcclxuICAgICAgICAgICAgZW1haWw6IHByb3ZpZGVyLmVtYWlsIHx8IG51bGwsXHJcbiAgICAgICAgICAgIHBob25lTnVtYmVyOiBwcm92aWRlci5waG9uZU51bWJlciB8fCBudWxsLFxyXG4gICAgICAgICAgICBwaG90b1VSTDogcHJvdmlkZXIucGhvdG9VcmwgfHwgbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0U3RzVG9rZW4oYXV0aCwgcmVmcmVzaFRva2VuKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9wZXJmb3JtRmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhhdXRoLCB7fSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGJvZHkgPSBxdWVyeXN0cmluZyh7XHJcbiAgICAgICAgICAgICdncmFudF90eXBlJzogJ3JlZnJlc2hfdG9rZW4nLFxyXG4gICAgICAgICAgICAncmVmcmVzaF90b2tlbic6IHJlZnJlc2hUb2tlblxyXG4gICAgICAgIH0pLnNsaWNlKDEpO1xyXG4gICAgICAgIGNvbnN0IHsgdG9rZW5BcGlIb3N0LCBhcGlLZXkgfSA9IGF1dGguY29uZmlnO1xyXG4gICAgICAgIGNvbnN0IHVybCA9IF9nZXRGaW5hbFRhcmdldChhdXRoLCB0b2tlbkFwaUhvc3QsIFwiL3YxL3Rva2VuXCIgLyogRW5kcG9pbnQuVE9LRU4gKi8sIGBrZXk9JHthcGlLZXl9YCk7XHJcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IGF1dGguX2dldEFkZGl0aW9uYWxIZWFkZXJzKCk7XHJcbiAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiIC8qIEh0dHBIZWFkZXIuQ09OVEVOVF9UWVBFICovXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xyXG4gICAgICAgIHJldHVybiBGZXRjaFByb3ZpZGVyLmZldGNoKCkodXJsLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLFxyXG4gICAgICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgICAgICBib2R5XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIC8vIFRoZSByZXNwb25zZSBjb21lcyBiYWNrIGluIHNuYWtlX2Nhc2UuIENvbnZlcnQgdG8gY2FtZWw6XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFjY2Vzc1Rva2VuOiByZXNwb25zZS5hY2Nlc3NfdG9rZW4sXHJcbiAgICAgICAgZXhwaXJlc0luOiByZXNwb25zZS5leHBpcmVzX2luLFxyXG4gICAgICAgIHJlZnJlc2hUb2tlbjogcmVzcG9uc2UucmVmcmVzaF90b2tlblxyXG4gICAgfTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiByZXZva2VUb2tlbihhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHM6cmV2b2tlVG9rZW5cIiAvKiBFbmRwb2ludC5SRVZPS0VfVE9LRU4gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFdlIG5lZWQgdG8gbWFyayB0aGlzIGNsYXNzIGFzIGludGVybmFsIGV4cGxpY2l0bHkgdG8gZXhjbHVkZSBpdCBpbiB0aGUgcHVibGljIHR5cGluZ3MsIGJlY2F1c2VcclxuICogaXQgcmVmZXJlbmNlcyBBdXRoSW50ZXJuYWwgd2hpY2ggaGFzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSB3aXRoIFVzZXJJbnRlcm5hbC5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBTdHNUb2tlbk1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRXhwaXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gKCF0aGlzLmV4cGlyYXRpb25UaW1lIHx8XHJcbiAgICAgICAgICAgIERhdGUubm93KCkgPiB0aGlzLmV4cGlyYXRpb25UaW1lIC0gMzAwMDAgLyogQnVmZmVyLlRPS0VOX1JFRlJFU0ggKi8pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlRnJvbVNlcnZlclJlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgX2Fzc2VydChyZXNwb25zZS5pZFRva2VuLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgcmVzcG9uc2UuaWRUb2tlbiAhPT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBfYXNzZXJ0KHR5cGVvZiByZXNwb25zZS5yZWZyZXNoVG9rZW4gIT09ICd1bmRlZmluZWQnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgY29uc3QgZXhwaXJlc0luID0gJ2V4cGlyZXNJbicgaW4gcmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlLmV4cGlyZXNJbiAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgPyBOdW1iZXIocmVzcG9uc2UuZXhwaXJlc0luKVxyXG4gICAgICAgICAgICA6IF90b2tlbkV4cGlyZXNJbihyZXNwb25zZS5pZFRva2VuKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRva2Vuc0FuZEV4cGlyYXRpb24ocmVzcG9uc2UuaWRUb2tlbiwgcmVzcG9uc2UucmVmcmVzaFRva2VuLCBleHBpcmVzSW4pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlRnJvbUlkVG9rZW4oaWRUb2tlbikge1xyXG4gICAgICAgIF9hc3NlcnQoaWRUb2tlbi5sZW5ndGggIT09IDAsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBjb25zdCBleHBpcmVzSW4gPSBfdG9rZW5FeHBpcmVzSW4oaWRUb2tlbik7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uKGlkVG9rZW4sIG51bGwsIGV4cGlyZXNJbik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRUb2tlbihhdXRoLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmIHRoaXMuYWNjZXNzVG9rZW4gJiYgIXRoaXMuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfYXNzZXJ0KHRoaXMucmVmcmVzaFRva2VuLCBhdXRoLCBcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqLyk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaFRva2VuKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaChhdXRoLCB0aGlzLnJlZnJlc2hUb2tlbik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNsZWFyUmVmcmVzaFRva2VuKCkge1xyXG4gICAgICAgIHRoaXMucmVmcmVzaFRva2VuID0gbnVsbDtcclxuICAgIH1cclxuICAgIGFzeW5jIHJlZnJlc2goYXV0aCwgb2xkVG9rZW4pIHtcclxuICAgICAgICBjb25zdCB7IGFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4sIGV4cGlyZXNJbiB9ID0gYXdhaXQgcmVxdWVzdFN0c1Rva2VuKGF1dGgsIG9sZFRva2VuKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRva2Vuc0FuZEV4cGlyYXRpb24oYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiwgTnVtYmVyKGV4cGlyZXNJbikpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVG9rZW5zQW5kRXhwaXJhdGlvbihhY2Nlc3NUb2tlbiwgcmVmcmVzaFRva2VuLCBleHBpcmVzSW5TZWMpIHtcclxuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHJlZnJlc2hUb2tlbiB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbiB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBEYXRlLm5vdygpICsgZXhwaXJlc0luU2VjICogMTAwMDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tSlNPTihhcHBOYW1lLCBvYmplY3QpIHtcclxuICAgICAgICBjb25zdCB7IHJlZnJlc2hUb2tlbiwgYWNjZXNzVG9rZW4sIGV4cGlyYXRpb25UaW1lIH0gPSBvYmplY3Q7XHJcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBTdHNUb2tlbk1hbmFnZXIoKTtcclxuICAgICAgICBpZiAocmVmcmVzaFRva2VuKSB7XHJcbiAgICAgICAgICAgIF9hc3NlcnQodHlwZW9mIHJlZnJlc2hUb2tlbiA9PT0gJ3N0cmluZycsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLCB7XHJcbiAgICAgICAgICAgICAgICBhcHBOYW1lXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtYW5hZ2VyLnJlZnJlc2hUb2tlbiA9IHJlZnJlc2hUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgIF9hc3NlcnQodHlwZW9mIGFjY2Vzc1Rva2VuID09PSAnc3RyaW5nJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sIHtcclxuICAgICAgICAgICAgICAgIGFwcE5hbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1hbmFnZXIuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4cGlyYXRpb25UaW1lKSB7XHJcbiAgICAgICAgICAgIF9hc3NlcnQodHlwZW9mIGV4cGlyYXRpb25UaW1lID09PSAnbnVtYmVyJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sIHtcclxuICAgICAgICAgICAgICAgIGFwcE5hbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1hbmFnZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVmcmVzaFRva2VuOiB0aGlzLnJlZnJlc2hUb2tlbixcclxuICAgICAgICAgICAgYWNjZXNzVG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXHJcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lOiB0aGlzLmV4cGlyYXRpb25UaW1lXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIF9hc3NpZ24oc3RzVG9rZW5NYW5hZ2VyKSB7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbjtcclxuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHN0c1Rva2VuTWFuYWdlci5yZWZyZXNoVG9rZW47XHJcbiAgICAgICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IHN0c1Rva2VuTWFuYWdlci5leHBpcmF0aW9uVGltZTtcclxuICAgIH1cclxuICAgIF9jbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgU3RzVG9rZW5NYW5hZ2VyKCksIHRoaXMudG9KU09OKCkpO1xyXG4gICAgfVxyXG4gICAgX3BlcmZvcm1SZWZyZXNoKCkge1xyXG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGFzc2VydGlvbiwgYXBwTmFtZSkge1xyXG4gICAgX2Fzc2VydCh0eXBlb2YgYXNzZXJ0aW9uID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXNzZXJ0aW9uID09PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sIHsgYXBwTmFtZSB9KTtcclxufVxyXG5jbGFzcyBVc2VySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfYSkge1xyXG4gICAgICAgIHZhciB7IHVpZCwgYXV0aCwgc3RzVG9rZW5NYW5hZ2VyIH0gPSBfYSwgb3B0ID0gX19yZXN0KF9hLCBbXCJ1aWRcIiwgXCJhdXRoXCIsIFwic3RzVG9rZW5NYW5hZ2VyXCJdKTtcclxuICAgICAgICAvLyBGb3IgdGhlIHVzZXIgb2JqZWN0LCBwcm92aWRlciBpcyBhbHdheXMgRmlyZWJhc2UuXHJcbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gXCJmaXJlYmFzZVwiIC8qIFByb3ZpZGVySWQuRklSRUJBU0UgKi87XHJcbiAgICAgICAgdGhpcy5wcm9hY3RpdmVSZWZyZXNoID0gbmV3IFByb2FjdGl2ZVJlZnJlc2godGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZWxvYWRVc2VySW5mbyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZWxvYWRMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51aWQgPSB1aWQ7XHJcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcclxuICAgICAgICB0aGlzLnN0c1Rva2VuTWFuYWdlciA9IHN0c1Rva2VuTWFuYWdlcjtcclxuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gc3RzVG9rZW5NYW5hZ2VyLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSBvcHQuZGlzcGxheU5hbWUgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLmVtYWlsID0gb3B0LmVtYWlsIHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbWFpbFZlcmlmaWVkID0gb3B0LmVtYWlsVmVyaWZpZWQgfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5waG9uZU51bWJlciA9IG9wdC5waG9uZU51bWJlciB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMucGhvdG9VUkwgPSBvcHQucGhvdG9VUkwgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLmlzQW5vbnltb3VzID0gb3B0LmlzQW5vbnltb3VzIHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGVuYW50SWQgPSBvcHQudGVuYW50SWQgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyRGF0YSA9IG9wdC5wcm92aWRlckRhdGEgPyBbLi4ub3B0LnByb3ZpZGVyRGF0YV0gOiBbXTtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3IFVzZXJNZXRhZGF0YShvcHQuY3JlYXRlZEF0IHx8IHVuZGVmaW5lZCwgb3B0Lmxhc3RMb2dpbkF0IHx8IHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRJZFRva2VuKGZvcmNlUmVmcmVzaCkge1xyXG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcywgdGhpcy5zdHNUb2tlbk1hbmFnZXIuZ2V0VG9rZW4odGhpcy5hdXRoLCBmb3JjZVJlZnJlc2gpKTtcclxuICAgICAgICBfYXNzZXJ0KGFjY2Vzc1Rva2VuLCB0aGlzLmF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBpZiAodGhpcy5hY2Nlc3NUb2tlbiAhPT0gYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmF1dGguX3BlcnNpc3RVc2VySWZDdXJyZW50KHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmF1dGguX25vdGlmeUxpc3RlbmVyc0lmQ3VycmVudCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1Rva2VuO1xyXG4gICAgfVxyXG4gICAgZ2V0SWRUb2tlblJlc3VsdChmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICByZXR1cm4gZ2V0SWRUb2tlblJlc3VsdCh0aGlzLCBmb3JjZVJlZnJlc2gpO1xyXG4gICAgfVxyXG4gICAgcmVsb2FkKCkge1xyXG4gICAgICAgIHJldHVybiByZWxvYWQodGhpcyk7XHJcbiAgICB9XHJcbiAgICBfYXNzaWduKHVzZXIpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gdXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9hc3NlcnQodGhpcy51aWQgPT09IHVzZXIudWlkLCB0aGlzLmF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICB0aGlzLmRpc3BsYXlOYW1lID0gdXNlci5kaXNwbGF5TmFtZTtcclxuICAgICAgICB0aGlzLnBob3RvVVJMID0gdXNlci5waG90b1VSTDtcclxuICAgICAgICB0aGlzLmVtYWlsID0gdXNlci5lbWFpbDtcclxuICAgICAgICB0aGlzLmVtYWlsVmVyaWZpZWQgPSB1c2VyLmVtYWlsVmVyaWZpZWQ7XHJcbiAgICAgICAgdGhpcy5waG9uZU51bWJlciA9IHVzZXIucGhvbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5pc0Fub255bW91cyA9IHVzZXIuaXNBbm9ueW1vdXM7XHJcbiAgICAgICAgdGhpcy50ZW5hbnRJZCA9IHVzZXIudGVuYW50SWQ7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlckRhdGEgPSB1c2VyLnByb3ZpZGVyRGF0YS5tYXAodXNlckluZm8gPT4gKE9iamVjdC5hc3NpZ24oe30sIHVzZXJJbmZvKSkpO1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEuX2NvcHkodXNlci5tZXRhZGF0YSk7XHJcbiAgICAgICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIuX2Fzc2lnbih1c2VyLnN0c1Rva2VuTWFuYWdlcik7XHJcbiAgICB9XHJcbiAgICBfY2xvbmUoYXV0aCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1VzZXIgPSBuZXcgVXNlckltcGwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzKSwgeyBhdXRoLCBzdHNUb2tlbk1hbmFnZXI6IHRoaXMuc3RzVG9rZW5NYW5hZ2VyLl9jbG9uZSgpIH0pKTtcclxuICAgICAgICBuZXdVc2VyLm1ldGFkYXRhLl9jb3B5KHRoaXMubWV0YWRhdGEpO1xyXG4gICAgICAgIHJldHVybiBuZXdVc2VyO1xyXG4gICAgfVxyXG4gICAgX29uUmVsb2FkKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy8gVGhlcmUgc2hvdWxkIG9ubHkgZXZlciBiZSBvbmUgbGlzdGVuZXIsIGFuZCB0aGF0IGlzIGEgc2luZ2xlIGluc3RhbmNlIG9mIE11bHRpRmFjdG9yVXNlclxyXG4gICAgICAgIF9hc3NlcnQoIXRoaXMucmVsb2FkTGlzdGVuZXIsIHRoaXMuYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIHRoaXMucmVsb2FkTGlzdGVuZXIgPSBjYWxsYmFjaztcclxuICAgICAgICBpZiAodGhpcy5yZWxvYWRVc2VySW5mbykge1xyXG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlSZWxvYWRMaXN0ZW5lcih0aGlzLnJlbG9hZFVzZXJJbmZvKTtcclxuICAgICAgICAgICAgdGhpcy5yZWxvYWRVc2VySW5mbyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX25vdGlmeVJlbG9hZExpc3RlbmVyKHVzZXJJbmZvKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVsb2FkTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWxvYWRMaXN0ZW5lcih1c2VySW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiBubyBsaXN0ZW5lciBpcyBzdWJzY3JpYmVkIHlldCwgc2F2ZSB0aGUgcmVzdWx0IHNvIGl0J3MgYXZhaWxhYmxlIHdoZW4gdGhleSBkbyBzdWJzY3JpYmVcclxuICAgICAgICAgICAgdGhpcy5yZWxvYWRVc2VySW5mbyA9IHVzZXJJbmZvO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zdGFydFByb2FjdGl2ZVJlZnJlc2goKSB7XHJcbiAgICAgICAgdGhpcy5wcm9hY3RpdmVSZWZyZXNoLl9zdGFydCgpO1xyXG4gICAgfVxyXG4gICAgX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCkge1xyXG4gICAgICAgIHRoaXMucHJvYWN0aXZlUmVmcmVzaC5fc3RvcCgpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KHJlc3BvbnNlLCByZWxvYWQgPSBmYWxzZSkge1xyXG4gICAgICAgIGxldCB0b2tlbnNSZWZyZXNoZWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAocmVzcG9uc2UuaWRUb2tlbiAmJlxyXG4gICAgICAgICAgICByZXNwb25zZS5pZFRva2VuICE9PSB0aGlzLnN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbikge1xyXG4gICAgICAgICAgICB0aGlzLnN0c1Rva2VuTWFuYWdlci51cGRhdGVGcm9tU2VydmVyUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB0b2tlbnNSZWZyZXNoZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVsb2FkKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IF9yZWxvYWRXaXRob3V0U2F2aW5nKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCB0aGlzLmF1dGguX3BlcnNpc3RVc2VySWZDdXJyZW50KHRoaXMpO1xyXG4gICAgICAgIGlmICh0b2tlbnNSZWZyZXNoZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hdXRoLl9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgZGVsZXRlKCkge1xyXG4gICAgICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcCh0aGlzLmF1dGguYXBwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcy5hdXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB0aGlzLmdldElkVG9rZW4oKTtcclxuICAgICAgICBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh0aGlzLCBkZWxldGVBY2NvdW50KHRoaXMuYXV0aCwgeyBpZFRva2VuIH0pKTtcclxuICAgICAgICB0aGlzLnN0c1Rva2VuTWFuYWdlci5jbGVhclJlZnJlc2hUb2tlbigpO1xyXG4gICAgICAgIC8vIFRPRE86IERldGVybWluZSBpZiBjYW5jZWxsYWJsZS1wcm9taXNlcyBhcmUgbmVjZXNzYXJ5IHRvIHVzZSBpbiB0aGlzIGNsYXNzIHNvIHRoYXQgZGVsZXRlKClcclxuICAgICAgICAvLyAgICAgICBjYW5jZWxzIHBlbmRpbmcgYWN0aW9ucy4uLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmF1dGguc2lnbk91dCgpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB1aWQ6IHRoaXMudWlkLCBlbWFpbDogdGhpcy5lbWFpbCB8fCB1bmRlZmluZWQsIGVtYWlsVmVyaWZpZWQ6IHRoaXMuZW1haWxWZXJpZmllZCwgZGlzcGxheU5hbWU6IHRoaXMuZGlzcGxheU5hbWUgfHwgdW5kZWZpbmVkLCBpc0Fub255bW91czogdGhpcy5pc0Fub255bW91cywgcGhvdG9VUkw6IHRoaXMucGhvdG9VUkwgfHwgdW5kZWZpbmVkLCBwaG9uZU51bWJlcjogdGhpcy5waG9uZU51bWJlciB8fCB1bmRlZmluZWQsIHRlbmFudElkOiB0aGlzLnRlbmFudElkIHx8IHVuZGVmaW5lZCwgcHJvdmlkZXJEYXRhOiB0aGlzLnByb3ZpZGVyRGF0YS5tYXAodXNlckluZm8gPT4gKE9iamVjdC5hc3NpZ24oe30sIHVzZXJJbmZvKSkpLCBzdHNUb2tlbk1hbmFnZXI6IHRoaXMuc3RzVG9rZW5NYW5hZ2VyLnRvSlNPTigpLCBcclxuICAgICAgICAgICAgLy8gUmVkaXJlY3QgZXZlbnQgSUQgbXVzdCBiZSBtYWludGFpbmVkIGluIGNhc2UgdGhlcmUgaXMgYSBwZW5kaW5nXHJcbiAgICAgICAgICAgIC8vIHJlZGlyZWN0IGV2ZW50LlxyXG4gICAgICAgICAgICBfcmVkaXJlY3RFdmVudElkOiB0aGlzLl9yZWRpcmVjdEV2ZW50SWQgfSwgdGhpcy5tZXRhZGF0YS50b0pTT04oKSksIHsgXHJcbiAgICAgICAgICAgIC8vIFJlcXVpcmVkIGZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGxlZ2FjeSBTREsgKGdvL2ZpcmViYXNlLWF1dGgtc2RrLXBlcnNpc3RlbmNlLXBhcnNpbmcpOlxyXG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXV0aC5jb25maWcuYXBpS2V5LCBhcHBOYW1lOiB0aGlzLmF1dGgubmFtZSB9KTtcclxuICAgIH1cclxuICAgIGdldCByZWZyZXNoVG9rZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RzVG9rZW5NYW5hZ2VyLnJlZnJlc2hUb2tlbiB8fCAnJztcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZnJvbUpTT04oYXV0aCwgb2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcclxuICAgICAgICBjb25zdCBkaXNwbGF5TmFtZSA9IChfYSA9IG9iamVjdC5kaXNwbGF5TmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGVtYWlsID0gKF9iID0gb2JqZWN0LmVtYWlsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgcGhvbmVOdW1iZXIgPSAoX2MgPSBvYmplY3QucGhvbmVOdW1iZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBwaG90b1VSTCA9IChfZCA9IG9iamVjdC5waG90b1VSTCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHRlbmFudElkID0gKF9lID0gb2JqZWN0LnRlbmFudElkKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgX3JlZGlyZWN0RXZlbnRJZCA9IChfZiA9IG9iamVjdC5fcmVkaXJlY3RFdmVudElkKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gKF9nID0gb2JqZWN0LmNyZWF0ZWRBdCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGxhc3RMb2dpbkF0ID0gKF9oID0gb2JqZWN0Lmxhc3RMb2dpbkF0KSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgeyB1aWQsIGVtYWlsVmVyaWZpZWQsIGlzQW5vbnltb3VzLCBwcm92aWRlckRhdGEsIHN0c1Rva2VuTWFuYWdlcjogcGxhaW5PYmplY3RUb2tlbk1hbmFnZXIgfSA9IG9iamVjdDtcclxuICAgICAgICBfYXNzZXJ0KHVpZCAmJiBwbGFpbk9iamVjdFRva2VuTWFuYWdlciwgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIGNvbnN0IHN0c1Rva2VuTWFuYWdlciA9IFN0c1Rva2VuTWFuYWdlci5mcm9tSlNPTih0aGlzLm5hbWUsIHBsYWluT2JqZWN0VG9rZW5NYW5hZ2VyKTtcclxuICAgICAgICBfYXNzZXJ0KHR5cGVvZiB1aWQgPT09ICdzdHJpbmcnLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoZGlzcGxheU5hbWUsIGF1dGgubmFtZSk7XHJcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoZW1haWwsIGF1dGgubmFtZSk7XHJcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgZW1haWxWZXJpZmllZCA9PT0gJ2Jvb2xlYW4nLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgaXNBbm9ueW1vdXMgPT09ICdib29sZWFuJywgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKHBob25lTnVtYmVyLCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKHBob3RvVVJMLCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKHRlbmFudElkLCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKF9yZWRpcmVjdEV2ZW50SWQsIGF1dGgubmFtZSk7XHJcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoY3JlYXRlZEF0LCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGxhc3RMb2dpbkF0LCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlckltcGwoe1xyXG4gICAgICAgICAgICB1aWQsXHJcbiAgICAgICAgICAgIGF1dGgsXHJcbiAgICAgICAgICAgIGVtYWlsLFxyXG4gICAgICAgICAgICBlbWFpbFZlcmlmaWVkLFxyXG4gICAgICAgICAgICBkaXNwbGF5TmFtZSxcclxuICAgICAgICAgICAgaXNBbm9ueW1vdXMsXHJcbiAgICAgICAgICAgIHBob3RvVVJMLFxyXG4gICAgICAgICAgICBwaG9uZU51bWJlcixcclxuICAgICAgICAgICAgdGVuYW50SWQsXHJcbiAgICAgICAgICAgIHN0c1Rva2VuTWFuYWdlcixcclxuICAgICAgICAgICAgY3JlYXRlZEF0LFxyXG4gICAgICAgICAgICBsYXN0TG9naW5BdFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwcm92aWRlckRhdGEgJiYgQXJyYXkuaXNBcnJheShwcm92aWRlckRhdGEpKSB7XHJcbiAgICAgICAgICAgIHVzZXIucHJvdmlkZXJEYXRhID0gcHJvdmlkZXJEYXRhLm1hcCh1c2VySW5mbyA9PiAoT2JqZWN0LmFzc2lnbih7fSwgdXNlckluZm8pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfcmVkaXJlY3RFdmVudElkKSB7XHJcbiAgICAgICAgICAgIHVzZXIuX3JlZGlyZWN0RXZlbnRJZCA9IF9yZWRpcmVjdEV2ZW50SWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1c2VyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIGEgVXNlciBmcm9tIGFuIGlkVG9rZW4gc2VydmVyIHJlc3BvbnNlXHJcbiAgICAgKiBAcGFyYW0gYXV0aFxyXG4gICAgICogQHBhcmFtIGlkVG9rZW5SZXNwb25zZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXN5bmMgX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aCwgaWRUb2tlblJlc3BvbnNlLCBpc0Fub255bW91cyA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3Qgc3RzVG9rZW5NYW5hZ2VyID0gbmV3IFN0c1Rva2VuTWFuYWdlcigpO1xyXG4gICAgICAgIHN0c1Rva2VuTWFuYWdlci51cGRhdGVGcm9tU2VydmVyUmVzcG9uc2UoaWRUb2tlblJlc3BvbnNlKTtcclxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBGaXJlYmFzZSBBdXRoIHVzZXIuXHJcbiAgICAgICAgY29uc3QgdXNlciA9IG5ldyBVc2VySW1wbCh7XHJcbiAgICAgICAgICAgIHVpZDogaWRUb2tlblJlc3BvbnNlLmxvY2FsSWQsXHJcbiAgICAgICAgICAgIGF1dGgsXHJcbiAgICAgICAgICAgIHN0c1Rva2VuTWFuYWdlcixcclxuICAgICAgICAgICAgaXNBbm9ueW1vdXNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBVcGRhdGVzIHRoZSB1c2VyIGluZm8gYW5kIGRhdGEgYW5kIHJlc29sdmVzIHdpdGggYSB1c2VyIGluc3RhbmNlLlxyXG4gICAgICAgIGF3YWl0IF9yZWxvYWRXaXRob3V0U2F2aW5nKHVzZXIpO1xyXG4gICAgICAgIHJldHVybiB1c2VyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIGEgVXNlciBmcm9tIGFuIGlkVG9rZW4gc2VydmVyIHJlc3BvbnNlXHJcbiAgICAgKiBAcGFyYW0gYXV0aFxyXG4gICAgICogQHBhcmFtIGlkVG9rZW5SZXNwb25zZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXN5bmMgX2Zyb21HZXRBY2NvdW50SW5mb1Jlc3BvbnNlKGF1dGgsIHJlc3BvbnNlLCBpZFRva2VuKSB7XHJcbiAgICAgICAgY29uc3QgY29yZUFjY291bnQgPSByZXNwb25zZS51c2Vyc1swXTtcclxuICAgICAgICBfYXNzZXJ0KGNvcmVBY2NvdW50LmxvY2FsSWQgIT09IHVuZGVmaW5lZCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyRGF0YSA9IGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8gIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IGV4dHJhY3RQcm92aWRlckRhdGEoY29yZUFjY291bnQucHJvdmlkZXJVc2VySW5mbylcclxuICAgICAgICAgICAgOiBbXTtcclxuICAgICAgICBjb25zdCBpc0Fub255bW91cyA9ICEoY29yZUFjY291bnQuZW1haWwgJiYgY29yZUFjY291bnQucGFzc3dvcmRIYXNoKSAmJiAhKHByb3ZpZGVyRGF0YSA9PT0gbnVsbCB8fCBwcm92aWRlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyRGF0YS5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IHN0c1Rva2VuTWFuYWdlciA9IG5ldyBTdHNUb2tlbk1hbmFnZXIoKTtcclxuICAgICAgICBzdHNUb2tlbk1hbmFnZXIudXBkYXRlRnJvbUlkVG9rZW4oaWRUb2tlbik7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgRmlyZWJhc2UgQXV0aCB1c2VyLlxyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlckltcGwoe1xyXG4gICAgICAgICAgICB1aWQ6IGNvcmVBY2NvdW50LmxvY2FsSWQsXHJcbiAgICAgICAgICAgIGF1dGgsXHJcbiAgICAgICAgICAgIHN0c1Rva2VuTWFuYWdlcixcclxuICAgICAgICAgICAgaXNBbm9ueW1vdXNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyB1cGRhdGUgdGhlIHVzZXIgd2l0aCBkYXRhIGZyb20gdGhlIEdldEFjY291bnRJbmZvIHJlc3BvbnNlLlxyXG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSB7XHJcbiAgICAgICAgICAgIHVpZDogY29yZUFjY291bnQubG9jYWxJZCxcclxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IGNvcmVBY2NvdW50LmRpc3BsYXlOYW1lIHx8IG51bGwsXHJcbiAgICAgICAgICAgIHBob3RvVVJMOiBjb3JlQWNjb3VudC5waG90b1VybCB8fCBudWxsLFxyXG4gICAgICAgICAgICBlbWFpbDogY29yZUFjY291bnQuZW1haWwgfHwgbnVsbCxcclxuICAgICAgICAgICAgZW1haWxWZXJpZmllZDogY29yZUFjY291bnQuZW1haWxWZXJpZmllZCB8fCBmYWxzZSxcclxuICAgICAgICAgICAgcGhvbmVOdW1iZXI6IGNvcmVBY2NvdW50LnBob25lTnVtYmVyIHx8IG51bGwsXHJcbiAgICAgICAgICAgIHRlbmFudElkOiBjb3JlQWNjb3VudC50ZW5hbnRJZCB8fCBudWxsLFxyXG4gICAgICAgICAgICBwcm92aWRlckRhdGEsXHJcbiAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgVXNlck1ldGFkYXRhKGNvcmVBY2NvdW50LmNyZWF0ZWRBdCwgY29yZUFjY291bnQubGFzdExvZ2luQXQpLFxyXG4gICAgICAgICAgICBpc0Fub255bW91czogIShjb3JlQWNjb3VudC5lbWFpbCAmJiBjb3JlQWNjb3VudC5wYXNzd29yZEhhc2gpICYmXHJcbiAgICAgICAgICAgICAgICAhKHByb3ZpZGVyRGF0YSA9PT0gbnVsbCB8fCBwcm92aWRlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyRGF0YS5sZW5ndGgpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHVzZXIsIHVwZGF0ZXMpO1xyXG4gICAgICAgIHJldHVybiB1c2VyO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGluc3RhbmNlQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbmZ1bmN0aW9uIF9nZXRJbnN0YW5jZShjbHMpIHtcclxuICAgIGRlYnVnQXNzZXJ0KGNscyBpbnN0YW5jZW9mIEZ1bmN0aW9uLCAnRXhwZWN0ZWQgYSBjbGFzcyBkZWZpbml0aW9uJyk7XHJcbiAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZUNhY2hlLmdldChjbHMpO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgZGVidWdBc3NlcnQoaW5zdGFuY2UgaW5zdGFuY2VvZiBjbHMsICdJbnN0YW5jZSBzdG9yZWQgaW4gY2FjaGUgbWlzbWF0Y2hlZCB3aXRoIGNsYXNzJyk7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgaW5zdGFuY2UgPSBuZXcgY2xzKCk7XHJcbiAgICBpbnN0YW5jZUNhY2hlLnNldChjbHMsIGluc3RhbmNlKTtcclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBJbk1lbW9yeVBlcnNpc3RlbmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiTk9ORVwiIC8qIFBlcnNpc3RlbmNlVHlwZS5OT05FICovO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHt9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX2lzQXZhaWxhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX3NldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9nZXQoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnN0b3JhZ2Vba2V5XTtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9yZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXldO1xyXG4gICAgfVxyXG4gICAgX2FkZExpc3RlbmVyKF9rZXksIF9saXN0ZW5lcikge1xyXG4gICAgICAgIC8vIExpc3RlbmVycyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgaW4tbWVtb3J5IHN0b3JhZ2Ugc2luY2UgaXQgY2Fubm90IGJlIHNoYXJlZCBhY3Jvc3Mgd2luZG93cy93b3JrZXJzXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgX3JlbW92ZUxpc3RlbmVyKF9rZXksIF9saXN0ZW5lcikge1xyXG4gICAgICAgIC8vIExpc3RlbmVycyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgaW4tbWVtb3J5IHN0b3JhZ2Ugc2luY2UgaXQgY2Fubm90IGJlIHNoYXJlZCBhY3Jvc3Mgd2luZG93cy93b3JrZXJzXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG59XHJcbkluTWVtb3J5UGVyc2lzdGVuY2UudHlwZSA9ICdOT05FJztcclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBQZXJzaXN0ZW5jZX0gb2YgdHlwZSAnTk9ORScuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGluTWVtb3J5UGVyc2lzdGVuY2UgPSBJbk1lbW9yeVBlcnNpc3RlbmNlO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBfcGVyc2lzdGVuY2VLZXlOYW1lKGtleSwgYXBpS2V5LCBhcHBOYW1lKSB7XHJcbiAgICByZXR1cm4gYCR7XCJmaXJlYmFzZVwiIC8qIE5hbWVzcGFjZS5QRVJTSVNURU5DRSAqL306JHtrZXl9OiR7YXBpS2V5fToke2FwcE5hbWV9YDtcclxufVxyXG5jbGFzcyBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlLCBhdXRoLCB1c2VyS2V5KSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xyXG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XHJcbiAgICAgICAgdGhpcy51c2VyS2V5ID0gdXNlcktleTtcclxuICAgICAgICBjb25zdCB7IGNvbmZpZywgbmFtZSB9ID0gdGhpcy5hdXRoO1xyXG4gICAgICAgIHRoaXMuZnVsbFVzZXJLZXkgPSBfcGVyc2lzdGVuY2VLZXlOYW1lKHRoaXMudXNlcktleSwgY29uZmlnLmFwaUtleSwgbmFtZSk7XHJcbiAgICAgICAgdGhpcy5mdWxsUGVyc2lzdGVuY2VLZXkgPSBfcGVyc2lzdGVuY2VLZXlOYW1lKFwicGVyc2lzdGVuY2VcIiAvKiBLZXlOYW1lLlBFUlNJU1RFTkNFX1VTRVIgKi8sIGNvbmZpZy5hcGlLZXksIG5hbWUpO1xyXG4gICAgICAgIHRoaXMuYm91bmRFdmVudEhhbmRsZXIgPSBhdXRoLl9vblN0b3JhZ2VFdmVudC5iaW5kKGF1dGgpO1xyXG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UuX2FkZExpc3RlbmVyKHRoaXMuZnVsbFVzZXJLZXksIHRoaXMuYm91bmRFdmVudEhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgc2V0Q3VycmVudFVzZXIodXNlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLl9zZXQodGhpcy5mdWxsVXNlcktleSwgdXNlci50b0pTT04oKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRDdXJyZW50VXNlcigpIHtcclxuICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5fZ2V0KHRoaXMuZnVsbFVzZXJLZXkpO1xyXG4gICAgICAgIHJldHVybiBibG9iID8gVXNlckltcGwuX2Zyb21KU09OKHRoaXMuYXV0aCwgYmxvYikgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQ3VycmVudFVzZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuX3JlbW92ZSh0aGlzLmZ1bGxVc2VyS2V5KTtcclxuICAgIH1cclxuICAgIHNhdmVQZXJzaXN0ZW5jZUZvclJlZGlyZWN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLl9zZXQodGhpcy5mdWxsUGVyc2lzdGVuY2VLZXksIHRoaXMucGVyc2lzdGVuY2UudHlwZSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZXRQZXJzaXN0ZW5jZShuZXdQZXJzaXN0ZW5jZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlID09PSBuZXdQZXJzaXN0ZW5jZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gYXdhaXQgdGhpcy5nZXRDdXJyZW50VXNlcigpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucmVtb3ZlQ3VycmVudFVzZXIoKTtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gbmV3UGVyc2lzdGVuY2U7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRVc2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRVc2VyKGN1cnJlbnRVc2VyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWxldGUoKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZS5fcmVtb3ZlTGlzdGVuZXIodGhpcy5mdWxsVXNlcktleSwgdGhpcy5ib3VuZEV2ZW50SGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGF1dGgsIHBlcnNpc3RlbmNlSGllcmFyY2h5LCB1c2VyS2V5ID0gXCJhdXRoVXNlclwiIC8qIEtleU5hbWUuQVVUSF9VU0VSICovKSB7XHJcbiAgICAgICAgaWYgKCFwZXJzaXN0ZW5jZUhpZXJhcmNoeS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyKF9nZXRJbnN0YW5jZShpbk1lbW9yeVBlcnNpc3RlbmNlKSwgYXV0aCwgdXNlcktleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVsaW1pbmF0ZSBhbnkgcGVyc2lzdGVuY2VzIHRoYXQgYXJlIG5vdCBhdmFpbGFibGVcclxuICAgICAgICBjb25zdCBhdmFpbGFibGVQZXJzaXN0ZW5jZXMgPSAoYXdhaXQgUHJvbWlzZS5hbGwocGVyc2lzdGVuY2VIaWVyYXJjaHkubWFwKGFzeW5jIChwZXJzaXN0ZW5jZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYXdhaXQgcGVyc2lzdGVuY2UuX2lzQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwZXJzaXN0ZW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pKSkuZmlsdGVyKHBlcnNpc3RlbmNlID0+IHBlcnNpc3RlbmNlKTtcclxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGZpcnN0IHBlcnNpc3RlbmNlIGxpc3RlZCwgb3IgaW4gbWVtb3J5IGlmIG5vbmUgYXZhaWxhYmxlXHJcbiAgICAgICAgbGV0IHNlbGVjdGVkUGVyc2lzdGVuY2UgPSBhdmFpbGFibGVQZXJzaXN0ZW5jZXNbMF0gfHxcclxuICAgICAgICAgICAgX2dldEluc3RhbmNlKGluTWVtb3J5UGVyc2lzdGVuY2UpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IF9wZXJzaXN0ZW5jZUtleU5hbWUodXNlcktleSwgYXV0aC5jb25maWcuYXBpS2V5LCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIC8vIFB1bGwgb3V0IHRoZSBleGlzdGluZyB1c2VyLCBzZXR0aW5nIHRoZSBjaG9zZW4gcGVyc2lzdGVuY2UgdG8gdGhhdFxyXG4gICAgICAgIC8vIHBlcnNpc3RlbmNlIGlmIHRoZSB1c2VyIGV4aXN0cy5cclxuICAgICAgICBsZXQgdXNlclRvTWlncmF0ZSA9IG51bGw7XHJcbiAgICAgICAgLy8gTm90ZSwgaGVyZSB3ZSBjaGVjayBmb3IgYSB1c2VyIGluIF9hbGxfIHBlcnNpc3RlbmNlcywgbm90IGp1c3QgdGhlXHJcbiAgICAgICAgLy8gb25lcyBkZWVtZWQgYXZhaWxhYmxlLiBJZiB3ZSBjYW4gbWlncmF0ZSBhIHVzZXIgb3V0IG9mIGEgYnJva2VuXHJcbiAgICAgICAgLy8gcGVyc2lzdGVuY2UsIHdlIHdpbGwgKGJ1dCBvbmx5IGlmIHRoYXQgcGVyc2lzdGVuY2Ugc3VwcG9ydHMgbWlncmF0aW9uKS5cclxuICAgICAgICBmb3IgKGNvbnN0IHBlcnNpc3RlbmNlIG9mIHBlcnNpc3RlbmNlSGllcmFyY2h5KSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgcGVyc2lzdGVuY2UuX2dldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJsb2IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyID0gVXNlckltcGwuX2Zyb21KU09OKGF1dGgsIGJsb2IpOyAvLyB0aHJvd3MgZm9yIHVucGFyc2FibGUgYmxvYiAod3JvbmcgZm9ybWF0KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJzaXN0ZW5jZSAhPT0gc2VsZWN0ZWRQZXJzaXN0ZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyVG9NaWdyYXRlID0gdXNlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRQZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGZpbmQgdGhlIHVzZXIgaW4gYSBwZXJzaXN0ZW5jZSB0aGF0IGRvZXMgc3VwcG9ydCBtaWdyYXRpb24sIHVzZVxyXG4gICAgICAgIC8vIHRoYXQgbWlncmF0aW9uIHBhdGggKG9mIG9ubHkgcGVyc2lzdGVuY2VzIHRoYXQgc3VwcG9ydCBtaWdyYXRpb24pXHJcbiAgICAgICAgY29uc3QgbWlncmF0aW9uSGllcmFyY2h5ID0gYXZhaWxhYmxlUGVyc2lzdGVuY2VzLmZpbHRlcihwID0+IHAuX3Nob3VsZEFsbG93TWlncmF0aW9uKTtcclxuICAgICAgICAvLyBJZiB0aGUgcGVyc2lzdGVuY2UgZG9lcyBfbm90XyBhbGxvdyBtaWdyYXRpb24sIGp1c3QgZmluaXNoIG9mZiBoZXJlXHJcbiAgICAgICAgaWYgKCFzZWxlY3RlZFBlcnNpc3RlbmNlLl9zaG91bGRBbGxvd01pZ3JhdGlvbiB8fFxyXG4gICAgICAgICAgICAhbWlncmF0aW9uSGllcmFyY2h5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIoc2VsZWN0ZWRQZXJzaXN0ZW5jZSwgYXV0aCwgdXNlcktleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGVjdGVkUGVyc2lzdGVuY2UgPSBtaWdyYXRpb25IaWVyYXJjaHlbMF07XHJcbiAgICAgICAgaWYgKHVzZXJUb01pZ3JhdGUpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBub3JtYWxseSBzaG91bGRuJ3QgdGhyb3cgc2luY2UgY2hvc2VuUGVyc2lzdGVuY2UuaXNBdmFpbGFibGUoKSBpcyB0cnVlLCBidXQgaWYgaXQgZG9lc1xyXG4gICAgICAgICAgICAvLyB3ZSdsbCBqdXN0IGxldCBpdCBidWJibGUgdG8gc3VyZmFjZSB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgIGF3YWl0IHNlbGVjdGVkUGVyc2lzdGVuY2UuX3NldChrZXksIHVzZXJUb01pZ3JhdGUudG9KU09OKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBdHRlbXB0IHRvIGNsZWFyIHRoZSBrZXkgaW4gb3RoZXIgcGVyc2lzdGVuY2VzIGJ1dCBpZ25vcmUgZXJyb3JzLiBUaGlzIGhlbHBzIHByZXZlbnQgaXNzdWVzXHJcbiAgICAgICAgLy8gc3VjaCBhcyB1c2VycyBnZXR0aW5nIHN0dWNrIHdpdGggYSBwcmV2aW91cyBhY2NvdW50IGFmdGVyIHNpZ25pbmcgb3V0IGFuZCByZWZyZXNoaW5nIHRoZSB0YWIuXHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocGVyc2lzdGVuY2VIaWVyYXJjaHkubWFwKGFzeW5jIChwZXJzaXN0ZW5jZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocGVyc2lzdGVuY2UgIT09IHNlbGVjdGVkUGVyc2lzdGVuY2UpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGVyc2lzdGVuY2UuX3JlbW92ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIoc2VsZWN0ZWRQZXJzaXN0ZW5jZSwgYXV0aCwgdXNlcktleSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERldGVybWluZSB0aGUgYnJvd3NlciBmb3IgdGhlIHB1cnBvc2VzIG9mIHJlcG9ydGluZyB1c2FnZSB0byB0aGUgQVBJXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0QnJvd3Nlck5hbWUodXNlckFnZW50KSB7XHJcbiAgICBjb25zdCB1YSA9IHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKHVhLmluY2x1ZGVzKCdvcGVyYS8nKSB8fCB1YS5pbmNsdWRlcygnb3ByLycpIHx8IHVhLmluY2x1ZGVzKCdvcGlvcy8nKSkge1xyXG4gICAgICAgIHJldHVybiBcIk9wZXJhXCIgLyogQnJvd3Nlck5hbWUuT1BFUkEgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfaXNJRU1vYmlsZSh1YSkpIHtcclxuICAgICAgICAvLyBXaW5kb3dzIHBob25lIElFTW9iaWxlIGJyb3dzZXIuXHJcbiAgICAgICAgcmV0dXJuIFwiSUVNb2JpbGVcIiAvKiBCcm93c2VyTmFtZS5JRU1PQklMRSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHVhLmluY2x1ZGVzKCdtc2llJykgfHwgdWEuaW5jbHVkZXMoJ3RyaWRlbnQvJykpIHtcclxuICAgICAgICByZXR1cm4gXCJJRVwiIC8qIEJyb3dzZXJOYW1lLklFICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodWEuaW5jbHVkZXMoJ2VkZ2UvJykpIHtcclxuICAgICAgICByZXR1cm4gXCJFZGdlXCIgLyogQnJvd3Nlck5hbWUuRURHRSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKF9pc0ZpcmVmb3godWEpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiRmlyZWZveFwiIC8qIEJyb3dzZXJOYW1lLkZJUkVGT1ggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh1YS5pbmNsdWRlcygnc2lsay8nKSkge1xyXG4gICAgICAgIHJldHVybiBcIlNpbGtcIiAvKiBCcm93c2VyTmFtZS5TSUxLICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoX2lzQmxhY2tCZXJyeSh1YSkpIHtcclxuICAgICAgICAvLyBCbGFja2JlcnJ5IGJyb3dzZXIuXHJcbiAgICAgICAgcmV0dXJuIFwiQmxhY2tiZXJyeVwiIC8qIEJyb3dzZXJOYW1lLkJMQUNLQkVSUlkgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfaXNXZWJPUyh1YSkpIHtcclxuICAgICAgICAvLyBXZWJPUyBkZWZhdWx0IGJyb3dzZXIuXHJcbiAgICAgICAgcmV0dXJuIFwiV2Vib3NcIiAvKiBCcm93c2VyTmFtZS5XRUJPUyAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKF9pc1NhZmFyaSh1YSkpIHtcclxuICAgICAgICByZXR1cm4gXCJTYWZhcmlcIiAvKiBCcm93c2VyTmFtZS5TQUZBUkkgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgodWEuaW5jbHVkZXMoJ2Nocm9tZS8nKSB8fCBfaXNDaHJvbWVJT1ModWEpKSAmJlxyXG4gICAgICAgICF1YS5pbmNsdWRlcygnZWRnZS8nKSkge1xyXG4gICAgICAgIHJldHVybiBcIkNocm9tZVwiIC8qIEJyb3dzZXJOYW1lLkNIUk9NRSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKF9pc0FuZHJvaWQodWEpKSB7XHJcbiAgICAgICAgLy8gQW5kcm9pZCBzdG9jayBicm93c2VyLlxyXG4gICAgICAgIHJldHVybiBcIkFuZHJvaWRcIiAvKiBCcm93c2VyTmFtZS5BTkRST0lEICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gTW9zdCBtb2Rlcm4gYnJvd3NlcnMgaGF2ZSBuYW1lL3ZlcnNpb24gYXQgZW5kIG9mIHVzZXIgYWdlbnQgc3RyaW5nLlxyXG4gICAgICAgIGNvbnN0IHJlID0gLyhbYS16QS1aXFxkXFwuXSspXFwvW2EtekEtWlxcZFxcLl0qJC87XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHVzZXJBZ2VudC5tYXRjaChyZSk7XHJcbiAgICAgICAgaWYgKChtYXRjaGVzID09PSBudWxsIHx8IG1hdGNoZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoZXMubGVuZ3RoKSA9PT0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1sxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCJPdGhlclwiIC8qIEJyb3dzZXJOYW1lLk9USEVSICovO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0ZpcmVmb3godWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gL2ZpcmVmb3hcXC8vaS50ZXN0KHVhKTtcclxufVxyXG5mdW5jdGlvbiBfaXNTYWZhcmkodXNlckFnZW50ID0gZ2V0VUEoKSkge1xyXG4gICAgY29uc3QgdWEgPSB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgIHJldHVybiAodWEuaW5jbHVkZXMoJ3NhZmFyaS8nKSAmJlxyXG4gICAgICAgICF1YS5pbmNsdWRlcygnY2hyb21lLycpICYmXHJcbiAgICAgICAgIXVhLmluY2x1ZGVzKCdjcmlvcy8nKSAmJlxyXG4gICAgICAgICF1YS5pbmNsdWRlcygnYW5kcm9pZCcpKTtcclxufVxyXG5mdW5jdGlvbiBfaXNDaHJvbWVJT1ModWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gL2NyaW9zXFwvL2kudGVzdCh1YSk7XHJcbn1cclxuZnVuY3Rpb24gX2lzSUVNb2JpbGUodWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gL2llbW9iaWxlL2kudGVzdCh1YSk7XHJcbn1cclxuZnVuY3Rpb24gX2lzQW5kcm9pZCh1YSA9IGdldFVBKCkpIHtcclxuICAgIHJldHVybiAvYW5kcm9pZC9pLnRlc3QodWEpO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0JsYWNrQmVycnkodWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gL2JsYWNrYmVycnkvaS50ZXN0KHVhKTtcclxufVxyXG5mdW5jdGlvbiBfaXNXZWJPUyh1YSA9IGdldFVBKCkpIHtcclxuICAgIHJldHVybiAvd2Vib3MvaS50ZXN0KHVhKTtcclxufVxyXG5mdW5jdGlvbiBfaXNJT1ModWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gKC9pcGhvbmV8aXBhZHxpcG9kL2kudGVzdCh1YSkgfHxcclxuICAgICAgICAoL21hY2ludG9zaC9pLnRlc3QodWEpICYmIC9tb2JpbGUvaS50ZXN0KHVhKSkpO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0lPUzdPcjgodWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gKC8oaVBhZHxpUGhvbmV8aVBvZCkuKk9TIDdfXFxkL2kudGVzdCh1YSkgfHxcclxuICAgICAgICAvKGlQYWR8aVBob25lfGlQb2QpLipPUyA4X1xcZC9pLnRlc3QodWEpKTtcclxufVxyXG5mdW5jdGlvbiBfaXNJRTEwKCkge1xyXG4gICAgcmV0dXJuIGlzSUUoKSAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09IDEwO1xyXG59XHJcbmZ1bmN0aW9uIF9pc01vYmlsZUJyb3dzZXIodWEgPSBnZXRVQSgpKSB7XHJcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgZ2V0QnJvd3Nlck5hbWUgZXF1aXZhbGVudCBmb3IgT1MuXHJcbiAgICByZXR1cm4gKF9pc0lPUyh1YSkgfHxcclxuICAgICAgICBfaXNBbmRyb2lkKHVhKSB8fFxyXG4gICAgICAgIF9pc1dlYk9TKHVhKSB8fFxyXG4gICAgICAgIF9pc0JsYWNrQmVycnkodWEpIHx8XHJcbiAgICAgICAgL3dpbmRvd3MgcGhvbmUvaS50ZXN0KHVhKSB8fFxyXG4gICAgICAgIF9pc0lFTW9iaWxlKHVhKSk7XHJcbn1cclxuZnVuY3Rpb24gX2lzSWZyYW1lKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBjdXJyZW50IHdpbmRvdyBpcyBub3QgdGhlIHRvcCB3aW5kb3cuXHJcbiAgICAgICAgLy8gSWYgc28sIHJldHVybiB0cnVlLlxyXG4gICAgICAgIHJldHVybiAhISh3aW5kb3cgJiYgd2luZG93ICE9PSB3aW5kb3cudG9wKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qXHJcbiAqIERldGVybWluZSB0aGUgU0RLIHZlcnNpb24gc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0Q2xpZW50VmVyc2lvbihjbGllbnRQbGF0Zm9ybSwgZnJhbWV3b3JrcyA9IFtdKSB7XHJcbiAgICBsZXQgcmVwb3J0ZWRQbGF0Zm9ybTtcclxuICAgIHN3aXRjaCAoY2xpZW50UGxhdGZvcm0pIHtcclxuICAgICAgICBjYXNlIFwiQnJvd3NlclwiIC8qIENsaWVudFBsYXRmb3JtLkJST1dTRVIgKi86XHJcbiAgICAgICAgICAgIC8vIEluIGEgYnJvd3NlciBlbnZpcm9ubWVudCwgcmVwb3J0IHRoZSBicm93c2VyIG5hbWUuXHJcbiAgICAgICAgICAgIHJlcG9ydGVkUGxhdGZvcm0gPSBfZ2V0QnJvd3Nlck5hbWUoZ2V0VUEoKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJXb3JrZXJcIiAvKiBDbGllbnRQbGF0Zm9ybS5XT1JLRVIgKi86XHJcbiAgICAgICAgICAgIC8vIFRlY2huaWNhbGx5IGEgd29ya2VyIHJ1bnMgZnJvbSBhIGJyb3dzZXIgYnV0IHdlIG5lZWQgdG8gZGlmZmVyZW50aWF0ZSBhXHJcbiAgICAgICAgICAgIC8vIHdvcmtlciBmcm9tIGEgYnJvd3Nlci5cclxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IENocm9tZS1Xb3JrZXIvSnNDb3JlLzQuOS4xL0ZpcmViYXNlQ29yZS13ZWIuXHJcbiAgICAgICAgICAgIHJlcG9ydGVkUGxhdGZvcm0gPSBgJHtfZ2V0QnJvd3Nlck5hbWUoZ2V0VUEoKSl9LSR7Y2xpZW50UGxhdGZvcm19YDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmVwb3J0ZWRQbGF0Zm9ybSA9IGNsaWVudFBsYXRmb3JtO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVwb3J0ZWRGcmFtZXdvcmtzID0gZnJhbWV3b3Jrcy5sZW5ndGhcclxuICAgICAgICA/IGZyYW1ld29ya3Muam9pbignLCcpXHJcbiAgICAgICAgOiAnRmlyZWJhc2VDb3JlLXdlYic7IC8qIGRlZmF1bHQgdmFsdWUgaWYgbm8gb3RoZXIgZnJhbWV3b3JrIGlzIHVzZWQgKi9cclxuICAgIHJldHVybiBgJHtyZXBvcnRlZFBsYXRmb3JtfS8ke1wiSnNDb3JlXCIgLyogQ2xpZW50SW1wbGVtZW50YXRpb24uQ09SRSAqL30vJHtTREtfVkVSU0lPTn0vJHtyZXBvcnRlZEZyYW1ld29ya3N9YDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBBdXRoTWlkZGxld2FyZVF1ZXVlIHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGgpIHtcclxuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xyXG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcclxuICAgIH1cclxuICAgIHB1c2hDYWxsYmFjayhjYWxsYmFjaywgb25BYm9ydCkge1xyXG4gICAgICAgIC8vIFRoZSBjYWxsYmFjayBjb3VsZCBiZSBzeW5jIG9yIGFzeW5jLiBXcmFwIGl0IGludG8gYVxyXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRoYXQgaXMgYWx3YXlzIGFzeW5jLlxyXG4gICAgICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFjayA9ICh1c2VyKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayh1c2VyKTtcclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciByZXNvbHZlIHdpdGggZXhpc3RpbmcgcHJvbWlzZSBvciB3cmFwIGEgbm9uLXByb21pc2VcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSBpbnRvIGEgcHJvbWlzZS5cclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3luYyBjYWxsYmFjayB0aHJvd3MuXHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBBdHRhY2ggdGhlIG9uQWJvcnQgaWYgcHJlc2VudFxyXG4gICAgICAgIHdyYXBwZWRDYWxsYmFjay5vbkFib3J0ID0gb25BYm9ydDtcclxuICAgICAgICB0aGlzLnF1ZXVlLnB1c2god3JhcHBlZENhbGxiYWNrKTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUubGVuZ3RoIC0gMTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBVbnN1YnNjcmliZS4gUmVwbGFjZSB3aXRoIG5vLW9wLiBEbyBub3QgcmVtb3ZlIGZyb20gYXJyYXksIG9yIGl0IHdpbGwgZGlzdHVyYlxyXG4gICAgICAgICAgICAvLyBpbmRleGluZyBvZiBvdGhlciBlbGVtZW50cy5cclxuICAgICAgICAgICAgdGhpcy5xdWV1ZVtpbmRleF0gPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcnVuTWlkZGxld2FyZShuZXh0VXNlcikge1xyXG4gICAgICAgIGlmICh0aGlzLmF1dGguY3VycmVudFVzZXIgPT09IG5leHRVc2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2hpbGUgcnVubmluZyB0aGUgbWlkZGxld2FyZSwgYnVpbGQgYSB0ZW1wb3Jhcnkgc3RhY2sgb2Ygb25BYm9ydFxyXG4gICAgICAgIC8vIGNhbGxiYWNrcyB0byBjYWxsIGlmIG9uZSBtaWRkbGV3YXJlIGNhbGxiYWNrIHJlamVjdHMuXHJcbiAgICAgICAgY29uc3Qgb25BYm9ydFN0YWNrID0gW107XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBiZWZvcmVTdGF0ZUNhbGxiYWNrIG9mIHRoaXMucXVldWUpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGJlZm9yZVN0YXRlQ2FsbGJhY2sobmV4dFVzZXIpO1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSBwdXNoIHRoZSBvbkFib3J0IGlmIHRoZSBjYWxsYmFjayBzdWNjZWVkc1xyXG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZVN0YXRlQ2FsbGJhY2sub25BYm9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQWJvcnRTdGFjay5wdXNoKGJlZm9yZVN0YXRlQ2FsbGJhY2sub25BYm9ydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gUnVuIGFsbCBvbkFib3J0LCB3aXRoIHNlcGFyYXRlIHRyeS9jYXRjaCB0byBpZ25vcmUgYW55IGVycm9ycyBhbmRcclxuICAgICAgICAgICAgLy8gY29udGludWVcclxuICAgICAgICAgICAgb25BYm9ydFN0YWNrLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBvbkFib3J0IG9mIG9uQWJvcnRTdGFjaykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIHN3YWxsb3cgZXJyb3IgKi9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyB0aGlzLmF1dGguX2Vycm9yRmFjdG9yeS5jcmVhdGUoXCJsb2dpbi1ibG9ja2VkXCIgLyogQXV0aEVycm9yQ29kZS5MT0dJTl9CTE9DS0VEICovLCB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRmV0Y2hlcyB0aGUgcGFzc3dvcmQgcG9saWN5IGZvciB0aGUgY3VycmVudGx5IHNldCB0ZW5hbnQgb3IgdGhlIHByb2plY3QgaWYgbm8gdGVuYW50IGlzIHNldC5cclxuICpcclxuICogQHBhcmFtIGF1dGggQXV0aCBvYmplY3QuXHJcbiAqIEBwYXJhbSByZXF1ZXN0IFBhc3N3b3JkIHBvbGljeSByZXF1ZXN0LlxyXG4gKiBAcmV0dXJucyBQYXNzd29yZCBwb2xpY3kgcmVzcG9uc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBfZ2V0UGFzc3dvcmRQb2xpY3koYXV0aCwgcmVxdWVzdCA9IHt9KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiR0VUXCIgLyogSHR0cE1ldGhvZC5HRVQgKi8sIFwiL3YyL3Bhc3N3b3JkUG9saWN5XCIgLyogRW5kcG9pbnQuR0VUX1BBU1NXT1JEX1BPTElDWSAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBNaW5pbXVtIG1pbiBwYXNzd29yZCBsZW5ndGggZW5mb3JjZWQgYnkgdGhlIGJhY2tlbmQsIGV2ZW4gaWYgbm8gbWluaW11bSBsZW5ndGggaXMgc2V0LlxyXG5jb25zdCBNSU5JTVVNX01JTl9QQVNTV09SRF9MRU5HVEggPSA2O1xyXG4vKipcclxuICogU3RvcmVzIHBhc3N3b3JkIHBvbGljeSByZXF1aXJlbWVudHMgYW5kIHByb3ZpZGVzIHBhc3N3b3JkIHZhbGlkYXRpb24gYWdhaW5zdCB0aGUgcG9saWN5LlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFBhc3N3b3JkUG9saWN5SW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICAvLyBPbmx5IGluY2x1ZGUgY3VzdG9tIHN0cmVuZ3RoIG9wdGlvbnMgZGVmaW5lZCBpbiB0aGUgcmVzcG9uc2UuXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2VPcHRpb25zID0gcmVzcG9uc2UuY3VzdG9tU3RyZW5ndGhPcHRpb25zO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zID0ge307XHJcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIG9uY2UgdGhlIGJhY2tlbmQgaXMgdXBkYXRlZCB0byBpbmNsdWRlIHRoZSBtaW5pbXVtIG1pbiBwYXNzd29yZCBsZW5ndGggaW5zdGVhZCBvZiB1bmRlZmluZWQgd2hlbiB0aGVyZSBpcyBubyBtaW5pbXVtIGxlbmd0aCBzZXQuXHJcbiAgICAgICAgdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGggPVxyXG4gICAgICAgICAgICAoX2EgPSByZXNwb25zZU9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IE1JTklNVU1fTUlOX1BBU1NXT1JEX0xFTkdUSDtcclxuICAgICAgICBpZiAocmVzcG9uc2VPcHRpb25zLm1heFBhc3N3b3JkTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLm1heFBhc3N3b3JkTGVuZ3RoID1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5tYXhQYXNzd29yZExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc0xvd2VyY2FzZUNoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyID1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5jb250YWluc0xvd2VyY2FzZUNoYXJhY3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUNoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyID1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUNoYXJhY3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIgPVxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyID1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbmZvcmNlbWVudFN0YXRlID0gcmVzcG9uc2UuZW5mb3JjZW1lbnRTdGF0ZTtcclxuICAgICAgICBpZiAodGhpcy5lbmZvcmNlbWVudFN0YXRlID09PSAnRU5GT1JDRU1FTlRfU1RBVEVfVU5TUEVDSUZJRUQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5mb3JjZW1lbnRTdGF0ZSA9ICdPRkYnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVc2UgYW4gZW1wdHkgc3RyaW5nIGlmIG5vIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhcmUgc3BlY2lmaWVkIGluIHRoZSByZXNwb25zZS5cclxuICAgICAgICB0aGlzLmFsbG93ZWROb25BbHBoYW51bWVyaWNDaGFyYWN0ZXJzID1cclxuICAgICAgICAgICAgKF9jID0gKF9iID0gcmVzcG9uc2UuYWxsb3dlZE5vbkFscGhhbnVtZXJpY0NoYXJhY3RlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5qb2luKCcnKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJyc7XHJcbiAgICAgICAgdGhpcy5mb3JjZVVwZ3JhZGVPblNpZ25pbiA9IChfZCA9IHJlc3BvbnNlLmZvcmNlVXBncmFkZU9uU2lnbmluKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZTtcclxuICAgICAgICB0aGlzLnNjaGVtYVZlcnNpb24gPSByZXNwb25zZS5zY2hlbWFWZXJzaW9uO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQYXNzd29yZChwYXNzd29yZCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHtcclxuICAgICAgICAgICAgaXNWYWxpZDogdHJ1ZSxcclxuICAgICAgICAgICAgcGFzc3dvcmRQb2xpY3k6IHRoaXNcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENoZWNrIHRoZSBwYXNzd29yZCBsZW5ndGggYW5kIGNoYXJhY3RlciBvcHRpb25zLlxyXG4gICAgICAgIHRoaXMudmFsaWRhdGVQYXNzd29yZExlbmd0aE9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cyk7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9ucyhwYXNzd29yZCwgc3RhdHVzKTtcclxuICAgICAgICAvLyBDb21iaW5lIHRoZSBzdGF0dXMgaW50byBzaW5nbGUgaXNWYWxpZCBwcm9wZXJ0eS5cclxuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2EgPSBzdGF0dXMubWVldHNNaW5QYXNzd29yZExlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSk7XHJcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9iID0gc3RhdHVzLm1lZXRzTWF4UGFzc3dvcmRMZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpO1xyXG4gICAgICAgIHN0YXR1cy5pc1ZhbGlkICYmIChzdGF0dXMuaXNWYWxpZCA9IChfYyA9IHN0YXR1cy5jb250YWluc0xvd2VyY2FzZUxldHRlcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdHJ1ZSk7XHJcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9kID0gc3RhdHVzLmNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlKTtcclxuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2UgPSBzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0cnVlKTtcclxuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2YgPSBzdGF0dXMuY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRydWUpO1xyXG4gICAgICAgIHJldHVybiBzdGF0dXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBwYXNzd29yZCBtZWV0cyB0aGUgbGVuZ3RoIG9wdGlvbnMgZm9yIHRoZSBwb2xpY3kuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFBhc3N3b3JkIHRvIHZhbGlkYXRlLlxyXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGVQYXNzd29yZExlbmd0aE9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cykge1xyXG4gICAgICAgIGNvbnN0IG1pblBhc3N3b3JkTGVuZ3RoID0gdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbWF4UGFzc3dvcmRMZW5ndGggPSB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5tYXhQYXNzd29yZExlbmd0aDtcclxuICAgICAgICBpZiAobWluUGFzc3dvcmRMZW5ndGgpIHtcclxuICAgICAgICAgICAgc3RhdHVzLm1lZXRzTWluUGFzc3dvcmRMZW5ndGggPSBwYXNzd29yZC5sZW5ndGggPj0gbWluUGFzc3dvcmRMZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXhQYXNzd29yZExlbmd0aCkge1xyXG4gICAgICAgICAgICBzdGF0dXMubWVldHNNYXhQYXNzd29yZExlbmd0aCA9IHBhc3N3b3JkLmxlbmd0aCA8PSBtYXhQYXNzd29yZExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBwYXNzd29yZCBtZWV0cyB0aGUgY2hhcmFjdGVyIG9wdGlvbnMgZm9yIHRoZSBwb2xpY3kuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFBhc3N3b3JkIHRvIHZhbGlkYXRlLlxyXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cykge1xyXG4gICAgICAgIC8vIEFzc2lnbiBzdGF0dXNlcyBmb3IgcmVxdWlyZW1lbnRzIGV2ZW4gaWYgdGhlIHBhc3N3b3JkIGlzIGFuIGVtcHR5IHN0cmluZy5cclxuICAgICAgICB0aGlzLnVwZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9uc1N0YXR1c2VzKHN0YXR1cywgXHJcbiAgICAgICAgLyogY29udGFpbnNMb3dlcmNhc2VDaGFyYWN0ZXI9ICovIGZhbHNlLCBcclxuICAgICAgICAvKiBjb250YWluc1VwcGVyY2FzZUNoYXJhY3Rlcj0gKi8gZmFsc2UsIFxyXG4gICAgICAgIC8qIGNvbnRhaW5zTnVtZXJpY0NoYXJhY3Rlcj0gKi8gZmFsc2UsIFxyXG4gICAgICAgIC8qIGNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyPSAqLyBmYWxzZSk7XHJcbiAgICAgICAgbGV0IHBhc3N3b3JkQ2hhcjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhc3N3b3JkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhc3N3b3JkQ2hhciA9IHBhc3N3b3JkLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnNTdGF0dXNlcyhzdGF0dXMsIFxyXG4gICAgICAgICAgICAvKiBjb250YWluc0xvd2VyY2FzZUNoYXJhY3Rlcj0gKi8gcGFzc3dvcmRDaGFyID49ICdhJyAmJlxyXG4gICAgICAgICAgICAgICAgcGFzc3dvcmRDaGFyIDw9ICd6JywgXHJcbiAgICAgICAgICAgIC8qIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyPSAqLyBwYXNzd29yZENoYXIgPj0gJ0EnICYmXHJcbiAgICAgICAgICAgICAgICBwYXNzd29yZENoYXIgPD0gJ1onLCBcclxuICAgICAgICAgICAgLyogY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyPSAqLyBwYXNzd29yZENoYXIgPj0gJzAnICYmXHJcbiAgICAgICAgICAgICAgICBwYXNzd29yZENoYXIgPD0gJzknLCBcclxuICAgICAgICAgICAgLyogY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXI9ICovIHRoaXMuYWxsb3dlZE5vbkFscGhhbnVtZXJpY0NoYXJhY3RlcnMuaW5jbHVkZXMocGFzc3dvcmRDaGFyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBydW5uaW5nIHZhbGlkYXRpb24gc3RhdHVzIHdpdGggdGhlIHN0YXR1c2VzIGZvciB0aGUgY2hhcmFjdGVyIG9wdGlvbnMuXHJcbiAgICAgKiBFeHBlY3RlZCB0byBiZSBjYWxsZWQgZWFjaCB0aW1lIGEgY2hhcmFjdGVyIGlzIHByb2Nlc3NlZCB0byB1cGRhdGUgZWFjaCBvcHRpb24gc3RhdHVzXHJcbiAgICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBjaGFyYWN0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cclxuICAgICAqIEBwYXJhbSBjb250YWluc0xvd2VyY2FzZUNoYXJhY3RlciBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgYSBsb3dlcmNhc2UgbGV0dGVyLlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyIFdoZXRoZXIgdGhlIGNoYXJhY3RlciBpcyBhbiB1cHBlcmNhc2UgbGV0dGVyLlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgYSBudW1lcmljIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSBjb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgYSBub24tYWxwaGFudW1lcmljIGNoYXJhY3Rlci5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlUGFzc3dvcmRDaGFyYWN0ZXJPcHRpb25zU3RhdHVzZXMoc3RhdHVzLCBjb250YWluc0xvd2VyY2FzZUNoYXJhY3RlciwgY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIsIGNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciwgY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMuY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIpIHtcclxuICAgICAgICAgICAgc3RhdHVzLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyIHx8IChzdGF0dXMuY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIgPSBjb250YWluc0xvd2VyY2FzZUNoYXJhY3Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUxldHRlcikge1xyXG4gICAgICAgICAgICBzdGF0dXMuY29udGFpbnNVcHBlcmNhc2VMZXR0ZXIgfHwgKHN0YXR1cy5jb250YWluc1VwcGVyY2FzZUxldHRlciA9IGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICBzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyIHx8IChzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyID0gY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciB8fCAoc3RhdHVzLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyID0gY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBBdXRoSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlciwgYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXIsIGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xyXG4gICAgICAgIHRoaXMuaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyID0gaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXIgPSBhcHBDaGVja1NlcnZpY2VQcm92aWRlcjtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVtdWxhdG9yQ29uZmlnID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB0aGlzLmF1dGhTdGF0ZVN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGhpcyk7XHJcbiAgICAgICAgdGhpcy5pZFRva2VuU3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0aGlzKTtcclxuICAgICAgICB0aGlzLmJlZm9yZVN0YXRlUXVldWUgPSBuZXcgQXV0aE1pZGRsZXdhcmVRdWV1ZSh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZGlyZWN0VXNlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5FWFBFQ1RFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04gPSAxO1xyXG4gICAgICAgIC8vIEFueSBuZXR3b3JrIGNhbGxzIHdpbGwgc2V0IHRoaXMgdG8gdHJ1ZSBhbmQgcHJldmVudCBzdWJzZXF1ZW50IGVtdWxhdG9yXHJcbiAgICAgICAgLy8gaW5pdGlhbGl6YXRpb25cclxuICAgICAgICB0aGlzLl9jYW5Jbml0RW11bGF0b3IgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kZWxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2Vycm9yRmFjdG9yeSA9IF9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWTtcclxuICAgICAgICB0aGlzLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGVuYW50UmVjYXB0Y2hhQ29uZmlncyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3Byb2plY3RQYXNzd29yZFBvbGljeSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGVuYW50UGFzc3dvcmRQb2xpY2llcyA9IHt9O1xyXG4gICAgICAgIC8vIFRyYWNrcyB0aGUgbGFzdCBub3RpZmllZCBVSUQgZm9yIHN0YXRlIGNoYW5nZSBsaXN0ZW5lcnMgdG8gcHJldmVudFxyXG4gICAgICAgIC8vIHJlcGVhdGVkIGNhbGxzIHRvIHRoZSBjYWxsYmFja3MuIFVuZGVmaW5lZCBtZWFucyBpdCdzIG5ldmVyIGJlZW5cclxuICAgICAgICAvLyBjYWxsZWQsIHdoZXJlYXMgbnVsbCBtZWFucyBpdCdzIGJlZW4gY2FsbGVkIHdpdGggYSBzaWduZWQgb3V0IHVzZXJcclxuICAgICAgICB0aGlzLmxhc3ROb3RpZmllZFVpZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlQ29kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50ZW5hbnRJZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHsgYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nOiBmYWxzZSB9O1xyXG4gICAgICAgIHRoaXMuZnJhbWV3b3JrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IGFwcC5uYW1lO1xyXG4gICAgICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGNvbmZpZy5zZGtDbGllbnRWZXJzaW9uO1xyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemVXaXRoUGVyc2lzdGVuY2UocGVyc2lzdGVuY2VIaWVyYXJjaHksIHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xyXG4gICAgICAgIGlmIChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyID0gX2dldEluc3RhbmNlKHBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGFwcCBkZWxldGlvbiB0aHJvdWdob3V0IGluaXRpYWxpemF0aW9uIChhZnRlciBlYWNoXHJcbiAgICAgICAgLy8gcHJvbWlzZSByZXNvbHV0aW9uKVxyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZSA9IHRoaXMucXVldWUoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGVyc2lzdGVuY2VNYW5hZ2VyID0gYXdhaXQgUGVyc2lzdGVuY2VVc2VyTWFuYWdlci5jcmVhdGUodGhpcywgcGVyc2lzdGVuY2VIaWVyYXJjaHkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJlc29sdmVyIGVhcmx5IGlmIG5lY2Vzc2FyeSAob25seSBhcHBsaWNhYmxlIHRvIHdlYjpcclxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGNhdXNlIHRoZSBpZnJhbWUgdG8gbG9hZCBpbW1lZGlhdGVseSBpbiBjZXJ0YWluIGNhc2VzKVxyXG4gICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3Nob3VsZEluaXRQcm9hY3RpdmVseSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBmYWlscywgZG9uJ3QgaGFsdCBhdXRoIGxvYWRpbmdcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLl9pbml0aWFsaXplKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBJZ25vcmUgdGhlIGVycm9yICovXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplQ3VycmVudFVzZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Tm90aWZpZWRVaWQgPSAoKF9iID0gdGhpcy5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVpZCkgfHwgbnVsbDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgcGVyc2lzdGVuY2UgaXMgY2hhbmdlZCBpbiBhbm90aGVyIHdpbmRvdywgdGhlIHVzZXIgbWFuYWdlciB3aWxsIGxldCB1cyBrbm93XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIF9vblN0b3JhZ2VFdmVudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UuZ2V0Q3VycmVudFVzZXIoKTtcclxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudFVzZXIgJiYgIXVzZXIpIHtcclxuICAgICAgICAgICAgLy8gTm8gY2hhbmdlLCBkbyBub3RoaW5nICh3YXMgc2lnbmVkIG91dCBhbmQgcmVtYWluZWQgc2lnbmVkIG91dCkuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlIHNhbWUgdXNlciBpcyB0byBiZSBzeW5jaHJvbml6ZWQuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIgJiYgdXNlciAmJiB0aGlzLmN1cnJlbnRVc2VyLnVpZCA9PT0gdXNlci51aWQpIHtcclxuICAgICAgICAgICAgLy8gRGF0YSB1cGRhdGUsIHNpbXBseSBjb3B5IGRhdGEgY2hhbmdlcy5cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFVzZXIuX2Fzc2lnbih1c2VyKTtcclxuICAgICAgICAgICAgLy8gSWYgdG9rZW5zIGNoYW5nZWQgZnJvbSBwcmV2aW91cyB1c2VyIHRva2VucywgdGhpcyB3aWxsIHRyaWdnZXJcclxuICAgICAgICAgICAgLy8gbm90aWZ5QXV0aExpc3RlbmVyc18uXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3VycmVudFVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBjdXJyZW50IEF1dGggc3RhdGUuIEVpdGhlciBhIG5ldyBsb2dpbiBvciBsb2dvdXQuXHJcbiAgICAgICAgLy8gU2tpcCBibG9ja2luZyBjYWxsYmFja3MsIHRoZXkgc2hvdWxkIG5vdCBhcHBseSB0byBhIGNoYW5nZSBpbiBhbm90aGVyIHRhYi5cclxuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVDdXJyZW50VXNlcih1c2VyLCAvKiBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgKi8gdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBpbml0aWFsaXplQ3VycmVudFVzZXJGcm9tSWRUb2tlbihpZFRva2VuKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRBY2NvdW50SW5mbyh0aGlzLCB7IGlkVG9rZW4gfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VySW1wbC5fZnJvbUdldEFjY291bnRJbmZvUmVzcG9uc2UodGhpcywgcmVzcG9uc2UsIGlkVG9rZW4pO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGaXJlYmFzZVNlcnZlckFwcCBjb3VsZCBub3QgbG9naW4gdXNlciB3aXRoIHByb3ZpZGVkIGF1dGhJZFRva2VuOiAnLCBlcnIpO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgaW5pdGlhbGl6ZUN1cnJlbnRVc2VyKHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodGhpcy5hcHApKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkVG9rZW4gPSB0aGlzLmFwcC5zZXR0aW5ncy5hdXRoSWRUb2tlbjtcclxuICAgICAgICAgICAgaWYgKGlkVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBhdXRoIG9wZXJhdGlvbiBpbiB0aGUgbmV4dCB0aWNrIHRvIGFsbG93IGEgbW9tZW50IGZvciB0aGUgY3VzdG9tZXIncyBhcHAgdG9cclxuICAgICAgICAgICAgICAgIC8vIGF0dGFjaCBhbiBlbXVsYXRvciwgaWYgZGVzaXJlZC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaW5pdGlhbGl6ZUN1cnJlbnRVc2VyRnJvbUlkVG9rZW4oaWRUb2tlbikudGhlbihyZXNvbHZlLCByZXNvbHZlKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBwZW5kaW5nIHJlZGlyZWN0IGV2ZW50LlxyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzbHlTdG9yZWRVc2VyID0gKGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5nZXRDdXJyZW50VXNlcigpKTtcclxuICAgICAgICBsZXQgZnV0dXJlQ3VycmVudFVzZXIgPSBwcmV2aW91c2x5U3RvcmVkVXNlcjtcclxuICAgICAgICBsZXQgbmVlZHNUb2NoZWNrTWlkZGxld2FyZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIgJiYgdGhpcy5jb25maWcuYXV0aERvbWFpbikge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmdldE9ySW5pdFJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZGlyZWN0VXNlckV2ZW50SWQgPSAoX2EgPSB0aGlzLnJlZGlyZWN0VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9yZWRpcmVjdEV2ZW50SWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFVzZXJFdmVudElkID0gZnV0dXJlQ3VycmVudFVzZXIgPT09IG51bGwgfHwgZnV0dXJlQ3VycmVudFVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudHJ5UmVkaXJlY3RTaWduSW4ocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCB1c2VyIChpLmUuIHRoZSBvbGQgXCJjdXJyZW50VXNlclwiKSBoYXMgYSByZWRpcmVjdElkIHRoYXRcclxuICAgICAgICAgICAgLy8gbWF0Y2hlcyB0aGUgcmVkaXJlY3QgdXNlciwgdGhlbiB3ZSB3YW50IHRvIGluaXRpYWxseSBzaWduIGluIHdpdGggdGhlXHJcbiAgICAgICAgICAgIC8vIG5ldyB1c2VyIG9iamVjdCBmcm9tIHJlc3VsdC5cclxuICAgICAgICAgICAgLy8gVE9ETyhzYW1naG8pOiBNb3JlIHRob3JvdWdobHkgdGVzdCBhbGwgb2YgdGhpc1xyXG4gICAgICAgICAgICBpZiAoKCFyZWRpcmVjdFVzZXJFdmVudElkIHx8IHJlZGlyZWN0VXNlckV2ZW50SWQgPT09IHN0b3JlZFVzZXJFdmVudElkKSAmJlxyXG4gICAgICAgICAgICAgICAgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC51c2VyKSkge1xyXG4gICAgICAgICAgICAgICAgZnV0dXJlQ3VycmVudFVzZXIgPSByZXN1bHQudXNlcjtcclxuICAgICAgICAgICAgICAgIG5lZWRzVG9jaGVja01pZGRsZXdhcmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIG5vIHVzZXIgaW4gcGVyc2lzdGVuY2UsIHRoZXJlIGlzIG5vIGN1cnJlbnQgdXNlci4gU2V0IHRvIG51bGwuXHJcbiAgICAgICAgaWYgKCFmdXR1cmVDdXJyZW50VXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBpc24ndCBhIHJlZGlyZWN0IGxpbmsgb3BlcmF0aW9uLCB3ZSBjYW4gcmVsb2FkIGFuZCBiYWlsLlxyXG4gICAgICAgICAgICAvLyBGaXJzdCB0aG91Z2gsIGVuc3VyZSB0aGF0IHdlIGNoZWNrIHRoZSBtaWRkbGV3YXJlIGlzIGhhcHB5LlxyXG4gICAgICAgICAgICBpZiAobmVlZHNUb2NoZWNrTWlkZGxld2FyZSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZVN0YXRlUXVldWUucnVuTWlkZGxld2FyZShmdXR1cmVDdXJyZW50VXNlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1dHVyZUN1cnJlbnRVc2VyID0gcHJldmlvdXNseVN0b3JlZFVzZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Uga25vdyB0aGlzIGlzIGF2YWlsYWJsZSBzaW5jZSB0aGUgYml0IGlzIG9ubHkgc2V0IHdoZW4gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2ZXIgaXMgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLl9vdmVycmlkZVJlZGlyZWN0UmVzdWx0KHRoaXMsICgpID0+IFByb21pc2UucmVqZWN0KGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZnV0dXJlQ3VycmVudFVzZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbG9hZEFuZFNldEN1cnJlbnRVc2VyT3JDbGVhcihmdXR1cmVDdXJyZW50VXNlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9hc3NlcnQodGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLCB0aGlzLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5nZXRPckluaXRSZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcigpO1xyXG4gICAgICAgIC8vIElmIHRoZSByZWRpcmVjdCB1c2VyJ3MgZXZlbnQgSUQgbWF0Y2hlcyB0aGUgY3VycmVudCB1c2VyJ3MgZXZlbnQgSUQsXHJcbiAgICAgICAgLy8gRE8gTk9UIHJlbG9hZCB0aGUgY3VycmVudCB1c2VyLCBvdGhlcndpc2UgdGhleSdsbCBiZSBjbGVhcmVkIGZyb20gc3RvcmFnZS5cclxuICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgdGhlIHJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0KCkgZmxvdy5cclxuICAgICAgICBpZiAodGhpcy5yZWRpcmVjdFVzZXIgJiZcclxuICAgICAgICAgICAgdGhpcy5yZWRpcmVjdFVzZXIuX3JlZGlyZWN0RXZlbnRJZCA9PT0gZnV0dXJlQ3VycmVudFVzZXIuX3JlZGlyZWN0RXZlbnRJZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKGZ1dHVyZUN1cnJlbnRVc2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsb2FkQW5kU2V0Q3VycmVudFVzZXJPckNsZWFyKGZ1dHVyZUN1cnJlbnRVc2VyKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHRyeVJlZGlyZWN0U2lnbkluKHJlZGlyZWN0UmVzb2x2ZXIpIHtcclxuICAgICAgICAvLyBUaGUgcmVkaXJlY3QgdXNlciBuZWVkcyB0byBiZSBjaGVja2VkIChhbmQgc2lnbmVkIGluIGlmIGF2YWlsYWJsZSlcclxuICAgICAgICAvLyBkdXJpbmcgYXV0aCBpbml0aWFsaXphdGlvbi4gQWxsIG9mIHRoZSBub3JtYWwgc2lnbiBpbiBhbmQgbGluay9yZWF1dGhcclxuICAgICAgICAvLyBmbG93cyBjYWxsIGJhY2sgaW50byBhdXRoIGFuZCBwdXNoIHRoaW5ncyBvbnRvIHRoZSBwcm9taXNlIHF1ZXVlLiBXZVxyXG4gICAgICAgIC8vIG5lZWQgdG8gYXdhaXQgdGhlIHJlc3VsdCBvZiB0aGUgcmVkaXJlY3Qgc2lnbiBpbiAqaW5zaWRlIHRoZSBwcm9taXNlXHJcbiAgICAgICAgLy8gcXVldWUqLiBUaGlzIHByZXNlbnRzIGEgcHJvYmxlbTogd2UgcnVuIGludG8gZGVhZGxvY2suIFNlZTpcclxuICAgICAgICAvLyAgICDilIw+IFtJbml0aWFsaXphdGlvbl0g4pSA4pSA4pSA4pSA4pSA4pSQXHJcbiAgICAgICAgLy8gICAg4pSMPiBbPG90aGVyIHF1ZXVlIHRhc2tzPl0g4pSCXHJcbiAgICAgICAgLy8gICAg4pSU4pSAIFtnZXRSZWRpcmVjdFJlc3VsdF0gPOKUgOKUmFxyXG4gICAgICAgIC8vICAgIHdoZXJlIFtdIGFyZSB0YXNrcyBvbiB0aGUgcXVldWUgYW5kIGFycm93cyBkZW5vdGUgYXdhaXRzXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6YXRpb24gd2lsbCBuZXZlciBjb21wbGV0ZSBiZWNhdXNlIGl0J3Mgd2FpdGluZyBvbiBzb21ldGhpbmdcclxuICAgICAgICAvLyB0aGF0J3Mgd2FpdGluZyBmb3IgaW5pdGlhbGl6YXRpb24gdG8gY29tcGxldGUhXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBJbnN0ZWFkLCB0aGlzIG1ldGhvZCBjYWxscyBnZXRSZWRpcmVjdFJlc3VsdCgpIChzdG9yZWQgaW5cclxuICAgICAgICAvLyBfY29tcGxldGVSZWRpcmVjdEZuKSB3aXRoIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IGluc3RydWN0cyBhbGwgb2ZcclxuICAgICAgICAvLyB0aGUgdW5kZXJseWluZyBhdXRoIG9wZXJhdGlvbnMgdG8gc2tpcCBhbnl0aGluZyB0aGF0IG11dGF0ZXMgYXV0aCBzdGF0ZS5cclxuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBXZSBrbm93IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciBpcyBzZXQgc2luY2UgcmVkaXJlY3RSZXNvbHZlclxyXG4gICAgICAgICAgICAvLyBpcyBwYXNzZWQgaW4uIFRoZSBfY29tcGxldGVSZWRpcmVjdEZuIGV4cGVjdHMgdGhlIHVud3JhcHBlZCBleHRlcm4uXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlci5fY29tcGxldGVSZWRpcmVjdEZuKHRoaXMsIHJlZGlyZWN0UmVzb2x2ZXIsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBTd2FsbG93IGFueSBlcnJvcnMgaGVyZTsgdGhlIGNvZGUgY2FuIHJldHJpZXZlIHRoZW0gaW5cclxuICAgICAgICAgICAgLy8gZ2V0UmVkaXJlY3RSZXN1bHQoKS5cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0UmVkaXJlY3RVc2VyKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcmVsb2FkQW5kU2V0Q3VycmVudFVzZXJPckNsZWFyKHVzZXIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuY29kZSkgIT09XHJcbiAgICAgICAgICAgICAgICBgYXV0aC8ke1wibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqL31gKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcncyB3cm9uZyB3aXRoIHRoZSB1c2VyJ3MgdG9rZW4uIExvZyB0aGVtIG91dCBhbmQgcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVtIGZyb20gc3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKHVzZXIpO1xyXG4gICAgfVxyXG4gICAgdXNlRGV2aWNlTGFuZ3VhZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNvZGUgPSBfZ2V0VXNlckxhbmd1YWdlKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfZGVsZXRlKCkge1xyXG4gICAgICAgIHRoaXMuX2RlbGV0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgdXBkYXRlQ3VycmVudFVzZXIodXNlckV4dGVybikge1xyXG4gICAgICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcCh0aGlzLmFwcCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlIHB1YmxpYyB1cGRhdGVDdXJyZW50VXNlciBtZXRob2QgbmVlZHMgdG8gbWFrZSBhIGNvcHkgb2YgdGhlIHVzZXIsXHJcbiAgICAgICAgLy8gYW5kIGFsc28gY2hlY2sgdGhhdCB0aGUgcHJvamVjdCBtYXRjaGVzXHJcbiAgICAgICAgY29uc3QgdXNlciA9IHVzZXJFeHRlcm5cclxuICAgICAgICAgICAgPyBnZXRNb2R1bGFySW5zdGFuY2UodXNlckV4dGVybilcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGlmICh1c2VyKSB7XHJcbiAgICAgICAgICAgIF9hc3NlcnQodXNlci5hdXRoLmNvbmZpZy5hcGlLZXkgPT09IHRoaXMuY29uZmlnLmFwaUtleSwgdGhpcywgXCJpbnZhbGlkLXVzZXItdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVVUSCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVDdXJyZW50VXNlcih1c2VyICYmIHVzZXIuX2Nsb25lKHRoaXMpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIF91cGRhdGVDdXJyZW50VXNlcih1c2VyLCBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZXIpIHtcclxuICAgICAgICAgICAgX2Fzc2VydCh0aGlzLnRlbmFudElkID09PSB1c2VyLnRlbmFudElkLCB0aGlzLCBcInRlbmFudC1pZC1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuVEVOQU5UX0lEX01JU01BVENIICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnJ1bk1pZGRsZXdhcmUodXNlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKHVzZXIpO1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUF1dGhMaXN0ZW5lcnMoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNpZ25PdXQoKSB7XHJcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSdW4gZmlyc3QsIHRvIGJsb2NrIF9zZXRSZWRpcmVjdFVzZXIoKSBpZiBhbnkgY2FsbGJhY2tzIGZhaWwuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnJ1bk1pZGRsZXdhcmUobnVsbCk7XHJcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHJlZGlyZWN0IHVzZXIgd2hlbiBzaWduT3V0IGlzIGNhbGxlZFxyXG4gICAgICAgIGlmICh0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyIHx8IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXRSZWRpcmVjdFVzZXIobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByZXZlbnQgY2FsbGJhY2tzIGZyb20gYmVpbmcgY2FsbGVkIGFnYWluIGluIF91cGRhdGVDdXJyZW50VXNlciwgYXNcclxuICAgICAgICAvLyB0aGV5IHdlcmUgYWxyZWFkeSBjYWxsZWQgaW4gdGhlIGZpcnN0IGxpbmUuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUN1cnJlbnRVc2VyKG51bGwsIC8qIHNraXBCZWZvcmVTdGF0ZUNhbGxiYWNrcyAqLyB0cnVlKTtcclxuICAgIH1cclxuICAgIHNldFBlcnNpc3RlbmNlKHBlcnNpc3RlbmNlKSB7XHJcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5zZXRQZXJzaXN0ZW5jZShfZ2V0SW5zdGFuY2UocGVyc2lzdGVuY2UpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9nZXRSZWNhcHRjaGFDb25maWcoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGVuYW50SWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWdlbnRSZWNhcHRjaGFDb25maWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1t0aGlzLnRlbmFudElkXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyB2YWxpZGF0ZVBhc3N3b3JkKHBhc3N3b3JkKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9nZXRQYXNzd29yZFBvbGljeUludGVybmFsKCkpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlUGFzc3dvcmRQb2xpY3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUGFzc3dvcmQgcG9saWN5IHdpbGwgYmUgZGVmaW5lZCBhZnRlciBmZXRjaGluZy5cclxuICAgICAgICBjb25zdCBwYXNzd29yZFBvbGljeSA9IHRoaXMuX2dldFBhc3N3b3JkUG9saWN5SW50ZXJuYWwoKTtcclxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBwb2xpY3kgc2NoZW1hIHZlcnNpb24gaXMgc3VwcG9ydGVkIGJ5IHRoZSBTREsuXHJcbiAgICAgICAgLy8gVE9ETzogVXBkYXRlIHRoaXMgbG9naWMgdG8gdXNlIGEgbWF4IHN1cHBvcnRlZCBwb2xpY3kgc2NoZW1hIHZlcnNpb24gb25jZSB3ZSBoYXZlIG11bHRpcGxlIHNjaGVtYSB2ZXJzaW9ucy5cclxuICAgICAgICBpZiAocGFzc3dvcmRQb2xpY3kuc2NoZW1hVmVyc2lvbiAhPT1cclxuICAgICAgICAgICAgdGhpcy5FWFBFQ1RFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuX2Vycm9yRmFjdG9yeS5jcmVhdGUoXCJ1bnN1cHBvcnRlZC1wYXNzd29yZC1wb2xpY3ktc2NoZW1hLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX1BBU1NXT1JEX1BPTElDWV9TQ0hFTUFfVkVSU0lPTiAqLywge30pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhc3N3b3JkUG9saWN5LnZhbGlkYXRlUGFzc3dvcmQocGFzc3dvcmQpO1xyXG4gICAgfVxyXG4gICAgX2dldFBhc3N3b3JkUG9saWN5SW50ZXJuYWwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGVuYW50SWQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3RQYXNzd29yZFBvbGljeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZW5hbnRQYXNzd29yZFBvbGljaWVzW3RoaXMudGVuYW50SWRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIF91cGRhdGVQYXNzd29yZFBvbGljeSgpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9nZXRQYXNzd29yZFBvbGljeSh0aGlzKTtcclxuICAgICAgICBjb25zdCBwYXNzd29yZFBvbGljeSA9IG5ldyBQYXNzd29yZFBvbGljeUltcGwocmVzcG9uc2UpO1xyXG4gICAgICAgIGlmICh0aGlzLnRlbmFudElkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2plY3RQYXNzd29yZFBvbGljeSA9IHBhc3N3b3JkUG9saWN5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdGVuYW50UGFzc3dvcmRQb2xpY2llc1t0aGlzLnRlbmFudElkXSA9IHBhc3N3b3JkUG9saWN5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRQZXJzaXN0ZW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hc3NlcnRlZFBlcnNpc3RlbmNlLnBlcnNpc3RlbmNlLnR5cGU7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRXJyb3JNYXAoZXJyb3JNYXApIHtcclxuICAgICAgICB0aGlzLl9lcnJvckZhY3RvcnkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhdXRoJywgJ0ZpcmViYXNlJywgZXJyb3JNYXAoKSk7XHJcbiAgICB9XHJcbiAgICBvbkF1dGhTdGF0ZUNoYW5nZWQobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclN0YXRlTGlzdGVuZXIodGhpcy5hdXRoU3RhdGVTdWJzY3JpcHRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcclxuICAgIH1cclxuICAgIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoY2FsbGJhY2ssIG9uQWJvcnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnB1c2hDYWxsYmFjayhjYWxsYmFjaywgb25BYm9ydCk7XHJcbiAgICB9XHJcbiAgICBvbklkVG9rZW5DaGFuZ2VkKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJTdGF0ZUxpc3RlbmVyKHRoaXMuaWRUb2tlblN1YnNjcmlwdGlvbiwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xyXG4gICAgfVxyXG4gICAgYXV0aFN0YXRlUmVhZHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5vbkF1dGhTdGF0ZUNoYW5nZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXZva2VzIHRoZSBnaXZlbiBhY2Nlc3MgdG9rZW4uIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIEFwcGxlIE9BdXRoIGFjY2VzcyB0b2tlbnMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJldm9rZUFjY2Vzc1Rva2VuKHRva2VuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHRoaXMuY3VycmVudFVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgICAgICAgICAvLyBHZW5lcmFsaXplIHRoaXMgdG8gYWNjZXB0IG90aGVyIHByb3ZpZGVycyBvbmNlIHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIHByb3ZpZGVySWQ6ICdhcHBsZS5jb20nLFxyXG4gICAgICAgICAgICAgICAgdG9rZW5UeXBlOiBcIkFDQ0VTU19UT0tFTlwiIC8qIFRva2VuVHlwZS5BQ0NFU1NfVE9LRU4gKi8sXHJcbiAgICAgICAgICAgICAgICB0b2tlbixcclxuICAgICAgICAgICAgICAgIGlkVG9rZW5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGVuYW50SWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC50ZW5hbnRJZCA9IHRoaXMudGVuYW50SWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgcmV2b2tlVG9rZW4odGhpcywgcmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuY29uZmlnLmFwaUtleSxcclxuICAgICAgICAgICAgYXV0aERvbWFpbjogdGhpcy5jb25maWcuYXV0aERvbWFpbixcclxuICAgICAgICAgICAgYXBwTmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBjdXJyZW50VXNlcjogKF9hID0gdGhpcy5fY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0pTT04oKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBfc2V0UmVkaXJlY3RVc2VyKHVzZXIsIHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xyXG4gICAgICAgIGNvbnN0IHJlZGlyZWN0TWFuYWdlciA9IGF3YWl0IHRoaXMuZ2V0T3JJbml0UmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcclxuICAgICAgICByZXR1cm4gdXNlciA9PT0gbnVsbFxyXG4gICAgICAgICAgICA/IHJlZGlyZWN0TWFuYWdlci5yZW1vdmVDdXJyZW50VXNlcigpXHJcbiAgICAgICAgICAgIDogcmVkaXJlY3RNYW5hZ2VyLnNldEN1cnJlbnRVc2VyKHVzZXIpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0T3JJbml0UmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gKHBvcHVwUmVkaXJlY3RSZXNvbHZlciAmJiBfZ2V0SW5zdGFuY2UocG9wdXBSZWRpcmVjdFJlc29sdmVyKSkgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlcjtcclxuICAgICAgICAgICAgX2Fzc2VydChyZXNvbHZlciwgdGhpcywgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgICAgICAgICB0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyID0gYXdhaXQgUGVyc2lzdGVuY2VVc2VyTWFuYWdlci5jcmVhdGUodGhpcywgW19nZXRJbnN0YW5jZShyZXNvbHZlci5fcmVkaXJlY3RQZXJzaXN0ZW5jZSldLCBcInJlZGlyZWN0VXNlclwiIC8qIEtleU5hbWUuUkVESVJFQ1RfVVNFUiAqLyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVkaXJlY3RVc2VyID1cclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIuZ2V0Q3VycmVudFVzZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfcmVkaXJlY3RVc2VyRm9ySWQoaWQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBjbGVhcmVkIGFueSBwZW5kaW5nIHBlcnNpc3RlbmNlIGFjdGlvbnMgaWYgd2UncmUgbm90IGluXHJcbiAgICAgICAgLy8gdGhlIGluaXRpYWxpemVyXHJcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2N1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3JlZGlyZWN0RXZlbnRJZCkgPT09IGlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VXNlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCgoX2IgPSB0aGlzLnJlZGlyZWN0VXNlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLl9yZWRpcmVjdEV2ZW50SWQpID09PSBpZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWRpcmVjdFVzZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX3BlcnNpc3RVc2VySWZDdXJyZW50KHVzZXIpIHtcclxuICAgICAgICBpZiAodXNlciA9PT0gdGhpcy5jdXJyZW50VXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBOb3RpZmllcyBsaXN0ZW5lcnMgb25seSBpZiB0aGUgdXNlciBpcyBjdXJyZW50ICovXHJcbiAgICBfbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHVzZXIpIHtcclxuICAgICAgICBpZiAodXNlciA9PT0gdGhpcy5jdXJyZW50VXNlcikge1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUF1dGhMaXN0ZW5lcnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfa2V5KCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbmZpZy5hdXRoRG9tYWlufToke3RoaXMuY29uZmlnLmFwaUtleX06JHt0aGlzLm5hbWV9YDtcclxuICAgIH1cclxuICAgIF9zdGFydFByb2FjdGl2ZVJlZnJlc2goKSB7XHJcbiAgICAgICAgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXNlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VXNlci5fc3RhcnRQcm9hY3RpdmVSZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCkge1xyXG4gICAgICAgIHRoaXMuaXNQcm9hY3RpdmVSZWZyZXNoRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRVc2VyLl9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRoZSBjdXJyZW50IHVzZXIgY2FzdCBhcyB0aGUgaW50ZXJuYWwgdHlwZSAqL1xyXG4gICAgZ2V0IF9jdXJyZW50VXNlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VXNlcjtcclxuICAgIH1cclxuICAgIG5vdGlmeUF1dGhMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlkVG9rZW5TdWJzY3JpcHRpb24ubmV4dCh0aGlzLmN1cnJlbnRVc2VyKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50VWlkID0gKF9iID0gKF9hID0gdGhpcy5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5sYXN0Tm90aWZpZWRVaWQgIT09IGN1cnJlbnRVaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Tm90aWZpZWRVaWQgPSBjdXJyZW50VWlkO1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhTdGF0ZVN1YnNjcmlwdGlvbi5uZXh0KHRoaXMuY3VycmVudFVzZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZ2lzdGVyU3RhdGVMaXN0ZW5lcihzdWJzY3JpcHRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2IgPSB0eXBlb2YgbmV4dE9yT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgPyBuZXh0T3JPYnNlcnZlclxyXG4gICAgICAgICAgICA6IG5leHRPck9ic2VydmVyLm5leHQuYmluZChuZXh0T3JPYnNlcnZlcik7XHJcbiAgICAgICAgbGV0IGlzVW5zdWJzY3JpYmVkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX2lzSW5pdGlhbGl6ZWRcclxuICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoKVxyXG4gICAgICAgICAgICA6IHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZTtcclxuICAgICAgICBfYXNzZXJ0KHByb21pc2UsIHRoaXMsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICAvLyBUaGUgY2FsbGJhY2sgbmVlZHMgdG8gYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IHBlciB0aGUgc3BlYy5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVW5zdWJzY3JpYmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2IodGhpcy5jdXJyZW50VXNlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXh0T3JPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmlwdGlvbi5hZGRPYnNlcnZlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpc1Vuc3Vic2NyaWJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdWJzY3JpcHRpb24uYWRkT2JzZXJ2ZXIobmV4dE9yT2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaXNVbnN1YnNjcmliZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVucHJvdGVjdGVkIChmcm9tIHJhY2UgY29uZGl0aW9ucykgbWV0aG9kIHRvIHNldCB0aGUgY3VycmVudCB1c2VyLiBUaGlzXHJcbiAgICAgKiBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBxdWV1ZWQgY2FsbGJhY2suIFRoaXMgaXMgbmVjZXNzYXJ5XHJcbiAgICAgKiBiZWNhdXNlIHRoZSBxdWV1ZSBzaG91bGRuJ3QgcmVseSBvbiBhbm90aGVyIHF1ZXVlZCBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZGlyZWN0bHlTZXRDdXJyZW50VXNlcih1c2VyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIgJiYgdGhpcy5jdXJyZW50VXNlciAhPT0gdXNlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VXNlci5fc3RvcFByb2FjdGl2ZVJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZXIgJiYgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHVzZXIuX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gdXNlcjtcclxuICAgICAgICBpZiAodXNlcikge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2Uuc2V0Q3VycmVudFVzZXIodXNlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UucmVtb3ZlQ3VycmVudFVzZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBxdWV1ZShhY3Rpb24pIHtcclxuICAgICAgICAvLyBJbiBjYXNlIHNvbWV0aGluZyBlcnJvcnMsIHRoZSBjYWxsYmFjayBzdGlsbCBzaG91bGQgYmUgY2FsbGVkIGluIG9yZGVyXHJcbiAgICAgICAgLy8gdG8ga2VlcCB0aGUgcHJvbWlzZSBjaGFpbiBhbGl2ZVxyXG4gICAgICAgIHRoaXMub3BlcmF0aW9ucyA9IHRoaXMub3BlcmF0aW9ucy50aGVuKGFjdGlvbiwgYWN0aW9uKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zO1xyXG4gICAgfVxyXG4gICAgZ2V0IGFzc2VydGVkUGVyc2lzdGVuY2UoKSB7XHJcbiAgICAgICAgX2Fzc2VydCh0aGlzLnBlcnNpc3RlbmNlTWFuYWdlciwgdGhpcywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlTWFuYWdlcjtcclxuICAgIH1cclxuICAgIF9sb2dGcmFtZXdvcmsoZnJhbWV3b3JrKSB7XHJcbiAgICAgICAgaWYgKCFmcmFtZXdvcmsgfHwgdGhpcy5mcmFtZXdvcmtzLmluY2x1ZGVzKGZyYW1ld29yaykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZyYW1ld29ya3MucHVzaChmcmFtZXdvcmspO1xyXG4gICAgICAgIC8vIFNvcnQgYWxwaGFiZXRpY2FsbHkgc28gdGhhdCBcIkZpcmViYXNlQ29yZS13ZWIsRmlyZWJhc2VVSS13ZWJcIiBhbmRcclxuICAgICAgICAvLyBcIkZpcmViYXNlVUktd2ViLEZpcmViYXNlQ29yZS13ZWJcIiBhcmVuJ3Qgdmlld2VkIGFzIGRpZmZlcmVudC5cclxuICAgICAgICB0aGlzLmZyYW1ld29ya3Muc29ydCgpO1xyXG4gICAgICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IF9nZXRDbGllbnRWZXJzaW9uKHRoaXMuY29uZmlnLmNsaWVudFBsYXRmb3JtLCB0aGlzLl9nZXRGcmFtZXdvcmtzKCkpO1xyXG4gICAgfVxyXG4gICAgX2dldEZyYW1ld29ya3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWV3b3JrcztcclxuICAgIH1cclxuICAgIGFzeW5jIF9nZXRBZGRpdGlvbmFsSGVhZGVycygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgLy8gQWRkaXRpb25hbCBoZWFkZXJzIG9uIGV2ZXJ5IHJlcXVlc3RcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xyXG4gICAgICAgICAgICBbXCJYLUNsaWVudC1WZXJzaW9uXCIgLyogSHR0cEhlYWRlci5YX0NMSUVOVF9WRVJTSU9OICovXTogdGhpcy5jbGllbnRWZXJzaW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5hcHAub3B0aW9ucy5hcHBJZCkge1xyXG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1nbXBpZFwiIC8qIEh0dHBIZWFkZXIuWF9GSVJFQkFTRV9HTVBJRCAqL10gPSB0aGlzLmFwcC5vcHRpb25zLmFwcElkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgaGVhcnRiZWF0IHNlcnZpY2UgZXhpc3RzLCBhZGQgdGhlIGhlYXJ0YmVhdCBzdHJpbmdcclxuICAgICAgICBjb25zdCBoZWFydGJlYXRzSGVhZGVyID0gYXdhaXQgKChfYSA9IHRoaXMuaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyXHJcbiAgICAgICAgICAgIC5nZXRJbW1lZGlhdGUoe1xyXG4gICAgICAgICAgICBvcHRpb25hbDogdHJ1ZVxyXG4gICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0SGVhcnRiZWF0c0hlYWRlcigpKTtcclxuICAgICAgICBpZiAoaGVhcnRiZWF0c0hlYWRlcikge1xyXG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1DbGllbnRcIiAvKiBIdHRwSGVhZGVyLlhfRklSRUJBU0VfQ0xJRU5UICovXSA9IGhlYXJ0YmVhdHNIZWFkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZSBBcHAgQ2hlY2sgc2VydmljZSBleGlzdHMsIGFkZCB0aGUgQXBwIENoZWNrIHRva2VuIGluIHRoZSBoZWFkZXJzXHJcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tUb2tlbiA9IGF3YWl0IHRoaXMuX2dldEFwcENoZWNrVG9rZW4oKTtcclxuICAgICAgICBpZiAoYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1BcHBDaGVja1wiIC8qIEh0dHBIZWFkZXIuWF9GSVJFQkFTRV9BUFBfQ0hFQ0sgKi9dID0gYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfZ2V0QXBwQ2hlY2tUb2tlbigpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tUb2tlblJlc3VsdCA9IGF3YWl0ICgoX2EgPSB0aGlzLmFwcENoZWNrU2VydmljZVByb3ZpZGVyXHJcbiAgICAgICAgICAgIC5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRva2VuKCkpO1xyXG4gICAgICAgIGlmIChhcHBDaGVja1Rva2VuUmVzdWx0ID09PSBudWxsIHx8IGFwcENoZWNrVG9rZW5SZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcENoZWNrVG9rZW5SZXN1bHQuZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gQ29udGV4dDogYXBwQ2hlY2suZ2V0VG9rZW4oKSB3aWxsIG5ldmVyIHRocm93IGV2ZW4gaWYgYW4gZXJyb3IgaGFwcGVuZWQuXHJcbiAgICAgICAgICAgIC8vIEluIHRoZSBlcnJvciBjYXNlLCBhIGR1bW15IHRva2VuIHdpbGwgYmUgcmV0dXJuZWQgYWxvbmcgd2l0aCBhbiBlcnJvciBmaWVsZCBkZXNjcmliaW5nXHJcbiAgICAgICAgICAgIC8vIHRoZSBlcnJvci4gSW4gZ2VuZXJhbCwgd2Ugc2hvdWxkbid0IGNhcmUgYWJvdXQgdGhlIGVycm9yIGNvbmRpdGlvbiBhbmQganVzdCB1c2VcclxuICAgICAgICAgICAgLy8gdGhlIHRva2VuIChhY3R1YWwgb3IgZHVtbXkpIHRvIHNlbmQgcmVxdWVzdHMuXHJcbiAgICAgICAgICAgIF9sb2dXYXJuKGBFcnJvciB3aGlsZSByZXRyaWV2aW5nIEFwcCBDaGVjayB0b2tlbjogJHthcHBDaGVja1Rva2VuUmVzdWx0LmVycm9yfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXBwQ2hlY2tUb2tlblJlc3VsdCA9PT0gbnVsbCB8fCBhcHBDaGVja1Rva2VuUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBDaGVja1Rva2VuUmVzdWx0LnRva2VuO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBNZXRob2QgdG8gYmUgdXNlZCB0byBjYXN0IGRvd24gdG8gb3VyIHByaXZhdGUgaW1wbG1lbnRhdGlvbiBvZiBBdXRoLlxyXG4gKiBJdCB3aWxsIGFsc28gaGFuZGxlIHVud3JhcHBpbmcgZnJvbSB0aGUgY29tcGF0IHR5cGUgaWYgbmVjZXNzYXJ5XHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIEF1dGggb2JqZWN0IHBhc3NlZCBpbiBmcm9tIGRldmVsb3BlclxyXG4gKi9cclxuZnVuY3Rpb24gX2Nhc3RBdXRoKGF1dGgpIHtcclxuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCk7XHJcbn1cclxuLyoqIEhlbHBlciBjbGFzcyB0byB3cmFwIHN1YnNjcmliZXIgbG9naWMgKi9cclxuY2xhc3MgU3Vic2NyaXB0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGgpIHtcclxuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYWRkT2JzZXJ2ZXIgPSBjcmVhdGVTdWJzY3JpYmUob2JzZXJ2ZXIgPT4gKHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcikpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG5leHQoKSB7XHJcbiAgICAgICAgX2Fzc2VydCh0aGlzLm9ic2VydmVyLCB0aGlzLmF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZlci5uZXh0LmJpbmQodGhpcy5vYnNlcnZlcik7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IGV4dGVybmFsSlNQcm92aWRlciA9IHtcclxuICAgIGFzeW5jIGxvYWRKUygpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2FkIGV4dGVybmFsIHNjcmlwdHMnKTtcclxuICAgIH0sXHJcbiAgICByZWNhcHRjaGFWMlNjcmlwdDogJycsXHJcbiAgICByZWNhcHRjaGFFbnRlcnByaXNlU2NyaXB0OiAnJyxcclxuICAgIGdhcGlTY3JpcHQ6ICcnXHJcbn07XHJcbmZ1bmN0aW9uIF9sb2FkSlModXJsKSB7XHJcbiAgICByZXR1cm4gZXh0ZXJuYWxKU1Byb3ZpZGVyLmxvYWRKUyh1cmwpO1xyXG59XHJcbmZ1bmN0aW9uIF9yZWNhcHRjaGFFbnRlcnByaXNlU2NyaXB0VXJsKCkge1xyXG4gICAgcmV0dXJuIGV4dGVybmFsSlNQcm92aWRlci5yZWNhcHRjaGFFbnRlcnByaXNlU2NyaXB0O1xyXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cclxuY29uc3QgUkVDQVBUQ0hBX0VOVEVSUFJJU0VfVkVSSUZJRVJfVFlQRSA9ICdyZWNhcHRjaGEtZW50ZXJwcmlzZSc7XHJcbmNvbnN0IEZBS0VfVE9LRU4gPSAnTk9fUkVDQVBUQ0hBJztcclxuY2xhc3MgUmVjYXB0Y2hhRW50ZXJwcmlzZVZlcmlmaWVyIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdXRoRXh0ZXJuIC0gVGhlIGNvcnJlc3BvbmRpbmcgRmlyZWJhc2Uge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYXV0aEV4dGVybikge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElkZW50aWZpZXMgdGhlIHR5cGUgb2YgYXBwbGljYXRpb24gdmVyaWZpZXIgKGUuZy4gXCJyZWNhcHRjaGEtZW50ZXJwcmlzZVwiKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBSRUNBUFRDSEFfRU5URVJQUklTRV9WRVJJRklFUl9UWVBFO1xyXG4gICAgICAgIHRoaXMuYXV0aCA9IF9jYXN0QXV0aChhdXRoRXh0ZXJuKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXhlY3V0ZXMgdGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSBmb3IgYSB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgdmFsaWRpdHkgb2YgYSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBhc3luYyB2ZXJpZnkoYWN0aW9uID0gJ3ZlcmlmeScsIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XHJcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcmV0cmlldmVTaXRlS2V5KGF1dGgpIHtcclxuICAgICAgICAgICAgaWYgKCFmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhdXRoLnRlbmFudElkID09IG51bGwgJiYgYXV0aC5fYWdlbnRSZWNhcHRjaGFDb25maWcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZy5zaXRlS2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGF1dGgudGVuYW50SWQgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGF1dGguX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3NbYXV0aC50ZW5hbnRJZF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRoLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW2F1dGgudGVuYW50SWRdLnNpdGVLZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGdldFJlY2FwdGNoYUNvbmZpZyhhdXRoLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqLyxcclxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBcIlJFQ0FQVENIQV9FTlRFUlBSSVNFXCIgLyogUmVjYXB0Y2hhVmVyc2lvbi5FTlRFUlBSSVNFICovXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UucmVjYXB0Y2hhS2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigncmVjYXB0Y2hhIEVudGVycHJpc2Ugc2l0ZSBrZXkgdW5kZWZpbmVkJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0gbmV3IFJlY2FwdGNoYUNvbmZpZyhyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdXRoLnRlbmFudElkID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGguX2FnZW50UmVjYXB0Y2hhQ29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aC5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1thdXRoLnRlbmFudElkXSA9IGNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjb25maWcuc2l0ZUtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJldHJpZXZlUmVjYXB0Y2hhVG9rZW4oc2l0ZUtleSwgcmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdyZWNhcHRjaGEgPSB3aW5kb3cuZ3JlY2FwdGNoYTtcclxuICAgICAgICAgICAgaWYgKGlzRW50ZXJwcmlzZShncmVjYXB0Y2hhKSkge1xyXG4gICAgICAgICAgICAgICAgZ3JlY2FwdGNoYS5lbnRlcnByaXNlLnJlYWR5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBncmVjYXB0Y2hhLmVudGVycHJpc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmV4ZWN1dGUoc2l0ZUtleSwgeyBhY3Rpb24gfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW4gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKEZBS0VfVE9LRU4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoRXJyb3IoJ05vIHJlQ0FQVENIQSBlbnRlcnByaXNlIHNjcmlwdCBsb2FkZWQuJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHJpZXZlU2l0ZUtleSh0aGlzLmF1dGgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihzaXRlS2V5ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmIGlzRW50ZXJwcmlzZSh3aW5kb3cuZ3JlY2FwdGNoYSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRyaWV2ZVJlY2FwdGNoYVRva2VuKHNpdGVLZXksIHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignUmVjYXB0Y2hhVmVyaWZpZXIgaXMgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gX3JlY2FwdGNoYUVudGVycHJpc2VTY3JpcHRVcmwoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodXJsLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gc2l0ZUtleTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2xvYWRKUyh1cmwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlldmVSZWNhcHRjaGFUb2tlbihzaXRlS2V5LCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaW5qZWN0UmVjYXB0Y2hhRmllbGRzKGF1dGgsIHJlcXVlc3QsIGFjdGlvbiwgY2FwdGNoYVJlc3AgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgdmVyaWZpZXIgPSBuZXcgUmVjYXB0Y2hhRW50ZXJwcmlzZVZlcmlmaWVyKGF1dGgpO1xyXG4gICAgbGV0IGNhcHRjaGFSZXNwb25zZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY2FwdGNoYVJlc3BvbnNlID0gYXdhaXQgdmVyaWZpZXIudmVyaWZ5KGFjdGlvbik7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjYXB0Y2hhUmVzcG9uc2UgPSBhd2FpdCB2ZXJpZmllci52ZXJpZnkoYWN0aW9uLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld1JlcXVlc3QgPSBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KTtcclxuICAgIGlmICghY2FwdGNoYVJlc3ApIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHsgY2FwdGNoYVJlc3BvbnNlIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdSZXF1ZXN0LCB7ICdjYXB0Y2hhUmVzcCc6IGNhcHRjaGFSZXNwb25zZSB9KTtcclxuICAgIH1cclxuICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwgeyAnY2xpZW50VHlwZSc6IFwiQ0xJRU5UX1RZUEVfV0VCXCIgLyogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIgKi8gfSk7XHJcbiAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHtcclxuICAgICAgICAncmVjYXB0Y2hhVmVyc2lvbic6IFwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VcIiAvKiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0UgKi9cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ld1JlcXVlc3Q7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVjYXB0Y2hhRmxvdyhhdXRoSW5zdGFuY2UsIHJlcXVlc3QsIGFjdGlvbk5hbWUsIGFjdGlvbk1ldGhvZCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgaWYgKChfYSA9IGF1dGhJbnN0YW5jZVxyXG4gICAgICAgIC5fZ2V0UmVjYXB0Y2hhQ29uZmlnKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1Byb3ZpZGVyRW5hYmxlZChcIkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGEgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoYXV0aEluc3RhbmNlLCByZXF1ZXN0LCBhY3Rpb25OYW1lLCBhY3Rpb25OYW1lID09PSBcImdldE9vYkNvZGVcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLkdFVF9PT0JfQ09ERSAqLyk7XHJcbiAgICAgICAgcmV0dXJuIGFjdGlvbk1ldGhvZChhdXRoSW5zdGFuY2UsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0KS5jYXRjaChhc3luYyAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGBhdXRoLyR7XCJtaXNzaW5nLXJlY2FwdGNoYS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4gKi99YCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCR7YWN0aW9uTmFtZX0gaXMgcHJvdGVjdGVkIGJ5IHJlQ0FQVENIQSBFbnRlcnByaXNlIGZvciB0aGlzIHByb2plY3QuIEF1dG9tYXRpY2FsbHkgdHJpZ2dlcmluZyB0aGUgcmVDQVBUQ0hBIGZsb3cgYW5kIHJlc3RhcnRpbmcgdGhlIGZsb3cuYCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYSA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoSW5zdGFuY2UsIHJlcXVlc3QsIGFjdGlvbk5hbWUsIGFjdGlvbk5hbWUgPT09IFwiZ2V0T29iQ29kZVwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuR0VUX09PQl9DT0RFICovKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0V2l0aFJlY2FwdGNoYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gX2luaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCkge1xyXG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRSZWNhcHRjaGFDb25maWcoYXV0aEludGVybmFsLCB7XHJcbiAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqLyxcclxuICAgICAgICB2ZXJzaW9uOiBcIlJFQ0FQVENIQV9FTlRFUlBSSVNFXCIgLyogUmVjYXB0Y2hhVmVyc2lvbi5FTlRFUlBSSVNFICovXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBSZWNhcHRjaGFDb25maWcocmVzcG9uc2UpO1xyXG4gICAgaWYgKGF1dGhJbnRlcm5hbC50ZW5hbnRJZCA9PSBudWxsKSB7XHJcbiAgICAgICAgYXV0aEludGVybmFsLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IGNvbmZpZztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGF1dGhJbnRlcm5hbC5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1thdXRoSW50ZXJuYWwudGVuYW50SWRdID0gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbmZpZy5pc1Byb3ZpZGVyRW5hYmxlZChcIkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pKSB7XHJcbiAgICAgICAgY29uc3QgdmVyaWZpZXIgPSBuZXcgUmVjYXB0Y2hhRW50ZXJwcmlzZVZlcmlmaWVyKGF1dGhJbnRlcm5hbCk7XHJcbiAgICAgICAgdm9pZCB2ZXJpZmllci52ZXJpZnkoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlIHdpdGggZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlclxyXG4gKiB7QGxpbmsgRGVwZW5kZW5jaWVzfS5cclxuICpcclxuICogQHJlbWFya3NcclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgbW9yZSBjb250cm9sIG92ZXIgdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSB0aGFuXHJcbiAqIHtAbGluayBnZXRBdXRofS4gYGdldEF1dGhgIHVzZXMgcGxhdGZvcm0tc3BlY2lmaWMgZGVmYXVsdHMgdG8gc3VwcGx5XHJcbiAqIHRoZSB7QGxpbmsgRGVwZW5kZW5jaWVzfS4gSW4gZ2VuZXJhbCwgYGdldEF1dGhgIGlzIHRoZSBlYXNpZXN0IHdheSB0b1xyXG4gKiBpbml0aWFsaXplIEF1dGggYW5kIHdvcmtzIGZvciBtb3N0IHVzZSBjYXNlcy4gVXNlIGBpbml0aWFsaXplQXV0aGAgaWYgeW91XHJcbiAqIG5lZWQgY29udHJvbCBvdmVyIHdoaWNoIHBlcnNpc3RlbmNlIGxheWVyIGlzIHVzZWQsIG9yIHRvIG1pbmltaXplIGJ1bmRsZVxyXG4gKiBzaXplIGlmIHlvdSdyZSBub3QgdXNpbmcgZWl0aGVyIGBzaWduSW5XaXRoUG9wdXBgIG9yIGBzaWduSW5XaXRoUmVkaXJlY3RgLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91ciBhcHAgb25seSB1c2VzIGFub255bW91cyBhY2NvdW50cyBhbmQgeW91IG9ubHkgd2FudFxyXG4gKiBhY2NvdW50cyBzYXZlZCBmb3IgdGhlIGN1cnJlbnQgc2Vzc2lvbiwgaW5pdGlhbGl6ZSBgQXV0aGAgd2l0aDpcclxuICpcclxuICogYGBganNcclxuICogY29uc3QgYXV0aCA9IGluaXRpYWxpemVBdXRoKGFwcCwge1xyXG4gKiAgIHBlcnNpc3RlbmNlOiBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlLFxyXG4gKiAgIHBvcHVwUmVkaXJlY3RSZXNvbHZlcjogdW5kZWZpbmVkLFxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGluaXRpYWxpemVBdXRoKGFwcCwgZGVwcykge1xyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBfZ2V0UHJvdmlkZXIoYXBwLCAnYXV0aCcpO1xyXG4gICAgaWYgKHByb3ZpZGVyLmlzSW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIGNvbnN0IGF1dGggPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICBjb25zdCBpbml0aWFsT3B0aW9ucyA9IHByb3ZpZGVyLmdldE9wdGlvbnMoKTtcclxuICAgICAgICBpZiAoZGVlcEVxdWFsKGluaXRpYWxPcHRpb25zLCBkZXBzICE9PSBudWxsICYmIGRlcHMgIT09IHZvaWQgMCA/IGRlcHMgOiB7fSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF1dGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfZmFpbChhdXRoLCBcImFscmVhZHktaW5pdGlhbGl6ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkFMUkVBRFlfSU5JVElBTElaRUQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGF1dGggPSBwcm92aWRlci5pbml0aWFsaXplKHsgb3B0aW9uczogZGVwcyB9KTtcclxuICAgIHJldHVybiBhdXRoO1xyXG59XHJcbmZ1bmN0aW9uIF9pbml0aWFsaXplQXV0aEluc3RhbmNlKGF1dGgsIGRlcHMpIHtcclxuICAgIGNvbnN0IHBlcnNpc3RlbmNlID0gKGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5wZXJzaXN0ZW5jZSkgfHwgW107XHJcbiAgICBjb25zdCBoaWVyYXJjaHkgPSAoQXJyYXkuaXNBcnJheShwZXJzaXN0ZW5jZSkgPyBwZXJzaXN0ZW5jZSA6IFtwZXJzaXN0ZW5jZV0pLm1hcChfZ2V0SW5zdGFuY2UpO1xyXG4gICAgaWYgKGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5lcnJvck1hcCkge1xyXG4gICAgICAgIGF1dGguX3VwZGF0ZUVycm9yTWFwKGRlcHMuZXJyb3JNYXApO1xyXG4gICAgfVxyXG4gICAgLy8gVGhpcyBwcm9taXNlIGlzIGludGVuZGVkIHRvIGZsb2F0OyBhdXRoIGluaXRpYWxpemF0aW9uIGhhcHBlbnMgaW4gdGhlXHJcbiAgICAvLyBiYWNrZ3JvdW5kLCBtZWFud2hpbGUgdGhlIGF1dGggb2JqZWN0IG1heSBiZSB1c2VkIGJ5IHRoZSBhcHAuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICBhdXRoLl9pbml0aWFsaXplV2l0aFBlcnNpc3RlbmNlKGhpZXJhcmNoeSwgZGVwcyA9PT0gbnVsbCB8fCBkZXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXBzLnBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XHJcbn1cblxuLyoqXHJcbiAqIENoYW5nZXMgdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBGaXJlYmFzZSBBdXRoIEVtdWxhdG9yLCBpbnN0ZWFkIG9mIHByb2R1Y3Rpb25cclxuICogRmlyZWJhc2UgQXV0aCBzZXJ2aWNlcy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBtdXN0IGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5IGltbWVkaWF0ZWx5IGZvbGxvd2luZyB0aGUgZmlyc3QgY2FsbCB0b1xyXG4gKiB7QGxpbmsgaW5pdGlhbGl6ZUF1dGh9LiAgRG8gbm90IHVzZSB3aXRoIHByb2R1Y3Rpb24gY3JlZGVudGlhbHMgYXMgZW11bGF0b3JcclxuICogdHJhZmZpYyBpcyBub3QgZW5jcnlwdGVkLlxyXG4gKlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGNvbm5lY3RBdXRoRW11bGF0b3IoYXV0aCwgJ2h0dHA6Ly8xMjcuMC4wLjE6OTA5OScsIHsgZGlzYWJsZVdhcm5pbmdzOiB0cnVlIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBhdCB3aGljaCB0aGUgZW11bGF0b3IgaXMgcnVubmluZyAoZWcsICdodHRwOi8vbG9jYWxob3N0OjkwOTknKS5cclxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gYG9wdGlvbnMuZGlzYWJsZVdhcm5pbmdzYCBkZWZhdWx0cyB0byBgZmFsc2VgLiBTZXQgaXQgdG9cclxuICogYHRydWVgIHRvIGRpc2FibGUgdGhlIHdhcm5pbmcgYmFubmVyIGF0dGFjaGVkIHRvIHRoZSBET00uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGNvbm5lY3RBdXRoRW11bGF0b3IoYXV0aCwgdXJsLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XHJcbiAgICBfYXNzZXJ0KGF1dGhJbnRlcm5hbC5fY2FuSW5pdEVtdWxhdG9yLCBhdXRoSW50ZXJuYWwsIFwiZW11bGF0b3ItY29uZmlnLWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuRU1VTEFUT1JfQ09ORklHX0ZBSUxFRCAqLyk7XHJcbiAgICBfYXNzZXJ0KC9eaHR0cHM/OlxcL1xcLy8udGVzdCh1cmwpLCBhdXRoSW50ZXJuYWwsIFwiaW52YWxpZC1lbXVsYXRvci1zY2hlbWVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRU1VTEFUT1JfU0NIRU1FICovKTtcclxuICAgIGNvbnN0IGRpc2FibGVXYXJuaW5ncyA9ICEhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kaXNhYmxlV2FybmluZ3MpO1xyXG4gICAgY29uc3QgcHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2wodXJsKTtcclxuICAgIGNvbnN0IHsgaG9zdCwgcG9ydCB9ID0gZXh0cmFjdEhvc3RBbmRQb3J0KHVybCk7XHJcbiAgICBjb25zdCBwb3J0U3RyID0gcG9ydCA9PT0gbnVsbCA/ICcnIDogYDoke3BvcnR9YDtcclxuICAgIC8vIEFsd2F5cyByZXBsYWNlIHBhdGggd2l0aCBcIi9cIiAoZXZlbiBpZiBpbnB1dCB1cmwgaGFkIG5vIHBhdGggYXQgYWxsLCBvciBoYWQgYSBkaWZmZXJlbnQgb25lKS5cclxuICAgIGF1dGhJbnRlcm5hbC5jb25maWcuZW11bGF0b3IgPSB7IHVybDogYCR7cHJvdG9jb2x9Ly8ke2hvc3R9JHtwb3J0U3RyfS9gIH07XHJcbiAgICBhdXRoSW50ZXJuYWwuc2V0dGluZ3MuYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nID0gdHJ1ZTtcclxuICAgIGF1dGhJbnRlcm5hbC5lbXVsYXRvckNvbmZpZyA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgIGhvc3QsXHJcbiAgICAgICAgcG9ydCxcclxuICAgICAgICBwcm90b2NvbDogcHJvdG9jb2wucmVwbGFjZSgnOicsICcnKSxcclxuICAgICAgICBvcHRpb25zOiBPYmplY3QuZnJlZXplKHsgZGlzYWJsZVdhcm5pbmdzIH0pXHJcbiAgICB9KTtcclxuICAgIGlmICghZGlzYWJsZVdhcm5pbmdzKSB7XHJcbiAgICAgICAgZW1pdEVtdWxhdG9yV2FybmluZygpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbCh1cmwpIHtcclxuICAgIGNvbnN0IHByb3RvY29sRW5kID0gdXJsLmluZGV4T2YoJzonKTtcclxuICAgIHJldHVybiBwcm90b2NvbEVuZCA8IDAgPyAnJyA6IHVybC5zdWJzdHIoMCwgcHJvdG9jb2xFbmQgKyAxKTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0SG9zdEFuZFBvcnQodXJsKSB7XHJcbiAgICBjb25zdCBwcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbCh1cmwpO1xyXG4gICAgY29uc3QgYXV0aG9yaXR5ID0gLyhcXC9cXC8pPyhbXj8jL10rKS8uZXhlYyh1cmwuc3Vic3RyKHByb3RvY29sLmxlbmd0aCkpOyAvLyBCZXR3ZWVuIC8vIGFuZCAvLCA/IG9yICMuXHJcbiAgICBpZiAoIWF1dGhvcml0eSkge1xyXG4gICAgICAgIHJldHVybiB7IGhvc3Q6ICcnLCBwb3J0OiBudWxsIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBob3N0QW5kUG9ydCA9IGF1dGhvcml0eVsyXS5zcGxpdCgnQCcpLnBvcCgpIHx8ICcnOyAvLyBTdHJpcCBvdXQgXCJ1c2VybmFtZTpwYXNzd29yZEBcIi5cclxuICAgIGNvbnN0IGJyYWNrZXRlZElQdjYgPSAvXihcXFtbXlxcXV0rXFxdKSg6fCQpLy5leGVjKGhvc3RBbmRQb3J0KTtcclxuICAgIGlmIChicmFja2V0ZWRJUHY2KSB7XHJcbiAgICAgICAgY29uc3QgaG9zdCA9IGJyYWNrZXRlZElQdjZbMV07XHJcbiAgICAgICAgcmV0dXJuIHsgaG9zdCwgcG9ydDogcGFyc2VQb3J0KGhvc3RBbmRQb3J0LnN1YnN0cihob3N0Lmxlbmd0aCArIDEpKSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgW2hvc3QsIHBvcnRdID0gaG9zdEFuZFBvcnQuc3BsaXQoJzonKTtcclxuICAgICAgICByZXR1cm4geyBob3N0LCBwb3J0OiBwYXJzZVBvcnQocG9ydCkgfTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZVBvcnQocG9ydFN0cikge1xyXG4gICAgaWYgKCFwb3J0U3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwb3J0ID0gTnVtYmVyKHBvcnRTdHIpO1xyXG4gICAgaWYgKGlzTmFOKHBvcnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9ydDtcclxufVxyXG5mdW5jdGlvbiBlbWl0RW11bGF0b3JXYXJuaW5nKCkge1xyXG4gICAgZnVuY3Rpb24gYXR0YWNoQmFubmVyKCkge1xyXG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xyXG4gICAgICAgIGNvbnN0IHN0eSA9IGVsLnN0eWxlO1xyXG4gICAgICAgIGVsLmlubmVyVGV4dCA9XHJcbiAgICAgICAgICAgICdSdW5uaW5nIGluIGVtdWxhdG9yIG1vZGUuIERvIG5vdCB1c2Ugd2l0aCBwcm9kdWN0aW9uIGNyZWRlbnRpYWxzLic7XHJcbiAgICAgICAgc3R5LnBvc2l0aW9uID0gJ2ZpeGVkJztcclxuICAgICAgICBzdHkud2lkdGggPSAnMTAwJSc7XHJcbiAgICAgICAgc3R5LmJhY2tncm91bmRDb2xvciA9ICcjZmZmZmZmJztcclxuICAgICAgICBzdHkuYm9yZGVyID0gJy4xZW0gc29saWQgIzAwMDAwMCc7XHJcbiAgICAgICAgc3R5LmNvbG9yID0gJyNiNTAwMDAnO1xyXG4gICAgICAgIHN0eS5ib3R0b20gPSAnMHB4JztcclxuICAgICAgICBzdHkubGVmdCA9ICcwcHgnO1xyXG4gICAgICAgIHN0eS5tYXJnaW4gPSAnMHB4JztcclxuICAgICAgICBzdHkuekluZGV4ID0gJzEwMDAwJztcclxuICAgICAgICBzdHkudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnZmlyZWJhc2UtZW11bGF0b3Itd2FybmluZycpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5pbmZvID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKCdXQVJOSU5HOiBZb3UgYXJlIHVzaW5nIHRoZSBBdXRoIEVtdWxhdG9yLCcgK1xyXG4gICAgICAgICAgICAnIHdoaWNoIGlzIGludGVuZGVkIGZvciBsb2NhbCB0ZXN0aW5nIG9ubHkuICBEbyBub3QgdXNlIHdpdGgnICtcclxuICAgICAgICAgICAgJyBwcm9kdWN0aW9uIGNyZWRlbnRpYWxzLicpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgYXR0YWNoQmFubmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGF0dGFjaEJhbm5lcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB0aGUgY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkgYW4ge0BsaW5rIEF1dGhQcm92aWRlcn0uXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIEltcGxlbWVudGF0aW9ucyBzcGVjaWZ5IHRoZSBkZXRhaWxzIGFib3V0IGVhY2ggYXV0aCBwcm92aWRlcidzIGNyZWRlbnRpYWwgcmVxdWlyZW1lbnRzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBBdXRoQ3JlZGVudGlhbCB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIElEIGZvciB0aGUgY3JlZGVudGlhbC5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogRm9yIGV4YW1wbGUsICdmYWNlYm9vay5jb20nLCBvciAnZ29vZ2xlLmNvbScuXHJcbiAgICAgKi9cclxuICAgIHByb3ZpZGVySWQsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXV0aGVudGljYXRpb24gc2lnbiBpbiBtZXRob2QgZm9yIHRoZSBjcmVkZW50aWFsLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQsIG9yXHJcbiAgICAgKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBzaWduLWluIG1ldGhvZFxyXG4gICAgICogaWRlbnRpZmllciBhcyByZXR1cm5lZCBpbiB7QGxpbmsgZmV0Y2hTaWduSW5NZXRob2RzRm9yRW1haWx9LlxyXG4gICAgICovXHJcbiAgICBzaWduSW5NZXRob2QpIHtcclxuICAgICAgICB0aGlzLnByb3ZpZGVySWQgPSBwcm92aWRlcklkO1xyXG4gICAgICAgIHRoaXMuc2lnbkluTWV0aG9kID0gc2lnbkluTWV0aG9kO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2dldElkVG9rZW5SZXNwb25zZShfYXV0aCkge1xyXG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2xpbmtUb0lkVG9rZW4oX2F1dGgsIF9pZFRva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgnbm90IGltcGxlbWVudGVkJyk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKF9hdXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgnbm90IGltcGxlbWVudGVkJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVzZXRQYXNzd29yZChhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6cmVzZXRQYXNzd29yZFwiIC8qIEVuZHBvaW50LlJFU0VUX1BBU1NXT1JEICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUVtYWlsUGFzc3dvcmQoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnVwZGF0ZVwiIC8qIEVuZHBvaW50LlNFVF9BQ0NPVU5UX0lORk8gKi8sIHJlcXVlc3QpO1xyXG59XHJcbi8vIFVzZWQgZm9yIGxpbmtpbmcgYW4gZW1haWwvcGFzc3dvcmQgYWNjb3VudCB0byBhbiBleGlzdGluZyBpZFRva2VuLiBVc2VzIHRoZSBzYW1lIHJlcXVlc3QvcmVzcG9uc2VcclxuLy8gZm9ybWF0IGFzIHVwZGF0ZUVtYWlsUGFzc3dvcmQuXHJcbmFzeW5jIGZ1bmN0aW9uIGxpbmtFbWFpbFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduVXBcIiAvKiBFbmRwb2ludC5TSUdOX1VQICovLCByZXF1ZXN0KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBhcHBseUFjdGlvbkNvZGUkMShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6dXBkYXRlXCIgLyogRW5kcG9pbnQuU0VUX0FDQ09VTlRfSU5GTyAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoUGFzc3dvcmQoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhQYXNzd29yZFwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QQVNTV09SRCAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2VuZE9vYkNvZGVcIiAvKiBFbmRwb2ludC5TRU5EX09PQl9DT0RFICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRFbWFpbFZlcmlmaWNhdGlvbiQxKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBzZW5kUGFzc3dvcmRSZXNldEVtYWlsJDEoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIHNlbmRPb2JDb2RlKGF1dGgsIHJlcXVlc3QpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRTaWduSW5MaW5rVG9FbWFpbCQxKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlBbmRDaGFuZ2VFbWFpbChhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEVtYWlsTGluayQxKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoRW1haWxMaW5rXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0VNQUlMX0xJTksgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEVtYWlsTGlua0ZvckxpbmtpbmcoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhFbWFpbExpbmtcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfRU1BSUxfTElOSyAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB0aGUgY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkge0BsaW5rIEVtYWlsQXV0aFByb3ZpZGVyfSBmb3JcclxuICoge0BsaW5rIFByb3ZpZGVySWR9LlBBU1NXT1JEXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIENvdmVycyBib3RoIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX1BBU1NXT1JEIGFuZFxyXG4gKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBFbWFpbEF1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfZW1haWwsIFxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX3Bhc3N3b3JkLCBzaWduSW5NZXRob2QsIFxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX3RlbmFudElkID0gbnVsbCkge1xyXG4gICAgICAgIHN1cGVyKFwicGFzc3dvcmRcIiAvKiBQcm92aWRlcklkLlBBU1NXT1JEICovLCBzaWduSW5NZXRob2QpO1xyXG4gICAgICAgIHRoaXMuX2VtYWlsID0gX2VtYWlsO1xyXG4gICAgICAgIHRoaXMuX3Bhc3N3b3JkID0gX3Bhc3N3b3JkO1xyXG4gICAgICAgIHRoaXMuX3RlbmFudElkID0gX3RlbmFudElkO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIF9mcm9tRW1haWxBbmRQYXNzd29yZChlbWFpbCwgcGFzc3dvcmQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEVtYWlsQXV0aENyZWRlbnRpYWwoZW1haWwsIHBhc3N3b3JkLCBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHN0YXRpYyBfZnJvbUVtYWlsQW5kQ29kZShlbWFpbCwgb29iQ29kZSwgdGVuYW50SWQgPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbWFpbEF1dGhDcmVkZW50aWFsKGVtYWlsLCBvb2JDb2RlLCBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovLCB0ZW5hbnRJZCk7XHJcbiAgICB9XHJcbiAgICAvKioge0Bpbmhlcml0ZG9jIEF1dGhDcmVkZW50aWFsLnRvSlNPTn0gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBlbWFpbDogdGhpcy5fZW1haWwsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9wYXNzd29yZCxcclxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiB0aGlzLnNpZ25Jbk1ldGhvZCxcclxuICAgICAgICAgICAgdGVuYW50SWQ6IHRoaXMuX3RlbmFudElkXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBkZXNlcmlhbGl6ZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGludG8gYW4ge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGpzb24gLSBFaXRoZXIgYG9iamVjdGAgb3IgdGhlIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuIFdoZW4gc3RyaW5nIGlzXHJcbiAgICAgKiBwcm92aWRlZCwgYEpTT04ucGFyc2VgIHdvdWxkIGJlIGNhbGxlZCBmaXJzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBJZiB0aGUgSlNPTiBpbnB1dCBkb2VzIG5vdCByZXByZXNlbnQgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSwgbnVsbCBpcyByZXR1cm5lZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBjb25zdCBvYmogPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcclxuICAgICAgICBpZiAoKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5lbWFpbCkgJiYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5wYXNzd29yZCkpIHtcclxuICAgICAgICAgICAgaWYgKG9iai5zaWduSW5NZXRob2QgPT09IFwicGFzc3dvcmRcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcm9tRW1haWxBbmRQYXNzd29yZChvYmouZW1haWwsIG9iai5wYXNzd29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2JqLnNpZ25Jbk1ldGhvZCA9PT0gXCJlbWFpbExpbmtcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfTElOSyAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zyb21FbWFpbEFuZENvZGUob2JqLmVtYWlsLCBvYmoucGFzc3dvcmQsIG9iai50ZW5hbnRJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBhc3luYyBfZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuc2lnbkluTWV0aG9kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwYXNzd29yZFwiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9QQVNTV09SRCAqLzpcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9wYXNzd29yZCxcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aCwgcmVxdWVzdCwgXCJzaWduSW5XaXRoUGFzc3dvcmRcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLlNJR05fSU5fV0lUSF9QQVNTV09SRCAqLywgc2lnbkluV2l0aFBhc3N3b3JkKTtcclxuICAgICAgICAgICAgY2FzZSBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhFbWFpbExpbmskMShhdXRoLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxyXG4gICAgICAgICAgICAgICAgICAgIG9vYkNvZGU6IHRoaXMuX3Bhc3N3b3JkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIF9mYWlsKGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBhc3luYyBfbGlua1RvSWRUb2tlbihhdXRoLCBpZFRva2VuKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnNpZ25Jbk1ldGhvZCkge1xyXG4gICAgICAgICAgICBjYXNlIFwicGFzc3dvcmRcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQgKi86XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9wYXNzd29yZCxcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aCwgcmVxdWVzdCwgXCJzaWduVXBQYXNzd29yZFwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuU0lHTl9VUF9QQVNTV09SRCAqLywgbGlua0VtYWlsUGFzc3dvcmQpO1xyXG4gICAgICAgICAgICBjYXNlIFwiZW1haWxMaW5rXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX0xJTksgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbkluV2l0aEVtYWlsTGlua0ZvckxpbmtpbmcoYXV0aCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxyXG4gICAgICAgICAgICAgICAgICAgIG9vYkNvZGU6IHRoaXMuX3Bhc3N3b3JkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIF9mYWlsKGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhJZHBcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfSURQICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IElEUF9SRVFVRVNUX1VSSSQxID0gJ2h0dHA6Ly9sb2NhbGhvc3QnO1xyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgT0F1dGggY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkgYW4ge0BsaW5rIE9BdXRoUHJvdmlkZXJ9LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBJbXBsZW1lbnRhdGlvbnMgc3BlY2lmeSB0aGUgZGV0YWlscyBhYm91dCBlYWNoIGF1dGggcHJvdmlkZXIncyBjcmVkZW50aWFsIHJlcXVpcmVtZW50cy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgT0F1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdUb2tlbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgX2Zyb21QYXJhbXMocGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgY3JlZCA9IG5ldyBPQXV0aENyZWRlbnRpYWwocGFyYW1zLnByb3ZpZGVySWQsIHBhcmFtcy5zaWduSW5NZXRob2QpO1xyXG4gICAgICAgIGlmIChwYXJhbXMuaWRUb2tlbiB8fCBwYXJhbXMuYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgLy8gT0F1dGggMiBhbmQgZWl0aGVyIElEIHRva2VuIG9yIGFjY2VzcyB0b2tlbi5cclxuICAgICAgICAgICAgaWYgKHBhcmFtcy5pZFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBjcmVkLmlkVG9rZW4gPSBwYXJhbXMuaWRUb2tlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGFyYW1zLmFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBjcmVkLmFjY2Vzc1Rva2VuID0gcGFyYW1zLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFkZCBub25jZSBpZiBhdmFpbGFibGUgYW5kIG5vIHBlbmRpbmdUb2tlbiBpcyBwcmVzZW50LlxyXG4gICAgICAgICAgICBpZiAocGFyYW1zLm5vbmNlICYmICFwYXJhbXMucGVuZGluZ1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBjcmVkLm5vbmNlID0gcGFyYW1zLm5vbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMucGVuZGluZ1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBjcmVkLnBlbmRpbmdUb2tlbiA9IHBhcmFtcy5wZW5kaW5nVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLm9hdXRoVG9rZW4gJiYgcGFyYW1zLm9hdXRoVG9rZW5TZWNyZXQpIHtcclxuICAgICAgICAgICAgLy8gT0F1dGggMSBhbmQgT0F1dGggdG9rZW4gd2l0aCB0b2tlbiBzZWNyZXRcclxuICAgICAgICAgICAgY3JlZC5hY2Nlc3NUb2tlbiA9IHBhcmFtcy5vYXV0aFRva2VuO1xyXG4gICAgICAgICAgICBjcmVkLnNlY3JldCA9IHBhcmFtcy5vYXV0aFRva2VuU2VjcmV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX2ZhaWwoXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3JlZDtcclxuICAgIH1cclxuICAgIC8qKiB7QGluaGVyaXRkb2MgQXV0aENyZWRlbnRpYWwudG9KU09OfSAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZFRva2VuOiB0aGlzLmlkVG9rZW4sXHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxyXG4gICAgICAgICAgICBzZWNyZXQ6IHRoaXMuc2VjcmV0LFxyXG4gICAgICAgICAgICBub25jZTogdGhpcy5ub25jZSxcclxuICAgICAgICAgICAgcGVuZGluZ1Rva2VuOiB0aGlzLnBlbmRpbmdUb2tlbixcclxuICAgICAgICAgICAgcHJvdmlkZXJJZDogdGhpcy5wcm92aWRlcklkLFxyXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IHRoaXMuc2lnbkluTWV0aG9kXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBkZXNlcmlhbGl6ZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGludG8gYW5cclxuICAgICAqIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBqc29uIC0gSW5wdXQgY2FuIGJlIGVpdGhlciBPYmplY3Qgb3IgdGhlIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKiBXaGVuIHN0cmluZyBpcyBwcm92aWRlZCwgSlNPTi5wYXJzZSB3b3VsZCBiZSBjYWxsZWQgZmlyc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgSWYgdGhlIEpTT04gaW5wdXQgZG9lcyBub3QgcmVwcmVzZW50IGFuIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LCBudWxsIGlzIHJldHVybmVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xyXG4gICAgICAgIGNvbnN0IHsgcHJvdmlkZXJJZCwgc2lnbkluTWV0aG9kIH0gPSBvYmosIHJlc3QgPSBfX3Jlc3Qob2JqLCBbXCJwcm92aWRlcklkXCIsIFwic2lnbkluTWV0aG9kXCJdKTtcclxuICAgICAgICBpZiAoIXByb3ZpZGVySWQgfHwgIXNpZ25Jbk1ldGhvZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY3JlZCA9IG5ldyBPQXV0aENyZWRlbnRpYWwocHJvdmlkZXJJZCwgc2lnbkluTWV0aG9kKTtcclxuICAgICAgICBjcmVkLmlkVG9rZW4gPSByZXN0LmlkVG9rZW4gfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGNyZWQuYWNjZXNzVG9rZW4gPSByZXN0LmFjY2Vzc1Rva2VuIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICBjcmVkLnNlY3JldCA9IHJlc3Quc2VjcmV0O1xyXG4gICAgICAgIGNyZWQubm9uY2UgPSByZXN0Lm5vbmNlO1xyXG4gICAgICAgIGNyZWQucGVuZGluZ1Rva2VuID0gcmVzdC5wZW5kaW5nVG9rZW4gfHwgbnVsbDtcclxuICAgICAgICByZXR1cm4gY3JlZDtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xyXG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2xpbmtUb0lkVG9rZW4oYXV0aCwgaWRUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xyXG4gICAgICAgIHJlcXVlc3QuaWRUb2tlbiA9IGlkVG9rZW47XHJcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcclxuICAgICAgICByZXF1ZXN0LmF1dG9DcmVhdGUgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIGJ1aWxkUmVxdWVzdCgpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICByZXF1ZXN0VXJpOiBJRFBfUkVRVUVTVF9VUkkkMSxcclxuICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdUb2tlbikge1xyXG4gICAgICAgICAgICByZXF1ZXN0LnBlbmRpbmdUb2tlbiA9IHRoaXMucGVuZGluZ1Rva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcG9zdEJvZHkgPSB7fTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaWRUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgcG9zdEJvZHlbJ2lkX3Rva2VuJ10gPSB0aGlzLmlkVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHBvc3RCb2R5WydhY2Nlc3NfdG9rZW4nXSA9IHRoaXMuYWNjZXNzVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VjcmV0KSB7XHJcbiAgICAgICAgICAgICAgICBwb3N0Qm9keVsnb2F1dGhfdG9rZW5fc2VjcmV0J10gPSB0aGlzLnNlY3JldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb3N0Qm9keVsncHJvdmlkZXJJZCddID0gdGhpcy5wcm92aWRlcklkO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ub25jZSAmJiAhdGhpcy5wZW5kaW5nVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHBvc3RCb2R5Wydub25jZSddID0gdGhpcy5ub25jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXF1ZXN0LnBvc3RCb2R5ID0gcXVlcnlzdHJpbmcocG9zdEJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoUGhvbmVOdW1iZXIkMShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aFBob25lTnVtYmVyXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX1BIT05FX05VTUJFUiAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBsaW5rV2l0aFBob25lTnVtYmVyJDEoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoUGhvbmVOdW1iZXJcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfUEhPTkVfTlVNQkVSICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG4gICAgaWYgKHJlc3BvbnNlLnRlbXBvcmFyeVByb29mKSB7XHJcbiAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBcImFjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLk5FRURfQ09ORklSTUFUSU9OICovLCByZXNwb25zZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzcG9uc2U7XHJcbn1cclxuY29uc3QgVkVSSUZZX1BIT05FX05VTUJFUl9GT1JfRVhJU1RJTkdfRVJST1JfTUFQXyA9IHtcclxuICAgIFtcIlVTRVJfTk9UX0ZPVU5EXCIgLyogU2VydmVyRXJyb3IuVVNFUl9OT1RfRk9VTkQgKi9dOiBcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi9cclxufTtcclxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5UGhvbmVOdW1iZXJGb3JFeGlzdGluZyhhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICBjb25zdCBhcGlSZXF1ZXN0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBvcGVyYXRpb246ICdSRUFVVEgnIH0pO1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhQaG9uZU51bWJlclwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QSE9ORV9OVU1CRVIgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCBhcGlSZXF1ZXN0KSwgVkVSSUZZX1BIT05FX05VTUJFUl9GT1JfRVhJU1RJTkdfRVJST1JfTUFQXyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IHtAbGluayBQaG9uZUF1dGhQcm92aWRlcn0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIFBob25lQXV0aENyZWRlbnRpYWwgZXh0ZW5kcyBBdXRoQ3JlZGVudGlhbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcclxuICAgICAgICBzdXBlcihcInBob25lXCIgLyogUHJvdmlkZXJJZC5QSE9ORSAqLywgXCJwaG9uZVwiIC8qIFNpZ25Jbk1ldGhvZC5QSE9ORSAqLyk7XHJcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgX2Zyb21WZXJpZmljYXRpb24odmVyaWZpY2F0aW9uSWQsIHZlcmlmaWNhdGlvbkNvZGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBob25lQXV0aENyZWRlbnRpYWwoeyB2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHN0YXRpYyBfZnJvbVRva2VuUmVzcG9uc2UocGhvbmVOdW1iZXIsIHRlbXBvcmFyeVByb29mKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQaG9uZUF1dGhDcmVkZW50aWFsKHsgcGhvbmVOdW1iZXIsIHRlbXBvcmFyeVByb29mIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2dldElkVG9rZW5SZXNwb25zZShhdXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhQaG9uZU51bWJlciQxKGF1dGgsIHRoaXMuX21ha2VWZXJpZmljYXRpb25SZXF1ZXN0KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2xpbmtUb0lkVG9rZW4oYXV0aCwgaWRUb2tlbikge1xyXG4gICAgICAgIHJldHVybiBsaW5rV2l0aFBob25lTnVtYmVyJDEoYXV0aCwgT2JqZWN0LmFzc2lnbih7IGlkVG9rZW4gfSwgdGhpcy5fbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSkpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3RpbmcoYXV0aCwgdGhpcy5fbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSB7XHJcbiAgICAgICAgY29uc3QgeyB0ZW1wb3JhcnlQcm9vZiwgcGhvbmVOdW1iZXIsIHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlIH0gPSB0aGlzLnBhcmFtcztcclxuICAgICAgICBpZiAodGVtcG9yYXJ5UHJvb2YgJiYgcGhvbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdGVtcG9yYXJ5UHJvb2YsIHBob25lTnVtYmVyIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNlc3Npb25JbmZvOiB2ZXJpZmljYXRpb25JZCxcclxuICAgICAgICAgICAgY29kZTogdmVyaWZpY2F0aW9uQ29kZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKioge0Bpbmhlcml0ZG9jIEF1dGhDcmVkZW50aWFsLnRvSlNPTn0gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBvYmogPSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnBob25lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIG9iai5waG9uZU51bWJlciA9IHRoaXMucGFyYW1zLnBob25lTnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXJhbXMudGVtcG9yYXJ5UHJvb2YpIHtcclxuICAgICAgICAgICAgb2JqLnRlbXBvcmFyeVByb29mID0gdGhpcy5wYXJhbXMudGVtcG9yYXJ5UHJvb2Y7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25Db2RlKSB7XHJcbiAgICAgICAgICAgIG9iai52ZXJpZmljYXRpb25Db2RlID0gdGhpcy5wYXJhbXMudmVyaWZpY2F0aW9uQ29kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbklkKSB7XHJcbiAgICAgICAgICAgIG9iai52ZXJpZmljYXRpb25JZCA9IHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbklkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgLyoqIEdlbmVyYXRlcyBhIHBob25lIGNyZWRlbnRpYWwgYmFzZWQgb24gYSBwbGFpbiBvYmplY3Qgb3IgYSBKU09OIHN0cmluZy4gKi9cclxuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSwgcGhvbmVOdW1iZXIsIHRlbXBvcmFyeVByb29mIH0gPSBqc29uO1xyXG4gICAgICAgIGlmICghdmVyaWZpY2F0aW9uQ29kZSAmJlxyXG4gICAgICAgICAgICAhdmVyaWZpY2F0aW9uSWQgJiZcclxuICAgICAgICAgICAgIXBob25lTnVtYmVyICYmXHJcbiAgICAgICAgICAgICF0ZW1wb3JhcnlQcm9vZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQaG9uZUF1dGhDcmVkZW50aWFsKHtcclxuICAgICAgICAgICAgdmVyaWZpY2F0aW9uSWQsXHJcbiAgICAgICAgICAgIHZlcmlmaWNhdGlvbkNvZGUsXHJcbiAgICAgICAgICAgIHBob25lTnVtYmVyLFxyXG4gICAgICAgICAgICB0ZW1wb3JhcnlQcm9vZlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBNYXBzIHRoZSBtb2RlIHN0cmluZyBpbiBhY3Rpb24gY29kZSBVUkwgdG8gQWN0aW9uIENvZGUgSW5mbyBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBtb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZU1vZGUobW9kZSkge1xyXG4gICAgc3dpdGNoIChtb2RlKSB7XHJcbiAgICAgICAgY2FzZSAncmVjb3ZlckVtYWlsJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiUkVDT1ZFUl9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUkVDT1ZFUl9FTUFJTCAqLztcclxuICAgICAgICBjYXNlICdyZXNldFBhc3N3b3JkJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiUEFTU1dPUkRfUkVTRVRcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlBBU1NXT1JEX1JFU0VUICovO1xyXG4gICAgICAgIGNhc2UgJ3NpZ25Jbic6XHJcbiAgICAgICAgICAgIHJldHVybiBcIkVNQUlMX1NJR05JTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOICovO1xyXG4gICAgICAgIGNhc2UgJ3ZlcmlmeUVtYWlsJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiVkVSSUZZX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfRU1BSUwgKi87XHJcbiAgICAgICAgY2FzZSAndmVyaWZ5QW5kQ2hhbmdlRW1haWwnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwgKi87XHJcbiAgICAgICAgY2FzZSAncmV2ZXJ0U2Vjb25kRmFjdG9yQWRkaXRpb24nOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT04gKi87XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBwYXJzZSBGREwgbGlua3NcclxuICpcclxuICogQHBhcmFtIHVybFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VEZWVwTGluayh1cmwpIHtcclxuICAgIGNvbnN0IGxpbmsgPSBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcodXJsKSlbJ2xpbmsnXTtcclxuICAgIC8vIERvdWJsZSBsaW5rIGNhc2UgKGF1dG9tYXRpYyByZWRpcmVjdCkuXHJcbiAgICBjb25zdCBkb3VibGVEZWVwTGluayA9IGxpbmtcclxuICAgICAgICA/IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyhsaW5rKSlbJ2RlZXBfbGlua19pZCddXHJcbiAgICAgICAgOiBudWxsO1xyXG4gICAgLy8gaU9TIGN1c3RvbSBzY2hlbWUgbGlua3MuXHJcbiAgICBjb25zdCBpT1NEZWVwTGluayA9IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyh1cmwpKVsnZGVlcF9saW5rX2lkJ107XHJcbiAgICBjb25zdCBpT1NEb3VibGVEZWVwTGluayA9IGlPU0RlZXBMaW5rXHJcbiAgICAgICAgPyBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcoaU9TRGVlcExpbmspKVsnbGluayddXHJcbiAgICAgICAgOiBudWxsO1xyXG4gICAgcmV0dXJuIGlPU0RvdWJsZURlZXBMaW5rIHx8IGlPU0RlZXBMaW5rIHx8IGRvdWJsZURlZXBMaW5rIHx8IGxpbmsgfHwgdXJsO1xyXG59XHJcbi8qKlxyXG4gKiBBIHV0aWxpdHkgY2xhc3MgdG8gcGFyc2UgZW1haWwgYWN0aW9uIFVSTHMgc3VjaCBhcyBwYXNzd29yZCByZXNldCwgZW1haWwgdmVyaWZpY2F0aW9uLFxyXG4gKiBlbWFpbCBsaW5rIHNpZ24gaW4sIGV0Yy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgQWN0aW9uQ29kZVVSTCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBhY3Rpb25MaW5rIC0gVGhlIGxpbmsgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBVUkwuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUge0BsaW5rIEFjdGlvbkNvZGVVUkx9IG9iamVjdCwgb3IgbnVsbCBpZiB0aGUgbGluayBpcyBpbnZhbGlkLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhY3Rpb25MaW5rKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gcXVlcnlzdHJpbmdEZWNvZGUoZXh0cmFjdFF1ZXJ5c3RyaW5nKGFjdGlvbkxpbmspKTtcclxuICAgICAgICBjb25zdCBhcGlLZXkgPSAoX2EgPSBzZWFyY2hQYXJhbXNbXCJhcGlLZXlcIiAvKiBRdWVyeUZpZWxkLkFQSV9LRVkgKi9dKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGNvZGUgPSAoX2IgPSBzZWFyY2hQYXJhbXNbXCJvb2JDb2RlXCIgLyogUXVlcnlGaWVsZC5DT0RFICovXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcclxuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBwYXJzZU1vZGUoKF9jID0gc2VhcmNoUGFyYW1zW1wibW9kZVwiIC8qIFF1ZXJ5RmllbGQuTU9ERSAqL10pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwpO1xyXG4gICAgICAgIC8vIFZhbGlkYXRlIEFQSSBrZXksIGNvZGUgYW5kIG1vZGUuXHJcbiAgICAgICAgX2Fzc2VydChhcGlLZXkgJiYgY29kZSAmJiBvcGVyYXRpb24sIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcclxuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcclxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIHRoaXMuY29udGludWVVcmwgPSAoX2QgPSBzZWFyY2hQYXJhbXNbXCJjb250aW51ZVVybFwiIC8qIFF1ZXJ5RmllbGQuQ09OVElOVUVfVVJMICovXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbnVsbDtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlQ29kZSA9IChfZSA9IHNlYXJjaFBhcmFtc1tcImxhbmd1YWdlQ29kZVwiIC8qIFF1ZXJ5RmllbGQuTEFOR1VBR0VfQ09ERSAqL10pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IG51bGw7XHJcbiAgICAgICAgdGhpcy50ZW5hbnRJZCA9IChfZiA9IHNlYXJjaFBhcmFtc1tcInRlbmFudElkXCIgLyogUXVlcnlGaWVsZC5URU5BTlRfSUQgKi9dKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgdGhlIGVtYWlsIGFjdGlvbiBsaW5rIHN0cmluZyBhbmQgcmV0dXJucyBhbiB7QGxpbmsgQWN0aW9uQ29kZVVSTH0gaWYgdGhlIGxpbmsgaXMgdmFsaWQsXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsaW5rICAtIFRoZSBlbWFpbCBhY3Rpb24gbGluayBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUge0BsaW5rIEFjdGlvbkNvZGVVUkx9IG9iamVjdCwgb3IgbnVsbCBpZiB0aGUgbGluayBpcyBpbnZhbGlkLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHBhcnNlTGluayhsaW5rKSB7XHJcbiAgICAgICAgY29uc3QgYWN0aW9uTGluayA9IHBhcnNlRGVlcExpbmsobGluayk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb25Db2RlVVJMKGFjdGlvbkxpbmspO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQYXJzZXMgdGhlIGVtYWlsIGFjdGlvbiBsaW5rIHN0cmluZyBhbmQgcmV0dXJucyBhbiB7QGxpbmsgQWN0aW9uQ29kZVVSTH0gaWZcclxuICogdGhlIGxpbmsgaXMgdmFsaWQsIG90aGVyd2lzZSByZXR1cm5zIG51bGwuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlQWN0aW9uQ29kZVVSTChsaW5rKSB7XHJcbiAgICByZXR1cm4gQWN0aW9uQ29kZVVSTC5wYXJzZUxpbmsobGluayk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIHtAbGluayBFbWFpbEF1dGhDcmVkZW50aWFsfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgRW1haWxBdXRoUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uUEFTU1dPUkQsIGV2ZW4gZm9yIGVtYWlsIGxpbmsuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gRW1haWxBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSB1c2luZyBhbiBlbWFpbCBhbmQgcGFzc3dvcmQuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIGNvbnN0IGF1dGhDcmVkZW50aWFsID0gRW1haWxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChlbWFpbCwgcGFzc3dvcmQpO1xyXG4gICAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBhdXRoQ3JlZGVudGlhbCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChhdXRoLCBlbWFpbCwgcGFzc3dvcmQpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVtYWlsIC0gRW1haWwgYWRkcmVzcy5cclxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAtIFVzZXIgYWNjb3VudCBwYXNzd29yZC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBhdXRoIHByb3ZpZGVyIGNyZWRlbnRpYWwuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsKGVtYWlsLCBwYXNzd29yZCkge1xyXG4gICAgICAgIHJldHVybiBFbWFpbEF1dGhDcmVkZW50aWFsLl9mcm9tRW1haWxBbmRQYXNzd29yZChlbWFpbCwgcGFzc3dvcmQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gdXNpbmcgYW4gZW1haWwgYW5kIGFuIGVtYWlsIGxpbmsgYWZ0ZXIgYSBzaWduIGluIHdpdGhcclxuICAgICAqIGVtYWlsIGxpbmsgb3BlcmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgKiBjb25zdCBhdXRoQ3JlZGVudGlhbCA9IEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxXaXRoTGluayhhdXRoLCBlbWFpbCwgZW1haWxMaW5rKTtcclxuICAgICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aCwgYXV0aENyZWRlbnRpYWwpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIGF3YWl0IHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCBlbWFpbCk7XHJcbiAgICAgKiAvLyBPYnRhaW4gZW1haWxMaW5rIGZyb20gdXNlci5cclxuICAgICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbCwgZW1haWxMaW5rKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSB1c2VkIHRvIHZlcmlmeSB0aGUgbGluay5cclxuICAgICAqIEBwYXJhbSBlbWFpbCAtIEVtYWlsIGFkZHJlc3MuXHJcbiAgICAgKiBAcGFyYW0gZW1haWxMaW5rIC0gU2lnbi1pbiBlbWFpbCBsaW5rLlxyXG4gICAgICogQHJldHVybnMgLSBUaGUgYXV0aCBwcm92aWRlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbFdpdGhMaW5rKGVtYWlsLCBlbWFpbExpbmspIHtcclxuICAgICAgICBjb25zdCBhY3Rpb25Db2RlVXJsID0gQWN0aW9uQ29kZVVSTC5wYXJzZUxpbmsoZW1haWxMaW5rKTtcclxuICAgICAgICBfYXNzZXJ0KGFjdGlvbkNvZGVVcmwsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcclxuICAgICAgICByZXR1cm4gRW1haWxBdXRoQ3JlZGVudGlhbC5fZnJvbUVtYWlsQW5kQ29kZShlbWFpbCwgYWN0aW9uQ29kZVVybC5jb2RlLCBhY3Rpb25Db2RlVXJsLnRlbmFudElkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uUEFTU1dPUkQsIGV2ZW4gZm9yIGVtYWlsIGxpbmsuXHJcbiAqL1xyXG5FbWFpbEF1dGhQcm92aWRlci5QUk9WSURFUl9JRCA9IFwicGFzc3dvcmRcIiAvKiBQcm92aWRlcklkLlBBU1NXT1JEICovO1xyXG4vKipcclxuICogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9QQVNTV09SRC5cclxuICovXHJcbkVtYWlsQXV0aFByb3ZpZGVyLkVNQUlMX1BBU1NXT1JEX1NJR05fSU5fTUVUSE9EID0gXCJwYXNzd29yZFwiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9QQVNTV09SRCAqLztcclxuLyoqXHJcbiAqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy5cclxuICovXHJcbkVtYWlsQXV0aFByb3ZpZGVyLkVNQUlMX0xJTktfU0lHTl9JTl9NRVRIT0QgPSBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBGZWRlcmF0ZWQgcHJvdmlkZXJzIChPQXV0aCAoaW5jbHVkaW5nIE9JREMpLCBTQU1MKS5cclxuICpcclxuICogVGhpcyBjbGFzcyBpcyBub3QgbWVhbnQgdG8gYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgZ2VuZXJpYyBPQXV0aCBwcm92aWRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3ZpZGVySWQgLSBQcm92aWRlciBmb3Igd2hpY2ggY3JlZGVudGlhbHMgc2hvdWxkIGJlIGdlbmVyYXRlZC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXJJZCkge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IHByb3ZpZGVySWQ7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdExhbmd1YWdlQ29kZSA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuY3VzdG9tUGFyYW1ldGVycyA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGxhbmd1YWdlIGdvZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlQ29kZSAtIGxhbmd1YWdlIGNvZGVcclxuICAgICAqL1xyXG4gICAgc2V0RGVmYXVsdExhbmd1YWdlKGxhbmd1YWdlQ29kZSkge1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdExhbmd1YWdlQ29kZSA9IGxhbmd1YWdlQ29kZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgT0F1dGggY3VzdG9tIHBhcmFtZXRlcnMgdG8gcGFzcyBpbiBhbiBPQXV0aCByZXF1ZXN0IGZvciBwb3B1cCBhbmQgcmVkaXJlY3Qgc2lnbi1pblxyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogRm9yIGEgZGV0YWlsZWQgbGlzdCwgY2hlY2sgdGhlIHJlc2VydmVkIHJlcXVpcmVkIE9BdXRoIDIuMCBwYXJhbWV0ZXJzIHN1Y2ggYXMgYGNsaWVudF9pZGAsXHJcbiAgICAgKiBgcmVkaXJlY3RfdXJpYCwgYHNjb3BlYCwgYHJlc3BvbnNlX3R5cGVgLCBhbmQgYHN0YXRlYCBhcmUgbm90IGFsbG93ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3VzdG9tT0F1dGhQYXJhbWV0ZXJzIC0gVGhlIGN1c3RvbSBPQXV0aCBwYXJhbWV0ZXJzIHRvIHBhc3MgaW4gdGhlIE9BdXRoIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIHNldEN1c3RvbVBhcmFtZXRlcnMoY3VzdG9tT0F1dGhQYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgdGhpcy5jdXN0b21QYXJhbWV0ZXJzID0gY3VzdG9tT0F1dGhQYXJhbWV0ZXJzO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBDdXN0b21QYXJhbWV0ZXJzfS5cclxuICAgICAqL1xyXG4gICAgZ2V0Q3VzdG9tUGFyYW1ldGVycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21QYXJhbWV0ZXJzO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDb21tb24gY29kZSB0byBhbGwgT0F1dGggcHJvdmlkZXJzLiBUaGlzIGlzIHNlcGFyYXRlIGZyb20gdGhlXHJcbiAqIHtAbGluayBPQXV0aFByb3ZpZGVyfSBzbyB0aGF0IGNoaWxkIHByb3ZpZGVycyAobGlrZVxyXG4gKiB7QGxpbmsgR29vZ2xlQXV0aFByb3ZpZGVyfSkgZG9uJ3QgaW5oZXJpdCB0aGUgYGNyZWRlbnRpYWxgIGluc3RhbmNlIG1ldGhvZC5cclxuICogSW5zdGVhZCwgdGhleSByZWx5IG9uIGEgc3RhdGljIGBjcmVkZW50aWFsYCBtZXRob2QuXHJcbiAqL1xyXG5jbGFzcyBCYXNlT0F1dGhQcm92aWRlciBleHRlbmRzIEZlZGVyYXRlZEF1dGhQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLnNjb3BlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gT0F1dGggc2NvcGUgdG8gdGhlIGNyZWRlbnRpYWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNjb3BlIC0gUHJvdmlkZXIgT0F1dGggc2NvcGUgdG8gYWRkLlxyXG4gICAgICovXHJcbiAgICBhZGRTY29wZShzY29wZSkge1xyXG4gICAgICAgIC8vIElmIG5vdCBhbHJlYWR5IGFkZGVkLCBhZGQgc2NvcGUgdG8gbGlzdC5cclxuICAgICAgICBpZiAoIXRoaXMuc2NvcGVzLmluY2x1ZGVzKHNjb3BlKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNjb3Blcy5wdXNoKHNjb3BlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGxpc3Qgb2YgT0F1dGggc2NvcGVzLlxyXG4gICAgICovXHJcbiAgICBnZXRTY29wZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnNjb3Blc107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGdlbmVyaWMge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxyXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBPQXV0aFByb3ZpZGVyKCdnb29nbGUuY29tJyk7XHJcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cclxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcclxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ2VtYWlsJyk7XHJcbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XHJcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxyXG4gKlxyXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XHJcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xyXG4gKiBpZiAocmVzdWx0KSB7XHJcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XHJcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBPQXV0aCBBY2Nlc3MgVG9rZW4gZm9yIHRoZSBwcm92aWRlci5cclxuICogICBjb25zdCBjcmVkZW50aWFsID0gcHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQoYXV0aCwgcmVzdWx0KTtcclxuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxyXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBPQXV0aFByb3ZpZGVyKCdnb29nbGUuY29tJyk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdwcm9maWxlJyk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xyXG4gKlxyXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cclxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xyXG4gKiAvLyBUaGlzIGdpdmVzIHlvdSBhIE9BdXRoIEFjY2VzcyBUb2tlbiBmb3IgdGhlIHByb3ZpZGVyLlxyXG4gKiBjb25zdCBjcmVkZW50aWFsID0gcHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQoYXV0aCwgcmVzdWx0KTtcclxuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiBgYGBcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgT0F1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEgSlNPTiBzdHJpbmcgb3IgYSBwbGFpbiBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ganNvbiAtIEEgcGxhaW4gb2JqZWN0IG9yIGEgSlNPTiBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0gdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XHJcbiAgICAgICAgX2Fzc2VydCgncHJvdmlkZXJJZCcgaW4gb2JqICYmICdzaWduSW5NZXRob2QnIGluIG9iaiwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMob2JqKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSBnZW5lcmljIE9BdXRoIHByb3ZpZGVyJ3MgYWNjZXNzIHRva2VuIG9yIElEIHRva2VuLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGUgcmF3IG5vbmNlIGlzIHJlcXVpcmVkIHdoZW4gYW4gSUQgdG9rZW4gd2l0aCBhIG5vbmNlIGZpZWxkIGlzIHByb3ZpZGVkLiBUaGUgU0hBLTI1NiBoYXNoIG9mXHJcbiAgICAgKiB0aGUgcmF3IG5vbmNlIG11c3QgbWF0Y2ggdGhlIG5vbmNlIGZpZWxkIGluIHRoZSBJRCB0b2tlbi5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICogLy8gYGdvb2dsZVVzZXJgIGZyb20gdGhlIG9uc3VjY2VzcyBHb29nbGUgU2lnbiBJbiBjYWxsYmFjay5cclxuICAgICAqIC8vIEluaXRpYWxpemUgYSBnZW5lcmF0ZSBPQXV0aCBwcm92aWRlciB3aXRoIGEgYGdvb2dsZS5jb21gIHByb3ZpZGVySWQuXHJcbiAgICAgKiBjb25zdCBwcm92aWRlciA9IG5ldyBPQXV0aFByb3ZpZGVyKCdnb29nbGUuY29tJyk7XHJcbiAgICAgKiBjb25zdCBjcmVkZW50aWFsID0gcHJvdmlkZXIuY3JlZGVudGlhbCh7XHJcbiAgICAgKiAgIGlkVG9rZW46IGdvb2dsZVVzZXIuZ2V0QXV0aFJlc3BvbnNlKCkuaWRfdG9rZW4sXHJcbiAgICAgKiB9KTtcclxuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGNyZWRlbnRpYWwpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIEVpdGhlciB0aGUgb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyB0aGUgSUQgdG9rZW4sIGFjY2VzcyB0b2tlbiBhbmQgcmF3IG5vbmNlXHJcbiAgICAgKiBvciB0aGUgSUQgdG9rZW4gc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBjcmVkZW50aWFsKHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVkZW50aWFsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgeyBub25jZTogcGFyYW1zLnJhd05vbmNlIH0pKTtcclxuICAgIH1cclxuICAgIC8qKiBBbiBpbnRlcm5hbCBjcmVkZW50aWFsIG1ldGhvZCB0aGF0IGFjY2VwdHMgbW9yZSBwZXJtaXNzaXZlIG9wdGlvbnMgKi9cclxuICAgIF9jcmVkZW50aWFsKHBhcmFtcykge1xyXG4gICAgICAgIF9hc3NlcnQocGFyYW1zLmlkVG9rZW4gfHwgcGFyYW1zLmFjY2Vzc1Rva2VuLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICAgICAgLy8gRm9yIE9BdXRoQ3JlZGVudGlhbCwgc2lnbiBpbiBtZXRob2QgaXMgc2FtZSBhcyBwcm92aWRlcklkLlxyXG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCwgc2lnbkluTWV0aG9kOiB0aGlzLnByb3ZpZGVySWQgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgcmV0dXJuIE9BdXRoUHJvdmlkZXIub2F1dGhDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXHJcbiAgICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIE9BdXRoUHJvdmlkZXIub2F1dGhDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG9hdXRoQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XHJcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IG9hdXRoSWRUb2tlbiwgb2F1dGhBY2Nlc3NUb2tlbiwgb2F1dGhUb2tlblNlY3JldCwgcGVuZGluZ1Rva2VuLCBub25jZSwgcHJvdmlkZXJJZCB9ID0gdG9rZW5SZXNwb25zZTtcclxuICAgICAgICBpZiAoIW9hdXRoQWNjZXNzVG9rZW4gJiZcclxuICAgICAgICAgICAgIW9hdXRoVG9rZW5TZWNyZXQgJiZcclxuICAgICAgICAgICAgIW9hdXRoSWRUb2tlbiAmJlxyXG4gICAgICAgICAgICAhcGVuZGluZ1Rva2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXByb3ZpZGVySWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT0F1dGhQcm92aWRlcihwcm92aWRlcklkKS5fY3JlZGVudGlhbCh7XHJcbiAgICAgICAgICAgICAgICBpZFRva2VuOiBvYXV0aElkVG9rZW4sXHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjogb2F1dGhBY2Nlc3NUb2tlbixcclxuICAgICAgICAgICAgICAgIG5vbmNlLFxyXG4gICAgICAgICAgICAgICAgcGVuZGluZ1Rva2VuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uRkFDRUJPT0suXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxyXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBGYWNlYm9va0F1dGhQcm92aWRlcigpO1xyXG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCd1c2VyX2JpcnRoZGF5Jyk7XHJcbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XHJcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxyXG4gKlxyXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XHJcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xyXG4gKiBpZiAocmVzdWx0KSB7XHJcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XHJcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBGYWNlYm9vayBBY2Nlc3MgVG9rZW4uXHJcbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IEZhY2Vib29rQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XHJcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cclxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcclxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3VzZXJfYmlydGhkYXknKTtcclxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcclxuICpcclxuICogLy8gVGhlIHNpZ25lZC1pbiB1c2VyIGluZm8uXHJcbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcclxuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBGYWNlYm9vayBBY2Nlc3MgVG9rZW4uXHJcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xyXG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBGYWNlYm9va0F1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKFwiZmFjZWJvb2suY29tXCIgLyogUHJvdmlkZXJJZC5GQUNFQk9PSyAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIGZvciBGYWNlYm9vay5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICogLy8gYGV2ZW50YCBmcm9tIHRoZSBGYWNlYm9vayBhdXRoLmF1dGhSZXNwb25zZUNoYW5nZSBjYWxsYmFjay5cclxuICAgICAqIGNvbnN0IGNyZWRlbnRpYWwgPSBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsKGV2ZW50LmF1dGhSZXNwb25zZS5hY2Nlc3NUb2tlbik7XHJcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChjcmVkZW50aWFsKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWwoYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcclxuICAgICAgICAgICAgcHJvdmlkZXJJZDogRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXHJcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogRmFjZWJvb2tBdXRoUHJvdmlkZXIuRkFDRUJPT0tfU0lHTl9JTl9NRVRIT0QsXHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpIHtcclxuICAgICAgICByZXR1cm4gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xyXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xyXG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSB8fCAhKCdvYXV0aEFjY2Vzc1Rva2VuJyBpbiB0b2tlblJlc3BvbnNlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsKHRva2VuUmVzcG9uc2Uub2F1dGhBY2Nlc3NUb2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRkFDRUJPT0suICovXHJcbkZhY2Vib29rQXV0aFByb3ZpZGVyLkZBQ0VCT09LX1NJR05fSU5fTUVUSE9EID0gXCJmYWNlYm9vay5jb21cIiAvKiBTaWduSW5NZXRob2QuRkFDRUJPT0sgKi87XHJcbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5GQUNFQk9PSy4gKi9cclxuRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQgPSBcImZhY2Vib29rLmNvbVwiIC8qIFByb3ZpZGVySWQuRkFDRUJPT0sgKi87XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmb3Ige0BsaW5rIFByb3ZpZGVySWR9LkdPT0dMRS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXHJcbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEdvb2dsZUF1dGhQcm92aWRlcigpO1xyXG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdwcm9maWxlJyk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xyXG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xyXG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcclxuICpcclxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcclxuICogaWYgKHJlc3VsdCkge1xyXG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXHJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xyXG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR29vZ2xlIEFjY2VzcyBUb2tlbi5cclxuICogICBjb25zdCBjcmVkZW50aWFsID0gR29vZ2xlQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XHJcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cclxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgR29vZ2xlQXV0aFByb3ZpZGVyKCk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdwcm9maWxlJyk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xyXG4gKlxyXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cclxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xyXG4gKiAvLyBUaGlzIGdpdmVzIHlvdSBhIEdvb2dsZSBBY2Nlc3MgVG9rZW4uXHJcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcclxuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgR29vZ2xlQXV0aFByb3ZpZGVyIGV4dGVuZHMgQmFzZU9BdXRoUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoXCJnb29nbGUuY29tXCIgLyogUHJvdmlkZXJJZC5HT09HTEUgKi8pO1xyXG4gICAgICAgIHRoaXMuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNyZWRlbnRpYWwgZm9yIEdvb2dsZS4gQXQgbGVhc3Qgb25lIG9mIElEIHRva2VuIGFuZCBhY2Nlc3MgdG9rZW4gaXMgcmVxdWlyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIC8vIFxcYGdvb2dsZVVzZXJcXGAgZnJvbSB0aGUgb25zdWNjZXNzIEdvb2dsZSBTaWduIEluIGNhbGxiYWNrLlxyXG4gICAgICogY29uc3QgY3JlZGVudGlhbCA9IEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsKGdvb2dsZVVzZXIuZ2V0QXV0aFJlc3BvbnNlKCkuaWRfdG9rZW4pO1xyXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoY3JlZGVudGlhbCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWRUb2tlbiAtIEdvb2dsZSBJRCB0b2tlbi5cclxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsKGlkVG9rZW4sIGFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyh7XHJcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IEdvb2dsZUF1dGhQcm92aWRlci5QUk9WSURFUl9JRCxcclxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiBHb29nbGVBdXRoUHJvdmlkZXIuR09PR0xFX1NJR05fSU5fTUVUSE9ELFxyXG4gICAgICAgICAgICBpZFRva2VuLFxyXG4gICAgICAgICAgICBhY2Nlc3NUb2tlblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgcmV0dXJuIEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXHJcbiAgICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xyXG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBvYXV0aElkVG9rZW4sIG9hdXRoQWNjZXNzVG9rZW4gfSA9IHRva2VuUmVzcG9uc2U7XHJcbiAgICAgICAgaWYgKCFvYXV0aElkVG9rZW4gJiYgIW9hdXRoQWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBhbiBvYXV0aCAxIGNyZWRlbnRpYWwgb3IgYSBwaG9uZSBjcmVkZW50aWFsXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gR29vZ2xlQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwob2F1dGhJZFRva2VuLCBvYXV0aEFjY2Vzc1Rva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5HT09HTEUuICovXHJcbkdvb2dsZUF1dGhQcm92aWRlci5HT09HTEVfU0lHTl9JTl9NRVRIT0QgPSBcImdvb2dsZS5jb21cIiAvKiBTaWduSW5NZXRob2QuR09PR0xFICovO1xyXG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uR09PR0xFLiAqL1xyXG5Hb29nbGVBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQgPSBcImdvb2dsZS5jb21cIiAvKiBQcm92aWRlcklkLkdPT0dMRSAqLztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uR0lUSFVCLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBHaXRIdWIgcmVxdWlyZXMgYW4gT0F1dGggMi4wIHJlZGlyZWN0LCBzbyB5b3UgY2FuIGVpdGhlciBoYW5kbGUgdGhlIHJlZGlyZWN0IGRpcmVjdGx5LCBvciB1c2VcclxuICogdGhlIHtAbGluayBzaWduSW5XaXRoUG9wdXB9IGhhbmRsZXI6XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxyXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBHaXRodWJBdXRoUHJvdmlkZXIoKTtcclxuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxyXG4gKiBwcm92aWRlci5hZGRTY29wZSgncmVwbycpO1xyXG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xyXG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcclxuICpcclxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcclxuICogaWYgKHJlc3VsdCkge1xyXG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXHJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xyXG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR2l0aHViIEFjY2VzcyBUb2tlbi5cclxuICogICBjb25zdCBjcmVkZW50aWFsID0gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XHJcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cclxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgR2l0aHViQXV0aFByb3ZpZGVyKCk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdyZXBvJyk7XHJcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBwcm92aWRlcik7XHJcbiAqXHJcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxyXG4gKiBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XHJcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR2l0aHViIEFjY2VzcyBUb2tlbi5cclxuICogY29uc3QgY3JlZGVudGlhbCA9IEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xyXG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XHJcbiAqIGBgYFxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBHaXRodWJBdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihcImdpdGh1Yi5jb21cIiAvKiBQcm92aWRlcklkLkdJVEhVQiAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIGZvciBHaXRodWIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIC0gR2l0aHViIGFjY2VzcyB0b2tlbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWwoYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcclxuICAgICAgICAgICAgcHJvdmlkZXJJZDogR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lELFxyXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IEdpdGh1YkF1dGhQcm92aWRlci5HSVRIVUJfU0lHTl9JTl9NRVRIT0QsXHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpIHtcclxuICAgICAgICByZXR1cm4gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHVzZXJDcmVkZW50aWFsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcclxuICAgICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XHJcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlIHx8ICEoJ29hdXRoQWNjZXNzVG9rZW4nIGluIHRva2VuUmVzcG9uc2UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2Uub2F1dGhBY2Nlc3NUb2tlbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsKHRva2VuUmVzcG9uc2Uub2F1dGhBY2Nlc3NUb2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uR0lUSFVCLiAqL1xyXG5HaXRodWJBdXRoUHJvdmlkZXIuR0lUSFVCX1NJR05fSU5fTUVUSE9EID0gXCJnaXRodWIuY29tXCIgLyogU2lnbkluTWV0aG9kLkdJVEhVQiAqLztcclxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LkdJVEhVQi4gKi9cclxuR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEID0gXCJnaXRodWIuY29tXCIgLyogUHJvdmlkZXJJZC5HSVRIVUIgKi87XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IElEUF9SRVFVRVNUX1VSSSA9ICdodHRwOi8vbG9jYWxob3N0JztcclxuLyoqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIFNBTUxBdXRoQ3JlZGVudGlhbCBleHRlbmRzIEF1dGhDcmVkZW50aWFsIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbikge1xyXG4gICAgICAgIHN1cGVyKHByb3ZpZGVySWQsIHByb3ZpZGVySWQpO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Rva2VuID0gcGVuZGluZ1Rva2VuO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2dldElkVG9rZW5SZXNwb25zZShhdXRoKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XHJcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfbGlua1RvSWRUb2tlbihhdXRoLCBpZFRva2VuKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XHJcbiAgICAgICAgcmVxdWVzdC5pZFRva2VuID0gaWRUb2tlbjtcclxuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9nZXRSZWF1dGhlbnRpY2F0aW9uUmVzb2x2ZXIoYXV0aCkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xyXG4gICAgICAgIHJlcXVlc3QuYXV0b0NyZWF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqIHtAaW5oZXJpdGRvYyBBdXRoQ3JlZGVudGlhbC50b0pTT059ICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogdGhpcy5zaWduSW5NZXRob2QsXHJcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCxcclxuICAgICAgICAgICAgcGVuZGluZ1Rva2VuOiB0aGlzLnBlbmRpbmdUb2tlblxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXRpYyBtZXRob2QgdG8gZGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbnRvIGFuXHJcbiAgICAgKiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ganNvbiAtIElucHV0IGNhbiBiZSBlaXRoZXIgT2JqZWN0IG9yIHRoZSBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogV2hlbiBzdHJpbmcgaXMgcHJvdmlkZWQsIEpTT04ucGFyc2Ugd291bGQgYmUgY2FsbGVkIGZpcnN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIElmIHRoZSBKU09OIGlucHV0IGRvZXMgbm90IHJlcHJlc2VudCBhbiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfSwgbnVsbCBpcyByZXR1cm5lZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBjb25zdCBvYmogPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcclxuICAgICAgICBjb25zdCB7IHByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZCwgcGVuZGluZ1Rva2VuIH0gPSBvYmo7XHJcbiAgICAgICAgaWYgKCFwcm92aWRlcklkIHx8XHJcbiAgICAgICAgICAgICFzaWduSW5NZXRob2QgfHxcclxuICAgICAgICAgICAgIXBlbmRpbmdUb2tlbiB8fFxyXG4gICAgICAgICAgICBwcm92aWRlcklkICE9PSBzaWduSW5NZXRob2QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU0FNTEF1dGhDcmVkZW50aWFsKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBzdGF0aWMgbWV0aG9kIHRvIGF2b2lkIGV4cG9zaW5nIHRoZSBjb25zdHJ1Y3RvciB0byBlbmQgdXNlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBfY3JlYXRlKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgU0FNTEF1dGhDcmVkZW50aWFsKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbik7XHJcbiAgICB9XHJcbiAgICBidWlsZFJlcXVlc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVxdWVzdFVyaTogSURQX1JFUVVFU1RfVVJJLFxyXG4gICAgICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZSxcclxuICAgICAgICAgICAgcGVuZGluZ1Rva2VuOiB0aGlzLnBlbmRpbmdUb2tlblxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgU0FNTF9QUk9WSURFUl9QUkVGSVggPSAnc2FtbC4nO1xyXG4vKipcclxuICogQW4ge0BsaW5rIEF1dGhQcm92aWRlcn0gZm9yIFNBTUwuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIFNBTUxBdXRoUHJvdmlkZXIgZXh0ZW5kcyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3Rvci4gVGhlIHByb3ZpZGVySWQgbXVzdCBzdGFydCB3aXRoIFwic2FtbC5cIlxyXG4gICAgICogQHBhcmFtIHByb3ZpZGVySWQgLSBTQU1MIHByb3ZpZGVyIElELlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcklkKSB7XHJcbiAgICAgICAgX2Fzc2VydChwcm92aWRlcklkLnN0YXJ0c1dpdGgoU0FNTF9QUk9WSURFUl9QUkVGSVgpLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICAgICAgc3VwZXIocHJvdmlkZXJJZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9IGFmdGVyIGFcclxuICAgICAqIHN1Y2Nlc3NmdWwgU0FNTCBmbG93IGNvbXBsZXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlLCB0byBnZXQgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSwgeW91IGNvdWxkIHdyaXRlIHRoZVxyXG4gICAgICogZm9sbG93aW5nIGNvZGU6XHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHNhbWxQcm92aWRlcik7XHJcbiAgICAgKiBjb25zdCBjcmVkZW50aWFsID0gU0FNTEF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpIHtcclxuICAgICAgICByZXR1cm4gU0FNTEF1dGhQcm92aWRlci5zYW1sQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xyXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBTQU1MQXV0aFByb3ZpZGVyLnNhbWxDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gZnJvbSBhIEpTT04gc3RyaW5nIG9yIGEgcGxhaW4gb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGpzb24gLSBBIHBsYWluIG9iamVjdCBvciBhIEpTT04gc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWwgPSBTQU1MQXV0aENyZWRlbnRpYWwuZnJvbUpTT04oanNvbik7XHJcbiAgICAgICAgX2Fzc2VydChjcmVkZW50aWFsLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWRlbnRpYWw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2FtbENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xyXG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBwZW5kaW5nVG9rZW4sIHByb3ZpZGVySWQgfSA9IHRva2VuUmVzcG9uc2U7XHJcbiAgICAgICAgaWYgKCFwZW5kaW5nVG9rZW4gfHwgIXByb3ZpZGVySWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTQU1MQXV0aENyZWRlbnRpYWwuX2NyZWF0ZShwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uVFdJVFRFUi5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXHJcbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IFR3aXR0ZXJBdXRoUHJvdmlkZXIoKTtcclxuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxyXG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xyXG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcclxuICpcclxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcclxuICogaWYgKHJlc3VsdCkge1xyXG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXHJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xyXG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgVHdpdHRlciBBY2Nlc3MgVG9rZW4gYW5kIFNlY3JldC5cclxuICogICBjb25zdCBjcmVkZW50aWFsID0gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xyXG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcclxuICogICBjb25zdCBzZWNyZXQgPSBjcmVkZW50aWFsLnNlY3JldDtcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXHJcbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IFR3aXR0ZXJBdXRoUHJvdmlkZXIoKTtcclxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcclxuICpcclxuICogLy8gVGhlIHNpZ25lZC1pbiB1c2VyIGluZm8uXHJcbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcclxuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBUd2l0dGVyIEFjY2VzcyBUb2tlbiBhbmQgU2VjcmV0LlxyXG4gKiBjb25zdCBjcmVkZW50aWFsID0gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xyXG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XHJcbiAqIGNvbnN0IHNlY3JldCA9IGNyZWRlbnRpYWwuc2VjcmV0O1xyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgVHdpdHRlckF1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKFwidHdpdHRlci5jb21cIiAvKiBQcm92aWRlcklkLlRXSVRURVIgKi8pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBmb3IgVHdpdHRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBUd2l0dGVyIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBwYXJhbSBzZWNyZXQgLSBUd2l0dGVyIHNlY3JldC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWwodG9rZW4sIHNlY3JldCkge1xyXG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoe1xyXG4gICAgICAgICAgICBwcm92aWRlcklkOiBUd2l0dGVyQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lELFxyXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IFR3aXR0ZXJBdXRoUHJvdmlkZXIuVFdJVFRFUl9TSUdOX0lOX01FVEhPRCxcclxuICAgICAgICAgICAgb2F1dGhUb2tlbjogdG9rZW4sXHJcbiAgICAgICAgICAgIG9hdXRoVG9rZW5TZWNyZXQ6IHNlY3JldFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgcmV0dXJuIFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xyXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBUd2l0dGVyQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XHJcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IG9hdXRoQWNjZXNzVG9rZW4sIG9hdXRoVG9rZW5TZWNyZXQgfSA9IHRva2VuUmVzcG9uc2U7XHJcbiAgICAgICAgaWYgKCFvYXV0aEFjY2Vzc1Rva2VuIHx8ICFvYXV0aFRva2VuU2VjcmV0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsKG9hdXRoQWNjZXNzVG9rZW4sIG9hdXRoVG9rZW5TZWNyZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LlRXSVRURVIuICovXHJcblR3aXR0ZXJBdXRoUHJvdmlkZXIuVFdJVFRFUl9TSUdOX0lOX01FVEhPRCA9IFwidHdpdHRlci5jb21cIiAvKiBTaWduSW5NZXRob2QuVFdJVFRFUiAqLztcclxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LlRXSVRURVIuICovXHJcblR3aXR0ZXJBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQgPSBcInR3aXR0ZXIuY29tXCIgLyogUHJvdmlkZXJJZC5UV0lUVEVSICovO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzaWduVXAoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25VcFwiIC8qIEVuZHBvaW50LlNJR05fVVAgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgVXNlckNyZWRlbnRpYWxJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMudXNlciA9IHBhcmFtcy51c2VyO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IHBhcmFtcy5wcm92aWRlcklkO1xyXG4gICAgICAgIHRoaXMuX3Rva2VuUmVzcG9uc2UgPSBwYXJhbXMuX3Rva2VuUmVzcG9uc2U7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25UeXBlID0gcGFyYW1zLm9wZXJhdGlvblR5cGU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aCwgb3BlcmF0aW9uVHlwZSwgaWRUb2tlblJlc3BvbnNlLCBpc0Fub255bW91cyA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IFVzZXJJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIGlkVG9rZW5SZXNwb25zZSwgaXNBbm9ueW1vdXMpO1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVySWQgPSBwcm92aWRlcklkRm9yUmVzcG9uc2UoaWRUb2tlblJlc3BvbnNlKTtcclxuICAgICAgICBjb25zdCB1c2VyQ3JlZCA9IG5ldyBVc2VyQ3JlZGVudGlhbEltcGwoe1xyXG4gICAgICAgICAgICB1c2VyLFxyXG4gICAgICAgICAgICBwcm92aWRlcklkLFxyXG4gICAgICAgICAgICBfdG9rZW5SZXNwb25zZTogaWRUb2tlblJlc3BvbnNlLFxyXG4gICAgICAgICAgICBvcGVyYXRpb25UeXBlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHVzZXJDcmVkO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIF9mb3JPcGVyYXRpb24odXNlciwgb3BlcmF0aW9uVHlwZSwgcmVzcG9uc2UpIHtcclxuICAgICAgICBhd2FpdCB1c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShyZXNwb25zZSwgLyogcmVsb2FkICovIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVySWQgPSBwcm92aWRlcklkRm9yUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVXNlckNyZWRlbnRpYWxJbXBsKHtcclxuICAgICAgICAgICAgdXNlcixcclxuICAgICAgICAgICAgcHJvdmlkZXJJZCxcclxuICAgICAgICAgICAgX3Rva2VuUmVzcG9uc2U6IHJlc3BvbnNlLFxyXG4gICAgICAgICAgICBvcGVyYXRpb25UeXBlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcHJvdmlkZXJJZEZvclJlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICBpZiAocmVzcG9uc2UucHJvdmlkZXJJZCkge1xyXG4gICAgICAgIHJldHVybiByZXNwb25zZS5wcm92aWRlcklkO1xyXG4gICAgfVxyXG4gICAgaWYgKCdwaG9uZU51bWJlcicgaW4gcmVzcG9uc2UpIHtcclxuICAgICAgICByZXR1cm4gXCJwaG9uZVwiIC8qIFByb3ZpZGVySWQuUEhPTkUgKi87XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gYXMgYW4gYW5vbnltb3VzIHVzZXIuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIElmIHRoZXJlIGlzIGFscmVhZHkgYW4gYW5vbnltb3VzIHVzZXIgc2lnbmVkIGluLCB0aGF0IHVzZXIgd2lsbCBiZSByZXR1cm5lZDsgb3RoZXJ3aXNlLCBhXHJcbiAqIG5ldyBhbm9ueW1vdXMgdXNlciBpZGVudGl0eSB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcclxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbkFub255bW91c2x5KGF1dGgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xyXG4gICAgYXdhaXQgYXV0aEludGVybmFsLl9pbml0aWFsaXphdGlvblByb21pc2U7XHJcbiAgICBpZiAoKF9hID0gYXV0aEludGVybmFsLmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNBbm9ueW1vdXMpIHtcclxuICAgICAgICAvLyBJZiBhbiBhbm9ueW1vdXMgdXNlciBpcyBhbHJlYWR5IHNpZ25lZCBpbiwgbm8gbmVlZCB0byBzaWduIHRoZW0gaW4gYWdhaW4uXHJcbiAgICAgICAgcmV0dXJuIG5ldyBVc2VyQ3JlZGVudGlhbEltcGwoe1xyXG4gICAgICAgICAgICB1c2VyOiBhdXRoSW50ZXJuYWwuY3VycmVudFVzZXIsXHJcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IG51bGwsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvblR5cGU6IFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpZ25VcChhdXRoSW50ZXJuYWwsIHtcclxuICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoSW50ZXJuYWwsIFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovLCByZXNwb25zZSwgdHJ1ZSk7XHJcbiAgICBhd2FpdCBhdXRoSW50ZXJuYWwuX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xyXG4gICAgcmV0dXJuIHVzZXJDcmVkZW50aWFsO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE11bHRpRmFjdG9yRXJyb3IgZXh0ZW5kcyBGaXJlYmFzZUVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGgsIGVycm9yLCBvcGVyYXRpb25UeXBlLCB1c2VyKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHN1cGVyKGVycm9yLmNvZGUsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uVHlwZSA9IG9wZXJhdGlvblR5cGU7XHJcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21hc3Rlci9CcmVha2luZy1DaGFuZ2VzLm1kI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBNdWx0aUZhY3RvckVycm9yLnByb3RvdHlwZSk7XHJcbiAgICAgICAgdGhpcy5jdXN0b21EYXRhID0ge1xyXG4gICAgICAgICAgICBhcHBOYW1lOiBhdXRoLm5hbWUsXHJcbiAgICAgICAgICAgIHRlbmFudElkOiAoX2EgPSBhdXRoLnRlbmFudElkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIF9zZXJ2ZXJSZXNwb25zZTogZXJyb3IuY3VzdG9tRGF0YS5fc2VydmVyUmVzcG9uc2UsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvblR5cGVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9mcm9tRXJyb3JBbmRPcGVyYXRpb24oYXV0aCwgZXJyb3IsIG9wZXJhdGlvblR5cGUsIHVzZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yRXJyb3IoYXV0aCwgZXJyb3IsIG9wZXJhdGlvblR5cGUsIHVzZXIpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeShhdXRoLCBvcGVyYXRpb25UeXBlLCBjcmVkZW50aWFsLCB1c2VyKSB7XHJcbiAgICBjb25zdCBpZFRva2VuUHJvdmlkZXIgPSBvcGVyYXRpb25UeXBlID09PSBcInJlYXV0aGVudGljYXRlXCIgLyogT3BlcmF0aW9uVHlwZS5SRUFVVEhFTlRJQ0FURSAqL1xyXG4gICAgICAgID8gY3JlZGVudGlhbC5fZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpXHJcbiAgICAgICAgOiBjcmVkZW50aWFsLl9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCk7XHJcbiAgICByZXR1cm4gaWRUb2tlblByb3ZpZGVyLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtcIm11bHRpLWZhY3Rvci1hdXRoLXJlcXVpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5NRkFfUkVRVUlSRUQgKi99YCkge1xyXG4gICAgICAgICAgICB0aHJvdyBNdWx0aUZhY3RvckVycm9yLl9mcm9tRXJyb3JBbmRPcGVyYXRpb24oYXV0aCwgZXJyb3IsIG9wZXJhdGlvblR5cGUsIHVzZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUYWtlcyBhIHNldCBvZiBVc2VySW5mbyBwcm92aWRlciBkYXRhIGFuZCBjb252ZXJ0cyBpdCB0byBhIHNldCBvZiBuYW1lc1xyXG4gKi9cclxuZnVuY3Rpb24gcHJvdmlkZXJEYXRhQXNOYW1lcyhwcm92aWRlckRhdGEpIHtcclxuICAgIHJldHVybiBuZXcgU2V0KHByb3ZpZGVyRGF0YVxyXG4gICAgICAgIC5tYXAoKHsgcHJvdmlkZXJJZCB9KSA9PiBwcm92aWRlcklkKVxyXG4gICAgICAgIC5maWx0ZXIocGlkID0+ICEhcGlkKSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFVubGlua3MgYSBwcm92aWRlciBmcm9tIGEgdXNlciBhY2NvdW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxyXG4gKiBAcGFyYW0gcHJvdmlkZXJJZCAtIFRoZSBwcm92aWRlciB0byB1bmxpbmsuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHVubGluayh1c2VyLCBwcm92aWRlcklkKSB7XHJcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XHJcbiAgICBhd2FpdCBfYXNzZXJ0TGlua2VkU3RhdHVzKHRydWUsIHVzZXJJbnRlcm5hbCwgcHJvdmlkZXJJZCk7XHJcbiAgICBjb25zdCB7IHByb3ZpZGVyVXNlckluZm8gfSA9IGF3YWl0IGRlbGV0ZUxpbmtlZEFjY291bnRzKHVzZXJJbnRlcm5hbC5hdXRoLCB7XHJcbiAgICAgICAgaWRUb2tlbjogYXdhaXQgdXNlckludGVybmFsLmdldElkVG9rZW4oKSxcclxuICAgICAgICBkZWxldGVQcm92aWRlcjogW3Byb3ZpZGVySWRdXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHByb3ZpZGVyc0xlZnQgPSBwcm92aWRlckRhdGFBc05hbWVzKHByb3ZpZGVyVXNlckluZm8gfHwgW10pO1xyXG4gICAgdXNlckludGVybmFsLnByb3ZpZGVyRGF0YSA9IHVzZXJJbnRlcm5hbC5wcm92aWRlckRhdGEuZmlsdGVyKHBkID0+IHByb3ZpZGVyc0xlZnQuaGFzKHBkLnByb3ZpZGVySWQpKTtcclxuICAgIGlmICghcHJvdmlkZXJzTGVmdC5oYXMoXCJwaG9uZVwiIC8qIFByb3ZpZGVySWQuUEhPTkUgKi8pKSB7XHJcbiAgICAgICAgdXNlckludGVybmFsLnBob25lTnVtYmVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIGF3YWl0IHVzZXJJbnRlcm5hbC5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh1c2VySW50ZXJuYWwpO1xyXG4gICAgcmV0dXJuIHVzZXJJbnRlcm5hbDtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBfbGluayh1c2VyLCBjcmVkZW50aWFsLCBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VyLCBjcmVkZW50aWFsLl9saW5rVG9JZFRva2VuKHVzZXIuYXV0aCwgYXdhaXQgdXNlci5nZXRJZFRva2VuKCkpLCBieXBhc3NBdXRoU3RhdGUpO1xyXG4gICAgcmV0dXJuIFVzZXJDcmVkZW50aWFsSW1wbC5fZm9yT3BlcmF0aW9uKHVzZXIsIFwibGlua1wiIC8qIE9wZXJhdGlvblR5cGUuTElOSyAqLywgcmVzcG9uc2UpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIF9hc3NlcnRMaW5rZWRTdGF0dXMoZXhwZWN0ZWQsIHVzZXIsIHByb3ZpZGVyKSB7XHJcbiAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKTtcclxuICAgIGNvbnN0IHByb3ZpZGVySWRzID0gcHJvdmlkZXJEYXRhQXNOYW1lcyh1c2VyLnByb3ZpZGVyRGF0YSk7XHJcbiAgICBjb25zdCBjb2RlID0gZXhwZWN0ZWQgPT09IGZhbHNlXHJcbiAgICAgICAgPyBcInByb3ZpZGVyLWFscmVhZHktbGlua2VkXCIgLyogQXV0aEVycm9yQ29kZS5QUk9WSURFUl9BTFJFQURZX0xJTktFRCAqL1xyXG4gICAgICAgIDogXCJuby1zdWNoLXByb3ZpZGVyXCIgLyogQXV0aEVycm9yQ29kZS5OT19TVUNIX1BST1ZJREVSICovO1xyXG4gICAgX2Fzc2VydChwcm92aWRlcklkcy5oYXMocHJvdmlkZXIpID09PSBleHBlY3RlZCwgdXNlci5hdXRoLCBjb2RlKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBfcmVhdXRoZW50aWNhdGUodXNlciwgY3JlZGVudGlhbCwgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHsgYXV0aCB9ID0gdXNlcjtcclxuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3BlcmF0aW9uVHlwZSA9IFwicmVhdXRoZW50aWNhdGVcIiAvKiBPcGVyYXRpb25UeXBlLlJFQVVUSEVOVElDQVRFICovO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHVzZXIsIF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeShhdXRoLCBvcGVyYXRpb25UeXBlLCBjcmVkZW50aWFsLCB1c2VyKSwgYnlwYXNzQXV0aFN0YXRlKTtcclxuICAgICAgICBfYXNzZXJ0KHJlc3BvbnNlLmlkVG9rZW4sIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBjb25zdCBwYXJzZWQgPSBfcGFyc2VUb2tlbihyZXNwb25zZS5pZFRva2VuKTtcclxuICAgICAgICBfYXNzZXJ0KHBhcnNlZCwgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIGNvbnN0IHsgc3ViOiBsb2NhbElkIH0gPSBwYXJzZWQ7XHJcbiAgICAgICAgX2Fzc2VydCh1c2VyLnVpZCA9PT0gbG9jYWxJZCwgYXV0aCwgXCJ1c2VyLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX01JU01BVENIICovKTtcclxuICAgICAgICByZXR1cm4gVXNlckNyZWRlbnRpYWxJbXBsLl9mb3JPcGVyYXRpb24odXNlciwgb3BlcmF0aW9uVHlwZSwgcmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBDb252ZXJ0IHVzZXIgZGVsZXRlZCBlcnJvciBpbnRvIHVzZXIgbWlzbWF0Y2hcclxuICAgICAgICBpZiAoKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5jb2RlKSA9PT0gYGF1dGgvJHtcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi99YCkge1xyXG4gICAgICAgICAgICBfZmFpbChhdXRoLCBcInVzZXItbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfTUlTTUFUQ0ggKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIF9zaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBjcmVkZW50aWFsLCBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZSkge1xyXG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvcGVyYXRpb25UeXBlID0gXCJzaWduSW5cIiAvKiBPcGVyYXRpb25UeXBlLlNJR05fSU4gKi87XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeShhdXRoLCBvcGVyYXRpb25UeXBlLCBjcmVkZW50aWFsKTtcclxuICAgIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIG9wZXJhdGlvblR5cGUsIHJlc3BvbnNlKTtcclxuICAgIGlmICghYnlwYXNzQXV0aFN0YXRlKSB7XHJcbiAgICAgICAgYXdhaXQgYXV0aC5fdXBkYXRlQ3VycmVudFVzZXIodXNlckNyZWRlbnRpYWwudXNlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXNlckNyZWRlbnRpYWw7XHJcbn1cclxuLyoqXHJcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHdpdGggdGhlIGdpdmVuIGNyZWRlbnRpYWxzLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBBbiB7QGxpbmsgQXV0aFByb3ZpZGVyfSBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY3JlZGVudGlhbC5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gY3JlZGVudGlhbCAtIFRoZSBhdXRoIGNyZWRlbnRpYWwuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIGNyZWRlbnRpYWwpIHtcclxuICAgIHJldHVybiBfc2lnbkluV2l0aENyZWRlbnRpYWwoX2Nhc3RBdXRoKGF1dGgpLCBjcmVkZW50aWFsKTtcclxufVxyXG4vKipcclxuICogTGlua3MgdGhlIHVzZXIgYWNjb3VudCB3aXRoIHRoZSBnaXZlbiBjcmVkZW50aWFscy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogQW4ge0BsaW5rIEF1dGhQcm92aWRlcn0gY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNyZWRlbnRpYWwuXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqIEBwYXJhbSBjcmVkZW50aWFsIC0gVGhlIGF1dGggY3JlZGVudGlhbC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gbGlua1dpdGhDcmVkZW50aWFsKHVzZXIsIGNyZWRlbnRpYWwpIHtcclxuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcclxuICAgIGF3YWl0IF9hc3NlcnRMaW5rZWRTdGF0dXMoZmFsc2UsIHVzZXJJbnRlcm5hbCwgY3JlZGVudGlhbC5wcm92aWRlcklkKTtcclxuICAgIHJldHVybiBfbGluayh1c2VySW50ZXJuYWwsIGNyZWRlbnRpYWwpO1xyXG59XHJcbi8qKlxyXG4gKiBSZS1hdXRoZW50aWNhdGVzIGEgdXNlciB1c2luZyBhIGZyZXNoIGNyZWRlbnRpYWwuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFVzZSBiZWZvcmUgb3BlcmF0aW9ucyBzdWNoIGFzIHtAbGluayB1cGRhdGVQYXNzd29yZH0gdGhhdCByZXF1aXJlIHRva2VucyBmcm9tIHJlY2VudCBzaWduLWluXHJcbiAqIGF0dGVtcHRzLiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byByZWNvdmVyIGZyb20gYSBgQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOYCBlcnJvclxyXG4gKiBvciBhIGBUT0tFTl9FWFBJUkVEYCBlcnJvci5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBvbiBhbnkge0BsaW5rIFVzZXJ9IHNpZ25lZCBpbiBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzXHJcbiAqIGNyZWF0ZWQgd2l0aCBhIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cclxuICogQHBhcmFtIGNyZWRlbnRpYWwgLSBUaGUgYXV0aCBjcmVkZW50aWFsLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsKHVzZXIsIGNyZWRlbnRpYWwpIHtcclxuICAgIHJldHVybiBfcmVhdXRoZW50aWNhdGUoZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpLCBjcmVkZW50aWFsKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoQ3VzdG9tVG9rZW4kMShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aEN1c3RvbVRva2VuXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0NVU1RPTV9UT0tFTiAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gdXNpbmcgYSBjdXN0b20gdG9rZW4uXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIEN1c3RvbSB0b2tlbnMgYXJlIHVzZWQgdG8gaW50ZWdyYXRlIEZpcmViYXNlIEF1dGggd2l0aCBleGlzdGluZyBhdXRoIHN5c3RlbXMsIGFuZCBtdXN0XHJcbiAqIGJlIGdlbmVyYXRlZCBieSBhbiBhdXRoIGJhY2tlbmQgdXNpbmcgdGhlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9yZWZlcmVuY2UvYWRtaW4vbm9kZS9hZG1pbi5hdXRoLkF1dGgjY3JlYXRlY3VzdG9tdG9rZW4gfCBjcmVhdGVDdXN0b21Ub2tlbn1cclxuICogbWV0aG9kIGluIHRoZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvYXV0aC9hZG1pbiB8IEFkbWluIFNES30gLlxyXG4gKlxyXG4gKiBGYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSB0b2tlbiBpcyBpbnZhbGlkLCBleHBpcmVkLCBvciBub3QgYWNjZXB0ZWQgYnkgdGhlIEZpcmViYXNlIEF1dGggc2VydmljZS5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gY3VzdG9tVG9rZW4gLSBUaGUgY3VzdG9tIHRva2VuIHRvIHNpZ24gaW4gd2l0aC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEN1c3RvbVRva2VuKGF1dGgsIGN1c3RvbVRva2VuKSB7XHJcbiAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2lnbkluV2l0aEN1c3RvbVRva2VuJDEoYXV0aEludGVybmFsLCB7XHJcbiAgICAgICAgdG9rZW46IGN1c3RvbVRva2VuLFxyXG4gICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNyZWQgPSBhd2FpdCBVc2VyQ3JlZGVudGlhbEltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aEludGVybmFsLCBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqLywgcmVzcG9uc2UpO1xyXG4gICAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVDdXJyZW50VXNlcihjcmVkLnVzZXIpO1xyXG4gICAgcmV0dXJuIGNyZWQ7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTXVsdGlGYWN0b3JJbmZvSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3JJZCwgcmVzcG9uc2UpIHtcclxuICAgICAgICB0aGlzLmZhY3RvcklkID0gZmFjdG9ySWQ7XHJcbiAgICAgICAgdGhpcy51aWQgPSByZXNwb25zZS5tZmFFbnJvbGxtZW50SWQ7XHJcbiAgICAgICAgdGhpcy5lbnJvbGxtZW50VGltZSA9IG5ldyBEYXRlKHJlc3BvbnNlLmVucm9sbGVkQXQpLnRvVVRDU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5TmFtZSA9IHJlc3BvbnNlLmRpc3BsYXlOYW1lO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9mcm9tU2VydmVyUmVzcG9uc2UoYXV0aCwgZW5yb2xsbWVudCkge1xyXG4gICAgICAgIGlmICgncGhvbmVJbmZvJyBpbiBlbnJvbGxtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQaG9uZU11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZShhdXRoLCBlbnJvbGxtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ3RvdHBJbmZvJyBpbiBlbnJvbGxtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUb3RwTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKGF1dGgsIGVucm9sbG1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2ZhaWwoYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFBob25lTXVsdGlGYWN0b3JJbmZvSW1wbCBleHRlbmRzIE11bHRpRmFjdG9ySW5mb0ltcGwge1xyXG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcclxuICAgICAgICBzdXBlcihcInBob25lXCIgLyogRmFjdG9ySWQuUEhPTkUgKi8sIHJlc3BvbnNlKTtcclxuICAgICAgICB0aGlzLnBob25lTnVtYmVyID0gcmVzcG9uc2UucGhvbmVJbmZvO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9mcm9tU2VydmVyUmVzcG9uc2UoX2F1dGgsIGVucm9sbG1lbnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBob25lTXVsdGlGYWN0b3JJbmZvSW1wbChlbnJvbGxtZW50KTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBUb3RwTXVsdGlGYWN0b3JJbmZvSW1wbCBleHRlbmRzIE11bHRpRmFjdG9ySW5mb0ltcGwge1xyXG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcclxuICAgICAgICBzdXBlcihcInRvdHBcIiAvKiBGYWN0b3JJZC5UT1RQICovLCByZXNwb25zZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2Zyb21TZXJ2ZXJSZXNwb25zZShfYXV0aCwgZW5yb2xsbWVudCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVG90cE11bHRpRmFjdG9ySW5mb0ltcGwoZW5yb2xsbWVudCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChhdXRoLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgIHZhciBfYTtcclxuICAgIF9hc3NlcnQoKChfYSA9IGFjdGlvbkNvZGVTZXR0aW5ncy51cmwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID4gMCwgYXV0aCwgXCJpbnZhbGlkLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT05USU5VRV9VUkkgKi8pO1xyXG4gICAgX2Fzc2VydCh0eXBlb2YgYWN0aW9uQ29kZVNldHRpbmdzLmR5bmFtaWNMaW5rRG9tYWluID09PSAndW5kZWZpbmVkJyB8fFxyXG4gICAgICAgIGFjdGlvbkNvZGVTZXR0aW5ncy5keW5hbWljTGlua0RvbWFpbi5sZW5ndGggPiAwLCBhdXRoLCBcImludmFsaWQtZHluYW1pYy1saW5rLWRvbWFpblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9EWU5BTUlDX0xJTktfRE9NQUlOICovKTtcclxuICAgIHJlcXVlc3QuY29udGludWVVcmwgPSBhY3Rpb25Db2RlU2V0dGluZ3MudXJsO1xyXG4gICAgcmVxdWVzdC5keW5hbWljTGlua0RvbWFpbiA9IGFjdGlvbkNvZGVTZXR0aW5ncy5keW5hbWljTGlua0RvbWFpbjtcclxuICAgIHJlcXVlc3QuY2FuSGFuZGxlQ29kZUluQXBwID0gYWN0aW9uQ29kZVNldHRpbmdzLmhhbmRsZUNvZGVJbkFwcDtcclxuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MuaU9TKSB7XHJcbiAgICAgICAgX2Fzc2VydChhY3Rpb25Db2RlU2V0dGluZ3MuaU9TLmJ1bmRsZUlkLmxlbmd0aCA+IDAsIGF1dGgsIFwibWlzc2luZy1pb3MtYnVuZGxlLWlkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0lPU19CVU5ETEVfSUQgKi8pO1xyXG4gICAgICAgIHJlcXVlc3QuaU9TQnVuZGxlSWQgPSBhY3Rpb25Db2RlU2V0dGluZ3MuaU9TLmJ1bmRsZUlkO1xyXG4gICAgfVxyXG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkKSB7XHJcbiAgICAgICAgX2Fzc2VydChhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5wYWNrYWdlTmFtZS5sZW5ndGggPiAwLCBhdXRoLCBcIm1pc3NpbmctYW5kcm9pZC1wa2ctbmFtZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSAqLyk7XHJcbiAgICAgICAgcmVxdWVzdC5hbmRyb2lkSW5zdGFsbEFwcCA9IGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkLmluc3RhbGxBcHA7XHJcbiAgICAgICAgcmVxdWVzdC5hbmRyb2lkTWluaW11bVZlcnNpb25Db2RlID1cclxuICAgICAgICAgICAgYWN0aW9uQ29kZVNldHRpbmdzLmFuZHJvaWQubWluaW11bVZlcnNpb247XHJcbiAgICAgICAgcmVxdWVzdC5hbmRyb2lkUGFja2FnZU5hbWUgPSBhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5wYWNrYWdlTmFtZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVXBkYXRlcyB0aGUgcGFzc3dvcmQgcG9saWN5IGNhY2hlZCBpbiB0aGUge0BsaW5rIEF1dGh9IGluc3RhbmNlIGlmIGEgcG9saWN5IGlzIGFscmVhZHlcclxuICogY2FjaGVkIGZvciB0aGUgcHJvamVjdCBvciB0ZW5hbnQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFdlIG9ubHkgZmV0Y2ggdGhlIHBhc3N3b3JkIHBvbGljeSBpZiB0aGUgcGFzc3dvcmQgZGlkIG5vdCBtZWV0IHBvbGljeSByZXF1aXJlbWVudHMgYW5kXHJcbiAqIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHBvbGljeSBjYWNoZWQuIEEgZGV2ZWxvcGVyIG11c3QgY2FsbCB2YWxpZGF0ZVBhc3N3b3JkIGF0IGxlYXN0XHJcbiAqIG9uY2UgZm9yIHRoZSBjYWNoZSB0byBiZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJlY2FjaGVQYXNzd29yZFBvbGljeShhdXRoKSB7XHJcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XHJcbiAgICBpZiAoYXV0aEludGVybmFsLl9nZXRQYXNzd29yZFBvbGljeUludGVybmFsKCkpIHtcclxuICAgICAgICBhd2FpdCBhdXRoSW50ZXJuYWwuX3VwZGF0ZVBhc3N3b3JkUG9saWN5KCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNlbmRzIGEgcGFzc3dvcmQgcmVzZXQgZW1haWwgdG8gdGhlIGdpdmVuIGVtYWlsIGFkZHJlc3MuIFRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHdoZW5cclxuICogdGhlcmUncyBubyB1c2VyIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gZW1haWwgYWRkcmVzcyBhbmRcclxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufVxyXG4gKiBpcyBlbmFibGVkLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUbyBjb21wbGV0ZSB0aGUgcGFzc3dvcmQgcmVzZXQsIGNhbGwge0BsaW5rIGNvbmZpcm1QYXNzd29yZFJlc2V0fSB3aXRoIHRoZSBjb2RlIHN1cHBsaWVkIGluXHJcbiAqIHRoZSBlbWFpbCBzZW50IHRvIHRoZSB1c2VyLCBhbG9uZyB3aXRoIHRoZSBuZXcgcGFzc3dvcmQgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGNvbnN0IGFjdGlvbkNvZGVTZXR0aW5ncyA9IHtcclxuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXHJcbiAqICAgaU9TOiB7XHJcbiAqICAgICAgYnVuZGxlSWQ6ICdjb20uZXhhbXBsZS5pb3MnXHJcbiAqICAgfSxcclxuICogICBhbmRyb2lkOiB7XHJcbiAqICAgICBwYWNrYWdlTmFtZTogJ2NvbS5leGFtcGxlLmFuZHJvaWQnLFxyXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcclxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXHJcbiAqICAgfSxcclxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcclxuICogfTtcclxuICogYXdhaXQgc2VuZFBhc3N3b3JkUmVzZXRFbWFpbChhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XHJcbiAqIC8vIE9idGFpbiBjb2RlIGZyb20gdXNlci5cclxuICogYXdhaXQgY29uZmlybVBhc3N3b3JkUmVzZXQoJ3VzZXJAZXhhbXBsZS5jb20nLCBjb2RlKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxyXG4gKiBAcGFyYW0gYWN0aW9uQ29kZVNldHRpbmdzIC0gVGhlIHtAbGluayBBY3Rpb25Db2RlU2V0dGluZ3N9LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzZW5kUGFzc3dvcmRSZXNldEVtYWlsKGF1dGgsIGVtYWlsLCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiUEFTU1dPUkRfUkVTRVRcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlBBU1NXT1JEX1JFU0VUICovLFxyXG4gICAgICAgIGVtYWlsLFxyXG4gICAgICAgIGNsaWVudFR5cGU6IFwiQ0xJRU5UX1RZUEVfV0VCXCIgLyogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIgKi9cclxuICAgIH07XHJcbiAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzKSB7XHJcbiAgICAgICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChhdXRoSW50ZXJuYWwsIHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XHJcbiAgICB9XHJcbiAgICBhd2FpdCBoYW5kbGVSZWNhcHRjaGFGbG93KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgXCJnZXRPb2JDb2RlXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUgKi8sIHNlbmRQYXNzd29yZFJlc2V0RW1haWwkMSk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXBsZXRlcyB0aGUgcGFzc3dvcmQgcmVzZXQgcHJvY2VzcywgZ2l2ZW4gYSBjb25maXJtYXRpb24gY29kZSBhbmQgbmV3IHBhc3N3b3JkLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBvb2JDb2RlIC0gQSBjb25maXJtYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyLlxyXG4gKiBAcGFyYW0gbmV3UGFzc3dvcmQgLSBUaGUgbmV3IHBhc3N3b3JkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjb25maXJtUGFzc3dvcmRSZXNldChhdXRoLCBvb2JDb2RlLCBuZXdQYXNzd29yZCkge1xyXG4gICAgYXdhaXQgcmVzZXRQYXNzd29yZChnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIHtcclxuICAgICAgICBvb2JDb2RlLFxyXG4gICAgICAgIG5ld1Bhc3N3b3JkXHJcbiAgICB9KVxyXG4gICAgICAgIC5jYXRjaChhc3luYyAoZXJyb3IpID0+IHtcclxuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT1cclxuICAgICAgICAgICAgYGF1dGgvJHtcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL31gKSB7XHJcbiAgICAgICAgICAgIHZvaWQgcmVjYWNoZVBhc3N3b3JkUG9saWN5KGF1dGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH0pO1xyXG4gICAgLy8gRG8gbm90IHJldHVybiB0aGUgZW1haWwuXHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyIGJ5IGVtYWlsIG9yIG90aGVyIG91dC1vZi1iYW5kIG1lY2hhbmlzbS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gb29iQ29kZSAtIEEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gYXBwbHlBY3Rpb25Db2RlKGF1dGgsIG9vYkNvZGUpIHtcclxuICAgIGF3YWl0IGFwcGx5QWN0aW9uQ29kZSQxKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgeyBvb2JDb2RlIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgYSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyIGJ5IGVtYWlsIG9yIG90aGVyIG91dC1vZi1iYW5kIG1lY2hhbmlzbS5cclxuICpcclxuICogQHJldHVybnMgbWV0YWRhdGEgYWJvdXQgdGhlIGNvZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIG9vYkNvZGUgLSBBIHZlcmlmaWNhdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQWN0aW9uQ29kZShhdXRoLCBvb2JDb2RlKSB7XHJcbiAgICBjb25zdCBhdXRoTW9kdWxhciA9IGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzZXRQYXNzd29yZChhdXRoTW9kdWxhciwgeyBvb2JDb2RlIH0pO1xyXG4gICAgLy8gRW1haWwgY291bGQgYmUgZW1wdHkgb25seSBpZiB0aGUgcmVxdWVzdCB0eXBlIGlzIEVNQUlMX1NJR05JTiBvclxyXG4gICAgLy8gVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwuXHJcbiAgICAvLyBOZXcgZW1haWwgc2hvdWxkIG5vdCBiZSBlbXB0eSBpZiB0aGUgcmVxdWVzdCB0eXBlIGlzXHJcbiAgICAvLyBWRVJJRllfQU5EX0NIQU5HRV9FTUFJTC5cclxuICAgIC8vIE11bHRpLWZhY3RvciBpbmZvIGNvdWxkIG5vdCBiZSBlbXB0eSBpZiB0aGUgcmVxdWVzdCB0eXBlIGlzXHJcbiAgICAvLyBSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTi5cclxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHJlc3BvbnNlLnJlcXVlc3RUeXBlO1xyXG4gICAgX2Fzc2VydChvcGVyYXRpb24sIGF1dGhNb2R1bGFyLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xyXG4gICAgICAgIGNhc2UgXCJFTUFJTF9TSUdOSU5cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTiAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTCAqLzpcclxuICAgICAgICAgICAgX2Fzc2VydChyZXNwb25zZS5uZXdFbWFpbCwgYXV0aE1vZHVsYXIsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIlJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5SRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTiAqLzpcclxuICAgICAgICAgICAgX2Fzc2VydChyZXNwb25zZS5tZmFJbmZvLCBhdXRoTW9kdWxhciwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaFxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIF9hc3NlcnQocmVzcG9uc2UuZW1haWwsIGF1dGhNb2R1bGFyLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgbXVsdGktZmFjdG9yIGluZm8gZm9yIHJldmVydCBzZWNvbmQgZmFjdG9yIGFkZGl0aW9uXHJcbiAgICBsZXQgbXVsdGlGYWN0b3JJbmZvID0gbnVsbDtcclxuICAgIGlmIChyZXNwb25zZS5tZmFJbmZvKSB7XHJcbiAgICAgICAgbXVsdGlGYWN0b3JJbmZvID0gTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKF9jYXN0QXV0aChhdXRoTW9kdWxhciksIHJlc3BvbnNlLm1mYUluZm8pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIGVtYWlsOiAocmVzcG9uc2UucmVxdWVzdFR5cGUgPT09IFwiVkVSSUZZX0FORF9DSEFOR0VfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMICovXHJcbiAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLm5ld0VtYWlsXHJcbiAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLmVtYWlsKSB8fCBudWxsLFxyXG4gICAgICAgICAgICBwcmV2aW91c0VtYWlsOiAocmVzcG9uc2UucmVxdWVzdFR5cGUgPT09IFwiVkVSSUZZX0FORF9DSEFOR0VfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMICovXHJcbiAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLmVtYWlsXHJcbiAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLm5ld0VtYWlsKSB8fCBudWxsLFxyXG4gICAgICAgICAgICBtdWx0aUZhY3RvckluZm9cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9wZXJhdGlvblxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGEgcGFzc3dvcmQgcmVzZXQgY29kZSBzZW50IHRvIHRoZSB1c2VyIGJ5IGVtYWlsIG9yIG90aGVyIG91dC1vZi1iYW5kIG1lY2hhbmlzbS5cclxuICpcclxuICogQHJldHVybnMgdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzIGlmIHZhbGlkLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBjb2RlIC0gQSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlQYXNzd29yZFJlc2V0Q29kZShhdXRoLCBjb2RlKSB7XHJcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGNoZWNrQWN0aW9uQ29kZShnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIGNvZGUpO1xyXG4gICAgLy8gRW1haWwgc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IHNpbmNlIGEgY29kZSB3YXMgc2VudCB0byBpdFxyXG4gICAgcmV0dXJuIGRhdGEuZW1haWw7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdXNlciBhY2NvdW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGVtYWlsIGFkZHJlc3MgYW5kIHBhc3N3b3JkLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBPbiBzdWNjZXNzZnVsIGNyZWF0aW9uIG9mIHRoZSB1c2VyIGFjY291bnQsIHRoaXMgdXNlciB3aWxsIGFsc28gYmUgc2lnbmVkIGluIHRvIHlvdXIgYXBwbGljYXRpb24uXHJcbiAqXHJcbiAqIFVzZXIgYWNjb3VudCBjcmVhdGlvbiBjYW4gZmFpbCBpZiB0aGUgYWNjb3VudCBhbHJlYWR5IGV4aXN0cyBvciB0aGUgcGFzc3dvcmQgaXMgaW52YWxpZC5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBvbiB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogTm90ZTogVGhlIGVtYWlsIGFkZHJlc3MgYWN0cyBhcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdXNlciBhbmQgZW5hYmxlcyBhbiBlbWFpbC1iYXNlZFxyXG4gKiBwYXNzd29yZCByZXNldC4gVGhpcyBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBhIG5ldyB1c2VyIGFjY291bnQgYW5kIHNldCB0aGUgaW5pdGlhbCB1c2VyIHBhc3N3b3JkLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cclxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHVzZXIncyBjaG9zZW4gcGFzc3dvcmQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZChhdXRoLCBlbWFpbCwgcGFzc3dvcmQpIHtcclxuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZSxcclxuICAgICAgICBlbWFpbCxcclxuICAgICAgICBwYXNzd29yZCxcclxuICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2lnblVwUmVzcG9uc2UgPSBoYW5kbGVSZWNhcHRjaGFGbG93KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgXCJzaWduVXBQYXNzd29yZFwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuU0lHTl9VUF9QQVNTV09SRCAqLywgc2lnblVwKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2lnblVwUmVzcG9uc2UuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke1wicGFzc3dvcmQtZG9lcy1ub3QtbWVldC1yZXF1aXJlbWVudHNcIiAvKiBBdXRoRXJyb3JDb2RlLlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTICovfWApIHtcclxuICAgICAgICAgICAgdm9pZCByZWNhY2hlUGFzc3dvcmRQb2xpY3koYXV0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoSW50ZXJuYWwsIFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovLCByZXNwb25zZSk7XHJcbiAgICBhd2FpdCBhdXRoSW50ZXJuYWwuX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xyXG4gICAgcmV0dXJuIHVzZXJDcmVkZW50aWFsO1xyXG59XHJcbi8qKlxyXG4gKiBBc3luY2hyb25vdXNseSBzaWducyBpbiB1c2luZyBhbiBlbWFpbCBhbmQgcGFzc3dvcmQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIEZhaWxzIHdpdGggYW4gZXJyb3IgaWYgdGhlIGVtYWlsIGFkZHJlc3MgYW5kIHBhc3N3b3JkIGRvIG5vdCBtYXRjaC4gV2hlblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lkZW50aXR5LXBsYXRmb3JtL2RvY3MvYWRtaW4vZW1haWwtZW51bWVyYXRpb24tcHJvdGVjdGlvbiB8IEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb259XHJcbiAqIGlzIGVuYWJsZWQsIHRoaXMgbWV0aG9kIGZhaWxzIHdpdGggXCJhdXRoL2ludmFsaWQtY3JlZGVudGlhbFwiIGluIGNhc2Ugb2YgYW4gaW52YWxpZFxyXG4gKiBlbWFpbC9wYXNzd29yZC5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBvbiB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogTm90ZTogVGhlIHVzZXIncyBwYXNzd29yZCBpcyBOT1QgdGhlIHBhc3N3b3JkIHVzZWQgdG8gYWNjZXNzIHRoZSB1c2VyJ3MgZW1haWwgYWNjb3VudC4gVGhlXHJcbiAqIGVtYWlsIGFkZHJlc3Mgc2VydmVzIGFzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB1c2VyLCBhbmQgdGhlIHBhc3N3b3JkIGlzIHVzZWQgdG8gYWNjZXNzXHJcbiAqIHRoZSB1c2VyJ3MgYWNjb3VudCBpbiB5b3VyIEZpcmViYXNlIHByb2plY3QuIFNlZSBhbHNvOiB7QGxpbmsgY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkfS5cclxuICpcclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcnMgZW1haWwgYWRkcmVzcy5cclxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHVzZXJzIHBhc3N3b3JkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChhdXRoLCBlbWFpbCwgcGFzc3dvcmQpIHtcclxuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNpZ25JbldpdGhDcmVkZW50aWFsKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgRW1haWxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChlbWFpbCwgcGFzc3dvcmQpKS5jYXRjaChhc3luYyAoZXJyb3IpID0+IHtcclxuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL31gKSB7XHJcbiAgICAgICAgICAgIHZvaWQgcmVjYWNoZVBhc3N3b3JkUG9saWN5KGF1dGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBTZW5kcyBhIHNpZ24taW4gZW1haWwgbGluayB0byB0aGUgdXNlciB3aXRoIHRoZSBzcGVjaWZpZWQgZW1haWwuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoZSBzaWduLWluIG9wZXJhdGlvbiBoYXMgdG8gYWx3YXlzIGJlIGNvbXBsZXRlZCBpbiB0aGUgYXBwIHVubGlrZSBvdGhlciBvdXQgb2YgYmFuZCBlbWFpbFxyXG4gKiBhY3Rpb25zIChwYXNzd29yZCByZXNldCBhbmQgZW1haWwgdmVyaWZpY2F0aW9ucykuIFRoaXMgaXMgYmVjYXVzZSwgYXQgdGhlIGVuZCBvZiB0aGUgZmxvdyxcclxuICogdGhlIHVzZXIgaXMgZXhwZWN0ZWQgdG8gYmUgc2lnbmVkIGluIGFuZCB0aGVpciBBdXRoIHN0YXRlIHBlcnNpc3RlZCB3aXRoaW4gdGhlIGFwcC5cclxuICpcclxuICogVG8gY29tcGxldGUgc2lnbiBpbiB3aXRoIHRoZSBlbWFpbCBsaW5rLCBjYWxsIHtAbGluayBzaWduSW5XaXRoRW1haWxMaW5rfSB3aXRoIHRoZSBlbWFpbFxyXG4gKiBhZGRyZXNzIGFuZCB0aGUgZW1haWwgbGluayBzdXBwbGllZCBpbiB0aGUgZW1haWwgc2VudCB0byB0aGUgdXNlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XHJcbiAqICAgdXJsOiAnaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vP2VtYWlsPXVzZXJAZXhhbXBsZS5jb20nLFxyXG4gKiAgIGlPUzoge1xyXG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xyXG4gKiAgIH0sXHJcbiAqICAgYW5kcm9pZDoge1xyXG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcclxuICogICAgIGluc3RhbGxBcHA6IHRydWUsXHJcbiAqICAgICBtaW5pbXVtVmVyc2lvbjogJzEyJ1xyXG4gKiAgIH0sXHJcbiAqICAgaGFuZGxlQ29kZUluQXBwOiB0cnVlXHJcbiAqIH07XHJcbiAqIGF3YWl0IHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XHJcbiAqIC8vIE9idGFpbiBlbWFpbExpbmsgZnJvbSB0aGUgdXNlci5cclxuICogaWYoaXNTaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsIGVtYWlsTGluaykpIHtcclxuICogICBhd2FpdCBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgZW1haWxMaW5rKTtcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIGF1dGhJbnRlcm5hbCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cclxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2VuZFNpZ25JbkxpbmtUb0VtYWlsKGF1dGgsIGVtYWlsLCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiRU1BSUxfU0lHTklOXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5FTUFJTF9TSUdOSU4gKi8sXHJcbiAgICAgICAgZW1haWwsXHJcbiAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHNldEFjdGlvbkNvZGVTZXR0aW5ncyhyZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgICAgICBfYXNzZXJ0KGFjdGlvbkNvZGVTZXR0aW5ncy5oYW5kbGVDb2RlSW5BcHAsIGF1dGhJbnRlcm5hbCwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChhdXRoSW50ZXJuYWwsIHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0QWN0aW9uQ29kZVNldHRpbmdzKHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XHJcbiAgICBhd2FpdCBoYW5kbGVSZWNhcHRjaGFGbG93KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgXCJnZXRPb2JDb2RlXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUgKi8sIHNlbmRTaWduSW5MaW5rVG9FbWFpbCQxKTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGFuIGluY29taW5nIGxpbmsgaXMgYSBzaWduLWluIHdpdGggZW1haWwgbGluayBzdWl0YWJsZSBmb3Ige0BsaW5rIHNpZ25JbldpdGhFbWFpbExpbmt9LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBlbWFpbExpbmsgLSBUaGUgbGluayBzZW50IHRvIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaXNTaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsIGVtYWlsTGluaykge1xyXG4gICAgY29uc3QgYWN0aW9uQ29kZVVybCA9IEFjdGlvbkNvZGVVUkwucGFyc2VMaW5rKGVtYWlsTGluayk7XHJcbiAgICByZXR1cm4gKGFjdGlvbkNvZGVVcmwgPT09IG51bGwgfHwgYWN0aW9uQ29kZVVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uQ29kZVVybC5vcGVyYXRpb24pID09PSBcIkVNQUlMX1NJR05JTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOICovO1xyXG59XHJcbi8qKlxyXG4gKiBBc3luY2hyb25vdXNseSBzaWducyBpbiB1c2luZyBhbiBlbWFpbCBhbmQgc2lnbi1pbiBlbWFpbCBsaW5rLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBJZiBubyBsaW5rIGlzIHBhc3NlZCwgdGhlIGxpbmsgaXMgaW5mZXJyZWQgZnJvbSB0aGUgY3VycmVudCBVUkwuXHJcbiAqXHJcbiAqIEZhaWxzIHdpdGggYW4gZXJyb3IgaWYgdGhlIGVtYWlsIGFkZHJlc3MgaXMgaW52YWxpZCBvciBPVFAgaW4gZW1haWwgbGluayBleHBpcmVzLlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcclxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxyXG4gKlxyXG4gKiBOb3RlOiBDb25maXJtIHRoZSBsaW5rIGlzIGEgc2lnbi1pbiBlbWFpbCBsaW5rIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kIGZpcmViYXNlLmF1dGguQXV0aC5pc1NpZ25JbldpdGhFbWFpbExpbmsuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xyXG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcclxuICogICBpT1M6IHtcclxuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcclxuICogICB9LFxyXG4gKiAgIGFuZHJvaWQ6IHtcclxuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXHJcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxyXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcclxuICogICB9LFxyXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxyXG4gKiB9O1xyXG4gKiBhd2FpdCBzZW5kU2lnbkluTGlua1RvRW1haWwoYXV0aCwgJ3VzZXJAZXhhbXBsZS5jb20nLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xyXG4gKiAvLyBPYnRhaW4gZW1haWxMaW5rIGZyb20gdGhlIHVzZXIuXHJcbiAqIGlmKGlzU2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbExpbmspKSB7XHJcbiAqICAgYXdhaXQgc2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGVtYWlsTGluayk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxyXG4gKiBAcGFyYW0gZW1haWxMaW5rIC0gVGhlIGxpbmsgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWwsIGVtYWlsTGluaykge1xyXG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhdXRoTW9kdWxhciA9IGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKTtcclxuICAgIGNvbnN0IGNyZWRlbnRpYWwgPSBFbWFpbEF1dGhQcm92aWRlci5jcmVkZW50aWFsV2l0aExpbmsoZW1haWwsIGVtYWlsTGluayB8fCBfZ2V0Q3VycmVudFVybCgpKTtcclxuICAgIC8vIENoZWNrIGlmIHRoZSB0ZW5hbnQgSUQgaW4gdGhlIGVtYWlsIGxpbmsgbWF0Y2hlcyB0aGUgdGVuYW50IElEIG9uIEF1dGhcclxuICAgIC8vIGluc3RhbmNlLlxyXG4gICAgX2Fzc2VydChjcmVkZW50aWFsLl90ZW5hbnRJZCA9PT0gKGF1dGhNb2R1bGFyLnRlbmFudElkIHx8IG51bGwpLCBhdXRoTW9kdWxhciwgXCJ0ZW5hbnQtaWQtbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLlRFTkFOVF9JRF9NSVNNQVRDSCAqLyk7XHJcbiAgICByZXR1cm4gc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aE1vZHVsYXIsIGNyZWRlbnRpYWwpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUF1dGhVcmkoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOmNyZWF0ZUF1dGhVcmlcIiAvKiBFbmRwb2ludC5DUkVBVEVfQVVUSF9VUkkgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxpc3Qgb2YgcG9zc2libGUgc2lnbiBpbiBtZXRob2RzIGZvciB0aGUgZ2l2ZW4gZW1haWwgYWRkcmVzcy4gVGhpcyBtZXRob2QgcmV0dXJucyBhblxyXG4gKiBlbXB0eSBsaXN0IHdoZW5cclxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufVxyXG4gKiBpcyBlbmFibGVkLCBpcnJlc3BlY3RpdmUgb2YgdGhlIG51bWJlciBvZiBhdXRoZW50aWNhdGlvbiBtZXRob2RzIGF2YWlsYWJsZSBmb3IgdGhlIGdpdmVuIGVtYWlsLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGlzIGlzIHVzZWZ1bCB0byBkaWZmZXJlbnRpYXRlIG1ldGhvZHMgb2Ygc2lnbi1pbiBmb3IgdGhlIHNhbWUgcHJvdmlkZXIsIGVnLlxyXG4gKiB7QGxpbmsgRW1haWxBdXRoUHJvdmlkZXJ9IHdoaWNoIGhhcyAyIG1ldGhvZHMgb2Ygc2lnbi1pbixcclxuICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQgYW5kXHJcbiAqIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX0xJTksuXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxyXG4gKlxyXG4gKiBEZXByZWNhdGVkLiBNaWdyYXRpbmcgb2ZmIG9mIHRoaXMgbWV0aG9kIGlzIHJlY29tbWVuZGVkIGFzIGEgc2VjdXJpdHkgYmVzdC1wcmFjdGljZS5cclxuICogTGVhcm4gbW9yZSBpbiB0aGUgSWRlbnRpdHkgUGxhdGZvcm0gZG9jdW1lbnRhdGlvbiBmb3JcclxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufS5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hTaWduSW5NZXRob2RzRm9yRW1haWwoYXV0aCwgZW1haWwpIHtcclxuICAgIC8vIGNyZWF0ZUF1dGhVcmkgcmV0dXJucyBhbiBlcnJvciBpZiBjb250aW51ZSBVUkkgaXMgbm90IGh0dHAgb3IgaHR0cHMuXHJcbiAgICAvLyBGb3IgZW52aXJvbm1lbnRzIGxpa2UgQ29yZG92YSwgQ2hyb21lIGV4dGVuc2lvbnMsIG5hdGl2ZSBmcmFtZXdvcmtzLCBmaWxlXHJcbiAgICAvLyBzeXN0ZW1zLCBldGMsIHVzZSBodHRwOi8vbG9jYWxob3N0IGFzIGNvbnRpbnVlIFVSTC5cclxuICAgIGNvbnN0IGNvbnRpbnVlVXJpID0gX2lzSHR0cE9ySHR0cHMoKSA/IF9nZXRDdXJyZW50VXJsKCkgOiAnaHR0cDovL2xvY2FsaG9zdCc7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIGlkZW50aWZpZXI6IGVtYWlsLFxyXG4gICAgICAgIGNvbnRpbnVlVXJpXHJcbiAgICB9O1xyXG4gICAgY29uc3QgeyBzaWduaW5NZXRob2RzIH0gPSBhd2FpdCBjcmVhdGVBdXRoVXJpKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgcmVxdWVzdCk7XHJcbiAgICByZXR1cm4gc2lnbmluTWV0aG9kcyB8fCBbXTtcclxufVxyXG4vKipcclxuICogU2VuZHMgYSB2ZXJpZmljYXRpb24gZW1haWwgdG8gYSB1c2VyLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGUgdmVyaWZpY2F0aW9uIHByb2Nlc3MgaXMgY29tcGxldGVkIGJ5IGNhbGxpbmcge0BsaW5rIGFwcGx5QWN0aW9uQ29kZX0uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xyXG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcclxuICogICBpT1M6IHtcclxuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcclxuICogICB9LFxyXG4gKiAgIGFuZHJvaWQ6IHtcclxuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXHJcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxyXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcclxuICogICB9LFxyXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxyXG4gKiB9O1xyXG4gKiBhd2FpdCBzZW5kRW1haWxWZXJpZmljYXRpb24odXNlciwgYWN0aW9uQ29kZVNldHRpbmdzKTtcclxuICogLy8gT2J0YWluIGNvZGUgZnJvbSB0aGUgdXNlci5cclxuICogYXdhaXQgYXBwbHlBY3Rpb25Db2RlKGF1dGgsIGNvZGUpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cclxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2VuZEVtYWlsVmVyaWZpY2F0aW9uKHVzZXIsIGFjdGlvbkNvZGVTZXR0aW5ncykge1xyXG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xyXG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICByZXF1ZXN0VHlwZTogXCJWRVJJRllfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9FTUFJTCAqLyxcclxuICAgICAgICBpZFRva2VuXHJcbiAgICB9O1xyXG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncykge1xyXG4gICAgICAgIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QodXNlckludGVybmFsLmF1dGgsIHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGVtYWlsIH0gPSBhd2FpdCBzZW5kRW1haWxWZXJpZmljYXRpb24kMSh1c2VySW50ZXJuYWwuYXV0aCwgcmVxdWVzdCk7XHJcbiAgICBpZiAoZW1haWwgIT09IHVzZXIuZW1haWwpIHtcclxuICAgICAgICBhd2FpdCB1c2VyLnJlbG9hZCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTZW5kcyBhIHZlcmlmaWNhdGlvbiBlbWFpbCB0byBhIG5ldyBlbWFpbCBhZGRyZXNzLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGUgdXNlcidzIGVtYWlsIHdpbGwgYmUgdXBkYXRlZCB0byB0aGUgbmV3IG9uZSBhZnRlciBiZWluZyB2ZXJpZmllZC5cclxuICpcclxuICogSWYgeW91IGhhdmUgYSBjdXN0b20gZW1haWwgYWN0aW9uIGhhbmRsZXIsIHlvdSBjYW4gY29tcGxldGUgdGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzIGJ5IGNhbGxpbmdcclxuICoge0BsaW5rIGFwcGx5QWN0aW9uQ29kZX0uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xyXG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcclxuICogICBpT1M6IHtcclxuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcclxuICogICB9LFxyXG4gKiAgIGFuZHJvaWQ6IHtcclxuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXHJcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxyXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcclxuICogICB9LFxyXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxyXG4gKiB9O1xyXG4gKiBhd2FpdCB2ZXJpZnlCZWZvcmVVcGRhdGVFbWFpbCh1c2VyLCAnbmV3ZW1haWxAZXhhbXBsZS5jb20nLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xyXG4gKiAvLyBPYnRhaW4gY29kZSBmcm9tIHRoZSB1c2VyLlxyXG4gKiBhd2FpdCBhcHBseUFjdGlvbkNvZGUoYXV0aCwgY29kZSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxyXG4gKiBAcGFyYW0gbmV3RW1haWwgLSBUaGUgbmV3IGVtYWlsIGFkZHJlc3MgdG8gYmUgdmVyaWZpZWQgYmVmb3JlIHVwZGF0ZS5cclxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5QmVmb3JlVXBkYXRlRW1haWwodXNlciwgbmV3RW1haWwsIGFjdGlvbkNvZGVTZXR0aW5ncykge1xyXG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xyXG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICByZXF1ZXN0VHlwZTogXCJWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwgKi8sXHJcbiAgICAgICAgaWRUb2tlbixcclxuICAgICAgICBuZXdFbWFpbFxyXG4gICAgfTtcclxuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgICAgICBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KHVzZXJJbnRlcm5hbC5hdXRoLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBlbWFpbCB9ID0gYXdhaXQgdmVyaWZ5QW5kQ2hhbmdlRW1haWwodXNlckludGVybmFsLmF1dGgsIHJlcXVlc3QpO1xyXG4gICAgaWYgKGVtYWlsICE9PSB1c2VyLmVtYWlsKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIGxvY2FsIGNvcHkgb2YgdGhlIGVtYWlsIG9uIHVzZXIgaXMgb3V0ZGF0ZWQsIHJlbG9hZCB0aGVcclxuICAgICAgICAvLyB1c2VyLlxyXG4gICAgICAgIGF3YWl0IHVzZXIucmVsb2FkKCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlUHJvZmlsZSQxKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czp1cGRhdGVcIiAvKiBFbmRwb2ludC5TRVRfQUNDT1VOVF9JTkZPICovLCByZXF1ZXN0KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVXBkYXRlcyBhIHVzZXIncyBwcm9maWxlIGRhdGEuXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqIEBwYXJhbSBwcm9maWxlIC0gVGhlIHByb2ZpbGUncyBgZGlzcGxheU5hbWVgIGFuZCBgcGhvdG9VUkxgIHRvIHVwZGF0ZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlUHJvZmlsZSh1c2VyLCB7IGRpc3BsYXlOYW1lLCBwaG90b1VSTDogcGhvdG9VcmwgfSkge1xyXG4gICAgaWYgKGRpc3BsYXlOYW1lID09PSB1bmRlZmluZWQgJiYgcGhvdG9VcmwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcclxuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VySW50ZXJuYWwuZ2V0SWRUb2tlbigpO1xyXG4gICAgY29uc3QgcHJvZmlsZVJlcXVlc3QgPSB7XHJcbiAgICAgICAgaWRUb2tlbixcclxuICAgICAgICBkaXNwbGF5TmFtZSxcclxuICAgICAgICBwaG90b1VybCxcclxuICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodXNlckludGVybmFsLCB1cGRhdGVQcm9maWxlJDEodXNlckludGVybmFsLmF1dGgsIHByb2ZpbGVSZXF1ZXN0KSk7XHJcbiAgICB1c2VySW50ZXJuYWwuZGlzcGxheU5hbWUgPSByZXNwb25zZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xyXG4gICAgdXNlckludGVybmFsLnBob3RvVVJMID0gcmVzcG9uc2UucGhvdG9VcmwgfHwgbnVsbDtcclxuICAgIC8vIFVwZGF0ZSB0aGUgcGFzc3dvcmQgcHJvdmlkZXIgYXMgd2VsbFxyXG4gICAgY29uc3QgcGFzc3dvcmRQcm92aWRlciA9IHVzZXJJbnRlcm5hbC5wcm92aWRlckRhdGEuZmluZCgoeyBwcm92aWRlcklkIH0pID0+IHByb3ZpZGVySWQgPT09IFwicGFzc3dvcmRcIiAvKiBQcm92aWRlcklkLlBBU1NXT1JEICovKTtcclxuICAgIGlmIChwYXNzd29yZFByb3ZpZGVyKSB7XHJcbiAgICAgICAgcGFzc3dvcmRQcm92aWRlci5kaXNwbGF5TmFtZSA9IHVzZXJJbnRlcm5hbC5kaXNwbGF5TmFtZTtcclxuICAgICAgICBwYXNzd29yZFByb3ZpZGVyLnBob3RvVVJMID0gdXNlckludGVybmFsLnBob3RvVVJMO1xyXG4gICAgfVxyXG4gICAgYXdhaXQgdXNlckludGVybmFsLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShyZXNwb25zZSk7XHJcbn1cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBBbiBlbWFpbCB3aWxsIGJlIHNlbnQgdG8gdGhlIG9yaWdpbmFsIGVtYWlsIGFkZHJlc3MgKGlmIGl0IHdhcyBzZXQpIHRoYXQgYWxsb3dzIHRvIHJldm9rZSB0aGVcclxuICogZW1haWwgYWRkcmVzcyBjaGFuZ2UsIGluIG9yZGVyIHRvIHByb3RlY3QgdGhlbSBmcm9tIGFjY291bnQgaGlqYWNraW5nLlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIG9uIGFueSB7QGxpbmsgVXNlcn0gc2lnbmVkIGluIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXNcclxuICogY3JlYXRlZCB3aXRoIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxyXG4gKlxyXG4gKiBJbXBvcnRhbnQ6IHRoaXMgaXMgYSBzZWN1cml0eSBzZW5zaXRpdmUgb3BlcmF0aW9uIHRoYXQgcmVxdWlyZXMgdGhlIHVzZXIgdG8gaGF2ZSByZWNlbnRseSBzaWduZWRcclxuICogaW4uIElmIHRoaXMgcmVxdWlyZW1lbnQgaXNuJ3QgbWV0LCBhc2sgdGhlIHVzZXIgdG8gYXV0aGVudGljYXRlIGFnYWluIGFuZCB0aGVuIGNhbGxcclxuICoge0BsaW5rIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWx9LlxyXG4gKlxyXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxyXG4gKiBAcGFyYW0gbmV3RW1haWwgLSBUaGUgbmV3IGVtYWlsIGFkZHJlc3MuXHJcbiAqXHJcbiAqIFRocm93cyBcImF1dGgvb3BlcmF0aW9uLW5vdC1hbGxvd2VkXCIgZXJyb3Igd2hlblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lkZW50aXR5LXBsYXRmb3JtL2RvY3MvYWRtaW4vZW1haWwtZW51bWVyYXRpb24tcHJvdGVjdGlvbiB8IEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb259XHJcbiAqIGlzIGVuYWJsZWQuXHJcbiAqIERlcHJlY2F0ZWQgLSBVc2Uge0BsaW5rIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsfSBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVFbWFpbCh1c2VyLCBuZXdFbWFpbCkge1xyXG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xyXG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHVzZXJJbnRlcm5hbC5hdXRoLmFwcCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodXNlckludGVybmFsLmF1dGgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1cGRhdGVFbWFpbE9yUGFzc3dvcmQodXNlckludGVybmFsLCBuZXdFbWFpbCwgbnVsbCk7XHJcbn1cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIHVzZXIncyBwYXNzd29yZC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogSW1wb3J0YW50OiB0aGlzIGlzIGEgc2VjdXJpdHkgc2Vuc2l0aXZlIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIHRoZSB1c2VyIHRvIGhhdmUgcmVjZW50bHkgc2lnbmVkXHJcbiAqIGluLiBJZiB0aGlzIHJlcXVpcmVtZW50IGlzbid0IG1ldCwgYXNrIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbiBhbmQgdGhlbiBjYWxsXHJcbiAqIHtAbGluayByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsfS5cclxuICpcclxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cclxuICogQHBhcmFtIG5ld1Bhc3N3b3JkIC0gVGhlIG5ldyBwYXNzd29yZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlUGFzc3dvcmQodXNlciwgbmV3UGFzc3dvcmQpIHtcclxuICAgIHJldHVybiB1cGRhdGVFbWFpbE9yUGFzc3dvcmQoZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpLCBudWxsLCBuZXdQYXNzd29yZCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlRW1haWxPclBhc3N3b3JkKHVzZXIsIGVtYWlsLCBwYXNzd29yZCkge1xyXG4gICAgY29uc3QgeyBhdXRoIH0gPSB1c2VyO1xyXG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICBpZFRva2VuLFxyXG4gICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXHJcbiAgICB9O1xyXG4gICAgaWYgKGVtYWlsKSB7XHJcbiAgICAgICAgcmVxdWVzdC5lbWFpbCA9IGVtYWlsO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhc3N3b3JkKSB7XHJcbiAgICAgICAgcmVxdWVzdC5wYXNzd29yZCA9IHBhc3N3b3JkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VyLCB1cGRhdGVFbWFpbFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpKTtcclxuICAgIGF3YWl0IHVzZXIuX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KHJlc3BvbnNlLCAvKiByZWxvYWQgKi8gdHJ1ZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFBhcnNlIHRoZSBgQWRkaXRpb25hbFVzZXJJbmZvYCBmcm9tIHRoZSBJRCB0b2tlbiByZXNwb25zZS5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIF9mcm9tSWRUb2tlblJlc3BvbnNlKGlkVG9rZW5SZXNwb25zZSkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGlmICghaWRUb2tlblJlc3BvbnNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHByb3ZpZGVySWQgfSA9IGlkVG9rZW5SZXNwb25zZTtcclxuICAgIGNvbnN0IHByb2ZpbGUgPSBpZFRva2VuUmVzcG9uc2UucmF3VXNlckluZm9cclxuICAgICAgICA/IEpTT04ucGFyc2UoaWRUb2tlblJlc3BvbnNlLnJhd1VzZXJJbmZvKVxyXG4gICAgICAgIDoge307XHJcbiAgICBjb25zdCBpc05ld1VzZXIgPSBpZFRva2VuUmVzcG9uc2UuaXNOZXdVc2VyIHx8XHJcbiAgICAgICAgaWRUb2tlblJlc3BvbnNlLmtpbmQgPT09IFwiaWRlbnRpdHl0b29sa2l0I1NpZ251cE5ld1VzZXJSZXNwb25zZVwiIC8qIElkVG9rZW5SZXNwb25zZUtpbmQuU2lnbnVwTmV3VXNlciAqLztcclxuICAgIGlmICghcHJvdmlkZXJJZCAmJiAoaWRUb2tlblJlc3BvbnNlID09PSBudWxsIHx8IGlkVG9rZW5SZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWRUb2tlblJlc3BvbnNlLmlkVG9rZW4pKSB7XHJcbiAgICAgICAgY29uc3Qgc2lnbkluUHJvdmlkZXIgPSAoX2IgPSAoX2EgPSBfcGFyc2VUb2tlbihpZFRva2VuUmVzcG9uc2UuaWRUb2tlbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJlYmFzZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWydzaWduX2luX3Byb3ZpZGVyJ107XHJcbiAgICAgICAgaWYgKHNpZ25JblByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkUHJvdmlkZXJJZCA9IHNpZ25JblByb3ZpZGVyICE9PSBcImFub255bW91c1wiIC8qIFByb3ZpZGVySWQuQU5PTllNT1VTICovICYmXHJcbiAgICAgICAgICAgICAgICBzaWduSW5Qcm92aWRlciAhPT0gXCJjdXN0b21cIiAvKiBQcm92aWRlcklkLkNVU1RPTSAqL1xyXG4gICAgICAgICAgICAgICAgPyBzaWduSW5Qcm92aWRlclxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICAvLyBVc2VzIGdlbmVyaWMgY2xhc3MgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBsZWdhY3kgU0RLLlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBmaWx0ZXJlZFByb3ZpZGVySWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcHJvdmlkZXJJZCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChwcm92aWRlcklkKSB7XHJcbiAgICAgICAgY2FzZSBcImZhY2Vib29rLmNvbVwiIC8qIFByb3ZpZGVySWQuRkFDRUJPT0sgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFjZWJvb2tBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlKTtcclxuICAgICAgICBjYXNlIFwiZ2l0aHViLmNvbVwiIC8qIFByb3ZpZGVySWQuR0lUSFVCICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEdpdGh1YkFkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIHByb2ZpbGUpO1xyXG4gICAgICAgIGNhc2UgXCJnb29nbGUuY29tXCIgLyogUHJvdmlkZXJJZC5HT09HTEUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgR29vZ2xlQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvZmlsZSk7XHJcbiAgICAgICAgY2FzZSBcInR3aXR0ZXIuY29tXCIgLyogUHJvdmlkZXJJZC5UV0lUVEVSICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFR3aXR0ZXJBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlLCBpZFRva2VuUmVzcG9uc2Uuc2NyZWVuTmFtZSB8fCBudWxsKTtcclxuICAgICAgICBjYXNlIFwiY3VzdG9tXCIgLyogUHJvdmlkZXJJZC5DVVNUT00gKi86XHJcbiAgICAgICAgY2FzZSBcImFub255bW91c1wiIC8qIFByb3ZpZGVySWQuQU5PTllNT1VTICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBudWxsKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm92aWRlcklkLCBwcm9maWxlKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvIHtcclxuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy5pc05ld1VzZXIgPSBpc05ld1VzZXI7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gcHJvdmlkZXJJZDtcclxuICAgICAgICB0aGlzLnByb2ZpbGUgPSBwcm9maWxlO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEZlZGVyYXRlZEFkZGl0aW9uYWxVc2VySW5mb1dpdGhVc2VybmFtZSBleHRlbmRzIEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8ge1xyXG4gICAgY29uc3RydWN0b3IoaXNOZXdVc2VyLCBwcm92aWRlcklkLCBwcm9maWxlLCB1c2VybmFtZSkge1xyXG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSk7XHJcbiAgICAgICAgdGhpcy51c2VybmFtZSA9IHVzZXJuYW1lO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEZhY2Vib29rQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihpc05ld1VzZXIsIHByb2ZpbGUpIHtcclxuICAgICAgICBzdXBlcihpc05ld1VzZXIsIFwiZmFjZWJvb2suY29tXCIgLyogUHJvdmlkZXJJZC5GQUNFQk9PSyAqLywgcHJvZmlsZSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgR2l0aHViQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgRmVkZXJhdGVkQWRkaXRpb25hbFVzZXJJbmZvV2l0aFVzZXJuYW1lIHtcclxuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvZmlsZSkge1xyXG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgXCJnaXRodWIuY29tXCIgLyogUHJvdmlkZXJJZC5HSVRIVUIgKi8sIHByb2ZpbGUsIHR5cGVvZiAocHJvZmlsZSA9PT0gbnVsbCB8fCBwcm9maWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9maWxlLmxvZ2luKSA9PT0gJ3N0cmluZycgPyBwcm9maWxlID09PSBudWxsIHx8IHByb2ZpbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2ZpbGUubG9naW4gOiBudWxsKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBHb29nbGVBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvIHtcclxuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvZmlsZSkge1xyXG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgXCJnb29nbGUuY29tXCIgLyogUHJvdmlkZXJJZC5HT09HTEUgKi8sIHByb2ZpbGUpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFR3aXR0ZXJBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBGZWRlcmF0ZWRBZGRpdGlvbmFsVXNlckluZm9XaXRoVXNlcm5hbWUge1xyXG4gICAgY29uc3RydWN0b3IoaXNOZXdVc2VyLCBwcm9maWxlLCBzY3JlZW5OYW1lKSB7XHJcbiAgICAgICAgc3VwZXIoaXNOZXdVc2VyLCBcInR3aXR0ZXIuY29tXCIgLyogUHJvdmlkZXJJZC5UV0lUVEVSICovLCBwcm9maWxlLCBzY3JlZW5OYW1lKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXh0cmFjdHMgcHJvdmlkZXIgc3BlY2lmaWMge0BsaW5rIEFkZGl0aW9uYWxVc2VySW5mb30gZm9yIHRoZSBnaXZlbiBjcmVkZW50aWFsLlxyXG4gKlxyXG4gKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBZGRpdGlvbmFsVXNlckluZm8odXNlckNyZWRlbnRpYWwpIHtcclxuICAgIGNvbnN0IHsgdXNlciwgX3Rva2VuUmVzcG9uc2UgfSA9IHVzZXJDcmVkZW50aWFsO1xyXG4gICAgaWYgKHVzZXIuaXNBbm9ueW1vdXMgJiYgIV90b2tlblJlc3BvbnNlKSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBzcGVjaWFsIGNhc2Ugd2hlcmUgc2lnbkluQW5vbnltb3VzbHkoKSBnZXRzIGNhbGxlZCB0d2ljZS5cclxuICAgICAgICAvLyBObyBuZXR3b3JrIGNhbGwgaXMgbWFkZSBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gYWN0dWFsbHkgZmlsbCB0aGlzIGluXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvdmlkZXJJZDogbnVsbCxcclxuICAgICAgICAgICAgaXNOZXdVc2VyOiBmYWxzZSxcclxuICAgICAgICAgICAgcHJvZmlsZTogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2Zyb21JZFRva2VuUmVzcG9uc2UoX3Rva2VuUmVzcG9uc2UpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIE5vbi1vcHRpb25hbCBhdXRoIG1ldGhvZHMuXHJcbi8qKlxyXG4gKiBDaGFuZ2VzIHRoZSB0eXBlIG9mIHBlcnNpc3RlbmNlIG9uIHRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50bHkgc2F2ZWRcclxuICogYEF1dGhgIHNlc3Npb24gYW5kIGFwcGxpZXMgdGhpcyB0eXBlIG9mIHBlcnNpc3RlbmNlIGZvciBmdXR1cmUgc2lnbi1pbiByZXF1ZXN0cywgaW5jbHVkaW5nXHJcbiAqIHNpZ24taW4gd2l0aCByZWRpcmVjdCByZXF1ZXN0cy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBtYWtlcyBpdCBlYXN5IGZvciBhIHVzZXIgc2lnbmluZyBpbiB0byBzcGVjaWZ5IHdoZXRoZXIgdGhlaXIgc2Vzc2lvbiBzaG91bGQgYmVcclxuICogcmVtZW1iZXJlZCBvciBub3QuIEl0IGFsc28gbWFrZXMgaXQgZWFzaWVyIHRvIG5ldmVyIHBlcnNpc3QgdGhlIGBBdXRoYCBzdGF0ZSBmb3IgYXBwbGljYXRpb25zXHJcbiAqIHRoYXQgYXJlIHNoYXJlZCBieSBvdGhlciB1c2VycyBvciBoYXZlIHNlbnNpdGl2ZSBkYXRhLlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB3b3JrIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudCBvciB3aXRoIHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcclxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIHNldFBlcnNpc3RlbmNlKGF1dGgsIGJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2UpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gcGVyc2lzdGVuY2UgLSBUaGUge0BsaW5rIFBlcnNpc3RlbmNlfSB0byB1c2UuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgcGVyc2lzdGVuY2UgY2hhbmdlIGhhcyBjb21wbGV0ZWRcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0UGVyc2lzdGVuY2UoYXV0aCwgcGVyc2lzdGVuY2UpIHtcclxuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkuc2V0UGVyc2lzdGVuY2UocGVyc2lzdGVuY2UpO1xyXG59XHJcbi8qKlxyXG4gKiBMb2FkcyB0aGUgcmVDQVBUQ0hBIGNvbmZpZ3VyYXRpb24gaW50byB0aGUgYEF1dGhgIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGlzIHdpbGwgbG9hZCB0aGUgcmVDQVBUQ0hBIGNvbmZpZywgd2hpY2ggaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJlQ0FQVENIQVxyXG4gKiB2ZXJpZmljYXRpb24gZmxvdyBzaG91bGQgYmUgdHJpZ2dlcmVkIGZvciBlYWNoIGF1dGggcHJvdmlkZXIsIGludG8gdGhlXHJcbiAqIGN1cnJlbnQgQXV0aCBzZXNzaW9uLlxyXG4gKlxyXG4gKiBJZiBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKCkgaXMgbm90IGludm9rZWQsIHRoZSBhdXRoIGZsb3cgd2lsbCBhbHdheXMgc3RhcnRcclxuICogd2l0aG91dCByZUNBUFRDSEEgdmVyaWZpY2F0aW9uLiBJZiB0aGUgcHJvdmlkZXIgaXMgY29uZmlndXJlZCB0byByZXF1aXJlIHJlQ0FQVENIQVxyXG4gKiB2ZXJpZmljYXRpb24sIHRoZSBTREsgd2lsbCB0cmFuc3BhcmVudGx5IGxvYWQgdGhlIHJlQ0FQVENIQSBjb25maWcgYW5kIHJlc3RhcnQgdGhlXHJcbiAqIGF1dGggZmxvd3MuXHJcbiAqXHJcbiAqIFRodXMsIGJ5IGNhbGxpbmcgdGhpcyBvcHRpb25hbCBtZXRob2QsIHlvdSB3aWxsIHJlZHVjZSB0aGUgbGF0ZW5jeSBvZiBmdXR1cmUgYXV0aCBmbG93cy5cclxuICogTG9hZGluZyB0aGUgcmVDQVBUQ0hBIGNvbmZpZyBlYXJseSB3aWxsIGFsc28gZW5oYW5jZSB0aGUgc2lnbmFsIGNvbGxlY3RlZCBieSByZUNBUFRDSEEuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHdvcmsgaW4gYSBOb2RlLmpzIGVudmlyb25tZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCkge1xyXG4gICAgcmV0dXJuIF9pbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKGF1dGgpO1xyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhlIHBhc3N3b3JkIGFnYWluc3QgdGhlIHBhc3N3b3JkIHBvbGljeSBjb25maWd1cmVkIGZvciB0aGUgcHJvamVjdCBvciB0ZW5hbnQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIElmIG5vIHRlbmFudCBJRCBpcyBzZXQgb24gdGhlIGBBdXRoYCBpbnN0YW5jZSwgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIHVzZSB0aGUgcGFzc3dvcmRcclxuICogcG9saWN5IGNvbmZpZ3VyZWQgZm9yIHRoZSBwcm9qZWN0LiBPdGhlcndpc2UsIHRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZSBwb2xpY3kgY29uZmlndXJlZFxyXG4gKiBmb3IgdGhlIHRlbmFudC4gSWYgYSBwYXNzd29yZCBwb2xpY3kgaGFzIG5vdCBiZWVuIGNvbmZpZ3VyZWQsIHRoZW4gdGhlIGRlZmF1bHQgcG9saWN5XHJcbiAqIGNvbmZpZ3VyZWQgZm9yIGFsbCBwcm9qZWN0cyB3aWxsIGJlIHVzZWQuXHJcbiAqXHJcbiAqIElmIGFuIGF1dGggZmxvdyBmYWlscyBiZWNhdXNlIGEgc3VibWl0dGVkIHBhc3N3b3JkIGRvZXMgbm90IG1lZXQgdGhlIHBhc3N3b3JkIHBvbGljeVxyXG4gKiByZXF1aXJlbWVudHMgYW5kIHRoaXMgbWV0aG9kIGhhcyBwcmV2aW91c2x5IGJlZW4gY2FsbGVkLCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZVxyXG4gKiBtb3N0IHJlY2VudCBwb2xpY3kgYXZhaWxhYmxlIHdoZW4gY2FsbGVkIGFnYWluLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIHZhbGlkYXRlUGFzc3dvcmQoYXV0aCwgJ3NvbWUtcGFzc3dvcmQnKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gdmFsaWRhdGUuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlUGFzc3dvcmQoYXV0aCwgcGFzc3dvcmQpIHtcclxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcclxuICAgIHJldHVybiBhdXRoSW50ZXJuYWwudmFsaWRhdGVQYXNzd29yZChwYXNzd29yZCk7XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgYW4gb2JzZXJ2ZXIgZm9yIGNoYW5nZXMgdG8gdGhlIHNpZ25lZC1pbiB1c2VyJ3MgSUQgdG9rZW4uXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoaXMgaW5jbHVkZXMgc2lnbi1pbiwgc2lnbi1vdXQsIGFuZCB0b2tlbiByZWZyZXNoIGV2ZW50cy5cclxuICogVGhpcyB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSB1cG9uIElEIHRva2VuIGV4cGlyYXRpb24uIFVzZSB7QGxpbmsgVXNlci5nZXRJZFRva2VufSB0byByZWZyZXNoIHRoZSBJRCB0b2tlbi5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gbmV4dE9yT2JzZXJ2ZXIgLSBjYWxsYmFjayB0cmlnZ2VyZWQgb24gY2hhbmdlLlxyXG4gKiBAcGFyYW0gZXJyb3IgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC4gRXJyb3JzXHJcbiAqIG9uIHNpZ25pbmcgaW4vb3V0IGNhbiBiZSBjYXVnaHQgaW4gcHJvbWlzZXMgcmV0dXJuZWQgZnJvbVxyXG4gKiBzaWduLWluL3NpZ24tb3V0IGZ1bmN0aW9ucy5cclxuICogQHBhcmFtIGNvbXBsZXRlZCAtIERlcHJlY2F0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbmV2ZXIgdHJpZ2dlcmVkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBvbklkVG9rZW5DaGFuZ2VkKGF1dGgsIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLm9uSWRUb2tlbkNoYW5nZWQobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIGEgYmxvY2tpbmcgY2FsbGJhY2sgdGhhdCBydW5zIGJlZm9yZSBhbiBhdXRoIHN0YXRlIGNoYW5nZVxyXG4gKiBzZXRzIGEgbmV3IHVzZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGNhbGxiYWNrIC0gY2FsbGJhY2sgdHJpZ2dlcmVkIGJlZm9yZSBuZXcgdXNlciB2YWx1ZSBpcyBzZXQuXHJcbiAqICAgSWYgdGhpcyB0aHJvd3MsIGl0IGJsb2NrcyB0aGUgdXNlciBmcm9tIGJlaW5nIHNldC5cclxuICogQHBhcmFtIG9uQWJvcnQgLSBjYWxsYmFjayB0cmlnZ2VyZWQgaWYgYSBsYXRlciBgYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZCgpYFxyXG4gKiAgIGNhbGxiYWNrIHRocm93cywgYWxsb3dpbmcgeW91IHRvIHVuZG8gYW55IHNpZGUgZWZmZWN0cy5cclxuICovXHJcbmZ1bmN0aW9uIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoYXV0aCwgY2FsbGJhY2ssIG9uQWJvcnQpIHtcclxuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkuYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZChjYWxsYmFjaywgb25BYm9ydCk7XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgYW4gb2JzZXJ2ZXIgZm9yIGNoYW5nZXMgdG8gdGhlIHVzZXIncyBzaWduLWluIHN0YXRlLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUbyBrZWVwIHRoZSBvbGQgYmVoYXZpb3IsIHNlZSB7QGxpbmsgb25JZFRva2VuQ2hhbmdlZH0uXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIG5leHRPck9ic2VydmVyIC0gY2FsbGJhY2sgdHJpZ2dlcmVkIG9uIGNoYW5nZS5cclxuICogQHBhcmFtIGVycm9yIC0gRGVwcmVjYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBuZXZlciB0cmlnZ2VyZWQuIEVycm9yc1xyXG4gKiBvbiBzaWduaW5nIGluL291dCBjYW4gYmUgY2F1Z2h0IGluIHByb21pc2VzIHJldHVybmVkIGZyb21cclxuICogc2lnbi1pbi9zaWduLW91dCBmdW5jdGlvbnMuXHJcbiAqIEBwYXJhbSBjb21wbGV0ZWQgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gb25BdXRoU3RhdGVDaGFuZ2VkKGF1dGgsIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLm9uQXV0aFN0YXRlQ2hhbmdlZChuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCk7XHJcbn1cclxuLyoqXHJcbiAqIFNldHMgdGhlIGN1cnJlbnQgbGFuZ3VhZ2UgdG8gdGhlIGRlZmF1bHQgZGV2aWNlL2Jyb3dzZXIgcHJlZmVyZW5jZS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VEZXZpY2VMYW5ndWFnZShhdXRoKSB7XHJcbiAgICBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkudXNlRGV2aWNlTGFuZ3VhZ2UoKTtcclxufVxyXG4vKipcclxuICogQXN5bmNocm9ub3VzbHkgc2V0cyB0aGUgcHJvdmlkZWQgdXNlciBhcyB7QGxpbmsgQXV0aC5jdXJyZW50VXNlcn0gb24gdGhlXHJcbiAqIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICpcclxuICogQHJlbWFya3NcclxuICogQSBuZXcgaW5zdGFuY2UgY29weSBvZiB0aGUgdXNlciBwcm92aWRlZCB3aWxsIGJlIG1hZGUgYW5kIHNldCBhcyBjdXJyZW50VXNlci5cclxuICpcclxuICogVGhpcyB3aWxsIHRyaWdnZXIge0BsaW5rIG9uQXV0aFN0YXRlQ2hhbmdlZH0gYW5kIHtAbGluayBvbklkVG9rZW5DaGFuZ2VkfSBsaXN0ZW5lcnNcclxuICogbGlrZSBvdGhlciBzaWduIGluIG1ldGhvZHMuXHJcbiAqXHJcbiAqIFRoZSBvcGVyYXRpb24gZmFpbHMgd2l0aCBhbiBlcnJvciBpZiB0aGUgdXNlciB0byBiZSB1cGRhdGVkIGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgRmlyZWJhc2VcclxuICogcHJvamVjdC5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gdXNlciAtIFRoZSBuZXcge0BsaW5rIFVzZXJ9LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVDdXJyZW50VXNlcihhdXRoLCB1c2VyKSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLnVwZGF0ZUN1cnJlbnRVc2VyKHVzZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBTaWducyBvdXQgdGhlIGN1cnJlbnQgdXNlci5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBzaWduT3V0KGF1dGgpIHtcclxuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkuc2lnbk91dCgpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXZva2VzIHRoZSBnaXZlbiBhY2Nlc3MgdG9rZW4uIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIEFwcGxlIE9BdXRoIGFjY2VzcyB0b2tlbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHRva2VuIC0gVGhlIEFwcGxlIE9BdXRoIGFjY2VzcyB0b2tlbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gcmV2b2tlQWNjZXNzVG9rZW4oYXV0aCwgdG9rZW4pIHtcclxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcclxuICAgIHJldHVybiBhdXRoSW50ZXJuYWwucmV2b2tlQWNjZXNzVG9rZW4odG9rZW4pO1xyXG59XHJcbi8qKlxyXG4gKiBEZWxldGVzIGFuZCBzaWducyBvdXQgdGhlIHVzZXIuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIEltcG9ydGFudDogdGhpcyBpcyBhIHNlY3VyaXR5LXNlbnNpdGl2ZSBvcGVyYXRpb24gdGhhdCByZXF1aXJlcyB0aGUgdXNlciB0byBoYXZlIHJlY2VudGx5XHJcbiAqIHNpZ25lZCBpbi4gSWYgdGhpcyByZXF1aXJlbWVudCBpc24ndCBtZXQsIGFzayB0aGUgdXNlciB0byBhdXRoZW50aWNhdGUgYWdhaW4gYW5kIHRoZW4gY2FsbFxyXG4gKiB7QGxpbmsgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbH0uXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVVzZXIodXNlcikge1xyXG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKS5kZWxldGUoKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBNdWx0aUZhY3RvclNlc3Npb25JbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGNyZWRlbnRpYWwsIHVzZXIpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuY3JlZGVudGlhbCA9IGNyZWRlbnRpYWw7XHJcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZnJvbUlkdG9rZW4oaWRUb2tlbiwgdXNlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbChcImVucm9sbFwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMICovLCBpZFRva2VuLCB1c2VyKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZnJvbU1mYVBlbmRpbmdDcmVkZW50aWFsKG1mYVBlbmRpbmdDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aUZhY3RvclNlc3Npb25JbXBsKFwic2lnbmluXCIgLyogTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5TSUdOX0lOICovLCBtZmFQZW5kaW5nQ3JlZGVudGlhbCk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy50eXBlID09PSBcImVucm9sbFwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMICovXHJcbiAgICAgICAgICAgID8gJ2lkVG9rZW4nXHJcbiAgICAgICAgICAgIDogJ3BlbmRpbmdDcmVkZW50aWFsJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtdWx0aUZhY3RvclNlc3Npb246IHtcclxuICAgICAgICAgICAgICAgIFtrZXldOiB0aGlzLmNyZWRlbnRpYWxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUpTT04ob2JqKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLm11bHRpRmFjdG9yU2Vzc2lvbikge1xyXG4gICAgICAgICAgICBpZiAoKF9hID0gb2JqLm11bHRpRmFjdG9yU2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlbmRpbmdDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTXVsdGlGYWN0b3JTZXNzaW9uSW1wbC5fZnJvbU1mYVBlbmRpbmdDcmVkZW50aWFsKG9iai5tdWx0aUZhY3RvclNlc3Npb24ucGVuZGluZ0NyZWRlbnRpYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChfYiA9IG9iai5tdWx0aUZhY3RvclNlc3Npb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTXVsdGlGYWN0b3JTZXNzaW9uSW1wbC5fZnJvbUlkdG9rZW4ob2JqLm11bHRpRmFjdG9yU2Vzc2lvbi5pZFRva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBNdWx0aUZhY3RvclJlc29sdmVySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uLCBoaW50cywgc2lnbkluUmVzb2x2ZXIpIHtcclxuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xyXG4gICAgICAgIHRoaXMuaGludHMgPSBoaW50cztcclxuICAgICAgICB0aGlzLnNpZ25JblJlc29sdmVyID0gc2lnbkluUmVzb2x2ZXI7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgX2Zyb21FcnJvcihhdXRoRXh0ZXJuLCBlcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGF1dGggPSBfY2FzdEF1dGgoYXV0aEV4dGVybik7XHJcbiAgICAgICAgY29uc3Qgc2VydmVyUmVzcG9uc2UgPSBlcnJvci5jdXN0b21EYXRhLl9zZXJ2ZXJSZXNwb25zZTtcclxuICAgICAgICBjb25zdCBoaW50cyA9IChzZXJ2ZXJSZXNwb25zZS5tZmFJbmZvIHx8IFtdKS5tYXAoZW5yb2xsbWVudCA9PiBNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UoYXV0aCwgZW5yb2xsbWVudCkpO1xyXG4gICAgICAgIF9hc3NlcnQoc2VydmVyUmVzcG9uc2UubWZhUGVuZGluZ0NyZWRlbnRpYWwsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBjb25zdCBzZXNzaW9uID0gTXVsdGlGYWN0b3JTZXNzaW9uSW1wbC5fZnJvbU1mYVBlbmRpbmdDcmVkZW50aWFsKHNlcnZlclJlc3BvbnNlLm1mYVBlbmRpbmdDcmVkZW50aWFsKTtcclxuICAgICAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yUmVzb2x2ZXJJbXBsKHNlc3Npb24sIGhpbnRzLCBhc3luYyAoYXNzZXJ0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1mYVJlc3BvbnNlID0gYXdhaXQgYXNzZXJ0aW9uLl9wcm9jZXNzKGF1dGgsIHNlc3Npb24pO1xyXG4gICAgICAgICAgICAvLyBDbGVhciBvdXQgdGhlIHVubmVlZGVkIGZpZWxkcyBmcm9tIHRoZSBvbGQgbG9naW4gcmVzcG9uc2VcclxuICAgICAgICAgICAgZGVsZXRlIHNlcnZlclJlc3BvbnNlLm1mYUluZm87XHJcbiAgICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXJSZXNwb25zZS5tZmFQZW5kaW5nQ3JlZGVudGlhbDtcclxuICAgICAgICAgICAgLy8gVXNlIGluIHRoZSBuZXcgdG9rZW4gJiByZWZyZXNoIHRva2VuIGluIHRoZSBvbGQgcmVzcG9uc2VcclxuICAgICAgICAgICAgY29uc3QgaWRUb2tlblJlc3BvbnNlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXJ2ZXJSZXNwb25zZSksIHsgaWRUb2tlbjogbWZhUmVzcG9uc2UuaWRUb2tlbiwgcmVmcmVzaFRva2VuOiBtZmFSZXNwb25zZS5yZWZyZXNoVG9rZW4gfSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBjb2xsYXBzZSB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQgaW50byBVc2VyQ3JlZGVudGlhbEltcGwuX2Zvck9wZXJhdGlvbiBhbmQgaGF2ZSBpdCBzdXBwb3J0IHRoZSBTSUdOX0lOIGNhc2VcclxuICAgICAgICAgICAgc3dpdGNoIChlcnJvci5vcGVyYXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIGVycm9yLm9wZXJhdGlvblR5cGUsIGlkVG9rZW5SZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYXV0aC5fdXBkYXRlQ3VycmVudFVzZXIodXNlckNyZWRlbnRpYWwudXNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJDcmVkZW50aWFsO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlYXV0aGVudGljYXRlXCIgLyogT3BlcmF0aW9uVHlwZS5SRUFVVEhFTlRJQ0FURSAqLzpcclxuICAgICAgICAgICAgICAgICAgICBfYXNzZXJ0KGVycm9yLnVzZXIsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXNlckNyZWRlbnRpYWxJbXBsLl9mb3JPcGVyYXRpb24oZXJyb3IudXNlciwgZXJyb3Iub3BlcmF0aW9uVHlwZSwgaWRUb2tlblJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZhaWwoYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyByZXNvbHZlU2lnbkluKGFzc2VydGlvbkV4dGVybikge1xyXG4gICAgICAgIGNvbnN0IGFzc2VydGlvbiA9IGFzc2VydGlvbkV4dGVybjtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaWduSW5SZXNvbHZlcihhc3NlcnRpb24pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhIHtAbGluayBNdWx0aUZhY3RvclJlc29sdmVyfSBzdWl0YWJsZSBmb3IgY29tcGxldGlvbiBvZiBhXHJcbiAqIG11bHRpLWZhY3RvciBmbG93LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSB7QGxpbmsgTXVsdGlGYWN0b3JFcnJvcn0gcmFpc2VkIGR1cmluZyBhIHNpZ24taW4sIG9yXHJcbiAqIHJlYXV0aGVudGljYXRpb24gb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNdWx0aUZhY3RvclJlc29sdmVyKGF1dGgsIGVycm9yKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBhdXRoTW9kdWxhciA9IGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKTtcclxuICAgIGNvbnN0IGVycm9ySW50ZXJuYWwgPSBlcnJvcjtcclxuICAgIF9hc3NlcnQoZXJyb3IuY3VzdG9tRGF0YS5vcGVyYXRpb25UeXBlLCBhdXRoTW9kdWxhciwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgX2Fzc2VydCgoX2EgPSBlcnJvckludGVybmFsLmN1c3RvbURhdGEuX3NlcnZlclJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWZhUGVuZGluZ0NyZWRlbnRpYWwsIGF1dGhNb2R1bGFyLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICByZXR1cm4gTXVsdGlGYWN0b3JSZXNvbHZlckltcGwuX2Zyb21FcnJvcihhdXRoTW9kdWxhciwgZXJyb3JJbnRlcm5hbCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3RhcnRFbnJvbGxUb3RwTWZhKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92Mi9hY2NvdW50cy9tZmFFbnJvbGxtZW50OnN0YXJ0XCIgLyogRW5kcG9pbnQuU1RBUlRfTUZBX0VOUk9MTE1FTlQgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cclxuZnVuY3Rpb24gZmluYWxpemVFbnJvbGxUb3RwTWZhKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92Mi9hY2NvdW50cy9tZmFFbnJvbGxtZW50OmZpbmFsaXplXCIgLyogRW5kcG9pbnQuRklOQUxJWkVfTUZBX0VOUk9MTE1FTlQgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cclxuZnVuY3Rpb24gd2l0aGRyYXdNZmEoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YyL2FjY291bnRzL21mYUVucm9sbG1lbnQ6d2l0aGRyYXdcIiAvKiBFbmRwb2ludC5XSVRIRFJBV19NRkEgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cblxuY2xhc3MgTXVsdGlGYWN0b3JVc2VySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1c2VyKSB7XHJcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcclxuICAgICAgICB0aGlzLmVucm9sbGVkRmFjdG9ycyA9IFtdO1xyXG4gICAgICAgIHVzZXIuX29uUmVsb2FkKHVzZXJJbmZvID0+IHtcclxuICAgICAgICAgICAgaWYgKHVzZXJJbmZvLm1mYUluZm8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5yb2xsZWRGYWN0b3JzID0gdXNlckluZm8ubWZhSW5mby5tYXAoZW5yb2xsbWVudCA9PiBNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UodXNlci5hdXRoLCBlbnJvbGxtZW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZnJvbVVzZXIodXNlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JVc2VySW1wbCh1c2VyKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldFNlc3Npb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21JZHRva2VuKGF3YWl0IHRoaXMudXNlci5nZXRJZFRva2VuKCksIHRoaXMudXNlcik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBlbnJvbGwoYXNzZXJ0aW9uRXh0ZXJuLCBkaXNwbGF5TmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGFzc2VydGlvbiA9IGFzc2VydGlvbkV4dGVybjtcclxuICAgICAgICBjb25zdCBzZXNzaW9uID0gKGF3YWl0IHRoaXMuZ2V0U2Vzc2lvbigpKTtcclxuICAgICAgICBjb25zdCBmaW5hbGl6ZU1mYVJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcy51c2VyLCBhc3NlcnRpb24uX3Byb2Nlc3ModGhpcy51c2VyLmF1dGgsIHNlc3Npb24sIGRpc3BsYXlOYW1lKSk7XHJcbiAgICAgICAgLy8gTmV3IHRva2VucyB3aWxsIGJlIGlzc3VlZCBhZnRlciBlbnJvbGxtZW50IG9mIHRoZSBuZXcgc2Vjb25kIGZhY3RvcnMuXHJcbiAgICAgICAgLy8gVGhleSBuZWVkIHRvIGJlIHVwZGF0ZWQgb24gdGhlIHVzZXIuXHJcbiAgICAgICAgYXdhaXQgdGhpcy51c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShmaW5hbGl6ZU1mYVJlc3BvbnNlKTtcclxuICAgICAgICAvLyBUaGUgdXNlciBuZWVkcyB0byBiZSByZWxvYWRlZCB0byBnZXQgdGhlIG5ldyBtdWx0aS1mYWN0b3IgaW5mb3JtYXRpb25cclxuICAgICAgICAvLyBmcm9tIHNlcnZlci4gVVNFUl9SRUxPQURFRCBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCBhbmQgYGVucm9sbGVkRmFjdG9yc2BcclxuICAgICAgICAvLyB3aWxsIGJlIHVwZGF0ZWQuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlci5yZWxvYWQoKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHVuZW5yb2xsKGluZm9PclVpZCkge1xyXG4gICAgICAgIGNvbnN0IG1mYUVucm9sbG1lbnRJZCA9IHR5cGVvZiBpbmZvT3JVaWQgPT09ICdzdHJpbmcnID8gaW5mb09yVWlkIDogaW5mb09yVWlkLnVpZDtcclxuICAgICAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdGhpcy51c2VyLmdldElkVG9rZW4oKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBpZFRva2VuUmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh0aGlzLnVzZXIsIHdpdGhkcmF3TWZhKHRoaXMudXNlci5hdXRoLCB7XHJcbiAgICAgICAgICAgICAgICBpZFRva2VuLFxyXG4gICAgICAgICAgICAgICAgbWZhRW5yb2xsbWVudElkXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZWNvbmQgZmFjdG9yIGZyb20gdGhlIHVzZXIncyBsaXN0LlxyXG4gICAgICAgICAgICB0aGlzLmVucm9sbGVkRmFjdG9ycyA9IHRoaXMuZW5yb2xsZWRGYWN0b3JzLmZpbHRlcigoeyB1aWQgfSkgPT4gdWlkICE9PSBtZmFFbnJvbGxtZW50SWQpO1xyXG4gICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB0aGUgYmFja2VuZCBkZWNpZGVkIHRvIHJldm9rZSB0aGUgdXNlcidzIHNlc3Npb24sXHJcbiAgICAgICAgICAgIC8vIHRoZSB0b2tlblJlc3BvbnNlIG1heSBiZSBlbXB0eS4gSWYgdGhlIHRva2VucyB3ZXJlIG5vdCB1cGRhdGVkIChhbmQgdGhleVxyXG4gICAgICAgICAgICAvLyBhcmUgbm93IGludmFsaWQpLCByZWxvYWRpbmcgdGhlIHVzZXIgd2lsbCBkaXNjb3ZlciB0aGlzIGFuZCBpbnZhbGlkYXRlXHJcbiAgICAgICAgICAgIC8vIHRoZSB1c2VyJ3Mgc3RhdGUgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXNlci5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkoaWRUb2tlblJlc3BvbnNlKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy51c2VyLnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBtdWx0aUZhY3RvclVzZXJDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XHJcbi8qKlxyXG4gKiBUaGUge0BsaW5rIE11bHRpRmFjdG9yVXNlcn0gY29ycmVzcG9uZGluZyB0byB0aGUgdXNlci5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBpcyB1c2VkIHRvIGFjY2VzcyBhbGwgbXVsdGktZmFjdG9yIHByb3BlcnRpZXMgYW5kIG9wZXJhdGlvbnMgcmVsYXRlZCB0byB0aGUgdXNlci5cclxuICpcclxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gbXVsdGlGYWN0b3IodXNlcikge1xyXG4gICAgY29uc3QgdXNlck1vZHVsYXIgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XHJcbiAgICBpZiAoIW11bHRpRmFjdG9yVXNlckNhY2hlLmhhcyh1c2VyTW9kdWxhcikpIHtcclxuICAgICAgICBtdWx0aUZhY3RvclVzZXJDYWNoZS5zZXQodXNlck1vZHVsYXIsIE11bHRpRmFjdG9yVXNlckltcGwuX2Zyb21Vc2VyKHVzZXJNb2R1bGFyKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbXVsdGlGYWN0b3JVc2VyQ2FjaGUuZ2V0KHVzZXJNb2R1bGFyKTtcclxufVxuXG52YXIgbmFtZSA9IFwiQGZpcmViYXNlL2F1dGhcIjtcbnZhciB2ZXJzaW9uID0gXCIxLjcuMlwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBBdXRoSW50ZXJvcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdXRoKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcclxuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0VWlkKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XHJcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLmF1dGguY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51aWQpIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRUb2tlbihmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5hdXRoLl9pbml0aWFsaXphdGlvblByb21pc2U7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF1dGguY3VycmVudFVzZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5hdXRoLmN1cnJlbnRVc2VyLmdldElkVG9rZW4oZm9yY2VSZWZyZXNoKTtcclxuICAgICAgICByZXR1cm4geyBhY2Nlc3NUb2tlbiB9O1xyXG4gICAgfVxyXG4gICAgYWRkQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuaGFzKGxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5hdXRoLm9uSWRUb2tlbkNoYW5nZWQodXNlciA9PiB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKCh1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIuc3RzVG9rZW5NYW5hZ2VyLmFjY2Vzc1Rva2VuKSB8fCBudWxsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzLnNldChsaXN0ZW5lciwgdW5zdWJzY3JpYmUpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XHJcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLmludGVybmFsTGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XHJcbiAgICAgICAgaWYgKCF1bnN1YnNjcmliZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcclxuICAgICAgICB1bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXV0aENvbmZpZ3VyZWQoKSB7XHJcbiAgICAgICAgX2Fzc2VydCh0aGlzLmF1dGguX2luaXRpYWxpemF0aW9uUHJvbWlzZSwgXCJkZXBlbmRlbnQtc2RrLWluaXRpYWxpemVkLWJlZm9yZS1hdXRoXCIgLyogQXV0aEVycm9yQ29kZS5ERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEggKi8pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJvYWN0aXZlUmVmcmVzaCgpIHtcclxuICAgICAgICBpZiAodGhpcy5pbnRlcm5hbExpc3RlbmVycy5zaXplID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmF1dGguX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hdXRoLl9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRWZXJzaW9uRm9yUGxhdGZvcm0oY2xpZW50UGxhdGZvcm0pIHtcclxuICAgIHN3aXRjaCAoY2xpZW50UGxhdGZvcm0pIHtcclxuICAgICAgICBjYXNlIFwiTm9kZVwiIC8qIENsaWVudFBsYXRmb3JtLk5PREUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAnbm9kZSc7XHJcbiAgICAgICAgY2FzZSBcIlJlYWN0TmF0aXZlXCIgLyogQ2xpZW50UGxhdGZvcm0uUkVBQ1RfTkFUSVZFICovOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3JuJztcclxuICAgICAgICBjYXNlIFwiV29ya2VyXCIgLyogQ2xpZW50UGxhdGZvcm0uV09SS0VSICovOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3dlYndvcmtlcic7XHJcbiAgICAgICAgY2FzZSBcIkNvcmRvdmFcIiAvKiBDbGllbnRQbGF0Zm9ybS5DT1JET1ZBICovOlxyXG4gICAgICAgICAgICByZXR1cm4gJ2NvcmRvdmEnO1xyXG4gICAgICAgIGNhc2UgXCJXZWJFeHRlbnNpb25cIiAvKiBDbGllbnRQbGF0Zm9ybS5XRUJfRVhURU5TSU9OICovOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3dlYi1leHRlbnNpb24nO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5mdW5jdGlvbiByZWdpc3RlckF1dGgoY2xpZW50UGxhdGZvcm0pIHtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KFwiYXV0aFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEggKi8sIChjb250YWluZXIsIHsgb3B0aW9uczogZGVwcyB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICBjb25zdCBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2hlYXJ0YmVhdCcpO1xyXG4gICAgICAgIGNvbnN0IGFwcENoZWNrU2VydmljZVByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnKTtcclxuICAgICAgICBjb25zdCB7IGFwaUtleSwgYXV0aERvbWFpbiB9ID0gYXBwLm9wdGlvbnM7XHJcbiAgICAgICAgX2Fzc2VydChhcGlLZXkgJiYgIWFwaUtleS5pbmNsdWRlcygnOicpLCBcImludmFsaWQtYXBpLWtleVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BUElfS0VZICovLCB7IGFwcE5hbWU6IGFwcC5uYW1lIH0pO1xyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgYXBpS2V5LFxyXG4gICAgICAgICAgICBhdXRoRG9tYWluLFxyXG4gICAgICAgICAgICBjbGllbnRQbGF0Zm9ybSxcclxuICAgICAgICAgICAgYXBpSG9zdDogXCJpZGVudGl0eXRvb2xraXQuZ29vZ2xlYXBpcy5jb21cIiAvKiBEZWZhdWx0Q29uZmlnLkFQSV9IT1NUICovLFxyXG4gICAgICAgICAgICB0b2tlbkFwaUhvc3Q6IFwic2VjdXJldG9rZW4uZ29vZ2xlYXBpcy5jb21cIiAvKiBEZWZhdWx0Q29uZmlnLlRPS0VOX0FQSV9IT1NUICovLFxyXG4gICAgICAgICAgICBhcGlTY2hlbWU6IFwiaHR0cHNcIiAvKiBEZWZhdWx0Q29uZmlnLkFQSV9TQ0hFTUUgKi8sXHJcbiAgICAgICAgICAgIHNka0NsaWVudFZlcnNpb246IF9nZXRDbGllbnRWZXJzaW9uKGNsaWVudFBsYXRmb3JtKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYXV0aEluc3RhbmNlID0gbmV3IEF1dGhJbXBsKGFwcCwgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyLCBhcHBDaGVja1NlcnZpY2VQcm92aWRlciwgY29uZmlnKTtcclxuICAgICAgICBfaW5pdGlhbGl6ZUF1dGhJbnN0YW5jZShhdXRoSW5zdGFuY2UsIGRlcHMpO1xyXG4gICAgICAgIHJldHVybiBhdXRoSW5zdGFuY2U7XHJcbiAgICB9LCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEF1dGggY2FuIG9ubHkgYmUgaW5pdGlhbGl6ZWQgYnkgZXhwbGljaXRseSBjYWxsaW5nIGdldEF1dGgoKSBvciBpbml0aWFsaXplQXV0aCgpXHJcbiAgICAgICAgICogRm9yIHdoeSB3ZSBkbyB0aGlzLCBTZWUgZ28vZmlyZWJhc2UtbmV4dC1hdXRoLWluaXRcclxuICAgICAgICAgKi9cclxuICAgICAgICAuc2V0SW5zdGFudGlhdGlvbk1vZGUoXCJFWFBMSUNJVFwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkVYUExJQ0lUICovKVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJlY2F1c2UgYWxsIGZpcmViYXNlIHByb2R1Y3RzIHRoYXQgZGVwZW5kIG9uIGF1dGggZGVwZW5kIG9uIGF1dGgtaW50ZXJuYWwgZGlyZWN0bHksXHJcbiAgICAgICAgICogd2UgbmVlZCB0byBpbml0aWFsaXplIGF1dGgtaW50ZXJuYWwgYWZ0ZXIgYXV0aCBpcyBpbml0aWFsaXplZCB0byBtYWtlIGl0IGF2YWlsYWJsZSB0byBvdGhlciBmaXJlYmFzZSBwcm9kdWN0cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICAuc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soKGNvbnRhaW5lciwgX2luc3RhbmNlSWRlbnRpZmllciwgX2luc3RhbmNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXV0aEludGVybmFsUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoXCJhdXRoLWludGVybmFsXCIgLyogX0NvbXBvbmVudE5hbWUuQVVUSF9JTlRFUk5BTCAqLyk7XHJcbiAgICAgICAgYXV0aEludGVybmFsUHJvdmlkZXIuaW5pdGlhbGl6ZSgpO1xyXG4gICAgfSkpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoXCJhdXRoLWludGVybmFsXCIgLyogX0NvbXBvbmVudE5hbWUuQVVUSF9JTlRFUk5BTCAqLywgY29udGFpbmVyID0+IHtcclxuICAgICAgICBjb25zdCBhdXRoID0gX2Nhc3RBdXRoKGNvbnRhaW5lci5nZXRQcm92aWRlcihcImF1dGhcIiAvKiBfQ29tcG9uZW50TmFtZS5BVVRIICovKS5nZXRJbW1lZGlhdGUoKSk7XHJcbiAgICAgICAgcmV0dXJuIChhdXRoID0+IG5ldyBBdXRoSW50ZXJvcChhdXRoKSkoYXV0aCk7XHJcbiAgICB9LCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pLnNldEluc3RhbnRpYXRpb25Nb2RlKFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLykpO1xyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sIGdldFZlcnNpb25Gb3JQbGF0Zm9ybShjbGllbnRQbGF0Zm9ybSkpO1xyXG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtNSwgZXNtMjAxNywgY2pzNSwgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCAnZXNtMjAxNycpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIEluaXRpYWxpemUgdGhlIGZldGNoIHBvbHlmaWxsLCB0aGUgdHlwZXMgYXJlIHNsaWdodGx5IG9mZiBzbyBqdXN0IGNhc3QgYW5kIGhvcGUgZm9yIHRoZSBiZXN0XHJcbkZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZShmZXRjaCQxLCBIZWFkZXJzJDEsIFJlc3BvbnNlJDEpO1xyXG4vLyBGaXJzdCwgd2Ugc2V0IHVwIHRoZSB2YXJpb3VzIHBsYXRmb3JtLXNwZWNpZmljIGZlYXR1cmVzIGZvciBOb2RlIChyZWdpc3RlclxyXG4vLyB0aGUgdmVyc2lvbiBhbmQgZGVjbGFyZSB0aGUgTm9kZSBnZXRBdXRoIGZ1bmN0aW9uKVxyXG5mdW5jdGlvbiBnZXRBdXRoKGFwcCA9IGdldEFwcCgpKSB7XHJcbiAgICBjb25zdCBwcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsICdhdXRoJyk7XHJcbiAgICBpZiAocHJvdmlkZXIuaXNJbml0aWFsaXplZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXV0aCA9IGluaXRpYWxpemVBdXRoKGFwcCk7XHJcbiAgICBjb25zdCBhdXRoRW11bGF0b3JIb3N0ID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCgnYXV0aCcpO1xyXG4gICAgaWYgKGF1dGhFbXVsYXRvckhvc3QpIHtcclxuICAgICAgICBjb25uZWN0QXV0aEVtdWxhdG9yKGF1dGgsIGBodHRwOi8vJHthdXRoRW11bGF0b3JIb3N0fWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGF1dGg7XHJcbn1cclxucmVnaXN0ZXJBdXRoKFwiTm9kZVwiIC8qIENsaWVudFBsYXRmb3JtLk5PREUgKi8pO1xyXG4vLyBUaGUgcmVzdCBvZiB0aGlzIGZpbGUgY29udGFpbnMgbm8tb3BzIGFuZCBlcnJvcnMgZm9yIGJyb3dzZXItc3BlY2lmaWNcclxuLy8gbWV0aG9kcy4gV2Uga2VlcCB0aGUgYnJvd3NlciBhbmQgTm9kZSBlbnRyeSBwb2ludHMgdGhlIHNhbWUsIGJ1dCBmZWF0dXJlc1xyXG4vLyB0aGF0IG9ubHkgd29yayBpbiBicm93c2VycyBhcmUgc2V0IHRvIGVpdGhlciBkbyBub3RoaW5nIChzZXRQZXJzaXN0ZW5jZSkgb3JcclxuLy8gdG8gcmVqZWN0IHdpdGggYW4gYXV0aC9vcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50IGVycm9yLlxyXG4vLyBUaGUgYmVsb3cgZXhwb3J0cyBhcmUgcHVsbGVkIGludG8gdGhlIG1haW4gZW50cnkgcG9pbnQgYnkgYSByb2xsdXAgYWxpYXNcclxuLy8gcGx1Z2luIChvdmVyd3JpdGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGltcG9ydHMpLlxyXG4vKiogYXV0aC9vcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50ICovXHJcbmNvbnN0IE5PVF9BVkFJTEFCTEVfRVJST1IgPSBfY3JlYXRlRXJyb3IoXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIgLyogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX1NVUFBPUlRFRCAqLyk7XHJcbi8qKiBSZWplY3Qgd2l0aCBhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQgKi9cclxuYXN5bmMgZnVuY3Rpb24gZmFpbCgpIHtcclxuICAgIHRocm93IE5PVF9BVkFJTEFCTEVfRVJST1I7XHJcbn1cclxuLyoqXHJcbiAqIEEgY2xhc3Mgd2hpY2ggd2lsbCB0aHJvdyB3aXRoXHJcbiAqIGF1dGgvb3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudCBpZiBpbnN0YW50aWF0ZWRcclxuICovXHJcbmNsYXNzIEZhaWxDbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aHJvdyBOT1RfQVZBSUxBQkxFX0VSUk9SO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGJyb3dzZXJMb2NhbFBlcnNpc3RlbmNlID0gaW5NZW1vcnlQZXJzaXN0ZW5jZTtcclxuY29uc3QgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSA9IGluTWVtb3J5UGVyc2lzdGVuY2U7XHJcbmNvbnN0IGluZGV4ZWREQkxvY2FsUGVyc2lzdGVuY2UgPSBpbk1lbW9yeVBlcnNpc3RlbmNlO1xyXG5jb25zdCBicm93c2VyUG9wdXBSZWRpcmVjdFJlc29sdmVyID0gTk9UX0FWQUlMQUJMRV9FUlJPUjtcclxuY29uc3QgUGhvbmVBdXRoUHJvdmlkZXIgPSBGYWlsQ2xhc3M7XHJcbmNvbnN0IHNpZ25JbldpdGhQaG9uZU51bWJlciA9IGZhaWw7XHJcbmNvbnN0IGxpbmtXaXRoUGhvbmVOdW1iZXIgPSBmYWlsO1xyXG5jb25zdCByZWF1dGhlbnRpY2F0ZVdpdGhQaG9uZU51bWJlciA9IGZhaWw7XHJcbmNvbnN0IHVwZGF0ZVBob25lTnVtYmVyID0gZmFpbDtcclxuY29uc3Qgc2lnbkluV2l0aFBvcHVwID0gZmFpbDtcclxuY29uc3QgbGlua1dpdGhQb3B1cCA9IGZhaWw7XHJcbmNvbnN0IHJlYXV0aGVudGljYXRlV2l0aFBvcHVwID0gZmFpbDtcclxuY29uc3Qgc2lnbkluV2l0aFJlZGlyZWN0ID0gZmFpbDtcclxuY29uc3QgbGlua1dpdGhSZWRpcmVjdCA9IGZhaWw7XHJcbmNvbnN0IHJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0ID0gZmFpbDtcclxuY29uc3QgZ2V0UmVkaXJlY3RSZXN1bHQgPSBmYWlsO1xyXG5jb25zdCBSZWNhcHRjaGFWZXJpZmllciA9IEZhaWxDbGFzcztcclxuY2xhc3MgUGhvbmVNdWx0aUZhY3RvckdlbmVyYXRvciB7XHJcbiAgICBzdGF0aWMgYXNzZXJ0aW9uKCkge1xyXG4gICAgICAgIHRocm93IE5PVF9BVkFJTEFCTEVfRVJST1I7XHJcbiAgICB9XHJcbn1cclxuLy8gU2V0IHBlcnNpc3RlbmNlIHNob3VsZCBuby1vcCBpbnN0ZWFkIG9mIGZhaWwuIENoYW5naW5nIHRoZSBwcm90b3R5cGUgd2lsbFxyXG4vLyBtYWtlIHN1cmUgYm90aCBzZXRQZXJzaXN0ZW5jZShhdXRoLCBwZXJzaXN0ZW5jZSkgYW5kXHJcbi8vIGF1dGguc2V0UGVyc2lzdGVuY2UocGVyc2lzdGVuY2UpIGFyZSBjb3ZlcmVkLlxyXG5BdXRoSW1wbC5wcm90b3R5cGUuc2V0UGVyc2lzdGVuY2UgPSBhc3luYyAoKSA9PiB7IH07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGZpbmFsaXplU2lnbkluVG90cE1mYShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHMvbWZhU2lnbkluOmZpbmFsaXplXCIgLyogRW5kcG9pbnQuRklOQUxJWkVfTUZBX1NJR05fSU4gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cblxuY2xhc3MgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGZhY3RvcklkKSB7XHJcbiAgICAgICAgdGhpcy5mYWN0b3JJZCA9IGZhY3RvcklkO1xyXG4gICAgfVxyXG4gICAgX3Byb2Nlc3MoYXV0aCwgc2Vzc2lvbiwgZGlzcGxheU5hbWUpIHtcclxuICAgICAgICBzd2l0Y2ggKHNlc3Npb24udHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiZW5yb2xsXCIgLyogTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5FTlJPTEwgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVFbnJvbGwoYXV0aCwgc2Vzc2lvbi5jcmVkZW50aWFsLCBkaXNwbGF5TmFtZSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzaWduaW5cIiAvKiBNdWx0aUZhY3RvclNlc3Npb25UeXBlLlNJR05fSU4gKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVTaWduSW4oYXV0aCwgc2Vzc2lvbi5jcmVkZW50aWFsKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ3VuZXhwZWN0ZWQgTXVsdGlGYWN0b3JTZXNzaW9uVHlwZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufSB0byBjb25maXJtIG93bmVyc2hpcCBvZlxyXG4gICAgICogdGhlIFRPVFAgKHRpbWUtYmFzZWQgb25lLXRpbWUgcGFzc3dvcmQpIHNlY29uZCBmYWN0b3IuXHJcbiAgICAgKiBUaGlzIGFzc2VydGlvbiBpcyB1c2VkIHRvIGNvbXBsZXRlIGVucm9sbG1lbnQgaW4gVE9UUCBzZWNvbmQgZmFjdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWNyZXQgQSB7QGxpbmsgVG90cFNlY3JldH0gY29udGFpbmluZyB0aGUgc2hhcmVkIHNlY3JldCBrZXkgYW5kIG90aGVyIFRPVFAgcGFyYW1ldGVycy5cclxuICAgICAqIEBwYXJhbSBvbmVUaW1lUGFzc3dvcmQgT25lLXRpbWUgcGFzc3dvcmQgZnJvbSBUT1RQIEFwcC5cclxuICAgICAqIEByZXR1cm5zIEEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gd2hpY2ggY2FuIGJlIHVzZWQgd2l0aFxyXG4gICAgICoge0BsaW5rIE11bHRpRmFjdG9yVXNlci5lbnJvbGx9LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXNzZXJ0aW9uRm9yRW5yb2xsbWVudChzZWNyZXQsIG9uZVRpbWVQYXNzd29yZCkge1xyXG4gICAgICAgIHJldHVybiBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsLl9mcm9tU2VjcmV0KHNlY3JldCwgb25lVGltZVBhc3N3b3JkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufSB0byBjb25maXJtIG93bmVyc2hpcCBvZiB0aGUgVE9UUCBzZWNvbmQgZmFjdG9yLlxyXG4gICAgICogVGhpcyBhc3NlcnRpb24gaXMgdXNlZCB0byBjb21wbGV0ZSBzaWduSW4gd2l0aCBUT1RQIGFzIHRoZSBzZWNvbmQgZmFjdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnJvbGxtZW50SWQgaWRlbnRpZmllcyB0aGUgZW5yb2xsZWQgVE9UUCBzZWNvbmQgZmFjdG9yLlxyXG4gICAgICogQHBhcmFtIG9uZVRpbWVQYXNzd29yZCBPbmUtdGltZSBwYXNzd29yZCBmcm9tIFRPVFAgQXBwLlxyXG4gICAgICogQHJldHVybnMgQSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufSB3aGljaCBjYW4gYmUgdXNlZCB3aXRoXHJcbiAgICAgKiB7QGxpbmsgTXVsdGlGYWN0b3JSZXNvbHZlci5yZXNvbHZlU2lnbklufS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzc2VydGlvbkZvclNpZ25JbihlbnJvbGxtZW50SWQsIG9uZVRpbWVQYXNzd29yZCkge1xyXG4gICAgICAgIHJldHVybiBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsLl9mcm9tRW5yb2xsbWVudElkKGVucm9sbG1lbnRJZCwgb25lVGltZVBhc3N3b3JkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdG8ge0BsaW5rIFRvdHBTZWNyZXR9IHdoaWNoIGNvbnRhaW5zIHRoZSBUT1RQIHNoYXJlZCBzZWNyZXQga2V5IGFuZCBvdGhlciBwYXJhbWV0ZXJzLlxyXG4gICAgICogQ3JlYXRlcyBhIFRPVFAgc2VjcmV0IGFzIHBhcnQgb2YgZW5yb2xsaW5nIGEgVE9UUCBzZWNvbmQgZmFjdG9yLlxyXG4gICAgICogVXNlZCBmb3IgZ2VuZXJhdGluZyBhIFFSIGNvZGUgVVJMIG9yIGlucHV0dGluZyBpbnRvIGEgVE9UUCBhcHAuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBhdXRoIGluc3RhbmNlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHVzZXIgaW4gdGhlIG11bHRpRmFjdG9yU2Vzc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2Vzc2lvbiBUaGUge0BsaW5rIE11bHRpRmFjdG9yU2Vzc2lvbn0gdGhhdCB0aGUgdXNlciBpcyBwYXJ0IG9mLlxyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRvIHtAbGluayBUb3RwU2VjcmV0fS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlU2VjcmV0KHNlc3Npb24pIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgbWZhU2Vzc2lvbiA9IHNlc3Npb247XHJcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgKChfYSA9IG1mYVNlc3Npb24udXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dGgpICE9PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc3RhcnRFbnJvbGxUb3RwTWZhKG1mYVNlc3Npb24udXNlci5hdXRoLCB7XHJcbiAgICAgICAgICAgIGlkVG9rZW46IG1mYVNlc3Npb24uY3JlZGVudGlhbCxcclxuICAgICAgICAgICAgdG90cEVucm9sbG1lbnRJbmZvOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBUb3RwU2VjcmV0Ll9mcm9tU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlKHJlc3BvbnNlLCBtZmFTZXNzaW9uLnVzZXIuYXV0aCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBUT1RQIHNlY29uZCBmYWN0b3I6IGB0b3RwYC5cclxuICovXHJcblRvdHBNdWx0aUZhY3RvckdlbmVyYXRvci5GQUNUT1JfSUQgPSBcInRvdHBcIiAvKiBGYWN0b3JJZC5UT1RQICovO1xyXG5jbGFzcyBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIGV4dGVuZHMgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKG90cCwgZW5yb2xsbWVudElkLCBzZWNyZXQpIHtcclxuICAgICAgICBzdXBlcihcInRvdHBcIiAvKiBGYWN0b3JJZC5UT1RQICovKTtcclxuICAgICAgICB0aGlzLm90cCA9IG90cDtcclxuICAgICAgICB0aGlzLmVucm9sbG1lbnRJZCA9IGVucm9sbG1lbnRJZDtcclxuICAgICAgICB0aGlzLnNlY3JldCA9IHNlY3JldDtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHN0YXRpYyBfZnJvbVNlY3JldChzZWNyZXQsIG90cCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbChvdHAsIHVuZGVmaW5lZCwgc2VjcmV0KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHN0YXRpYyBfZnJvbUVucm9sbG1lbnRJZChlbnJvbGxtZW50SWQsIG90cCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbChvdHAsIGVucm9sbG1lbnRJZCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBhc3luYyBfZmluYWxpemVFbnJvbGwoYXV0aCwgaWRUb2tlbiwgZGlzcGxheU5hbWUpIHtcclxuICAgICAgICBfYXNzZXJ0KHR5cGVvZiB0aGlzLnNlY3JldCAhPT0gJ3VuZGVmaW5lZCcsIGF1dGgsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcclxuICAgICAgICByZXR1cm4gZmluYWxpemVFbnJvbGxUb3RwTWZhKGF1dGgsIHtcclxuICAgICAgICAgICAgaWRUb2tlbixcclxuICAgICAgICAgICAgZGlzcGxheU5hbWUsXHJcbiAgICAgICAgICAgIHRvdHBWZXJpZmljYXRpb25JbmZvOiB0aGlzLnNlY3JldC5fbWFrZVRvdHBWZXJpZmljYXRpb25JbmZvKHRoaXMub3RwKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgYXN5bmMgX2ZpbmFsaXplU2lnbkluKGF1dGgsIG1mYVBlbmRpbmdDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgX2Fzc2VydCh0aGlzLmVucm9sbG1lbnRJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3RwICE9PSB1bmRlZmluZWQsIGF1dGgsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcclxuICAgICAgICBjb25zdCB0b3RwVmVyaWZpY2F0aW9uSW5mbyA9IHsgdmVyaWZpY2F0aW9uQ29kZTogdGhpcy5vdHAgfTtcclxuICAgICAgICByZXR1cm4gZmluYWxpemVTaWduSW5Ub3RwTWZhKGF1dGgsIHtcclxuICAgICAgICAgICAgbWZhUGVuZGluZ0NyZWRlbnRpYWwsXHJcbiAgICAgICAgICAgIG1mYUVucm9sbG1lbnRJZDogdGhpcy5lbnJvbGxtZW50SWQsXHJcbiAgICAgICAgICAgIHRvdHBWZXJpZmljYXRpb25JbmZvXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0uXHJcbiAqXHJcbiAqIFN0b3JlcyB0aGUgc2hhcmVkIHNlY3JldCBrZXkgYW5kIG90aGVyIHBhcmFtZXRlcnMgdG8gZ2VuZXJhdGUgdGltZS1iYXNlZCBPVFBzLlxyXG4gKiBJbXBsZW1lbnRzIG1ldGhvZHMgdG8gcmV0cmlldmUgdGhlIHNoYXJlZCBzZWNyZXQga2V5IGFuZCBnZW5lcmF0ZSBhIFFSIGNvZGUgVVJMLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBUb3RwU2VjcmV0IHtcclxuICAgIC8vIFRoZSBwdWJsaWMgbWVtYmVycyBhcmUgZGVjbGFyZWQgb3V0c2lkZSB0aGUgY29uc3RydWN0b3Igc28gdGhlIGRvY3MgY2FuIGJlIGdlbmVyYXRlZC5cclxuICAgIGNvbnN0cnVjdG9yKHNlY3JldEtleSwgaGFzaGluZ0FsZ29yaXRobSwgY29kZUxlbmd0aCwgY29kZUludGVydmFsU2Vjb25kcywgZW5yb2xsbWVudENvbXBsZXRpb25EZWFkbGluZSwgc2Vzc2lvbkluZm8sIGF1dGgpIHtcclxuICAgICAgICB0aGlzLnNlc3Npb25JbmZvID0gc2Vzc2lvbkluZm87XHJcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcclxuICAgICAgICB0aGlzLnNlY3JldEtleSA9IHNlY3JldEtleTtcclxuICAgICAgICB0aGlzLmhhc2hpbmdBbGdvcml0aG0gPSBoYXNoaW5nQWxnb3JpdGhtO1xyXG4gICAgICAgIHRoaXMuY29kZUxlbmd0aCA9IGNvZGVMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5jb2RlSW50ZXJ2YWxTZWNvbmRzID0gY29kZUludGVydmFsU2Vjb25kcztcclxuICAgICAgICB0aGlzLmVucm9sbG1lbnRDb21wbGV0aW9uRGVhZGxpbmUgPSBlbnJvbGxtZW50Q29tcGxldGlvbkRlYWRsaW5lO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIF9mcm9tU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlKHJlc3BvbnNlLCBhdXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUb3RwU2VjcmV0KHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5zaGFyZWRTZWNyZXRLZXksIHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5oYXNoaW5nQWxnb3JpdGhtLCByZXNwb25zZS50b3RwU2Vzc2lvbkluZm8udmVyaWZpY2F0aW9uQ29kZUxlbmd0aCwgcmVzcG9uc2UudG90cFNlc3Npb25JbmZvLnBlcmlvZFNlYywgbmV3IERhdGUocmVzcG9uc2UudG90cFNlc3Npb25JbmZvLmZpbmFsaXplRW5yb2xsbWVudFRpbWUpLnRvVVRDU3RyaW5nKCksIHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5zZXNzaW9uSW5mbywgYXV0aCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfbWFrZVRvdHBWZXJpZmljYXRpb25JbmZvKG90cCkge1xyXG4gICAgICAgIHJldHVybiB7IHNlc3Npb25JbmZvOiB0aGlzLnNlc3Npb25JbmZvLCB2ZXJpZmljYXRpb25Db2RlOiBvdHAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIFFSIGNvZGUgVVJMIGFzIGRlc2NyaWJlZCBpblxyXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9nb29nbGUtYXV0aGVudGljYXRvci93aWtpL0tleS1VcmktRm9ybWF0XHJcbiAgICAgKiBUaGlzIGNhbiBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgYXMgYSBRUiBjb2RlIHRvIGJlIHNjYW5uZWQgaW50byBhIFRPVFAgYXBwIGxpa2UgR29vZ2xlIEF1dGhlbnRpY2F0b3IuXHJcbiAgICAgKiBJZiB0aGUgb3B0aW9uYWwgcGFyYW1ldGVycyBhcmUgdW5zcGVjaWZpZWQsIGFuIGFjY291bnROYW1lIG9mIDx1c2VyRW1haWw+IGFuZCBpc3N1ZXIgb2YgPGZpcmViYXNlQXBwTmFtZT4gYXJlIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjY291bnROYW1lIHRoZSBuYW1lIG9mIHRoZSBhY2NvdW50L2FwcCBhbG9uZyB3aXRoIGEgdXNlciBpZGVudGlmaWVyLlxyXG4gICAgICogQHBhcmFtIGlzc3VlciBpc3N1ZXIgb2YgdGhlIFRPVFAgKGxpa2VseSB0aGUgYXBwIG5hbWUpLlxyXG4gICAgICogQHJldHVybnMgQSBRUiBjb2RlIFVSTCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlUXJDb2RlVXJsKGFjY291bnROYW1lLCBpc3N1ZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgbGV0IHVzZURlZmF1bHRzID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKF9pc0VtcHR5U3RyaW5nKGFjY291bnROYW1lKSB8fCBfaXNFbXB0eVN0cmluZyhpc3N1ZXIpKSB7XHJcbiAgICAgICAgICAgIHVzZURlZmF1bHRzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZURlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgIGlmIChfaXNFbXB0eVN0cmluZyhhY2NvdW50TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY291bnROYW1lID0gKChfYSA9IHRoaXMuYXV0aC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtYWlsKSB8fCAndW5rbm93bnVzZXInO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfaXNFbXB0eVN0cmluZyhpc3N1ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBpc3N1ZXIgPSB0aGlzLmF1dGgubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYG90cGF1dGg6Ly90b3RwLyR7aXNzdWVyfToke2FjY291bnROYW1lfT9zZWNyZXQ9JHt0aGlzLnNlY3JldEtleX0maXNzdWVyPSR7aXNzdWVyfSZhbGdvcml0aG09JHt0aGlzLmhhc2hpbmdBbGdvcml0aG19JmRpZ2l0cz0ke3RoaXMuY29kZUxlbmd0aH1gO1xyXG4gICAgfVxyXG59XHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZnVuY3Rpb24gX2lzRW1wdHlTdHJpbmcoaW5wdXQpIHtcclxuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnIHx8IChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXQubGVuZ3RoKSA9PT0gMDtcclxufVxuXG5leHBvcnQgeyBUd2l0dGVyQXV0aFByb3ZpZGVyIGFzICQsIEFjdGlvbkNvZGVPcGVyYXRpb24gYXMgQSwgdXBkYXRlQ3VycmVudFVzZXIgYXMgQiwgc2lnbk91dCBhcyBDLCByZXZva2VBY2Nlc3NUb2tlbiBhcyBELCBkZWxldGVVc2VyIGFzIEUsIEZhY3RvcklkIGFzIEYsIGRlYnVnRXJyb3JNYXAgYXMgRywgcHJvZEVycm9yTWFwIGFzIEgsIEFVVEhfRVJST1JfQ09ERVNfTUFQX0RPX05PVF9VU0VfSU5URVJOQUxMWSBhcyBJLCBpbml0aWFsaXplQXV0aCBhcyBKLCBjb25uZWN0QXV0aEVtdWxhdG9yIGFzIEssIEF1dGhDcmVkZW50aWFsIGFzIEwsIEVtYWlsQXV0aENyZWRlbnRpYWwgYXMgTSwgT0F1dGhDcmVkZW50aWFsIGFzIE4sIE9wZXJhdGlvblR5cGUgYXMgTywgUGhvbmVBdXRoUHJvdmlkZXIgYXMgUCwgUGhvbmVBdXRoQ3JlZGVudGlhbCBhcyBRLCBSZWNhcHRjaGFWZXJpZmllciBhcyBSLCBTaWduSW5NZXRob2QgYXMgUywgVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yIGFzIFQsIGluTWVtb3J5UGVyc2lzdGVuY2UgYXMgVSwgRW1haWxBdXRoUHJvdmlkZXIgYXMgViwgRmFjZWJvb2tBdXRoUHJvdmlkZXIgYXMgVywgR29vZ2xlQXV0aFByb3ZpZGVyIGFzIFgsIEdpdGh1YkF1dGhQcm92aWRlciBhcyBZLCBPQXV0aFByb3ZpZGVyIGFzIFosIFNBTUxBdXRoUHJvdmlkZXIgYXMgXywgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSBhcyBhLCBzaWduSW5Bbm9ueW1vdXNseSBhcyBhMCwgc2lnbkluV2l0aENyZWRlbnRpYWwgYXMgYTEsIGxpbmtXaXRoQ3JlZGVudGlhbCBhcyBhMiwgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbCBhcyBhMywgc2lnbkluV2l0aEN1c3RvbVRva2VuIGFzIGE0LCBzZW5kUGFzc3dvcmRSZXNldEVtYWlsIGFzIGE1LCBjb25maXJtUGFzc3dvcmRSZXNldCBhcyBhNiwgYXBwbHlBY3Rpb25Db2RlIGFzIGE3LCBjaGVja0FjdGlvbkNvZGUgYXMgYTgsIHZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlIGFzIGE5LCBfZmFpbCBhcyBhQSwgZGVidWdBc3NlcnQgYXMgYUIsIF9wZXJzaXN0ZW5jZUtleU5hbWUgYXMgYUMsIF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yIGFzIGFELCBfY2FzdEF1dGggYXMgYUUsIEZlZGVyYXRlZEF1dGhQcm92aWRlciBhcyBhRiwgQmFzZU9BdXRoUHJvdmlkZXIgYXMgYUcsIF9lbXVsYXRvclVybCBhcyBhSCwgX3BlcmZvcm1BcGlSZXF1ZXN0IGFzIGFJLCBfaXNJT1MgYXMgYUosIF9pc0FuZHJvaWQgYXMgYUssIF9pc0lPUzdPcjggYXMgYUwsIF9jcmVhdGVFcnJvciBhcyBhTSwgX2lzSWZyYW1lIGFzIGFOLCBfaXNNb2JpbGVCcm93c2VyIGFzIGFPLCBfaXNJRTEwIGFzIGFQLCBfaXNTYWZhcmkgYXMgYVEsIFVzZXJJbXBsIGFzIGFSLCBBdXRoSW1wbCBhcyBhUywgX2dldENsaWVudFZlcnNpb24gYXMgYVQsIEZldGNoUHJvdmlkZXIgYXMgYVUsIFNBTUxBdXRoQ3JlZGVudGlhbCBhcyBhViwgY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkIGFzIGFhLCBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZCBhcyBhYiwgc2VuZFNpZ25JbkxpbmtUb0VtYWlsIGFzIGFjLCBpc1NpZ25JbldpdGhFbWFpbExpbmsgYXMgYWQsIHNpZ25JbldpdGhFbWFpbExpbmsgYXMgYWUsIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsIGFzIGFmLCBzZW5kRW1haWxWZXJpZmljYXRpb24gYXMgYWcsIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsIGFzIGFoLCBBY3Rpb25Db2RlVVJMIGFzIGFpLCBwYXJzZUFjdGlvbkNvZGVVUkwgYXMgYWosIHVwZGF0ZVByb2ZpbGUgYXMgYWssIHVwZGF0ZUVtYWlsIGFzIGFsLCB1cGRhdGVQYXNzd29yZCBhcyBhbSwgZ2V0SWRUb2tlbiBhcyBhbiwgZ2V0SWRUb2tlblJlc3VsdCBhcyBhbywgdW5saW5rIGFzIGFwLCBnZXRBZGRpdGlvbmFsVXNlckluZm8gYXMgYXEsIHJlbG9hZCBhcyBhciwgZ2V0TXVsdGlGYWN0b3JSZXNvbHZlciBhcyBhcywgbXVsdGlGYWN0b3IgYXMgYXQsIF9nZXRJbnN0YW5jZSBhcyBhdSwgX2Fzc2VydCBhcyBhdiwgX3NpZ25JbldpdGhDcmVkZW50aWFsIGFzIGF3LCBfcmVhdXRoZW50aWNhdGUgYXMgYXgsIF9saW5rIGFzIGF5LCBzaWduSW5XaXRoSWRwIGFzIGF6LCBicm93c2VyTG9jYWxQZXJzaXN0ZW5jZSBhcyBiLCBzaWduSW5XaXRoUG9wdXAgYXMgYywgbGlua1dpdGhQb3B1cCBhcyBkLCByZWF1dGhlbnRpY2F0ZVdpdGhQb3B1cCBhcyBlLCBzaWduSW5XaXRoUmVkaXJlY3QgYXMgZiwgbGlua1dpdGhSZWRpcmVjdCBhcyBnLCByZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCBhcyBoLCBpbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlIGFzIGksIGdldFJlZGlyZWN0UmVzdWx0IGFzIGosIGJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIgYXMgaywgbGlua1dpdGhQaG9uZU51bWJlciBhcyBsLCBQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yIGFzIG0sIFRvdHBTZWNyZXQgYXMgbiwgZ2V0QXV0aCBhcyBvLCBQcm92aWRlcklkIGFzIHAsIHNldFBlcnNpc3RlbmNlIGFzIHEsIHJlYXV0aGVudGljYXRlV2l0aFBob25lTnVtYmVyIGFzIHIsIHNpZ25JbldpdGhQaG9uZU51bWJlciBhcyBzLCBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnIGFzIHQsIHVwZGF0ZVBob25lTnVtYmVyIGFzIHUsIHZhbGlkYXRlUGFzc3dvcmQgYXMgdiwgb25JZFRva2VuQ2hhbmdlZCBhcyB3LCBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkIGFzIHgsIG9uQXV0aFN0YXRlQ2hhbmdlZCBhcyB5LCB1c2VEZXZpY2VMYW5ndWFnZSBhcyB6IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b3RwLWNiNjI4NWM3LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/auth/dist/node-esm/totp-cb6285c7.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer),\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass Component {\r\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */\r\n    constructor(name, instanceFactory, type) {\r\n        this.name = name;\r\n        this.instanceFactory = instanceFactory;\r\n        this.type = type;\r\n        this.multipleInstances = false;\r\n        /**\r\n         * Properties to be added to the service namespace\r\n         */\r\n        this.serviceProps = {};\r\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\r\n        this.onInstanceCreated = null;\r\n    }\r\n    setInstantiationMode(mode) {\r\n        this.instantiationMode = mode;\r\n        return this;\r\n    }\r\n    setMultipleInstances(multipleInstances) {\r\n        this.multipleInstances = multipleInstances;\r\n        return this;\r\n    }\r\n    setServiceProps(props) {\r\n        this.serviceProps = props;\r\n        return this;\r\n    }\r\n    setInstanceCreatedCallback(callback) {\r\n        this.onInstanceCreated = callback;\r\n        return this;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\r\nclass Provider {\r\n    constructor(name, container) {\r\n        this.name = name;\r\n        this.container = container;\r\n        this.component = null;\r\n        this.instances = new Map();\r\n        this.instancesDeferred = new Map();\r\n        this.instancesOptions = new Map();\r\n        this.onInitCallbacks = new Map();\r\n    }\r\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */\r\n    get(identifier) {\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\r\n            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\r\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\r\n            if (this.isInitialized(normalizedIdentifier) ||\r\n                this.shouldAutoInitialize()) {\r\n                // initialize the service if it can be auto-initialized\r\n                try {\r\n                    const instance = this.getOrInitializeService({\r\n                        instanceIdentifier: normalizedIdentifier\r\n                    });\r\n                    if (instance) {\r\n                        deferred.resolve(instance);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception during get(), it should not cause\r\n                    // a fatal error. We just return the unresolved promise in this case.\r\n                }\r\n            }\r\n        }\r\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\r\n    }\r\n    getImmediate(options) {\r\n        var _a;\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\r\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\r\n        if (this.isInitialized(normalizedIdentifier) ||\r\n            this.shouldAutoInitialize()) {\r\n            try {\r\n                return this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n            }\r\n            catch (e) {\r\n                if (optional) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\r\n            if (optional) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw Error(`Service ${this.name} is not available`);\r\n            }\r\n        }\r\n    }\r\n    getComponent() {\r\n        return this.component;\r\n    }\r\n    setComponent(component) {\r\n        if (component.name !== this.name) {\r\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\r\n        }\r\n        if (this.component) {\r\n            throw Error(`Component for ${this.name} has already been provided`);\r\n        }\r\n        this.component = component;\r\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\r\n        if (!this.shouldAutoInitialize()) {\r\n            return;\r\n        }\r\n        // if the service is eager, initialize the default instance\r\n        if (isComponentEager(component)) {\r\n            try {\r\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\r\n            }\r\n            catch (e) {\r\n                // when the instance factory for an eager Component throws an exception during the eager\r\n                // initialization, it should not cause a fatal error.\r\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\r\n                // a fatal error in this case?\r\n            }\r\n        }\r\n        // Create service instances for the pending promises and resolve them\r\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\r\n        // and all promises with resolve with it regardless of the identifier.\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            try {\r\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\r\n                const instance = this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n            catch (e) {\r\n                // when the instance factory throws an exception, it should not cause\r\n                // a fatal error. We just leave the promise unresolved.\r\n            }\r\n        }\r\n    }\r\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\r\n        this.instancesDeferred.delete(identifier);\r\n        this.instancesOptions.delete(identifier);\r\n        this.instances.delete(identifier);\r\n    }\r\n    // app.delete() will call this method on every provider to delete the services\r\n    // TODO: should we mark the provider as deleted?\r\n    async delete() {\r\n        const services = Array.from(this.instances.values());\r\n        await Promise.all([\r\n            ...services\r\n                .filter(service => 'INTERNAL' in service) // legacy services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service.INTERNAL.delete()),\r\n            ...services\r\n                .filter(service => '_delete' in service) // modularized services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service._delete())\r\n        ]);\r\n    }\r\n    isComponentSet() {\r\n        return this.component != null;\r\n    }\r\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instances.has(identifier);\r\n    }\r\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instancesOptions.get(identifier) || {};\r\n    }\r\n    initialize(opts = {}) {\r\n        const { options = {} } = opts;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\r\n        if (this.isInitialized(normalizedIdentifier)) {\r\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\r\n        }\r\n        if (!this.isComponentSet()) {\r\n            throw Error(`Component ${this.name} has not been registered yet`);\r\n        }\r\n        const instance = this.getOrInitializeService({\r\n            instanceIdentifier: normalizedIdentifier,\r\n            options\r\n        });\r\n        // resolve any pending promise waiting for the service instance\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */\r\n    onInit(callback, identifier) {\r\n        var _a;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\r\n        existingCallbacks.add(callback);\r\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\r\n        const existingInstance = this.instances.get(normalizedIdentifier);\r\n        if (existingInstance) {\r\n            callback(existingInstance, normalizedIdentifier);\r\n        }\r\n        return () => {\r\n            existingCallbacks.delete(callback);\r\n        };\r\n    }\r\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */\r\n    invokeOnInitCallbacks(instance, identifier) {\r\n        const callbacks = this.onInitCallbacks.get(identifier);\r\n        if (!callbacks) {\r\n            return;\r\n        }\r\n        for (const callback of callbacks) {\r\n            try {\r\n                callback(instance, identifier);\r\n            }\r\n            catch (_a) {\r\n                // ignore errors in the onInit callback\r\n            }\r\n        }\r\n    }\r\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\r\n        let instance = this.instances.get(instanceIdentifier);\r\n        if (!instance && this.component) {\r\n            instance = this.component.instanceFactory(this.container, {\r\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\r\n                options\r\n            });\r\n            this.instances.set(instanceIdentifier, instance);\r\n            this.instancesOptions.set(instanceIdentifier, options);\r\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */\r\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\r\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */\r\n            if (this.component.onInstanceCreated) {\r\n                try {\r\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\r\n                }\r\n                catch (_a) {\r\n                    // ignore errors in the onInstanceCreatedCallback\r\n                }\r\n            }\r\n        }\r\n        return instance || null;\r\n    }\r\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\r\n        if (this.component) {\r\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\r\n        }\r\n        else {\r\n            return identifier; // assume multiple instances are supported before the component is provided.\r\n        }\r\n    }\r\n    shouldAutoInitialize() {\r\n        return (!!this.component &&\r\n            this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */);\r\n    }\r\n}\r\n// undefined should be passed to the service factory for the default instance\r\nfunction normalizeIdentifierForFactory(identifier) {\r\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\r\n}\r\nfunction isComponentEager(component) {\r\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass ComponentContainer {\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.providers = new Map();\r\n    }\r\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */\r\n    addComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\r\n        }\r\n        provider.setComponent(component);\r\n    }\r\n    addOrOverwriteComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            // delete the existing provider from the container, so we can register the new component\r\n            this.providers.delete(component.name);\r\n        }\r\n        this.addComponent(component);\r\n    }\r\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\r\n    getProvider(name) {\r\n        if (this.providers.has(name)) {\r\n            return this.providers.get(name);\r\n        }\r\n        // create a Provider for a service that hasn't registered with Firebase\r\n        const provider = new Provider(name, this);\r\n        this.providers.set(name, provider);\r\n        return provider;\r\n    }\r\n    getProviders() {\r\n        return Array.from(this.providers.values());\r\n    }\r\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQixlQUFlLFVBQVU7QUFDMUY7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsR0FBRyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0IsbUNBQW1DLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1EO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhcm50dWJlLTEuMC8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/MzU1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuLyoqXHJcbiAqIENvbXBvbmVudCBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcclxuICovXHJcbmNsYXNzIENvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgcHVibGljIHNlcnZpY2UgbmFtZSwgZS5nLiBhcHAsIGF1dGgsIGZpcmVzdG9yZSwgZGF0YWJhc2VcclxuICAgICAqIEBwYXJhbSBpbnN0YW5jZUZhY3RvcnkgU2VydmljZSBmYWN0b3J5IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgcHVibGljIGludGVyZmFjZVxyXG4gICAgICogQHBhcmFtIHR5cGUgd2hldGhlciB0aGUgc2VydmljZSBwcm92aWRlZCBieSB0aGUgY29tcG9uZW50IGlzIHB1YmxpYyBvciBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGluc3RhbmNlRmFjdG9yeSwgdHlwZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZUZhY3RvcnkgPSBpbnN0YW5jZUZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyB0byBiZSBhZGRlZCB0byB0aGUgc2VydmljZSBuYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBcIkxBWllcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5MQVpZICovO1xyXG4gICAgICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFudGlhdGlvbk1vZGUobW9kZSkge1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBtb2RlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0TXVsdGlwbGVJbnN0YW5jZXMobXVsdGlwbGVJbnN0YW5jZXMpIHtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gbXVsdGlwbGVJbnN0YW5jZXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRTZXJ2aWNlUHJvcHMocHJvcHMpIHtcclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgaW5zdGFuY2UgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuICdhdXRoJywgJ2F1dGgtaW50ZXJuYWwnXHJcbiAqIE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSBpcyBhbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgdGhlIGluc3RhbmNlXHJcbiAqL1xyXG5jbGFzcyBQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQSBwcm92aWRlciBjYW4gcHJvdmlkZSBtdWxpdHBsZSBpbnN0YW5jZXMgb2YgYSBzZXJ2aWNlXHJcbiAgICAgKiBpZiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyBpcyB0cnVlLlxyXG4gICAgICovXHJcbiAgICBnZXQoaWRlbnRpZmllcikge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuaGFzKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZGVmZXJyZWQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzZXJ2aWNlIGlmIGl0IGNhbiBiZSBhdXRvLWluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgZ2V0KCksIGl0IHNob3VsZCBub3QgY2F1c2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IHJldHVybiB0aGUgdW5yZXNvbHZlZCBwcm9taXNlIGluIHRoaXMgY2FzZS5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICBnZXRJbW1lZGlhdGUob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkZW50aWZpZXIpO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wdGlvbmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEluIGNhc2UgYSBjb21wb25lbnQgaXMgbm90IGluaXRpYWxpemVkIGFuZCBzaG91bGQvY2FuIG5vdCBiZSBhdXRvLWluaXRpYWxpemVkIGF0IHRoZSBtb21lbnQsIHJldHVybiBudWxsIGlmIHRoZSBvcHRpb25hbCBmbGFnIGlzIHNldCwgb3IgdGhyb3dcclxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBTZXJ2aWNlICR7dGhpcy5uYW1lfSBpcyBub3QgYXZhaWxhYmxlYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgc2V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGlmIChjb21wb25lbnQubmFtZSAhPT0gdGhpcy5uYW1lKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBNaXNtYXRjaGluZyBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZm9yIFByb3ZpZGVyICR7dGhpcy5uYW1lfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgZm9yICR7dGhpcy5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHByb3ZpZGVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIC8vIHJldHVybiBlYXJseSB3aXRob3V0IGF0dGVtcHRpbmcgdG8gaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGlmIHRoZSBjb21wb25lbnQgcmVxdWlyZXMgZXhwbGljaXQgaW5pdGlhbGl6YXRpb24gKGNhbGxpbmcgYFByb3ZpZGVyLmluaXRpYWxpemUoKWApXHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgc2VydmljZSBpcyBlYWdlciwgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZVxyXG4gICAgICAgIGlmIChpc0NvbXBvbmVudEVhZ2VyKGNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllcjogREVGQVVMVF9FTlRSWV9OQU1FIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IGZvciBhbiBlYWdlciBDb21wb25lbnQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgdGhlIGVhZ2VyXHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXphdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZSBhIGZhdGFsIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgd2UgbmVlZCB0byBtYWtlIGl0IGNvbmZpZ3VyYWJsZSwgYmVjYXVzZSBzb21lIGNvbXBvbmVudCBtYXkgd2FudCB0byBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvciBpbiB0aGlzIGNhc2U/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ3JlYXRlIHNlcnZpY2UgaW5zdGFuY2VzIGZvciB0aGUgcGVuZGluZyBwcm9taXNlcyBhbmQgcmVzb2x2ZSB0aGVtXHJcbiAgICAgICAgLy8gTk9URTogaWYgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyBpcyBmYWxzZSwgb25seSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWRcclxuICAgICAgICAvLyBhbmQgYWxsIHByb21pc2VzIHdpdGggcmVzb2x2ZSB3aXRoIGl0IHJlZ2FyZGxlc3Mgb2YgdGhlIGlkZW50aWZpZXIuXHJcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBgZ2V0T3JJbml0aWFsaXplU2VydmljZSgpYCBzaG91bGQgYWx3YXlzIHJldHVybiBhIHZhbGlkIGluc3RhbmNlIHNpbmNlIGEgY29tcG9uZW50IGlzIGd1YXJhbnRlZWQuIHVzZSAhIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvci4gV2UganVzdCBsZWF2ZSB0aGUgcHJvbWlzZSB1bnJlc29sdmVkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJJbnN0YW5jZShpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zLmRlbGV0ZShpZGVudGlmaWVyKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcy5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICB9XHJcbiAgICAvLyBhcHAuZGVsZXRlKCkgd2lsbCBjYWxsIHRoaXMgbWV0aG9kIG9uIGV2ZXJ5IHByb3ZpZGVyIHRvIGRlbGV0ZSB0aGUgc2VydmljZXNcclxuICAgIC8vIFRPRE86IHNob3VsZCB3ZSBtYXJrIHRoZSBwcm92aWRlciBhcyBkZWxldGVkP1xyXG4gICAgYXN5bmMgZGVsZXRlKCkge1xyXG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gQXJyYXkuZnJvbSh0aGlzLmluc3RhbmNlcy52YWx1ZXMoKSk7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdJTlRFUk5BTCcgaW4gc2VydmljZSkgLy8gbGVnYWN5IHNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuSU5URVJOQUwuZGVsZXRlKCkpLFxyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdfZGVsZXRlJyBpbiBzZXJ2aWNlKSAvLyBtb2R1bGFyaXplZCBzZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLl9kZWxldGUoKSlcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGlzQ29tcG9uZW50U2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudCAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaXNJbml0aWFsaXplZChpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhpZGVudGlmaWVyKTtcclxuICAgIH1cclxuICAgIGdldE9wdGlvbnMoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc09wdGlvbnMuZ2V0KGlkZW50aWZpZXIpIHx8IHt9O1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShvcHRzID0ge30pIHtcclxuICAgICAgICBjb25zdCB7IG9wdGlvbnMgPSB7fSB9ID0gb3B0cztcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKG9wdHMuaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHt0aGlzLm5hbWV9KCR7bm9ybWFsaXplZElkZW50aWZpZXJ9KSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc0NvbXBvbmVudFNldCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgJHt0aGlzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XHJcbiAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXIsXHJcbiAgICAgICAgICAgIG9wdGlvbnNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2Ugd2FpdGluZyBmb3IgdGhlIHNlcnZpY2UgaW5zdGFuY2VcclxuICAgICAgICBmb3IgKGNvbnN0IFtpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlRGVmZXJyZWRdIG9mIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZElkZW50aWZpZXIgPT09IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCAgYWZ0ZXIgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGluaXRpYWxpemVkIGJ5IGNhbGxpbmcgcHJvdmlkZXIuaW5pdGlhbGl6ZSgpLlxyXG4gICAgICogVGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgU1lOQ0hST05PVVNMWSwgc28gaXQgc2hvdWxkIG5vdCBleGVjdXRlIGFueSBsb25ncnVubmluZyB0YXNrcyBpbiBvcmRlciB0byBub3QgYmxvY2sgdGhlIHByb2dyYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQW4gb3B0aW9uYWwgaW5zdGFuY2UgaWRlbnRpZmllclxyXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIHRoZSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBvbkluaXQoY2FsbGJhY2ssIGlkZW50aWZpZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0NhbGxiYWNrcyA9IChfYSA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChub3JtYWxpemVkSWRlbnRpZmllcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBTZXQoKTtcclxuICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xyXG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZXhpc3RpbmdDYWxsYmFja3MpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGV4aXN0aW5nSW5zdGFuY2UsIG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZXhpc3RpbmdDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2Ugb25Jbml0IGNhbGxiYWNrcyBzeW5jaHJvbm91c2x5XHJcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2UgdGhlIHNlcnZpY2UgaW5zdGFuY2VgXHJcbiAgICAgKi9cclxuICAgIGludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaWRlbnRpZmllcikge1xyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnN0YW5jZSwgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluaXQgY2FsbGJhY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoeyBpbnN0YW5jZUlkZW50aWZpZXIsIG9wdGlvbnMgPSB7fSB9KSB7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZSAmJiB0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZSA9IHRoaXMuY29tcG9uZW50Lmluc3RhbmNlRmFjdG9yeSh0aGlzLmNvbnRhaW5lciwge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeShpbnN0YW5jZUlkZW50aWZpZXIpLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnZva2Ugb25Jbml0IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICogTm90ZSB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCBpcyBkaWZmZXJlbnQsIHdoaWNoIGlzIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBjcmVhdG9yLFxyXG4gICAgICAgICAgICAgKiB3aGlsZSBvbkluaXQgbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGJ5IGNvbnN1bWVycyBvZiB0aGUgcHJvdmlkZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9yZGVyIGlzIGltcG9ydGFudFxyXG4gICAgICAgICAgICAgKiBvbkluc3RhbmNlQ3JlYXRlZCgpIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpOyB3aGljaFxyXG4gICAgICAgICAgICAgKiBtYWtlcyBgaXNJbml0aWFsaXplZCgpYCByZXR1cm4gdHJ1ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCh0aGlzLmNvbnRhaW5lciwgaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgPyBpZGVudGlmaWVyIDogREVGQVVMVF9FTlRSWV9OQU1FO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7IC8vIGFzc3VtZSBtdWx0aXBsZSBpbnN0YW5jZXMgYXJlIHN1cHBvcnRlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzaG91bGRBdXRvSW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICByZXR1cm4gKCEhdGhpcy5jb21wb25lbnQgJiZcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgIT09IFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLyk7XHJcbiAgICB9XHJcbn1cclxuLy8gdW5kZWZpbmVkIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHNlcnZpY2UgZmFjdG9yeSBmb3IgdGhlIGRlZmF1bHQgaW5zdGFuY2VcclxuZnVuY3Rpb24gbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaWRlbnRpZmllcikge1xyXG4gICAgcmV0dXJuIGlkZW50aWZpZXIgPT09IERFRkFVTFRfRU5UUllfTkFNRSA/IHVuZGVmaW5lZCA6IGlkZW50aWZpZXI7XHJcbn1cclxuZnVuY3Rpb24gaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpIHtcclxuICAgIHJldHVybiBjb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgPT09IFwiRUFHRVJcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FQUdFUiAqLztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29tcG9uZW50Q29udGFpbmVyIHRoYXQgcHJvdmlkZXMgUHJvdmlkZXJzIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiBgYXV0aGAsIGBhdXRoLWludGVybmFsYFxyXG4gKi9cclxuY2xhc3MgQ29tcG9uZW50Q29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBDb21wb25lbnQgYmVpbmcgYWRkZWRcclxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgV2hlbiBhIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLFxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIHRydWU6IG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgY29tcG9uZW50IHdpdGggdGhlIG5ldyBjb21wb25lbnQgYW5kIGNyZWF0ZSBhIG5ld1xyXG4gICAgICogcHJvdmlkZXIgd2l0aCB0aGUgbmV3IGNvbXBvbmVudC4gSXQgY2FuIGJlIHVzZWZ1bCBpbiB0ZXN0cyB3aGVyZSB5b3Ugd2FudCB0byB1c2UgZGlmZmVyZW50IG1vY2tzXHJcbiAgICAgKiBmb3IgZGlmZmVyZW50IHRlc3RzLlxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIGZhbHNlOiB0aHJvdyBhbiBleGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgYWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyLmlzQ29tcG9uZW50U2V0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIHdpdGggJHt0aGlzLm5hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3ZpZGVyLnNldENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGNvbXBvbmVudC5uYW1lKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xyXG4gICAgICAgICAgICAvLyBkZWxldGUgdGhlIGV4aXN0aW5nIHByb3ZpZGVyIGZyb20gdGhlIGNvbnRhaW5lciwgc28gd2UgY2FuIHJlZ2lzdGVyIHRoZSBuZXcgY29tcG9uZW50XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLmRlbGV0ZShjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGdldFByb3ZpZGVyIHByb3ZpZGVzIGEgdHlwZSBzYWZlIGludGVyZmFjZSB3aGVyZSBpdCBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIGZpZWxkIG5hbWVcclxuICAgICAqIHByZXNlbnQgaW4gTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBGaXJlYmFzZSBTREtzIHByb3ZpZGluZyBzZXJ2aWNlcyBzaG91bGQgZXh0ZW5kIE5hbWVTZXJ2aWNlTWFwcGluZyBpbnRlcmZhY2UgdG8gcmVnaXN0ZXJcclxuICAgICAqIHRoZW1zZWx2ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldFByb3ZpZGVyKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm92aWRlcnMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNyZWF0ZSBhIFByb3ZpZGVyIGZvciBhIHNlcnZpY2UgdGhhdCBoYXNuJ3QgcmVnaXN0ZXJlZCB3aXRoIEZpcmViYXNlXHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIobmFtZSwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5hbWUsIHByb3ZpZGVyKTtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICBnZXRQcm92aWRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wcm92aWRlcnMudmFsdWVzKCkpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q29udGFpbmVyLCBQcm92aWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setUserLogHandler: () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A container for all of the Logger instances\r\n */\r\nconst instances = [];\r\n/**\r\n * The JS SDK supports 5 log levels and also allows a user the ability to\r\n * silence the logs altogether.\r\n *\r\n * The order is a follows:\r\n * DEBUG < VERBOSE < INFO < WARN < ERROR\r\n *\r\n * All of the log types above the current log level will be captured (i.e. if\r\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\r\n * `VERBOSE` logs will not)\r\n */\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\r\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\r\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\r\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\r\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\r\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\r\n})(LogLevel || (LogLevel = {}));\r\nconst levelStringToEnum = {\r\n    'debug': LogLevel.DEBUG,\r\n    'verbose': LogLevel.VERBOSE,\r\n    'info': LogLevel.INFO,\r\n    'warn': LogLevel.WARN,\r\n    'error': LogLevel.ERROR,\r\n    'silent': LogLevel.SILENT\r\n};\r\n/**\r\n * The default log level\r\n */\r\nconst defaultLogLevel = LogLevel.INFO;\r\n/**\r\n * By default, `console.debug` is not displayed in the developer console (in\r\n * chrome). To avoid forcing users to have to opt-in to these logs twice\r\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\r\n * logs to the `console.log` function.\r\n */\r\nconst ConsoleMethod = {\r\n    [LogLevel.DEBUG]: 'log',\r\n    [LogLevel.VERBOSE]: 'log',\r\n    [LogLevel.INFO]: 'info',\r\n    [LogLevel.WARN]: 'warn',\r\n    [LogLevel.ERROR]: 'error'\r\n};\r\n/**\r\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\r\n * messages on to their corresponding console counterparts (if the log method\r\n * is supported by the current log level)\r\n */\r\nconst defaultLogHandler = (instance, logType, ...args) => {\r\n    if (logType < instance.logLevel) {\r\n        return;\r\n    }\r\n    const now = new Date().toISOString();\r\n    const method = ConsoleMethod[logType];\r\n    if (method) {\r\n        console[method](`[${now}]  ${instance.name}:`, ...args);\r\n    }\r\n    else {\r\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\r\n    }\r\n};\r\nclass Logger {\r\n    /**\r\n     * Gives you an instance of a Logger to capture messages according to\r\n     * Firebase's logging scheme.\r\n     *\r\n     * @param name The name that the logs will be associated with\r\n     */\r\n    constructor(name) {\r\n        this.name = name;\r\n        /**\r\n         * The log level of the given Logger instance.\r\n         */\r\n        this._logLevel = defaultLogLevel;\r\n        /**\r\n         * The main (internal) log handler for the Logger instance.\r\n         * Can be set to a new function in internal package code but not by user.\r\n         */\r\n        this._logHandler = defaultLogHandler;\r\n        /**\r\n         * The optional, additional, user-defined log handler for the Logger instance.\r\n         */\r\n        this._userLogHandler = null;\r\n        /**\r\n         * Capture the current instance for later use\r\n         */\r\n        instances.push(this);\r\n    }\r\n    get logLevel() {\r\n        return this._logLevel;\r\n    }\r\n    set logLevel(val) {\r\n        if (!(val in LogLevel)) {\r\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\r\n        }\r\n        this._logLevel = val;\r\n    }\r\n    // Workaround for setter/getter having to be the same type.\r\n    setLogLevel(val) {\r\n        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\r\n    }\r\n    get logHandler() {\r\n        return this._logHandler;\r\n    }\r\n    set logHandler(val) {\r\n        if (typeof val !== 'function') {\r\n            throw new TypeError('Value assigned to `logHandler` must be a function');\r\n        }\r\n        this._logHandler = val;\r\n    }\r\n    get userLogHandler() {\r\n        return this._userLogHandler;\r\n    }\r\n    set userLogHandler(val) {\r\n        this._userLogHandler = val;\r\n    }\r\n    /**\r\n     * The functions below are all based on the `console` interface\r\n     */\r\n    debug(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\r\n        this._logHandler(this, LogLevel.DEBUG, ...args);\r\n    }\r\n    log(...args) {\r\n        this._userLogHandler &&\r\n            this._userLogHandler(this, LogLevel.VERBOSE, ...args);\r\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\r\n    }\r\n    info(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\r\n        this._logHandler(this, LogLevel.INFO, ...args);\r\n    }\r\n    warn(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\r\n        this._logHandler(this, LogLevel.WARN, ...args);\r\n    }\r\n    error(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\r\n        this._logHandler(this, LogLevel.ERROR, ...args);\r\n    }\r\n}\r\nfunction setLogLevel(level) {\r\n    instances.forEach(inst => {\r\n        inst.setLogLevel(level);\r\n    });\r\n}\r\nfunction setUserLogHandler(logCallback, options) {\r\n    for (const instance of instances) {\r\n        let customLogLevel = null;\r\n        if (options && options.level) {\r\n            customLogLevel = levelStringToEnum[options.level];\r\n        }\r\n        if (logCallback === null) {\r\n            instance.userLogHandler = null;\r\n        }\r\n        else {\r\n            instance.userLogHandler = (instance, level, ...args) => {\r\n                const message = args\r\n                    .map(arg => {\r\n                    if (arg == null) {\r\n                        return null;\r\n                    }\r\n                    else if (typeof arg === 'string') {\r\n                        return arg;\r\n                    }\r\n                    else if (typeof arg === 'number' || typeof arg === 'boolean') {\r\n                        return arg.toString();\r\n                    }\r\n                    else if (arg instanceof Error) {\r\n                        return arg.message;\r\n                    }\r\n                    else {\r\n                        try {\r\n                            return JSON.stringify(arg);\r\n                        }\r\n                        catch (ignored) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                })\r\n                    .filter(arg => arg)\r\n                    .join(' ');\r\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\r\n                    logCallback({\r\n                        level: LogLevel[level].toLowerCase(),\r\n                        message,\r\n                        args,\r\n                        type: instance.name\r\n                    });\r\n                }\r\n            };\r\n        }\r\n    }\r\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJLEtBQUssY0FBYztBQUNuRDtBQUNBO0FBQ0Esc0ZBQXNGLFFBQVE7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFybnR1YmUtMS4wLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9sb2dnZXIvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz81OWZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2VzXHJcbiAqL1xyXG5jb25zdCBpbnN0YW5jZXMgPSBbXTtcclxuLyoqXHJcbiAqIFRoZSBKUyBTREsgc3VwcG9ydHMgNSBsb2cgbGV2ZWxzIGFuZCBhbHNvIGFsbG93cyBhIHVzZXIgdGhlIGFiaWxpdHkgdG9cclxuICogc2lsZW5jZSB0aGUgbG9ncyBhbHRvZ2V0aGVyLlxyXG4gKlxyXG4gKiBUaGUgb3JkZXIgaXMgYSBmb2xsb3dzOlxyXG4gKiBERUJVRyA8IFZFUkJPU0UgPCBJTkZPIDwgV0FSTiA8IEVSUk9SXHJcbiAqXHJcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCB3aWxsIGJlIGNhcHR1cmVkIChpLmUuIGlmXHJcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgSU5GT2AsIGVycm9ycyB3aWxsIHN0aWxsIGJlIGxvZ2dlZCwgYnV0IGBERUJVR2AgYW5kXHJcbiAqIGBWRVJCT1NFYCBsb2dzIHdpbGwgbm90KVxyXG4gKi9cclxudmFyIExvZ0xldmVsO1xyXG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRFQlVHXCJdID0gMF0gPSBcIkRFQlVHXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlZFUkJPU0VcIl0gPSAxXSA9IFwiVkVSQk9TRVwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV0FSTlwiXSA9IDNdID0gXCJXQVJOXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVSUk9SXCJdID0gNF0gPSBcIkVSUk9SXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlNJTEVOVFwiXSA9IDVdID0gXCJTSUxFTlRcIjtcclxufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcclxuY29uc3QgbGV2ZWxTdHJpbmdUb0VudW0gPSB7XHJcbiAgICAnZGVidWcnOiBMb2dMZXZlbC5ERUJVRyxcclxuICAgICd2ZXJib3NlJzogTG9nTGV2ZWwuVkVSQk9TRSxcclxuICAgICdpbmZvJzogTG9nTGV2ZWwuSU5GTyxcclxuICAgICd3YXJuJzogTG9nTGV2ZWwuV0FSTixcclxuICAgICdlcnJvcic6IExvZ0xldmVsLkVSUk9SLFxyXG4gICAgJ3NpbGVudCc6IExvZ0xldmVsLlNJTEVOVFxyXG59O1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgbG9nIGxldmVsXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0TG9nTGV2ZWwgPSBMb2dMZXZlbC5JTkZPO1xyXG4vKipcclxuICogQnkgZGVmYXVsdCwgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBkaXNwbGF5ZWQgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIChpblxyXG4gKiBjaHJvbWUpLiBUbyBhdm9pZCBmb3JjaW5nIHVzZXJzIHRvIGhhdmUgdG8gb3B0LWluIHRvIHRoZXNlIGxvZ3MgdHdpY2VcclxuICogKGkuZS4gb25jZSBmb3IgZmlyZWJhc2UsIGFuZCBvbmNlIGluIHRoZSBjb25zb2xlKSwgd2UgYXJlIHNlbmRpbmcgYERFQlVHYFxyXG4gKiBsb2dzIHRvIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgQ29uc29sZU1ldGhvZCA9IHtcclxuICAgIFtMb2dMZXZlbC5ERUJVR106ICdsb2cnLFxyXG4gICAgW0xvZ0xldmVsLlZFUkJPU0VdOiAnbG9nJyxcclxuICAgIFtMb2dMZXZlbC5JTkZPXTogJ2luZm8nLFxyXG4gICAgW0xvZ0xldmVsLldBUk5dOiAnd2FybicsXHJcbiAgICBbTG9nTGV2ZWwuRVJST1JdOiAnZXJyb3InXHJcbn07XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBsb2cgaGFuZGxlciB3aWxsIGZvcndhcmQgREVCVUcsIFZFUkJPU0UsIElORk8sIFdBUk4sIGFuZCBFUlJPUlxyXG4gKiBtZXNzYWdlcyBvbiB0byB0aGVpciBjb3JyZXNwb25kaW5nIGNvbnNvbGUgY291bnRlcnBhcnRzIChpZiB0aGUgbG9nIG1ldGhvZFxyXG4gKiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgbG9nIGxldmVsKVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdExvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxvZ1R5cGUsIC4uLmFyZ3MpID0+IHtcclxuICAgIGlmIChsb2dUeXBlIDwgaW5zdGFuY2UubG9nTGV2ZWwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICBjb25zdCBtZXRob2QgPSBDb25zb2xlTWV0aG9kW2xvZ1R5cGVdO1xyXG4gICAgaWYgKG1ldGhvZCkge1xyXG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXShgWyR7bm93fV0gICR7aW5zdGFuY2UubmFtZX06YCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBsb2cgYSBtZXNzYWdlIHdpdGggYW4gaW52YWxpZCBsb2dUeXBlICh2YWx1ZTogJHtsb2dUeXBlfSlgKTtcclxuICAgIH1cclxufTtcclxuY2xhc3MgTG9nZ2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZXMgeW91IGFuIGluc3RhbmNlIG9mIGEgTG9nZ2VyIHRvIGNhcHR1cmUgbWVzc2FnZXMgYWNjb3JkaW5nIHRvXHJcbiAgICAgKiBGaXJlYmFzZSdzIGxvZ2dpbmcgc2NoZW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHRoYXQgdGhlIGxvZ3Mgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGhcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZ2l2ZW4gTG9nZ2VyIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gZGVmYXVsdExvZ0xldmVsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYWluIChpbnRlcm5hbCkgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQ2FuIGJlIHNldCB0byBhIG5ldyBmdW5jdGlvbiBpbiBpbnRlcm5hbCBwYWNrYWdlIGNvZGUgYnV0IG5vdCBieSB1c2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSBkZWZhdWx0TG9nSGFuZGxlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3B0aW9uYWwsIGFkZGl0aW9uYWwsIHVzZXItZGVmaW5lZCBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FwdHVyZSB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5zdGFuY2VzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9nTGV2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xyXG4gICAgfVxyXG4gICAgc2V0IGxvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIGlmICghKHZhbCBpbiBMb2dMZXZlbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBcIiR7dmFsfVwiIGFzc2lnbmVkIHRvIFxcYGxvZ0xldmVsXFxgYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLy8gV29ya2Fyb3VuZCBmb3Igc2V0dGVyL2dldHRlciBoYXZpbmcgdG8gYmUgdGhlIHNhbWUgdHlwZS5cclxuICAgIHNldExvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBsZXZlbFN0cmluZ1RvRW51bVt2YWxdIDogdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0hhbmRsZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgbG9nSGFuZGxlcih2YWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBhc3NpZ25lZCB0byBgbG9nSGFuZGxlcmAgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgdXNlckxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJMb2dIYW5kbGVyO1xyXG4gICAgfVxyXG4gICAgc2V0IHVzZXJMb2dIYW5kbGVyKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBhbGwgYmFzZWQgb24gdGhlIGBjb25zb2xlYCBpbnRlcmZhY2VcclxuICAgICAqL1xyXG4gICAgZGVidWcoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGxvZyguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiZcclxuICAgICAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5WRVJCT1NFLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGluZm8oLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICB3YXJuKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZXJyb3IoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xyXG4gICAgaW5zdGFuY2VzLmZvckVhY2goaW5zdCA9PiB7XHJcbiAgICAgICAgaW5zdC5zZXRMb2dMZXZlbChsZXZlbCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcclxuICAgICAgICBsZXQgY3VzdG9tTG9nTGV2ZWwgPSBudWxsO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubGV2ZWwpIHtcclxuICAgICAgICAgICAgY3VzdG9tTG9nTGV2ZWwgPSBsZXZlbFN0cmluZ1RvRW51bVtvcHRpb25zLmxldmVsXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvZ0NhbGxiYWNrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gKGluc3RhbmNlLCBsZXZlbCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGFyZyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGFyZyA9PiBhcmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSAoY3VzdG9tTG9nTGV2ZWwgIT09IG51bGwgJiYgY3VzdG9tTG9nTGV2ZWwgIT09IHZvaWQgMCA/IGN1c3RvbUxvZ0xldmVsIDogaW5zdGFuY2UubG9nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nQ2FsbGJhY2soe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWxbbGV2ZWxdLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGluc3RhbmNlLm5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgTG9nTGV2ZWwsIExvZ2dlciwgc2V0TG9nTGV2ZWwsIHNldFVzZXJMb2dIYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/storage/dist/node-esm/index.node.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/@firebase/storage/dist/node-esm/index.node.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageErrorCode: () => (/* binding */ StorageErrorCode),\n/* harmony export */   StringFormat: () => (/* binding */ StringFormat),\n/* harmony export */   _FbsBlob: () => (/* binding */ FbsBlob),\n/* harmony export */   _Location: () => (/* binding */ Location),\n/* harmony export */   _TaskEvent: () => (/* binding */ TaskEvent),\n/* harmony export */   _TaskState: () => (/* binding */ TaskState),\n/* harmony export */   _UploadTask: () => (/* binding */ UploadTask),\n/* harmony export */   _dataFromString: () => (/* binding */ dataFromString),\n/* harmony export */   _getChild: () => (/* binding */ _getChild),\n/* harmony export */   _invalidArgument: () => (/* binding */ invalidArgument),\n/* harmony export */   _invalidRootOperation: () => (/* binding */ invalidRootOperation),\n/* harmony export */   connectStorageEmulator: () => (/* binding */ connectStorageEmulator),\n/* harmony export */   deleteObject: () => (/* binding */ deleteObject),\n/* harmony export */   getBlob: () => (/* binding */ getBlob),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getDownloadURL: () => (/* binding */ getDownloadURL),\n/* harmony export */   getMetadata: () => (/* binding */ getMetadata),\n/* harmony export */   getStorage: () => (/* binding */ getStorage),\n/* harmony export */   getStream: () => (/* binding */ getStream),\n/* harmony export */   list: () => (/* binding */ list),\n/* harmony export */   listAll: () => (/* binding */ listAll),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   updateMetadata: () => (/* binding */ updateMetadata),\n/* harmony export */   uploadBytes: () => (/* binding */ uploadBytes),\n/* harmony export */   uploadBytesResumable: () => (/* binding */ uploadBytesResumable),\n/* harmony export */   uploadString: () => (/* binding */ uploadString)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! undici */ \"undici\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview Constants used in the Firebase Storage library.\r\n */\r\n/**\r\n * Domain name for firebase storage.\r\n */\r\nconst DEFAULT_HOST = 'firebasestorage.googleapis.com';\r\n/**\r\n * The key in Firebase config json for the storage bucket.\r\n */\r\nconst CONFIG_STORAGE_BUCKET_KEY = 'storageBucket';\r\n/**\r\n * 2 minutes\r\n *\r\n * The timeout for all operations except upload.\r\n */\r\nconst DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1000;\r\n/**\r\n * 10 minutes\r\n *\r\n * The timeout for upload.\r\n */\r\nconst DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1000;\r\n/**\r\n * 1 second\r\n */\r\nconst DEFAULT_MIN_SLEEP_TIME_MILLIS = 1000;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An error returned by the Firebase Storage SDK.\r\n * @public\r\n */\r\nclass StorageError extends _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError {\r\n    /**\r\n     * @param code - A `StorageErrorCode` string to be prefixed with 'storage/' and\r\n     *  added to the end of the message.\r\n     * @param message  - Error message.\r\n     * @param status_ - Corresponding HTTP Status Code\r\n     */\r\n    constructor(code, message, status_ = 0) {\r\n        super(prependCode(code), `Firebase Storage: ${message} (${prependCode(code)})`);\r\n        this.status_ = status_;\r\n        /**\r\n         * Stores custom error data unique to the `StorageError`.\r\n         */\r\n        this.customData = { serverResponse: null };\r\n        this._baseMessage = this.message;\r\n        // Without this, `instanceof StorageError`, in tests for example,\r\n        // returns false.\r\n        Object.setPrototypeOf(this, StorageError.prototype);\r\n    }\r\n    get status() {\r\n        return this.status_;\r\n    }\r\n    set status(status) {\r\n        this.status_ = status;\r\n    }\r\n    /**\r\n     * Compares a `StorageErrorCode` against this error's code, filtering out the prefix.\r\n     */\r\n    _codeEquals(code) {\r\n        return prependCode(code) === this.code;\r\n    }\r\n    /**\r\n     * Optional response message that was added by the server.\r\n     */\r\n    get serverResponse() {\r\n        return this.customData.serverResponse;\r\n    }\r\n    set serverResponse(serverResponse) {\r\n        this.customData.serverResponse = serverResponse;\r\n        if (this.customData.serverResponse) {\r\n            this.message = `${this._baseMessage}\\n${this.customData.serverResponse}`;\r\n        }\r\n        else {\r\n            this.message = this._baseMessage;\r\n        }\r\n    }\r\n}\r\n/**\r\n * @public\r\n * Error codes that can be attached to `StorageError` objects.\r\n */\r\nvar StorageErrorCode;\r\n(function (StorageErrorCode) {\r\n    // Shared between all platforms\r\n    StorageErrorCode[\"UNKNOWN\"] = \"unknown\";\r\n    StorageErrorCode[\"OBJECT_NOT_FOUND\"] = \"object-not-found\";\r\n    StorageErrorCode[\"BUCKET_NOT_FOUND\"] = \"bucket-not-found\";\r\n    StorageErrorCode[\"PROJECT_NOT_FOUND\"] = \"project-not-found\";\r\n    StorageErrorCode[\"QUOTA_EXCEEDED\"] = \"quota-exceeded\";\r\n    StorageErrorCode[\"UNAUTHENTICATED\"] = \"unauthenticated\";\r\n    StorageErrorCode[\"UNAUTHORIZED\"] = \"unauthorized\";\r\n    StorageErrorCode[\"UNAUTHORIZED_APP\"] = \"unauthorized-app\";\r\n    StorageErrorCode[\"RETRY_LIMIT_EXCEEDED\"] = \"retry-limit-exceeded\";\r\n    StorageErrorCode[\"INVALID_CHECKSUM\"] = \"invalid-checksum\";\r\n    StorageErrorCode[\"CANCELED\"] = \"canceled\";\r\n    // JS specific\r\n    StorageErrorCode[\"INVALID_EVENT_NAME\"] = \"invalid-event-name\";\r\n    StorageErrorCode[\"INVALID_URL\"] = \"invalid-url\";\r\n    StorageErrorCode[\"INVALID_DEFAULT_BUCKET\"] = \"invalid-default-bucket\";\r\n    StorageErrorCode[\"NO_DEFAULT_BUCKET\"] = \"no-default-bucket\";\r\n    StorageErrorCode[\"CANNOT_SLICE_BLOB\"] = \"cannot-slice-blob\";\r\n    StorageErrorCode[\"SERVER_FILE_WRONG_SIZE\"] = \"server-file-wrong-size\";\r\n    StorageErrorCode[\"NO_DOWNLOAD_URL\"] = \"no-download-url\";\r\n    StorageErrorCode[\"INVALID_ARGUMENT\"] = \"invalid-argument\";\r\n    StorageErrorCode[\"INVALID_ARGUMENT_COUNT\"] = \"invalid-argument-count\";\r\n    StorageErrorCode[\"APP_DELETED\"] = \"app-deleted\";\r\n    StorageErrorCode[\"INVALID_ROOT_OPERATION\"] = \"invalid-root-operation\";\r\n    StorageErrorCode[\"INVALID_FORMAT\"] = \"invalid-format\";\r\n    StorageErrorCode[\"INTERNAL_ERROR\"] = \"internal-error\";\r\n    StorageErrorCode[\"UNSUPPORTED_ENVIRONMENT\"] = \"unsupported-environment\";\r\n})(StorageErrorCode || (StorageErrorCode = {}));\r\nfunction prependCode(code) {\r\n    return 'storage/' + code;\r\n}\r\nfunction unknown() {\r\n    const message = 'An unknown error occurred, please check the error payload for ' +\r\n        'server response.';\r\n    return new StorageError(StorageErrorCode.UNKNOWN, message);\r\n}\r\nfunction objectNotFound(path) {\r\n    return new StorageError(StorageErrorCode.OBJECT_NOT_FOUND, \"Object '\" + path + \"' does not exist.\");\r\n}\r\nfunction quotaExceeded(bucket) {\r\n    return new StorageError(StorageErrorCode.QUOTA_EXCEEDED, \"Quota for bucket '\" +\r\n        bucket +\r\n        \"' exceeded, please view quota on \" +\r\n        'https://firebase.google.com/pricing/.');\r\n}\r\nfunction unauthenticated() {\r\n    const message = 'User is not authenticated, please authenticate using Firebase ' +\r\n        'Authentication and try again.';\r\n    return new StorageError(StorageErrorCode.UNAUTHENTICATED, message);\r\n}\r\nfunction unauthorizedApp() {\r\n    return new StorageError(StorageErrorCode.UNAUTHORIZED_APP, 'This app does not have permission to access Firebase Storage on this project.');\r\n}\r\nfunction unauthorized(path) {\r\n    return new StorageError(StorageErrorCode.UNAUTHORIZED, \"User does not have permission to access '\" + path + \"'.\");\r\n}\r\nfunction retryLimitExceeded() {\r\n    return new StorageError(StorageErrorCode.RETRY_LIMIT_EXCEEDED, 'Max retry time for operation exceeded, please try again.');\r\n}\r\nfunction canceled() {\r\n    return new StorageError(StorageErrorCode.CANCELED, 'User canceled the upload/download.');\r\n}\r\nfunction invalidUrl(url) {\r\n    return new StorageError(StorageErrorCode.INVALID_URL, \"Invalid URL '\" + url + \"'.\");\r\n}\r\nfunction invalidDefaultBucket(bucket) {\r\n    return new StorageError(StorageErrorCode.INVALID_DEFAULT_BUCKET, \"Invalid default bucket '\" + bucket + \"'.\");\r\n}\r\nfunction noDefaultBucket() {\r\n    return new StorageError(StorageErrorCode.NO_DEFAULT_BUCKET, 'No default bucket ' +\r\n        \"found. Did you set the '\" +\r\n        CONFIG_STORAGE_BUCKET_KEY +\r\n        \"' property when initializing the app?\");\r\n}\r\nfunction cannotSliceBlob() {\r\n    return new StorageError(StorageErrorCode.CANNOT_SLICE_BLOB, 'Cannot slice blob for upload. Please retry the upload.');\r\n}\r\nfunction serverFileWrongSize() {\r\n    return new StorageError(StorageErrorCode.SERVER_FILE_WRONG_SIZE, 'Server recorded incorrect upload file size, please retry the upload.');\r\n}\r\nfunction noDownloadURL() {\r\n    return new StorageError(StorageErrorCode.NO_DOWNLOAD_URL, 'The given file does not have any download URLs.');\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction invalidArgument(message) {\r\n    return new StorageError(StorageErrorCode.INVALID_ARGUMENT, message);\r\n}\r\nfunction appDeleted() {\r\n    return new StorageError(StorageErrorCode.APP_DELETED, 'The Firebase app was deleted.');\r\n}\r\n/**\r\n * @param name - The name of the operation that was invalid.\r\n *\r\n * @internal\r\n */\r\nfunction invalidRootOperation(name) {\r\n    return new StorageError(StorageErrorCode.INVALID_ROOT_OPERATION, \"The operation '\" +\r\n        name +\r\n        \"' cannot be performed on a root reference, create a non-root \" +\r\n        \"reference using child, such as .child('file.png').\");\r\n}\r\n/**\r\n * @param format - The format that was not valid.\r\n * @param message - A message describing the format violation.\r\n */\r\nfunction invalidFormat(format, message) {\r\n    return new StorageError(StorageErrorCode.INVALID_FORMAT, \"String does not match format '\" + format + \"': \" + message);\r\n}\r\n/**\r\n * @param message - A message describing the internal error.\r\n */\r\nfunction internalError(message) {\r\n    throw new StorageError(StorageErrorCode.INTERNAL_ERROR, 'Internal error: ' + message);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Firebase Storage location data.\r\n *\r\n * @internal\r\n */\r\nclass Location {\r\n    constructor(bucket, path) {\r\n        this.bucket = bucket;\r\n        this.path_ = path;\r\n    }\r\n    get path() {\r\n        return this.path_;\r\n    }\r\n    get isRoot() {\r\n        return this.path.length === 0;\r\n    }\r\n    fullServerUrl() {\r\n        const encode = encodeURIComponent;\r\n        return '/b/' + encode(this.bucket) + '/o/' + encode(this.path);\r\n    }\r\n    bucketOnlyServerUrl() {\r\n        const encode = encodeURIComponent;\r\n        return '/b/' + encode(this.bucket) + '/o';\r\n    }\r\n    static makeFromBucketSpec(bucketString, host) {\r\n        let bucketLocation;\r\n        try {\r\n            bucketLocation = Location.makeFromUrl(bucketString, host);\r\n        }\r\n        catch (e) {\r\n            // Not valid URL, use as-is. This lets you put bare bucket names in\r\n            // config.\r\n            return new Location(bucketString, '');\r\n        }\r\n        if (bucketLocation.path === '') {\r\n            return bucketLocation;\r\n        }\r\n        else {\r\n            throw invalidDefaultBucket(bucketString);\r\n        }\r\n    }\r\n    static makeFromUrl(url, host) {\r\n        let location = null;\r\n        const bucketDomain = '([A-Za-z0-9.\\\\-_]+)';\r\n        function gsModify(loc) {\r\n            if (loc.path.charAt(loc.path.length - 1) === '/') {\r\n                loc.path_ = loc.path_.slice(0, -1);\r\n            }\r\n        }\r\n        const gsPath = '(/(.*))?$';\r\n        const gsRegex = new RegExp('^gs://' + bucketDomain + gsPath, 'i');\r\n        const gsIndices = { bucket: 1, path: 3 };\r\n        function httpModify(loc) {\r\n            loc.path_ = decodeURIComponent(loc.path);\r\n        }\r\n        const version = 'v[A-Za-z0-9_]+';\r\n        const firebaseStorageHost = host.replace(/[.]/g, '\\\\.');\r\n        const firebaseStoragePath = '(/([^?#]*).*)?$';\r\n        const firebaseStorageRegExp = new RegExp(`^https?://${firebaseStorageHost}/${version}/b/${bucketDomain}/o${firebaseStoragePath}`, 'i');\r\n        const firebaseStorageIndices = { bucket: 1, path: 3 };\r\n        const cloudStorageHost = host === DEFAULT_HOST\r\n            ? '(?:storage.googleapis.com|storage.cloud.google.com)'\r\n            : host;\r\n        const cloudStoragePath = '([^?#]*)';\r\n        const cloudStorageRegExp = new RegExp(`^https?://${cloudStorageHost}/${bucketDomain}/${cloudStoragePath}`, 'i');\r\n        const cloudStorageIndices = { bucket: 1, path: 2 };\r\n        const groups = [\r\n            { regex: gsRegex, indices: gsIndices, postModify: gsModify },\r\n            {\r\n                regex: firebaseStorageRegExp,\r\n                indices: firebaseStorageIndices,\r\n                postModify: httpModify\r\n            },\r\n            {\r\n                regex: cloudStorageRegExp,\r\n                indices: cloudStorageIndices,\r\n                postModify: httpModify\r\n            }\r\n        ];\r\n        for (let i = 0; i < groups.length; i++) {\r\n            const group = groups[i];\r\n            const captures = group.regex.exec(url);\r\n            if (captures) {\r\n                const bucketValue = captures[group.indices.bucket];\r\n                let pathValue = captures[group.indices.path];\r\n                if (!pathValue) {\r\n                    pathValue = '';\r\n                }\r\n                location = new Location(bucketValue, pathValue);\r\n                group.postModify(location);\r\n                break;\r\n            }\r\n        }\r\n        if (location == null) {\r\n            throw invalidUrl(url);\r\n        }\r\n        return location;\r\n    }\r\n}\n\n/**\r\n * A request whose promise always fails.\r\n */\r\nclass FailRequest {\r\n    constructor(error) {\r\n        this.promise_ = Promise.reject(error);\r\n    }\r\n    /** @inheritDoc */\r\n    getPromise() {\r\n        return this.promise_;\r\n    }\r\n    /** @inheritDoc */\r\n    cancel(_appDelete = false) { }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Accepts a callback for an action to perform (`doRequest`),\r\n * and then a callback for when the backoff has completed (`backoffCompleteCb`).\r\n * The callback sent to start requires an argument to call (`onRequestComplete`).\r\n * When `start` calls `doRequest`, it passes a callback for when the request has\r\n * completed, `onRequestComplete`. Based on this, the backoff continues, with\r\n * another call to `doRequest` and the above loop continues until the timeout\r\n * is hit, or a successful response occurs.\r\n * @description\r\n * @param doRequest Callback to perform request\r\n * @param backoffCompleteCb Callback to call when backoff has been completed\r\n */\r\nfunction start(doRequest, \r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nbackoffCompleteCb, timeout) {\r\n    // TODO(andysoto): make this code cleaner (probably refactor into an actual\r\n    // type instead of a bunch of functions with state shared in the closure)\r\n    let waitSeconds = 1;\r\n    // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\r\n    // TODO: find a way to exclude Node type definition for storage because storage only works in browser\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    let retryTimeoutId = null;\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    let globalTimeoutId = null;\r\n    let hitTimeout = false;\r\n    let cancelState = 0;\r\n    function canceled() {\r\n        return cancelState === 2;\r\n    }\r\n    let triggeredCallback = false;\r\n    function triggerCallback(...args) {\r\n        if (!triggeredCallback) {\r\n            triggeredCallback = true;\r\n            backoffCompleteCb.apply(null, args);\r\n        }\r\n    }\r\n    function callWithDelay(millis) {\r\n        retryTimeoutId = setTimeout(() => {\r\n            retryTimeoutId = null;\r\n            doRequest(responseHandler, canceled());\r\n        }, millis);\r\n    }\r\n    function clearGlobalTimeout() {\r\n        if (globalTimeoutId) {\r\n            clearTimeout(globalTimeoutId);\r\n        }\r\n    }\r\n    function responseHandler(success, ...args) {\r\n        if (triggeredCallback) {\r\n            clearGlobalTimeout();\r\n            return;\r\n        }\r\n        if (success) {\r\n            clearGlobalTimeout();\r\n            triggerCallback.call(null, success, ...args);\r\n            return;\r\n        }\r\n        const mustStop = canceled() || hitTimeout;\r\n        if (mustStop) {\r\n            clearGlobalTimeout();\r\n            triggerCallback.call(null, success, ...args);\r\n            return;\r\n        }\r\n        if (waitSeconds < 64) {\r\n            /* TODO(andysoto): don't back off so quickly if we know we're offline. */\r\n            waitSeconds *= 2;\r\n        }\r\n        let waitMillis;\r\n        if (cancelState === 1) {\r\n            cancelState = 2;\r\n            waitMillis = 0;\r\n        }\r\n        else {\r\n            waitMillis = (waitSeconds + Math.random()) * 1000;\r\n        }\r\n        callWithDelay(waitMillis);\r\n    }\r\n    let stopped = false;\r\n    function stop(wasTimeout) {\r\n        if (stopped) {\r\n            return;\r\n        }\r\n        stopped = true;\r\n        clearGlobalTimeout();\r\n        if (triggeredCallback) {\r\n            return;\r\n        }\r\n        if (retryTimeoutId !== null) {\r\n            if (!wasTimeout) {\r\n                cancelState = 2;\r\n            }\r\n            clearTimeout(retryTimeoutId);\r\n            callWithDelay(0);\r\n        }\r\n        else {\r\n            if (!wasTimeout) {\r\n                cancelState = 1;\r\n            }\r\n        }\r\n    }\r\n    callWithDelay(0);\r\n    globalTimeoutId = setTimeout(() => {\r\n        hitTimeout = true;\r\n        stop(true);\r\n    }, timeout);\r\n    return stop;\r\n}\r\n/**\r\n * Stops the retry loop from repeating.\r\n * If the function is currently \"in between\" retries, it is invoked immediately\r\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\r\n * after the current invocation finishes iff the current invocation would have\r\n * triggered another retry.\r\n */\r\nfunction stop(id) {\r\n    id(false);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction isJustDef(p) {\r\n    return p !== void 0;\r\n}\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction isFunction(p) {\r\n    return typeof p === 'function';\r\n}\r\nfunction isNonArrayObject(p) {\r\n    return typeof p === 'object' && !Array.isArray(p);\r\n}\r\nfunction isString(p) {\r\n    return typeof p === 'string' || p instanceof String;\r\n}\r\nfunction isNativeBlob(p) {\r\n    return isNativeBlobDefined() && p instanceof Blob;\r\n}\r\nfunction isNativeBlobDefined() {\r\n    return typeof Blob !== 'undefined';\r\n}\r\nfunction validateNumber(argument, minValue, maxValue, value) {\r\n    if (value < minValue) {\r\n        throw invalidArgument(`Invalid value for '${argument}'. Expected ${minValue} or greater.`);\r\n    }\r\n    if (value > maxValue) {\r\n        throw invalidArgument(`Invalid value for '${argument}'. Expected ${maxValue} or less.`);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction makeUrl(urlPart, host, protocol) {\r\n    let origin = host;\r\n    if (protocol == null) {\r\n        origin = `https://${host}`;\r\n    }\r\n    return `${protocol}://${origin}/v0${urlPart}`;\r\n}\r\nfunction makeQueryString(params) {\r\n    const encode = encodeURIComponent;\r\n    let queryPart = '?';\r\n    for (const key in params) {\r\n        if (params.hasOwnProperty(key)) {\r\n            const nextPart = encode(key) + '=' + encode(params[key]);\r\n            queryPart = queryPart + nextPart + '&';\r\n        }\r\n    }\r\n    // Chop off the extra '&' or '?' on the end\r\n    queryPart = queryPart.slice(0, -1);\r\n    return queryPart;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Error codes for requests made by the the XhrIo wrapper.\r\n */\r\nvar ErrorCode;\r\n(function (ErrorCode) {\r\n    ErrorCode[ErrorCode[\"NO_ERROR\"] = 0] = \"NO_ERROR\";\r\n    ErrorCode[ErrorCode[\"NETWORK_ERROR\"] = 1] = \"NETWORK_ERROR\";\r\n    ErrorCode[ErrorCode[\"ABORT\"] = 2] = \"ABORT\";\r\n})(ErrorCode || (ErrorCode = {}));\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Checks the status code to see if the action should be retried.\r\n *\r\n * @param status Current HTTP status code returned by server.\r\n * @param additionalRetryCodes additional retry codes to check against\r\n */\r\nfunction isRetryStatusCode(status, additionalRetryCodes) {\r\n    // The codes for which to retry came from this page:\r\n    // https://cloud.google.com/storage/docs/exponential-backoff\r\n    const isFiveHundredCode = status >= 500 && status < 600;\r\n    const extraRetryCodes = [\r\n        // Request Timeout: web server didn't receive full request in time.\r\n        408,\r\n        // Too Many Requests: you're getting rate-limited, basically.\r\n        429\r\n    ];\r\n    const isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;\r\n    const isAdditionalRetryCode = additionalRetryCodes.indexOf(status) !== -1;\r\n    return isFiveHundredCode || isExtraRetryCode || isAdditionalRetryCode;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Handles network logic for all Storage Requests, including error reporting and\r\n * retries with backoff.\r\n *\r\n * @param I - the type of the backend's network response.\r\n * @param - O the output type used by the rest of the SDK. The conversion\r\n * happens in the specified `callback_`.\r\n */\r\nclass NetworkRequest {\r\n    constructor(url_, method_, headers_, body_, successCodes_, additionalRetryCodes_, callback_, errorCallback_, timeout_, progressCallback_, connectionFactory_, retry = true) {\r\n        this.url_ = url_;\r\n        this.method_ = method_;\r\n        this.headers_ = headers_;\r\n        this.body_ = body_;\r\n        this.successCodes_ = successCodes_;\r\n        this.additionalRetryCodes_ = additionalRetryCodes_;\r\n        this.callback_ = callback_;\r\n        this.errorCallback_ = errorCallback_;\r\n        this.timeout_ = timeout_;\r\n        this.progressCallback_ = progressCallback_;\r\n        this.connectionFactory_ = connectionFactory_;\r\n        this.retry = retry;\r\n        this.pendingConnection_ = null;\r\n        this.backoffId_ = null;\r\n        this.canceled_ = false;\r\n        this.appDelete_ = false;\r\n        this.promise_ = new Promise((resolve, reject) => {\r\n            this.resolve_ = resolve;\r\n            this.reject_ = reject;\r\n            this.start_();\r\n        });\r\n    }\r\n    /**\r\n     * Actually starts the retry loop.\r\n     */\r\n    start_() {\r\n        const doTheRequest = (backoffCallback, canceled) => {\r\n            if (canceled) {\r\n                backoffCallback(false, new RequestEndStatus(false, null, true));\r\n                return;\r\n            }\r\n            const connection = this.connectionFactory_();\r\n            this.pendingConnection_ = connection;\r\n            const progressListener = progressEvent => {\r\n                const loaded = progressEvent.loaded;\r\n                const total = progressEvent.lengthComputable ? progressEvent.total : -1;\r\n                if (this.progressCallback_ !== null) {\r\n                    this.progressCallback_(loaded, total);\r\n                }\r\n            };\r\n            if (this.progressCallback_ !== null) {\r\n                connection.addUploadProgressListener(progressListener);\r\n            }\r\n            // connection.send() never rejects, so we don't need to have a error handler or use catch on the returned promise.\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            connection\r\n                .send(this.url_, this.method_, this.body_, this.headers_)\r\n                .then(() => {\r\n                if (this.progressCallback_ !== null) {\r\n                    connection.removeUploadProgressListener(progressListener);\r\n                }\r\n                this.pendingConnection_ = null;\r\n                const hitServer = connection.getErrorCode() === ErrorCode.NO_ERROR;\r\n                const status = connection.getStatus();\r\n                if (!hitServer ||\r\n                    (isRetryStatusCode(status, this.additionalRetryCodes_) &&\r\n                        this.retry)) {\r\n                    const wasCanceled = connection.getErrorCode() === ErrorCode.ABORT;\r\n                    backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));\r\n                    return;\r\n                }\r\n                const successCode = this.successCodes_.indexOf(status) !== -1;\r\n                backoffCallback(true, new RequestEndStatus(successCode, connection));\r\n            });\r\n        };\r\n        /**\r\n         * @param requestWentThrough - True if the request eventually went\r\n         *     through, false if it hit the retry limit or was canceled.\r\n         */\r\n        const backoffDone = (requestWentThrough, status) => {\r\n            const resolve = this.resolve_;\r\n            const reject = this.reject_;\r\n            const connection = status.connection;\r\n            if (status.wasSuccessCode) {\r\n                try {\r\n                    const result = this.callback_(connection, connection.getResponse());\r\n                    if (isJustDef(result)) {\r\n                        resolve(result);\r\n                    }\r\n                    else {\r\n                        resolve();\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            }\r\n            else {\r\n                if (connection !== null) {\r\n                    const err = unknown();\r\n                    err.serverResponse = connection.getErrorText();\r\n                    if (this.errorCallback_) {\r\n                        reject(this.errorCallback_(connection, err));\r\n                    }\r\n                    else {\r\n                        reject(err);\r\n                    }\r\n                }\r\n                else {\r\n                    if (status.canceled) {\r\n                        const err = this.appDelete_ ? appDeleted() : canceled();\r\n                        reject(err);\r\n                    }\r\n                    else {\r\n                        const err = retryLimitExceeded();\r\n                        reject(err);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        if (this.canceled_) {\r\n            backoffDone(false, new RequestEndStatus(false, null, true));\r\n        }\r\n        else {\r\n            this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    getPromise() {\r\n        return this.promise_;\r\n    }\r\n    /** @inheritDoc */\r\n    cancel(appDelete) {\r\n        this.canceled_ = true;\r\n        this.appDelete_ = appDelete || false;\r\n        if (this.backoffId_ !== null) {\r\n            stop(this.backoffId_);\r\n        }\r\n        if (this.pendingConnection_ !== null) {\r\n            this.pendingConnection_.abort();\r\n        }\r\n    }\r\n}\r\n/**\r\n * A collection of information about the result of a network request.\r\n * @param opt_canceled - Defaults to false.\r\n */\r\nclass RequestEndStatus {\r\n    constructor(wasSuccessCode, connection, canceled) {\r\n        this.wasSuccessCode = wasSuccessCode;\r\n        this.connection = connection;\r\n        this.canceled = !!canceled;\r\n    }\r\n}\r\nfunction addAuthHeader_(headers, authToken) {\r\n    if (authToken !== null && authToken.length > 0) {\r\n        headers['Authorization'] = 'Firebase ' + authToken;\r\n    }\r\n}\r\nfunction addVersionHeader_(headers, firebaseVersion) {\r\n    headers['X-Firebase-Storage-Version'] =\r\n        'webjs/' + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : 'AppManager');\r\n}\r\nfunction addGmpidHeader_(headers, appId) {\r\n    if (appId) {\r\n        headers['X-Firebase-GMPID'] = appId;\r\n    }\r\n}\r\nfunction addAppCheckHeader_(headers, appCheckToken) {\r\n    if (appCheckToken !== null) {\r\n        headers['X-Firebase-AppCheck'] = appCheckToken;\r\n    }\r\n}\r\nfunction makeRequest(requestInfo, appId, authToken, appCheckToken, requestFactory, firebaseVersion, retry = true) {\r\n    const queryPart = makeQueryString(requestInfo.urlParams);\r\n    const url = requestInfo.url + queryPart;\r\n    const headers = Object.assign({}, requestInfo.headers);\r\n    addGmpidHeader_(headers, appId);\r\n    addAuthHeader_(headers, authToken);\r\n    addVersionHeader_(headers, firebaseVersion);\r\n    addAppCheckHeader_(headers, appCheckToken);\r\n    return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, requestFactory, retry);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getBlobBuilder() {\r\n    if (typeof BlobBuilder !== 'undefined') {\r\n        return BlobBuilder;\r\n    }\r\n    else if (typeof WebKitBlobBuilder !== 'undefined') {\r\n        return WebKitBlobBuilder;\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\n/**\r\n * Concatenates one or more values together and converts them to a Blob.\r\n *\r\n * @param args The values that will make up the resulting blob.\r\n * @return The blob.\r\n */\r\nfunction getBlob$1(...args) {\r\n    const BlobBuilder = getBlobBuilder();\r\n    if (BlobBuilder !== undefined) {\r\n        const bb = new BlobBuilder();\r\n        for (let i = 0; i < args.length; i++) {\r\n            bb.append(args[i]);\r\n        }\r\n        return bb.getBlob();\r\n    }\r\n    else {\r\n        if (isNativeBlobDefined()) {\r\n            return new Blob(args);\r\n        }\r\n        else {\r\n            throw new StorageError(StorageErrorCode.UNSUPPORTED_ENVIRONMENT, \"This browser doesn't seem to support creating Blobs\");\r\n        }\r\n    }\r\n}\r\n/**\r\n * Slices the blob. The returned blob contains data from the start byte\r\n * (inclusive) till the end byte (exclusive). Negative indices cannot be used.\r\n *\r\n * @param blob The blob to be sliced.\r\n * @param start Index of the starting byte.\r\n * @param end Index of the ending byte.\r\n * @return The blob slice or null if not supported.\r\n */\r\nfunction sliceBlob(blob, start, end) {\r\n    if (blob.webkitSlice) {\r\n        return blob.webkitSlice(start, end);\r\n    }\r\n    else if (blob.mozSlice) {\r\n        return blob.mozSlice(start, end);\r\n    }\r\n    else if (blob.slice) {\r\n        return blob.slice(start, end);\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Converts a Base64 encoded string to a binary string. */\r\nfunction decodeBase64(encoded) {\r\n    // Node actually doesn't validate base64 strings.\r\n    // A quick sanity check that is not a fool-proof validation\r\n    if (/[^-A-Za-z0-9+/=]/.test(encoded)) {\r\n        throw invalidFormat('base64', 'Invalid character found');\r\n    }\r\n    return Buffer.from(encoded, 'base64').toString('binary');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An enumeration of the possible string formats for upload.\r\n * @public\r\n */\r\nconst StringFormat = {\r\n    /**\r\n     * Indicates the string should be interpreted \"raw\", that is, as normal text.\r\n     * The string will be interpreted as UTF-16, then uploaded as a UTF-8 byte\r\n     * sequence.\r\n     * Example: The string 'Hello! \\\\ud83d\\\\ude0a' becomes the byte sequence\r\n     * 48 65 6c 6c 6f 21 20 f0 9f 98 8a\r\n     */\r\n    RAW: 'raw',\r\n    /**\r\n     * Indicates the string should be interpreted as base64-encoded data.\r\n     * Padding characters (trailing '='s) are optional.\r\n     * Example: The string 'rWmO++E6t7/rlw==' becomes the byte sequence\r\n     * ad 69 8e fb e1 3a b7 bf eb 97\r\n     */\r\n    BASE64: 'base64',\r\n    /**\r\n     * Indicates the string should be interpreted as base64url-encoded data.\r\n     * Padding characters (trailing '='s) are optional.\r\n     * Example: The string 'rWmO--E6t7_rlw==' becomes the byte sequence\r\n     * ad 69 8e fb e1 3a b7 bf eb 97\r\n     */\r\n    BASE64URL: 'base64url',\r\n    /**\r\n     * Indicates the string is a data URL, such as one obtained from\r\n     * canvas.toDataURL().\r\n     * Example: the string 'data:application/octet-stream;base64,aaaa'\r\n     * becomes the byte sequence\r\n     * 69 a6 9a\r\n     * (the content-type \"application/octet-stream\" is also applied, but can\r\n     * be overridden in the metadata object).\r\n     */\r\n    DATA_URL: 'data_url'\r\n};\r\nclass StringData {\r\n    constructor(data, contentType) {\r\n        this.data = data;\r\n        this.contentType = contentType || null;\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction dataFromString(format, stringData) {\r\n    switch (format) {\r\n        case StringFormat.RAW:\r\n            return new StringData(utf8Bytes_(stringData));\r\n        case StringFormat.BASE64:\r\n        case StringFormat.BASE64URL:\r\n            return new StringData(base64Bytes_(format, stringData));\r\n        case StringFormat.DATA_URL:\r\n            return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));\r\n        // do nothing\r\n    }\r\n    // assert(false);\r\n    throw unknown();\r\n}\r\nfunction utf8Bytes_(value) {\r\n    const b = [];\r\n    for (let i = 0; i < value.length; i++) {\r\n        let c = value.charCodeAt(i);\r\n        if (c <= 127) {\r\n            b.push(c);\r\n        }\r\n        else {\r\n            if (c <= 2047) {\r\n                b.push(192 | (c >> 6), 128 | (c & 63));\r\n            }\r\n            else {\r\n                if ((c & 64512) === 55296) {\r\n                    // The start of a surrogate pair.\r\n                    const valid = i < value.length - 1 && (value.charCodeAt(i + 1) & 64512) === 56320;\r\n                    if (!valid) {\r\n                        // The second surrogate wasn't there.\r\n                        b.push(239, 191, 189);\r\n                    }\r\n                    else {\r\n                        const hi = c;\r\n                        const lo = value.charCodeAt(++i);\r\n                        c = 65536 | ((hi & 1023) << 10) | (lo & 1023);\r\n                        b.push(240 | (c >> 18), 128 | ((c >> 12) & 63), 128 | ((c >> 6) & 63), 128 | (c & 63));\r\n                    }\r\n                }\r\n                else {\r\n                    if ((c & 64512) === 56320) {\r\n                        // Invalid low surrogate.\r\n                        b.push(239, 191, 189);\r\n                    }\r\n                    else {\r\n                        b.push(224 | (c >> 12), 128 | ((c >> 6) & 63), 128 | (c & 63));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return new Uint8Array(b);\r\n}\r\nfunction percentEncodedBytes_(value) {\r\n    let decoded;\r\n    try {\r\n        decoded = decodeURIComponent(value);\r\n    }\r\n    catch (e) {\r\n        throw invalidFormat(StringFormat.DATA_URL, 'Malformed data URL.');\r\n    }\r\n    return utf8Bytes_(decoded);\r\n}\r\nfunction base64Bytes_(format, value) {\r\n    switch (format) {\r\n        case StringFormat.BASE64: {\r\n            const hasMinus = value.indexOf('-') !== -1;\r\n            const hasUnder = value.indexOf('_') !== -1;\r\n            if (hasMinus || hasUnder) {\r\n                const invalidChar = hasMinus ? '-' : '_';\r\n                throw invalidFormat(format, \"Invalid character '\" +\r\n                    invalidChar +\r\n                    \"' found: is it base64url encoded?\");\r\n            }\r\n            break;\r\n        }\r\n        case StringFormat.BASE64URL: {\r\n            const hasPlus = value.indexOf('+') !== -1;\r\n            const hasSlash = value.indexOf('/') !== -1;\r\n            if (hasPlus || hasSlash) {\r\n                const invalidChar = hasPlus ? '+' : '/';\r\n                throw invalidFormat(format, \"Invalid character '\" + invalidChar + \"' found: is it base64 encoded?\");\r\n            }\r\n            value = value.replace(/-/g, '+').replace(/_/g, '/');\r\n            break;\r\n        }\r\n        // do nothing\r\n    }\r\n    let bytes;\r\n    try {\r\n        bytes = decodeBase64(value);\r\n    }\r\n    catch (e) {\r\n        if (e.message.includes('polyfill')) {\r\n            throw e;\r\n        }\r\n        throw invalidFormat(format, 'Invalid character found');\r\n    }\r\n    const array = new Uint8Array(bytes.length);\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        array[i] = bytes.charCodeAt(i);\r\n    }\r\n    return array;\r\n}\r\nclass DataURLParts {\r\n    constructor(dataURL) {\r\n        this.base64 = false;\r\n        this.contentType = null;\r\n        const matches = dataURL.match(/^data:([^,]+)?,/);\r\n        if (matches === null) {\r\n            throw invalidFormat(StringFormat.DATA_URL, \"Must be formatted 'data:[<mediatype>][;base64],<data>\");\r\n        }\r\n        const middle = matches[1] || null;\r\n        if (middle != null) {\r\n            this.base64 = endsWith(middle, ';base64');\r\n            this.contentType = this.base64\r\n                ? middle.substring(0, middle.length - ';base64'.length)\r\n                : middle;\r\n        }\r\n        this.rest = dataURL.substring(dataURL.indexOf(',') + 1);\r\n    }\r\n}\r\nfunction dataURLBytes_(dataUrl) {\r\n    const parts = new DataURLParts(dataUrl);\r\n    if (parts.base64) {\r\n        return base64Bytes_(StringFormat.BASE64, parts.rest);\r\n    }\r\n    else {\r\n        return percentEncodedBytes_(parts.rest);\r\n    }\r\n}\r\nfunction dataURLContentType_(dataUrl) {\r\n    const parts = new DataURLParts(dataUrl);\r\n    return parts.contentType;\r\n}\r\nfunction endsWith(s, end) {\r\n    const longEnough = s.length >= end.length;\r\n    if (!longEnough) {\r\n        return false;\r\n    }\r\n    return s.substring(s.length - end.length) === end;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @param opt_elideCopy - If true, doesn't copy mutable input data\r\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\r\n *     modified after this blob's construction.\r\n *\r\n * @internal\r\n */\r\nclass FbsBlob {\r\n    constructor(data, elideCopy) {\r\n        let size = 0;\r\n        let blobType = '';\r\n        if (isNativeBlob(data)) {\r\n            this.data_ = data;\r\n            size = data.size;\r\n            blobType = data.type;\r\n        }\r\n        else if (data instanceof ArrayBuffer) {\r\n            if (elideCopy) {\r\n                this.data_ = new Uint8Array(data);\r\n            }\r\n            else {\r\n                this.data_ = new Uint8Array(data.byteLength);\r\n                this.data_.set(new Uint8Array(data));\r\n            }\r\n            size = this.data_.length;\r\n        }\r\n        else if (data instanceof Uint8Array) {\r\n            if (elideCopy) {\r\n                this.data_ = data;\r\n            }\r\n            else {\r\n                this.data_ = new Uint8Array(data.length);\r\n                this.data_.set(data);\r\n            }\r\n            size = data.length;\r\n        }\r\n        this.size_ = size;\r\n        this.type_ = blobType;\r\n    }\r\n    size() {\r\n        return this.size_;\r\n    }\r\n    type() {\r\n        return this.type_;\r\n    }\r\n    slice(startByte, endByte) {\r\n        if (isNativeBlob(this.data_)) {\r\n            const realBlob = this.data_;\r\n            const sliced = sliceBlob(realBlob, startByte, endByte);\r\n            if (sliced === null) {\r\n                return null;\r\n            }\r\n            return new FbsBlob(sliced);\r\n        }\r\n        else {\r\n            const slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);\r\n            return new FbsBlob(slice, true);\r\n        }\r\n    }\r\n    static getBlob(...args) {\r\n        if (isNativeBlobDefined()) {\r\n            const blobby = args.map((val) => {\r\n                if (val instanceof FbsBlob) {\r\n                    return val.data_;\r\n                }\r\n                else {\r\n                    return val;\r\n                }\r\n            });\r\n            return new FbsBlob(getBlob$1.apply(null, blobby));\r\n        }\r\n        else {\r\n            const uint8Arrays = args.map((val) => {\r\n                if (isString(val)) {\r\n                    return dataFromString(StringFormat.RAW, val).data;\r\n                }\r\n                else {\r\n                    // Blobs don't exist, so this has to be a Uint8Array.\r\n                    return val.data_;\r\n                }\r\n            });\r\n            let finalLength = 0;\r\n            uint8Arrays.forEach((array) => {\r\n                finalLength += array.byteLength;\r\n            });\r\n            const merged = new Uint8Array(finalLength);\r\n            let index = 0;\r\n            uint8Arrays.forEach((array) => {\r\n                for (let i = 0; i < array.length; i++) {\r\n                    merged[index++] = array[i];\r\n                }\r\n            });\r\n            return new FbsBlob(merged, true);\r\n        }\r\n    }\r\n    uploadData() {\r\n        return this.data_;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns the Object resulting from parsing the given JSON, or null if the\r\n * given string does not represent a JSON object.\r\n */\r\nfunction jsonObjectOrNull(s) {\r\n    let obj;\r\n    try {\r\n        obj = JSON.parse(s);\r\n    }\r\n    catch (e) {\r\n        return null;\r\n    }\r\n    if (isNonArrayObject(obj)) {\r\n        return obj;\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview Contains helper methods for manipulating paths.\r\n */\r\n/**\r\n * @return Null if the path is already at the root.\r\n */\r\nfunction parent(path) {\r\n    if (path.length === 0) {\r\n        return null;\r\n    }\r\n    const index = path.lastIndexOf('/');\r\n    if (index === -1) {\r\n        return '';\r\n    }\r\n    const newPath = path.slice(0, index);\r\n    return newPath;\r\n}\r\nfunction child(path, childPath) {\r\n    const canonicalChildPath = childPath\r\n        .split('/')\r\n        .filter(component => component.length > 0)\r\n        .join('/');\r\n    if (path.length === 0) {\r\n        return canonicalChildPath;\r\n    }\r\n    else {\r\n        return path + '/' + canonicalChildPath;\r\n    }\r\n}\r\n/**\r\n * Returns the last component of a path.\r\n * '/foo/bar' -> 'bar'\r\n * '/foo/bar/baz/' -> 'baz/'\r\n * '/a' -> 'a'\r\n */\r\nfunction lastComponent(path) {\r\n    const index = path.lastIndexOf('/', path.length - 2);\r\n    if (index === -1) {\r\n        return path;\r\n    }\r\n    else {\r\n        return path.slice(index + 1);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction noXform_(metadata, value) {\r\n    return value;\r\n}\r\nclass Mapping {\r\n    constructor(server, local, writable, xform) {\r\n        this.server = server;\r\n        this.local = local || server;\r\n        this.writable = !!writable;\r\n        this.xform = xform || noXform_;\r\n    }\r\n}\r\nlet mappings_ = null;\r\nfunction xformPath(fullPath) {\r\n    if (!isString(fullPath) || fullPath.length < 2) {\r\n        return fullPath;\r\n    }\r\n    else {\r\n        return lastComponent(fullPath);\r\n    }\r\n}\r\nfunction getMappings() {\r\n    if (mappings_) {\r\n        return mappings_;\r\n    }\r\n    const mappings = [];\r\n    mappings.push(new Mapping('bucket'));\r\n    mappings.push(new Mapping('generation'));\r\n    mappings.push(new Mapping('metageneration'));\r\n    mappings.push(new Mapping('name', 'fullPath', true));\r\n    function mappingsXformPath(_metadata, fullPath) {\r\n        return xformPath(fullPath);\r\n    }\r\n    const nameMapping = new Mapping('name');\r\n    nameMapping.xform = mappingsXformPath;\r\n    mappings.push(nameMapping);\r\n    /**\r\n     * Coerces the second param to a number, if it is defined.\r\n     */\r\n    function xformSize(_metadata, size) {\r\n        if (size !== undefined) {\r\n            return Number(size);\r\n        }\r\n        else {\r\n            return size;\r\n        }\r\n    }\r\n    const sizeMapping = new Mapping('size');\r\n    sizeMapping.xform = xformSize;\r\n    mappings.push(sizeMapping);\r\n    mappings.push(new Mapping('timeCreated'));\r\n    mappings.push(new Mapping('updated'));\r\n    mappings.push(new Mapping('md5Hash', null, true));\r\n    mappings.push(new Mapping('cacheControl', null, true));\r\n    mappings.push(new Mapping('contentDisposition', null, true));\r\n    mappings.push(new Mapping('contentEncoding', null, true));\r\n    mappings.push(new Mapping('contentLanguage', null, true));\r\n    mappings.push(new Mapping('contentType', null, true));\r\n    mappings.push(new Mapping('metadata', 'customMetadata', true));\r\n    mappings_ = mappings;\r\n    return mappings_;\r\n}\r\nfunction addRef(metadata, service) {\r\n    function generateRef() {\r\n        const bucket = metadata['bucket'];\r\n        const path = metadata['fullPath'];\r\n        const loc = new Location(bucket, path);\r\n        return service._makeStorageReference(loc);\r\n    }\r\n    Object.defineProperty(metadata, 'ref', { get: generateRef });\r\n}\r\nfunction fromResource(service, resource, mappings) {\r\n    const metadata = {};\r\n    metadata['type'] = 'file';\r\n    const len = mappings.length;\r\n    for (let i = 0; i < len; i++) {\r\n        const mapping = mappings[i];\r\n        metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\r\n    }\r\n    addRef(metadata, service);\r\n    return metadata;\r\n}\r\nfunction fromResourceString(service, resourceString, mappings) {\r\n    const obj = jsonObjectOrNull(resourceString);\r\n    if (obj === null) {\r\n        return null;\r\n    }\r\n    const resource = obj;\r\n    return fromResource(service, resource, mappings);\r\n}\r\nfunction downloadUrlFromResourceString(metadata, resourceString, host, protocol) {\r\n    const obj = jsonObjectOrNull(resourceString);\r\n    if (obj === null) {\r\n        return null;\r\n    }\r\n    if (!isString(obj['downloadTokens'])) {\r\n        // This can happen if objects are uploaded through GCS and retrieved\r\n        // through list, so we don't want to throw an Error.\r\n        return null;\r\n    }\r\n    const tokens = obj['downloadTokens'];\r\n    if (tokens.length === 0) {\r\n        return null;\r\n    }\r\n    const encode = encodeURIComponent;\r\n    const tokensList = tokens.split(',');\r\n    const urls = tokensList.map((token) => {\r\n        const bucket = metadata['bucket'];\r\n        const path = metadata['fullPath'];\r\n        const urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\r\n        const base = makeUrl(urlPart, host, protocol);\r\n        const queryString = makeQueryString({\r\n            alt: 'media',\r\n            token\r\n        });\r\n        return base + queryString;\r\n    });\r\n    return urls[0];\r\n}\r\nfunction toResourceString(metadata, mappings) {\r\n    const resource = {};\r\n    const len = mappings.length;\r\n    for (let i = 0; i < len; i++) {\r\n        const mapping = mappings[i];\r\n        if (mapping.writable) {\r\n            resource[mapping.server] = metadata[mapping.local];\r\n        }\r\n    }\r\n    return JSON.stringify(resource);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst PREFIXES_KEY = 'prefixes';\r\nconst ITEMS_KEY = 'items';\r\nfunction fromBackendResponse(service, bucket, resource) {\r\n    const listResult = {\r\n        prefixes: [],\r\n        items: [],\r\n        nextPageToken: resource['nextPageToken']\r\n    };\r\n    if (resource[PREFIXES_KEY]) {\r\n        for (const path of resource[PREFIXES_KEY]) {\r\n            const pathWithoutTrailingSlash = path.replace(/\\/$/, '');\r\n            const reference = service._makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));\r\n            listResult.prefixes.push(reference);\r\n        }\r\n    }\r\n    if (resource[ITEMS_KEY]) {\r\n        for (const item of resource[ITEMS_KEY]) {\r\n            const reference = service._makeStorageReference(new Location(bucket, item['name']));\r\n            listResult.items.push(reference);\r\n        }\r\n    }\r\n    return listResult;\r\n}\r\nfunction fromResponseString(service, bucket, resourceString) {\r\n    const obj = jsonObjectOrNull(resourceString);\r\n    if (obj === null) {\r\n        return null;\r\n    }\r\n    const resource = obj;\r\n    return fromBackendResponse(service, bucket, resource);\r\n}\n\n/**\r\n * Contains a fully specified request.\r\n *\r\n * @param I - the type of the backend's network response.\r\n * @param O - the output response type used by the rest of the SDK.\r\n */\r\nclass RequestInfo {\r\n    constructor(url, method, \r\n    /**\r\n     * Returns the value with which to resolve the request's promise. Only called\r\n     * if the request is successful. Throw from this function to reject the\r\n     * returned Request's promise with the thrown error.\r\n     * Note: The XhrIo passed to this function may be reused after this callback\r\n     * returns. Do not keep a reference to it in any way.\r\n     */\r\n    handler, timeout) {\r\n        this.url = url;\r\n        this.method = method;\r\n        this.handler = handler;\r\n        this.timeout = timeout;\r\n        this.urlParams = {};\r\n        this.headers = {};\r\n        this.body = null;\r\n        this.errorHandler = null;\r\n        /**\r\n         * Called with the current number of bytes uploaded and total size (-1 if not\r\n         * computable) of the request body (i.e. used to report upload progress).\r\n         */\r\n        this.progressCallback = null;\r\n        this.successCodes = [200];\r\n        this.additionalRetryCodes = [];\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Throws the UNKNOWN StorageError if cndn is false.\r\n */\r\nfunction handlerCheck(cndn) {\r\n    if (!cndn) {\r\n        throw unknown();\r\n    }\r\n}\r\nfunction metadataHandler(service, mappings) {\r\n    function handler(xhr, text) {\r\n        const metadata = fromResourceString(service, text, mappings);\r\n        handlerCheck(metadata !== null);\r\n        return metadata;\r\n    }\r\n    return handler;\r\n}\r\nfunction listHandler(service, bucket) {\r\n    function handler(xhr, text) {\r\n        const listResult = fromResponseString(service, bucket, text);\r\n        handlerCheck(listResult !== null);\r\n        return listResult;\r\n    }\r\n    return handler;\r\n}\r\nfunction downloadUrlHandler(service, mappings) {\r\n    function handler(xhr, text) {\r\n        const metadata = fromResourceString(service, text, mappings);\r\n        handlerCheck(metadata !== null);\r\n        return downloadUrlFromResourceString(metadata, text, service.host, service._protocol);\r\n    }\r\n    return handler;\r\n}\r\nfunction sharedErrorHandler(location) {\r\n    function errorHandler(xhr, err) {\r\n        let newErr;\r\n        if (xhr.getStatus() === 401) {\r\n            if (\r\n            // This exact message string is the only consistent part of the\r\n            // server's error response that identifies it as an App Check error.\r\n            xhr.getErrorText().includes('Firebase App Check token is invalid')) {\r\n                newErr = unauthorizedApp();\r\n            }\r\n            else {\r\n                newErr = unauthenticated();\r\n            }\r\n        }\r\n        else {\r\n            if (xhr.getStatus() === 402) {\r\n                newErr = quotaExceeded(location.bucket);\r\n            }\r\n            else {\r\n                if (xhr.getStatus() === 403) {\r\n                    newErr = unauthorized(location.path);\r\n                }\r\n                else {\r\n                    newErr = err;\r\n                }\r\n            }\r\n        }\r\n        newErr.status = xhr.getStatus();\r\n        newErr.serverResponse = err.serverResponse;\r\n        return newErr;\r\n    }\r\n    return errorHandler;\r\n}\r\nfunction objectErrorHandler(location) {\r\n    const shared = sharedErrorHandler(location);\r\n    function errorHandler(xhr, err) {\r\n        let newErr = shared(xhr, err);\r\n        if (xhr.getStatus() === 404) {\r\n            newErr = objectNotFound(location.path);\r\n        }\r\n        newErr.serverResponse = err.serverResponse;\r\n        return newErr;\r\n    }\r\n    return errorHandler;\r\n}\r\nfunction getMetadata$2(service, location, mappings) {\r\n    const urlPart = location.fullServerUrl();\r\n    const url = makeUrl(urlPart, service.host, service._protocol);\r\n    const method = 'GET';\r\n    const timeout = service.maxOperationRetryTime;\r\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\r\n    requestInfo.errorHandler = objectErrorHandler(location);\r\n    return requestInfo;\r\n}\r\nfunction list$2(service, location, delimiter, pageToken, maxResults) {\r\n    const urlParams = {};\r\n    if (location.isRoot) {\r\n        urlParams['prefix'] = '';\r\n    }\r\n    else {\r\n        urlParams['prefix'] = location.path + '/';\r\n    }\r\n    if (delimiter && delimiter.length > 0) {\r\n        urlParams['delimiter'] = delimiter;\r\n    }\r\n    if (pageToken) {\r\n        urlParams['pageToken'] = pageToken;\r\n    }\r\n    if (maxResults) {\r\n        urlParams['maxResults'] = maxResults;\r\n    }\r\n    const urlPart = location.bucketOnlyServerUrl();\r\n    const url = makeUrl(urlPart, service.host, service._protocol);\r\n    const method = 'GET';\r\n    const timeout = service.maxOperationRetryTime;\r\n    const requestInfo = new RequestInfo(url, method, listHandler(service, location.bucket), timeout);\r\n    requestInfo.urlParams = urlParams;\r\n    requestInfo.errorHandler = sharedErrorHandler(location);\r\n    return requestInfo;\r\n}\r\nfunction getBytes$1(service, location, maxDownloadSizeBytes) {\r\n    const urlPart = location.fullServerUrl();\r\n    const url = makeUrl(urlPart, service.host, service._protocol) + '?alt=media';\r\n    const method = 'GET';\r\n    const timeout = service.maxOperationRetryTime;\r\n    const requestInfo = new RequestInfo(url, method, (_, data) => data, timeout);\r\n    requestInfo.errorHandler = objectErrorHandler(location);\r\n    if (maxDownloadSizeBytes !== undefined) {\r\n        requestInfo.headers['Range'] = `bytes=0-${maxDownloadSizeBytes}`;\r\n        requestInfo.successCodes = [200 /* OK */, 206 /* Partial Content */];\r\n    }\r\n    return requestInfo;\r\n}\r\nfunction getDownloadUrl(service, location, mappings) {\r\n    const urlPart = location.fullServerUrl();\r\n    const url = makeUrl(urlPart, service.host, service._protocol);\r\n    const method = 'GET';\r\n    const timeout = service.maxOperationRetryTime;\r\n    const requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);\r\n    requestInfo.errorHandler = objectErrorHandler(location);\r\n    return requestInfo;\r\n}\r\nfunction updateMetadata$2(service, location, metadata, mappings) {\r\n    const urlPart = location.fullServerUrl();\r\n    const url = makeUrl(urlPart, service.host, service._protocol);\r\n    const method = 'PATCH';\r\n    const body = toResourceString(metadata, mappings);\r\n    const headers = { 'Content-Type': 'application/json; charset=utf-8' };\r\n    const timeout = service.maxOperationRetryTime;\r\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\r\n    requestInfo.headers = headers;\r\n    requestInfo.body = body;\r\n    requestInfo.errorHandler = objectErrorHandler(location);\r\n    return requestInfo;\r\n}\r\nfunction deleteObject$2(service, location) {\r\n    const urlPart = location.fullServerUrl();\r\n    const url = makeUrl(urlPart, service.host, service._protocol);\r\n    const method = 'DELETE';\r\n    const timeout = service.maxOperationRetryTime;\r\n    function handler(_xhr, _text) { }\r\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\r\n    requestInfo.successCodes = [200, 204];\r\n    requestInfo.errorHandler = objectErrorHandler(location);\r\n    return requestInfo;\r\n}\r\nfunction determineContentType_(metadata, blob) {\r\n    return ((metadata && metadata['contentType']) ||\r\n        (blob && blob.type()) ||\r\n        'application/octet-stream');\r\n}\r\nfunction metadataForUpload_(location, blob, metadata) {\r\n    const metadataClone = Object.assign({}, metadata);\r\n    metadataClone['fullPath'] = location.path;\r\n    metadataClone['size'] = blob.size();\r\n    if (!metadataClone['contentType']) {\r\n        metadataClone['contentType'] = determineContentType_(null, blob);\r\n    }\r\n    return metadataClone;\r\n}\r\n/**\r\n * Prepare RequestInfo for uploads as Content-Type: multipart.\r\n */\r\nfunction multipartUpload(service, location, mappings, blob, metadata) {\r\n    const urlPart = location.bucketOnlyServerUrl();\r\n    const headers = {\r\n        'X-Goog-Upload-Protocol': 'multipart'\r\n    };\r\n    function genBoundary() {\r\n        let str = '';\r\n        for (let i = 0; i < 2; i++) {\r\n            str = str + Math.random().toString().slice(2);\r\n        }\r\n        return str;\r\n    }\r\n    const boundary = genBoundary();\r\n    headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\r\n    const metadata_ = metadataForUpload_(location, blob, metadata);\r\n    const metadataString = toResourceString(metadata_, mappings);\r\n    const preBlobPart = '--' +\r\n        boundary +\r\n        '\\r\\n' +\r\n        'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' +\r\n        metadataString +\r\n        '\\r\\n--' +\r\n        boundary +\r\n        '\\r\\n' +\r\n        'Content-Type: ' +\r\n        metadata_['contentType'] +\r\n        '\\r\\n\\r\\n';\r\n    const postBlobPart = '\\r\\n--' + boundary + '--';\r\n    const body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\r\n    if (body === null) {\r\n        throw cannotSliceBlob();\r\n    }\r\n    const urlParams = { name: metadata_['fullPath'] };\r\n    const url = makeUrl(urlPart, service.host, service._protocol);\r\n    const method = 'POST';\r\n    const timeout = service.maxUploadRetryTime;\r\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\r\n    requestInfo.urlParams = urlParams;\r\n    requestInfo.headers = headers;\r\n    requestInfo.body = body.uploadData();\r\n    requestInfo.errorHandler = sharedErrorHandler(location);\r\n    return requestInfo;\r\n}\r\n/**\r\n * @param current The number of bytes that have been uploaded so far.\r\n * @param total The total number of bytes in the upload.\r\n * @param opt_finalized True if the server has finished the upload.\r\n * @param opt_metadata The upload metadata, should\r\n *     only be passed if opt_finalized is true.\r\n */\r\nclass ResumableUploadStatus {\r\n    constructor(current, total, finalized, metadata) {\r\n        this.current = current;\r\n        this.total = total;\r\n        this.finalized = !!finalized;\r\n        this.metadata = metadata || null;\r\n    }\r\n}\r\nfunction checkResumeHeader_(xhr, allowed) {\r\n    let status = null;\r\n    try {\r\n        status = xhr.getResponseHeader('X-Goog-Upload-Status');\r\n    }\r\n    catch (e) {\r\n        handlerCheck(false);\r\n    }\r\n    const allowedStatus = allowed || ['active'];\r\n    handlerCheck(!!status && allowedStatus.indexOf(status) !== -1);\r\n    return status;\r\n}\r\nfunction createResumableUpload(service, location, mappings, blob, metadata) {\r\n    const urlPart = location.bucketOnlyServerUrl();\r\n    const metadataForUpload = metadataForUpload_(location, blob, metadata);\r\n    const urlParams = { name: metadataForUpload['fullPath'] };\r\n    const url = makeUrl(urlPart, service.host, service._protocol);\r\n    const method = 'POST';\r\n    const headers = {\r\n        'X-Goog-Upload-Protocol': 'resumable',\r\n        'X-Goog-Upload-Command': 'start',\r\n        'X-Goog-Upload-Header-Content-Length': `${blob.size()}`,\r\n        'X-Goog-Upload-Header-Content-Type': metadataForUpload['contentType'],\r\n        'Content-Type': 'application/json; charset=utf-8'\r\n    };\r\n    const body = toResourceString(metadataForUpload, mappings);\r\n    const timeout = service.maxUploadRetryTime;\r\n    function handler(xhr) {\r\n        checkResumeHeader_(xhr);\r\n        let url;\r\n        try {\r\n            url = xhr.getResponseHeader('X-Goog-Upload-URL');\r\n        }\r\n        catch (e) {\r\n            handlerCheck(false);\r\n        }\r\n        handlerCheck(isString(url));\r\n        return url;\r\n    }\r\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\r\n    requestInfo.urlParams = urlParams;\r\n    requestInfo.headers = headers;\r\n    requestInfo.body = body;\r\n    requestInfo.errorHandler = sharedErrorHandler(location);\r\n    return requestInfo;\r\n}\r\n/**\r\n * @param url From a call to fbs.requests.createResumableUpload.\r\n */\r\nfunction getResumableUploadStatus(service, location, url, blob) {\r\n    const headers = { 'X-Goog-Upload-Command': 'query' };\r\n    function handler(xhr) {\r\n        const status = checkResumeHeader_(xhr, ['active', 'final']);\r\n        let sizeString = null;\r\n        try {\r\n            sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\r\n        }\r\n        catch (e) {\r\n            handlerCheck(false);\r\n        }\r\n        if (!sizeString) {\r\n            // null or empty string\r\n            handlerCheck(false);\r\n        }\r\n        const size = Number(sizeString);\r\n        handlerCheck(!isNaN(size));\r\n        return new ResumableUploadStatus(size, blob.size(), status === 'final');\r\n    }\r\n    const method = 'POST';\r\n    const timeout = service.maxUploadRetryTime;\r\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\r\n    requestInfo.headers = headers;\r\n    requestInfo.errorHandler = sharedErrorHandler(location);\r\n    return requestInfo;\r\n}\r\n/**\r\n * Any uploads via the resumable upload API must transfer a number of bytes\r\n * that is a multiple of this number.\r\n */\r\nconst RESUMABLE_UPLOAD_CHUNK_SIZE = 256 * 1024;\r\n/**\r\n * @param url From a call to fbs.requests.createResumableUpload.\r\n * @param chunkSize Number of bytes to upload.\r\n * @param status The previous status.\r\n *     If not passed or null, we start from the beginning.\r\n * @throws fbs.Error If the upload is already complete, the passed in status\r\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\r\n *     for upload.\r\n */\r\nfunction continueResumableUpload(location, service, url, blob, chunkSize, mappings, status, progressCallback) {\r\n    // TODO(andysoto): standardize on internal asserts\r\n    // assert(!(opt_status && opt_status.finalized));\r\n    const status_ = new ResumableUploadStatus(0, 0);\r\n    if (status) {\r\n        status_.current = status.current;\r\n        status_.total = status.total;\r\n    }\r\n    else {\r\n        status_.current = 0;\r\n        status_.total = blob.size();\r\n    }\r\n    if (blob.size() !== status_.total) {\r\n        throw serverFileWrongSize();\r\n    }\r\n    const bytesLeft = status_.total - status_.current;\r\n    let bytesToUpload = bytesLeft;\r\n    if (chunkSize > 0) {\r\n        bytesToUpload = Math.min(bytesToUpload, chunkSize);\r\n    }\r\n    const startByte = status_.current;\r\n    const endByte = startByte + bytesToUpload;\r\n    let uploadCommand = '';\r\n    if (bytesToUpload === 0) {\r\n        uploadCommand = 'finalize';\r\n    }\r\n    else if (bytesLeft === bytesToUpload) {\r\n        uploadCommand = 'upload, finalize';\r\n    }\r\n    else {\r\n        uploadCommand = 'upload';\r\n    }\r\n    const headers = {\r\n        'X-Goog-Upload-Command': uploadCommand,\r\n        'X-Goog-Upload-Offset': `${status_.current}`\r\n    };\r\n    const body = blob.slice(startByte, endByte);\r\n    if (body === null) {\r\n        throw cannotSliceBlob();\r\n    }\r\n    function handler(xhr, text) {\r\n        // TODO(andysoto): Verify the MD5 of each uploaded range:\r\n        // the 'x-range-md5' header comes back with status code 308 responses.\r\n        // We'll only be able to bail out though, because you can't re-upload a\r\n        // range that you previously uploaded.\r\n        const uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\r\n        const newCurrent = status_.current + bytesToUpload;\r\n        const size = blob.size();\r\n        let metadata;\r\n        if (uploadStatus === 'final') {\r\n            metadata = metadataHandler(service, mappings)(xhr, text);\r\n        }\r\n        else {\r\n            metadata = null;\r\n        }\r\n        return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);\r\n    }\r\n    const method = 'POST';\r\n    const timeout = service.maxUploadRetryTime;\r\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\r\n    requestInfo.headers = headers;\r\n    requestInfo.body = body.uploadData();\r\n    requestInfo.progressCallback = progressCallback || null;\r\n    requestInfo.errorHandler = sharedErrorHandler(location);\r\n    return requestInfo;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An event that is triggered on a task.\r\n * @internal\r\n */\r\nconst TaskEvent = {\r\n    /**\r\n     * For this event,\r\n     * <ul>\r\n     *   <li>The `next` function is triggered on progress updates and when the\r\n     *       task is paused/resumed with an `UploadTaskSnapshot` as the first\r\n     *       argument.</li>\r\n     *   <li>The `error` function is triggered if the upload is canceled or fails\r\n     *       for another reason.</li>\r\n     *   <li>The `complete` function is triggered if the upload completes\r\n     *       successfully.</li>\r\n     * </ul>\r\n     */\r\n    STATE_CHANGED: 'state_changed'\r\n};\r\n// type keys = keyof TaskState\r\n/**\r\n * Represents the current state of a running upload.\r\n * @internal\r\n */\r\nconst TaskState = {\r\n    /** The task is currently transferring data. */\r\n    RUNNING: 'running',\r\n    /** The task was paused by the user. */\r\n    PAUSED: 'paused',\r\n    /** The task completed successfully. */\r\n    SUCCESS: 'success',\r\n    /** The task was canceled. */\r\n    CANCELED: 'canceled',\r\n    /** The task failed with an error. */\r\n    ERROR: 'error'\r\n};\r\nfunction taskStateFromInternalTaskState(state) {\r\n    switch (state) {\r\n        case \"running\" /* InternalTaskState.RUNNING */:\r\n        case \"pausing\" /* InternalTaskState.PAUSING */:\r\n        case \"canceling\" /* InternalTaskState.CANCELING */:\r\n            return TaskState.RUNNING;\r\n        case \"paused\" /* InternalTaskState.PAUSED */:\r\n            return TaskState.PAUSED;\r\n        case \"success\" /* InternalTaskState.SUCCESS */:\r\n            return TaskState.SUCCESS;\r\n        case \"canceled\" /* InternalTaskState.CANCELED */:\r\n            return TaskState.CANCELED;\r\n        case \"error\" /* InternalTaskState.ERROR */:\r\n            return TaskState.ERROR;\r\n        default:\r\n            // TODO(andysoto): assert(false);\r\n            return TaskState.ERROR;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Observer {\r\n    constructor(nextOrObserver, error, complete) {\r\n        const asFunctions = isFunction(nextOrObserver) || error != null || complete != null;\r\n        if (asFunctions) {\r\n            this.next = nextOrObserver;\r\n            this.error = error !== null && error !== void 0 ? error : undefined;\r\n            this.complete = complete !== null && complete !== void 0 ? complete : undefined;\r\n        }\r\n        else {\r\n            const observer = nextOrObserver;\r\n            this.next = observer.next;\r\n            this.error = observer.error;\r\n            this.complete = observer.complete;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a function that invokes f with its arguments asynchronously as a\r\n * microtask, i.e. as soon as possible after the current script returns back\r\n * into browser code.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction async(f) {\r\n    return (...argsToForward) => {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        Promise.resolve().then(() => f(...argsToForward));\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** An override for the text-based Connection. Used in tests. */\r\nlet textFactoryOverride = null;\r\n/**\r\n * Network layer that works in Node.\r\n *\r\n * This network implementation should not be used in browsers as it does not\r\n * support progress updates.\r\n */\r\nclass FetchConnection {\r\n    constructor() {\r\n        this.errorText_ = '';\r\n        this.sent_ = false;\r\n        this.fetch_ = undici__WEBPACK_IMPORTED_MODULE_3__.fetch;\r\n        this.errorCode_ = ErrorCode.NO_ERROR;\r\n    }\r\n    async send(url, method, body, headers) {\r\n        if (this.sent_) {\r\n            throw internalError('cannot .send() more than once');\r\n        }\r\n        this.sent_ = true;\r\n        try {\r\n            const response = await this.fetch_(url, {\r\n                method,\r\n                headers: headers || {},\r\n                body: body\r\n            });\r\n            this.headers_ = response.headers;\r\n            this.statusCode_ = response.status;\r\n            this.errorCode_ = ErrorCode.NO_ERROR;\r\n            this.body_ = await response.arrayBuffer();\r\n        }\r\n        catch (e) {\r\n            this.errorText_ = e === null || e === void 0 ? void 0 : e.message;\r\n            // emulate XHR which sets status to 0 when encountering a network error\r\n            this.statusCode_ = 0;\r\n            this.errorCode_ = ErrorCode.NETWORK_ERROR;\r\n        }\r\n    }\r\n    getErrorCode() {\r\n        if (this.errorCode_ === undefined) {\r\n            throw internalError('cannot .getErrorCode() before receiving response');\r\n        }\r\n        return this.errorCode_;\r\n    }\r\n    getStatus() {\r\n        if (this.statusCode_ === undefined) {\r\n            throw internalError('cannot .getStatus() before receiving response');\r\n        }\r\n        return this.statusCode_;\r\n    }\r\n    getErrorText() {\r\n        return this.errorText_;\r\n    }\r\n    abort() {\r\n        // Not supported\r\n    }\r\n    getResponseHeader(header) {\r\n        if (!this.headers_) {\r\n            throw internalError('cannot .getResponseHeader() before receiving response');\r\n        }\r\n        return this.headers_.get(header);\r\n    }\r\n    addUploadProgressListener(listener) {\r\n        // Not supported\r\n    }\r\n    removeUploadProgressListener(listener) {\r\n        // Not supported\r\n    }\r\n}\r\nclass FetchTextConnection extends FetchConnection {\r\n    getResponse() {\r\n        if (!this.body_) {\r\n            throw internalError('cannot .getResponse() before receiving response');\r\n        }\r\n        return Buffer.from(this.body_).toString('utf-8');\r\n    }\r\n}\r\nfunction newTextConnection() {\r\n    return textFactoryOverride\r\n        ? textFactoryOverride()\r\n        : new FetchTextConnection();\r\n}\r\nclass FetchBytesConnection extends FetchConnection {\r\n    getResponse() {\r\n        if (!this.body_) {\r\n            throw internalError('cannot .getResponse() before sending');\r\n        }\r\n        return this.body_;\r\n    }\r\n}\r\nfunction newBytesConnection() {\r\n    return new FetchBytesConnection();\r\n}\r\nclass FetchStreamConnection extends FetchConnection {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.stream_ = null;\r\n    }\r\n    async send(url, method, body, headers) {\r\n        if (this.sent_) {\r\n            throw internalError('cannot .send() more than once');\r\n        }\r\n        this.sent_ = true;\r\n        try {\r\n            const response = await this.fetch_(url, {\r\n                method,\r\n                headers: headers || {},\r\n                body: body\r\n            });\r\n            this.headers_ = response.headers;\r\n            this.statusCode_ = response.status;\r\n            this.errorCode_ = ErrorCode.NO_ERROR;\r\n            this.stream_ = response.body;\r\n        }\r\n        catch (e) {\r\n            this.errorText_ = e === null || e === void 0 ? void 0 : e.message;\r\n            // emulate XHR which sets status to 0 when encountering a network error\r\n            this.statusCode_ = 0;\r\n            this.errorCode_ = ErrorCode.NETWORK_ERROR;\r\n        }\r\n    }\r\n    getResponse() {\r\n        if (!this.stream_) {\r\n            throw internalError('cannot .getResponse() before sending');\r\n        }\r\n        return this.stream_;\r\n    }\r\n}\r\nfunction newStreamConnection() {\r\n    return new FetchStreamConnection();\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\r\n * upload and manage callbacks for various events.\r\n * @internal\r\n */\r\nclass UploadTask {\r\n    /**\r\n     * @param ref - The firebaseStorage.Reference object this task came\r\n     *     from, untyped to avoid cyclic dependencies.\r\n     * @param blob - The blob to upload.\r\n     */\r\n    constructor(ref, blob, metadata = null) {\r\n        /**\r\n         * Number of bytes transferred so far.\r\n         */\r\n        this._transferred = 0;\r\n        this._needToFetchStatus = false;\r\n        this._needToFetchMetadata = false;\r\n        this._observers = [];\r\n        this._error = undefined;\r\n        this._uploadUrl = undefined;\r\n        this._request = undefined;\r\n        this._chunkMultiplier = 1;\r\n        this._resolve = undefined;\r\n        this._reject = undefined;\r\n        this._ref = ref;\r\n        this._blob = blob;\r\n        this._metadata = metadata;\r\n        this._mappings = getMappings();\r\n        this._resumable = this._shouldDoResumable(this._blob);\r\n        this._state = \"running\" /* InternalTaskState.RUNNING */;\r\n        this._errorHandler = error => {\r\n            this._request = undefined;\r\n            this._chunkMultiplier = 1;\r\n            if (error._codeEquals(StorageErrorCode.CANCELED)) {\r\n                this._needToFetchStatus = true;\r\n                this.completeTransitions_();\r\n            }\r\n            else {\r\n                const backoffExpired = this.isExponentialBackoffExpired();\r\n                if (isRetryStatusCode(error.status, [])) {\r\n                    if (backoffExpired) {\r\n                        error = retryLimitExceeded();\r\n                    }\r\n                    else {\r\n                        this.sleepTime = Math.max(this.sleepTime * 2, DEFAULT_MIN_SLEEP_TIME_MILLIS);\r\n                        this._needToFetchStatus = true;\r\n                        this.completeTransitions_();\r\n                        return;\r\n                    }\r\n                }\r\n                this._error = error;\r\n                this._transition(\"error\" /* InternalTaskState.ERROR */);\r\n            }\r\n        };\r\n        this._metadataErrorHandler = error => {\r\n            this._request = undefined;\r\n            if (error._codeEquals(StorageErrorCode.CANCELED)) {\r\n                this.completeTransitions_();\r\n            }\r\n            else {\r\n                this._error = error;\r\n                this._transition(\"error\" /* InternalTaskState.ERROR */);\r\n            }\r\n        };\r\n        this.sleepTime = 0;\r\n        this.maxSleepTime = this._ref.storage.maxUploadRetryTime;\r\n        this._promise = new Promise((resolve, reject) => {\r\n            this._resolve = resolve;\r\n            this._reject = reject;\r\n            this._start();\r\n        });\r\n        // Prevent uncaught rejections on the internal promise from bubbling out\r\n        // to the top level with a dummy handler.\r\n        this._promise.then(null, () => { });\r\n    }\r\n    isExponentialBackoffExpired() {\r\n        return this.sleepTime > this.maxSleepTime;\r\n    }\r\n    _makeProgressCallback() {\r\n        const sizeBefore = this._transferred;\r\n        return loaded => this._updateProgress(sizeBefore + loaded);\r\n    }\r\n    _shouldDoResumable(blob) {\r\n        return blob.size() > 256 * 1024;\r\n    }\r\n    _start() {\r\n        if (this._state !== \"running\" /* InternalTaskState.RUNNING */) {\r\n            // This can happen if someone pauses us in a resume callback, for example.\r\n            return;\r\n        }\r\n        if (this._request !== undefined) {\r\n            return;\r\n        }\r\n        if (this._resumable) {\r\n            if (this._uploadUrl === undefined) {\r\n                this._createResumable();\r\n            }\r\n            else {\r\n                if (this._needToFetchStatus) {\r\n                    this._fetchStatus();\r\n                }\r\n                else {\r\n                    if (this._needToFetchMetadata) {\r\n                        // Happens if we miss the metadata on upload completion.\r\n                        this._fetchMetadata();\r\n                    }\r\n                    else {\r\n                        this.pendingTimeout = setTimeout(() => {\r\n                            this.pendingTimeout = undefined;\r\n                            this._continueUpload();\r\n                        }, this.sleepTime);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this._oneShotUpload();\r\n        }\r\n    }\r\n    _resolveToken(callback) {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        Promise.all([\r\n            this._ref.storage._getAuthToken(),\r\n            this._ref.storage._getAppCheckToken()\r\n        ]).then(([authToken, appCheckToken]) => {\r\n            switch (this._state) {\r\n                case \"running\" /* InternalTaskState.RUNNING */:\r\n                    callback(authToken, appCheckToken);\r\n                    break;\r\n                case \"canceling\" /* InternalTaskState.CANCELING */:\r\n                    this._transition(\"canceled\" /* InternalTaskState.CANCELED */);\r\n                    break;\r\n                case \"pausing\" /* InternalTaskState.PAUSING */:\r\n                    this._transition(\"paused\" /* InternalTaskState.PAUSED */);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    // TODO(andysoto): assert false\r\n    _createResumable() {\r\n        this._resolveToken((authToken, appCheckToken) => {\r\n            const requestInfo = createResumableUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);\r\n            const createRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\r\n            this._request = createRequest;\r\n            createRequest.getPromise().then((url) => {\r\n                this._request = undefined;\r\n                this._uploadUrl = url;\r\n                this._needToFetchStatus = false;\r\n                this.completeTransitions_();\r\n            }, this._errorHandler);\r\n        });\r\n    }\r\n    _fetchStatus() {\r\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\r\n        const url = this._uploadUrl;\r\n        this._resolveToken((authToken, appCheckToken) => {\r\n            const requestInfo = getResumableUploadStatus(this._ref.storage, this._ref._location, url, this._blob);\r\n            const statusRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\r\n            this._request = statusRequest;\r\n            statusRequest.getPromise().then(status => {\r\n                status = status;\r\n                this._request = undefined;\r\n                this._updateProgress(status.current);\r\n                this._needToFetchStatus = false;\r\n                if (status.finalized) {\r\n                    this._needToFetchMetadata = true;\r\n                }\r\n                this.completeTransitions_();\r\n            }, this._errorHandler);\r\n        });\r\n    }\r\n    _continueUpload() {\r\n        const chunkSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;\r\n        const status = new ResumableUploadStatus(this._transferred, this._blob.size());\r\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\r\n        const url = this._uploadUrl;\r\n        this._resolveToken((authToken, appCheckToken) => {\r\n            let requestInfo;\r\n            try {\r\n                requestInfo = continueResumableUpload(this._ref._location, this._ref.storage, url, this._blob, chunkSize, this._mappings, status, this._makeProgressCallback());\r\n            }\r\n            catch (e) {\r\n                this._error = e;\r\n                this._transition(\"error\" /* InternalTaskState.ERROR */);\r\n                return;\r\n            }\r\n            const uploadRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken, \r\n            /*retry=*/ false // Upload requests should not be retried as each retry should be preceded by another query request. Which is handled in this file.\r\n            );\r\n            this._request = uploadRequest;\r\n            uploadRequest.getPromise().then((newStatus) => {\r\n                this._increaseMultiplier();\r\n                this._request = undefined;\r\n                this._updateProgress(newStatus.current);\r\n                if (newStatus.finalized) {\r\n                    this._metadata = newStatus.metadata;\r\n                    this._transition(\"success\" /* InternalTaskState.SUCCESS */);\r\n                }\r\n                else {\r\n                    this.completeTransitions_();\r\n                }\r\n            }, this._errorHandler);\r\n        });\r\n    }\r\n    _increaseMultiplier() {\r\n        const currentSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;\r\n        // Max chunk size is 32M.\r\n        if (currentSize * 2 < 32 * 1024 * 1024) {\r\n            this._chunkMultiplier *= 2;\r\n        }\r\n    }\r\n    _fetchMetadata() {\r\n        this._resolveToken((authToken, appCheckToken) => {\r\n            const requestInfo = getMetadata$2(this._ref.storage, this._ref._location, this._mappings);\r\n            const metadataRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\r\n            this._request = metadataRequest;\r\n            metadataRequest.getPromise().then(metadata => {\r\n                this._request = undefined;\r\n                this._metadata = metadata;\r\n                this._transition(\"success\" /* InternalTaskState.SUCCESS */);\r\n            }, this._metadataErrorHandler);\r\n        });\r\n    }\r\n    _oneShotUpload() {\r\n        this._resolveToken((authToken, appCheckToken) => {\r\n            const requestInfo = multipartUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);\r\n            const multipartRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\r\n            this._request = multipartRequest;\r\n            multipartRequest.getPromise().then(metadata => {\r\n                this._request = undefined;\r\n                this._metadata = metadata;\r\n                this._updateProgress(this._blob.size());\r\n                this._transition(\"success\" /* InternalTaskState.SUCCESS */);\r\n            }, this._errorHandler);\r\n        });\r\n    }\r\n    _updateProgress(transferred) {\r\n        const old = this._transferred;\r\n        this._transferred = transferred;\r\n        // A progress update can make the \"transferred\" value smaller (e.g. a\r\n        // partial upload not completed by server, after which the \"transferred\"\r\n        // value may reset to the value at the beginning of the request).\r\n        if (this._transferred !== old) {\r\n            this._notifyObservers();\r\n        }\r\n    }\r\n    _transition(state) {\r\n        if (this._state === state) {\r\n            return;\r\n        }\r\n        switch (state) {\r\n            case \"canceling\" /* InternalTaskState.CANCELING */:\r\n            case \"pausing\" /* InternalTaskState.PAUSING */:\r\n                // TODO(andysoto):\r\n                // assert(this.state_ === InternalTaskState.RUNNING ||\r\n                //        this.state_ === InternalTaskState.PAUSING);\r\n                this._state = state;\r\n                if (this._request !== undefined) {\r\n                    this._request.cancel();\r\n                }\r\n                else if (this.pendingTimeout) {\r\n                    clearTimeout(this.pendingTimeout);\r\n                    this.pendingTimeout = undefined;\r\n                    this.completeTransitions_();\r\n                }\r\n                break;\r\n            case \"running\" /* InternalTaskState.RUNNING */:\r\n                // TODO(andysoto):\r\n                // assert(this.state_ === InternalTaskState.PAUSED ||\r\n                //        this.state_ === InternalTaskState.PAUSING);\r\n                const wasPaused = this._state === \"paused\" /* InternalTaskState.PAUSED */;\r\n                this._state = state;\r\n                if (wasPaused) {\r\n                    this._notifyObservers();\r\n                    this._start();\r\n                }\r\n                break;\r\n            case \"paused\" /* InternalTaskState.PAUSED */:\r\n                // TODO(andysoto):\r\n                // assert(this.state_ === InternalTaskState.PAUSING);\r\n                this._state = state;\r\n                this._notifyObservers();\r\n                break;\r\n            case \"canceled\" /* InternalTaskState.CANCELED */:\r\n                // TODO(andysoto):\r\n                // assert(this.state_ === InternalTaskState.PAUSED ||\r\n                //        this.state_ === InternalTaskState.CANCELING);\r\n                this._error = canceled();\r\n                this._state = state;\r\n                this._notifyObservers();\r\n                break;\r\n            case \"error\" /* InternalTaskState.ERROR */:\r\n                // TODO(andysoto):\r\n                // assert(this.state_ === InternalTaskState.RUNNING ||\r\n                //        this.state_ === InternalTaskState.PAUSING ||\r\n                //        this.state_ === InternalTaskState.CANCELING);\r\n                this._state = state;\r\n                this._notifyObservers();\r\n                break;\r\n            case \"success\" /* InternalTaskState.SUCCESS */:\r\n                // TODO(andysoto):\r\n                // assert(this.state_ === InternalTaskState.RUNNING ||\r\n                //        this.state_ === InternalTaskState.PAUSING ||\r\n                //        this.state_ === InternalTaskState.CANCELING);\r\n                this._state = state;\r\n                this._notifyObservers();\r\n                break;\r\n        }\r\n    }\r\n    completeTransitions_() {\r\n        switch (this._state) {\r\n            case \"pausing\" /* InternalTaskState.PAUSING */:\r\n                this._transition(\"paused\" /* InternalTaskState.PAUSED */);\r\n                break;\r\n            case \"canceling\" /* InternalTaskState.CANCELING */:\r\n                this._transition(\"canceled\" /* InternalTaskState.CANCELED */);\r\n                break;\r\n            case \"running\" /* InternalTaskState.RUNNING */:\r\n                this._start();\r\n                break;\r\n        }\r\n    }\r\n    /**\r\n     * A snapshot of the current task state.\r\n     */\r\n    get snapshot() {\r\n        const externalState = taskStateFromInternalTaskState(this._state);\r\n        return {\r\n            bytesTransferred: this._transferred,\r\n            totalBytes: this._blob.size(),\r\n            state: externalState,\r\n            metadata: this._metadata,\r\n            task: this,\r\n            ref: this._ref\r\n        };\r\n    }\r\n    /**\r\n     * Adds a callback for an event.\r\n     * @param type - The type of event to listen for.\r\n     * @param nextOrObserver -\r\n     *     The `next` function, which gets called for each item in\r\n     *     the event stream, or an observer object with some or all of these three\r\n     *     properties (`next`, `error`, `complete`).\r\n     * @param error - A function that gets called with a `StorageError`\r\n     *     if the event stream ends due to an error.\r\n     * @param completed - A function that gets called if the\r\n     *     event stream ends normally.\r\n     * @returns\r\n     *     If only the event argument is passed, returns a function you can use to\r\n     *     add callbacks (see the examples above). If more than just the event\r\n     *     argument is passed, returns a function you can call to unregister the\r\n     *     callbacks.\r\n     */\r\n    on(type, nextOrObserver, error, completed) {\r\n        // Note: `type` isn't being used. Its type is also incorrect. TaskEvent should not be a string.\r\n        const observer = new Observer(nextOrObserver || undefined, error || undefined, completed || undefined);\r\n        this._addObserver(observer);\r\n        return () => {\r\n            this._removeObserver(observer);\r\n        };\r\n    }\r\n    /**\r\n     * This object behaves like a Promise, and resolves with its snapshot data\r\n     * when the upload completes.\r\n     * @param onFulfilled - The fulfillment callback. Promise chaining works as normal.\r\n     * @param onRejected - The rejection callback.\r\n     */\r\n    then(onFulfilled, onRejected) {\r\n        // These casts are needed so that TypeScript can infer the types of the\r\n        // resulting Promise.\r\n        return this._promise.then(onFulfilled, onRejected);\r\n    }\r\n    /**\r\n     * Equivalent to calling `then(null, onRejected)`.\r\n     */\r\n    catch(onRejected) {\r\n        return this.then(null, onRejected);\r\n    }\r\n    /**\r\n     * Adds the given observer.\r\n     */\r\n    _addObserver(observer) {\r\n        this._observers.push(observer);\r\n        this._notifyObserver(observer);\r\n    }\r\n    /**\r\n     * Removes the given observer.\r\n     */\r\n    _removeObserver(observer) {\r\n        const i = this._observers.indexOf(observer);\r\n        if (i !== -1) {\r\n            this._observers.splice(i, 1);\r\n        }\r\n    }\r\n    _notifyObservers() {\r\n        this._finishPromise();\r\n        const observers = this._observers.slice();\r\n        observers.forEach(observer => {\r\n            this._notifyObserver(observer);\r\n        });\r\n    }\r\n    _finishPromise() {\r\n        if (this._resolve !== undefined) {\r\n            let triggered = true;\r\n            switch (taskStateFromInternalTaskState(this._state)) {\r\n                case TaskState.SUCCESS:\r\n                    async(this._resolve.bind(null, this.snapshot))();\r\n                    break;\r\n                case TaskState.CANCELED:\r\n                case TaskState.ERROR:\r\n                    const toCall = this._reject;\r\n                    async(toCall.bind(null, this._error))();\r\n                    break;\r\n                default:\r\n                    triggered = false;\r\n                    break;\r\n            }\r\n            if (triggered) {\r\n                this._resolve = undefined;\r\n                this._reject = undefined;\r\n            }\r\n        }\r\n    }\r\n    _notifyObserver(observer) {\r\n        const externalState = taskStateFromInternalTaskState(this._state);\r\n        switch (externalState) {\r\n            case TaskState.RUNNING:\r\n            case TaskState.PAUSED:\r\n                if (observer.next) {\r\n                    async(observer.next.bind(observer, this.snapshot))();\r\n                }\r\n                break;\r\n            case TaskState.SUCCESS:\r\n                if (observer.complete) {\r\n                    async(observer.complete.bind(observer))();\r\n                }\r\n                break;\r\n            case TaskState.CANCELED:\r\n            case TaskState.ERROR:\r\n                if (observer.error) {\r\n                    async(observer.error.bind(observer, this._error))();\r\n                }\r\n                break;\r\n            default:\r\n                // TODO(andysoto): assert(false);\r\n                if (observer.error) {\r\n                    async(observer.error.bind(observer, this._error))();\r\n                }\r\n        }\r\n    }\r\n    /**\r\n     * Resumes a paused task. Has no effect on a currently running or failed task.\r\n     * @returns True if the operation took effect, false if ignored.\r\n     */\r\n    resume() {\r\n        const valid = this._state === \"paused\" /* InternalTaskState.PAUSED */ ||\r\n            this._state === \"pausing\" /* InternalTaskState.PAUSING */;\r\n        if (valid) {\r\n            this._transition(\"running\" /* InternalTaskState.RUNNING */);\r\n        }\r\n        return valid;\r\n    }\r\n    /**\r\n     * Pauses a currently running task. Has no effect on a paused or failed task.\r\n     * @returns True if the operation took effect, false if ignored.\r\n     */\r\n    pause() {\r\n        const valid = this._state === \"running\" /* InternalTaskState.RUNNING */;\r\n        if (valid) {\r\n            this._transition(\"pausing\" /* InternalTaskState.PAUSING */);\r\n        }\r\n        return valid;\r\n    }\r\n    /**\r\n     * Cancels a currently running or paused task. Has no effect on a complete or\r\n     * failed task.\r\n     * @returns True if the operation took effect, false if ignored.\r\n     */\r\n    cancel() {\r\n        const valid = this._state === \"running\" /* InternalTaskState.RUNNING */ ||\r\n            this._state === \"pausing\" /* InternalTaskState.PAUSING */;\r\n        if (valid) {\r\n            this._transition(\"canceling\" /* InternalTaskState.CANCELING */);\r\n        }\r\n        return valid;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provides methods to interact with a bucket in the Firebase Storage service.\r\n * @internal\r\n * @param _location - An fbs.location, or the URL at\r\n *     which to base this object, in one of the following forms:\r\n *         gs://<bucket>/<object-path>\r\n *         http[s]://firebasestorage.googleapis.com/\r\n *                     <api-version>/b/<bucket>/o/<object-path>\r\n *     Any query or fragment strings will be ignored in the http[s]\r\n *     format. If no value is passed, the storage object will use a URL based on\r\n *     the project ID of the base firebase.App instance.\r\n */\r\nclass Reference {\r\n    constructor(_service, location) {\r\n        this._service = _service;\r\n        if (location instanceof Location) {\r\n            this._location = location;\r\n        }\r\n        else {\r\n            this._location = Location.makeFromUrl(location, _service.host);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the URL for the bucket and path this object references,\r\n     *     in the form gs://<bucket>/<object-path>\r\n     * @override\r\n     */\r\n    toString() {\r\n        return 'gs://' + this._location.bucket + '/' + this._location.path;\r\n    }\r\n    _newRef(service, location) {\r\n        return new Reference(service, location);\r\n    }\r\n    /**\r\n     * A reference to the root of this object's bucket.\r\n     */\r\n    get root() {\r\n        const location = new Location(this._location.bucket, '');\r\n        return this._newRef(this._service, location);\r\n    }\r\n    /**\r\n     * The name of the bucket containing this reference's object.\r\n     */\r\n    get bucket() {\r\n        return this._location.bucket;\r\n    }\r\n    /**\r\n     * The full path of this object.\r\n     */\r\n    get fullPath() {\r\n        return this._location.path;\r\n    }\r\n    /**\r\n     * The short name of this object, which is the last component of the full path.\r\n     * For example, if fullPath is 'full/path/image.png', name is 'image.png'.\r\n     */\r\n    get name() {\r\n        return lastComponent(this._location.path);\r\n    }\r\n    /**\r\n     * The `StorageService` instance this `StorageReference` is associated with.\r\n     */\r\n    get storage() {\r\n        return this._service;\r\n    }\r\n    /**\r\n     * A `StorageReference` pointing to the parent location of this `StorageReference`, or null if\r\n     * this reference is the root.\r\n     */\r\n    get parent() {\r\n        const newPath = parent(this._location.path);\r\n        if (newPath === null) {\r\n            return null;\r\n        }\r\n        const location = new Location(this._location.bucket, newPath);\r\n        return new Reference(this._service, location);\r\n    }\r\n    /**\r\n     * Utility function to throw an error in methods that do not accept a root reference.\r\n     */\r\n    _throwIfRoot(name) {\r\n        if (this._location.path === '') {\r\n            throw invalidRootOperation(name);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Download the bytes at the object's location.\r\n * @returns A Promise containing the downloaded bytes.\r\n */\r\nfunction getBytesInternal(ref, maxDownloadSizeBytes) {\r\n    ref._throwIfRoot('getBytes');\r\n    const requestInfo = getBytes$1(ref.storage, ref._location, maxDownloadSizeBytes);\r\n    return ref.storage\r\n        .makeRequestWithTokens(requestInfo, newBytesConnection)\r\n        .then(bytes => maxDownloadSizeBytes !== undefined\r\n        ? // GCS may not honor the Range header for small files\r\n            bytes.slice(0, maxDownloadSizeBytes)\r\n        : bytes);\r\n}\r\n/** Stream the bytes at the object's location. */\r\nfunction getStreamInternal(ref, maxDownloadSizeBytes) {\r\n    ref._throwIfRoot('getStream');\r\n    const requestInfo = getBytes$1(ref.storage, ref._location, maxDownloadSizeBytes);\r\n    /** A transformer that passes through the first n bytes. */\r\n    const newMaxSizeTransform = n => {\r\n        let missingBytes = n;\r\n        return {\r\n            transform(chunk, encoding, callback) {\r\n                // GCS may not honor the Range header for small files\r\n                if (chunk.length < missingBytes) {\r\n                    this.push(chunk);\r\n                    missingBytes -= chunk.length;\r\n                }\r\n                else {\r\n                    this.push(chunk.slice(0, missingBytes));\r\n                    this.emit('end');\r\n                }\r\n                callback();\r\n            }\r\n        };\r\n    };\r\n    const result = maxDownloadSizeBytes !== undefined\r\n        ? new stream__WEBPACK_IMPORTED_MODULE_2__.Transform(newMaxSizeTransform(maxDownloadSizeBytes))\r\n        : new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();\r\n    ref.storage\r\n        .makeRequestWithTokens(requestInfo, newStreamConnection)\r\n        .then(stream => stream.pipe(result))\r\n        .catch(e => result.destroy(e));\r\n    return result;\r\n}\r\n/**\r\n * Uploads data to this object's location.\r\n * The upload is not resumable.\r\n *\r\n * @param ref - StorageReference where data should be uploaded.\r\n * @param data - The data to upload.\r\n * @param metadata - Metadata for the newly uploaded data.\r\n * @returns A Promise containing an UploadResult\r\n */\r\nfunction uploadBytes$1(ref, data, metadata) {\r\n    ref._throwIfRoot('uploadBytes');\r\n    const requestInfo = multipartUpload(ref.storage, ref._location, getMappings(), new FbsBlob(data, true), metadata);\r\n    return ref.storage\r\n        .makeRequestWithTokens(requestInfo, newTextConnection)\r\n        .then(finalMetadata => {\r\n        return {\r\n            metadata: finalMetadata,\r\n            ref\r\n        };\r\n    });\r\n}\r\n/**\r\n * Uploads data to this object's location.\r\n * The upload can be paused and resumed, and exposes progress updates.\r\n * @public\r\n * @param ref - StorageReference where data should be uploaded.\r\n * @param data - The data to upload.\r\n * @param metadata - Metadata for the newly uploaded data.\r\n * @returns An UploadTask\r\n */\r\nfunction uploadBytesResumable$1(ref, data, metadata) {\r\n    ref._throwIfRoot('uploadBytesResumable');\r\n    return new UploadTask(ref, new FbsBlob(data), metadata);\r\n}\r\n/**\r\n * Uploads a string to this object's location.\r\n * The upload is not resumable.\r\n * @public\r\n * @param ref - StorageReference where string should be uploaded.\r\n * @param value - The string to upload.\r\n * @param format - The format of the string to upload.\r\n * @param metadata - Metadata for the newly uploaded string.\r\n * @returns A Promise containing an UploadResult\r\n */\r\nfunction uploadString$1(ref, value, format = StringFormat.RAW, metadata) {\r\n    ref._throwIfRoot('uploadString');\r\n    const data = dataFromString(format, value);\r\n    const metadataClone = Object.assign({}, metadata);\r\n    if (metadataClone['contentType'] == null && data.contentType != null) {\r\n        metadataClone['contentType'] = data.contentType;\r\n    }\r\n    return uploadBytes$1(ref, data.data, metadataClone);\r\n}\r\n/**\r\n * List all items (files) and prefixes (folders) under this storage reference.\r\n *\r\n * This is a helper method for calling list() repeatedly until there are\r\n * no more results. The default pagination size is 1000.\r\n *\r\n * Note: The results may not be consistent if objects are changed while this\r\n * operation is running.\r\n *\r\n * Warning: listAll may potentially consume too many resources if there are\r\n * too many results.\r\n * @public\r\n * @param ref - StorageReference to get list from.\r\n *\r\n * @returns A Promise that resolves with all the items and prefixes under\r\n *      the current storage reference. `prefixes` contains references to\r\n *      sub-directories and `items` contains references to objects in this\r\n *      folder. `nextPageToken` is never returned.\r\n */\r\nfunction listAll$1(ref) {\r\n    const accumulator = {\r\n        prefixes: [],\r\n        items: []\r\n    };\r\n    return listAllHelper(ref, accumulator).then(() => accumulator);\r\n}\r\n/**\r\n * Separated from listAll because async functions can't use \"arguments\".\r\n * @param ref\r\n * @param accumulator\r\n * @param pageToken\r\n */\r\nasync function listAllHelper(ref, accumulator, pageToken) {\r\n    const opt = {\r\n        // maxResults is 1000 by default.\r\n        pageToken\r\n    };\r\n    const nextPage = await list$1(ref, opt);\r\n    accumulator.prefixes.push(...nextPage.prefixes);\r\n    accumulator.items.push(...nextPage.items);\r\n    if (nextPage.nextPageToken != null) {\r\n        await listAllHelper(ref, accumulator, nextPage.nextPageToken);\r\n    }\r\n}\r\n/**\r\n * List items (files) and prefixes (folders) under this storage reference.\r\n *\r\n * List API is only available for Firebase Rules Version 2.\r\n *\r\n * GCS is a key-blob store. Firebase Storage imposes the semantic of '/'\r\n * delimited folder structure.\r\n * Refer to GCS's List API if you want to learn more.\r\n *\r\n * To adhere to Firebase Rules's Semantics, Firebase Storage does not\r\n * support objects whose paths end with \"/\" or contain two consecutive\r\n * \"/\"s. Firebase Storage List API will filter these unsupported objects.\r\n * list() may fail if there are too many unsupported objects in the bucket.\r\n * @public\r\n *\r\n * @param ref - StorageReference to get list from.\r\n * @param options - See ListOptions for details.\r\n * @returns A Promise that resolves with the items and prefixes.\r\n *      `prefixes` contains references to sub-folders and `items`\r\n *      contains references to objects in this folder. `nextPageToken`\r\n *      can be used to get the rest of the results.\r\n */\r\nfunction list$1(ref, options) {\r\n    if (options != null) {\r\n        if (typeof options.maxResults === 'number') {\r\n            validateNumber('options.maxResults', \r\n            /* minValue= */ 1, \r\n            /* maxValue= */ 1000, options.maxResults);\r\n        }\r\n    }\r\n    const op = options || {};\r\n    const requestInfo = list$2(ref.storage, ref._location, \r\n    /*delimiter= */ '/', op.pageToken, op.maxResults);\r\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\r\n}\r\n/**\r\n * A `Promise` that resolves with the metadata for this object. If this\r\n * object doesn't exist or metadata cannot be retreived, the promise is\r\n * rejected.\r\n * @public\r\n * @param ref - StorageReference to get metadata from.\r\n */\r\nfunction getMetadata$1(ref) {\r\n    ref._throwIfRoot('getMetadata');\r\n    const requestInfo = getMetadata$2(ref.storage, ref._location, getMappings());\r\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\r\n}\r\n/**\r\n * Updates the metadata for this object.\r\n * @public\r\n * @param ref - StorageReference to update metadata for.\r\n * @param metadata - The new metadata for the object.\r\n *     Only values that have been explicitly set will be changed. Explicitly\r\n *     setting a value to null will remove the metadata.\r\n * @returns A `Promise` that resolves\r\n *     with the new metadata for this object.\r\n *     See `firebaseStorage.Reference.prototype.getMetadata`\r\n */\r\nfunction updateMetadata$1(ref, metadata) {\r\n    ref._throwIfRoot('updateMetadata');\r\n    const requestInfo = updateMetadata$2(ref.storage, ref._location, metadata, getMappings());\r\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\r\n}\r\n/**\r\n * Returns the download URL for the given Reference.\r\n * @public\r\n * @returns A `Promise` that resolves with the download\r\n *     URL for this object.\r\n */\r\nfunction getDownloadURL$1(ref) {\r\n    ref._throwIfRoot('getDownloadURL');\r\n    const requestInfo = getDownloadUrl(ref.storage, ref._location, getMappings());\r\n    return ref.storage\r\n        .makeRequestWithTokens(requestInfo, newTextConnection)\r\n        .then(url => {\r\n        if (url === null) {\r\n            throw noDownloadURL();\r\n        }\r\n        return url;\r\n    });\r\n}\r\n/**\r\n * Deletes the object at this location.\r\n * @public\r\n * @param ref - StorageReference for object to delete.\r\n * @returns A `Promise` that resolves if the deletion succeeds.\r\n */\r\nfunction deleteObject$1(ref) {\r\n    ref._throwIfRoot('deleteObject');\r\n    const requestInfo = deleteObject$2(ref.storage, ref._location);\r\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\r\n}\r\n/**\r\n * Returns reference for object obtained by appending `childPath` to `ref`.\r\n *\r\n * @param ref - StorageReference to get child of.\r\n * @param childPath - Child path from provided ref.\r\n * @returns A reference to the object obtained by\r\n * appending childPath, removing any duplicate, beginning, or trailing\r\n * slashes.\r\n *\r\n */\r\nfunction _getChild$1(ref, childPath) {\r\n    const newPath = child(ref._location.path, childPath);\r\n    const location = new Location(ref._location.bucket, newPath);\r\n    return new Reference(ref.storage, location);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction isUrl(path) {\r\n    return /^[A-Za-z]+:\\/\\//.test(path);\r\n}\r\n/**\r\n * Returns a firebaseStorage.Reference for the given url.\r\n */\r\nfunction refFromURL(service, url) {\r\n    return new Reference(service, url);\r\n}\r\n/**\r\n * Returns a firebaseStorage.Reference for the given path in the default\r\n * bucket.\r\n */\r\nfunction refFromPath(ref, path) {\r\n    if (ref instanceof FirebaseStorageImpl) {\r\n        const service = ref;\r\n        if (service._bucket == null) {\r\n            throw noDefaultBucket();\r\n        }\r\n        const reference = new Reference(service, service._bucket);\r\n        if (path != null) {\r\n            return refFromPath(reference, path);\r\n        }\r\n        else {\r\n            return reference;\r\n        }\r\n    }\r\n    else {\r\n        // ref is a Reference\r\n        if (path !== undefined) {\r\n            return _getChild$1(ref, path);\r\n        }\r\n        else {\r\n            return ref;\r\n        }\r\n    }\r\n}\r\nfunction ref$1(serviceOrRef, pathOrUrl) {\r\n    if (pathOrUrl && isUrl(pathOrUrl)) {\r\n        if (serviceOrRef instanceof FirebaseStorageImpl) {\r\n            return refFromURL(serviceOrRef, pathOrUrl);\r\n        }\r\n        else {\r\n            throw invalidArgument('To use ref(service, url), the first argument must be a Storage instance.');\r\n        }\r\n    }\r\n    else {\r\n        return refFromPath(serviceOrRef, pathOrUrl);\r\n    }\r\n}\r\nfunction extractBucket(host, config) {\r\n    const bucketString = config === null || config === void 0 ? void 0 : config[CONFIG_STORAGE_BUCKET_KEY];\r\n    if (bucketString == null) {\r\n        return null;\r\n    }\r\n    return Location.makeFromBucketSpec(bucketString, host);\r\n}\r\nfunction connectStorageEmulator$1(storage, host, port, options = {}) {\r\n    storage.host = `${host}:${port}`;\r\n    storage._protocol = 'http';\r\n    const { mockUserToken } = options;\r\n    if (mockUserToken) {\r\n        storage._overrideAuthToken =\r\n            typeof mockUserToken === 'string'\r\n                ? mockUserToken\r\n                : (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createMockUserToken)(mockUserToken, storage.app.options.projectId);\r\n    }\r\n}\r\n/**\r\n * A service that provides Firebase Storage Reference instances.\r\n * @param opt_url - gs:// url to a custom Storage Bucket\r\n *\r\n * @internal\r\n */\r\nclass FirebaseStorageImpl {\r\n    constructor(\r\n    /**\r\n     * FirebaseApp associated with this StorageService instance.\r\n     */\r\n    app, _authProvider, \r\n    /**\r\n     * @internal\r\n     */\r\n    _appCheckProvider, \r\n    /**\r\n     * @internal\r\n     */\r\n    _url, _firebaseVersion) {\r\n        this.app = app;\r\n        this._authProvider = _authProvider;\r\n        this._appCheckProvider = _appCheckProvider;\r\n        this._url = _url;\r\n        this._firebaseVersion = _firebaseVersion;\r\n        this._bucket = null;\r\n        /**\r\n         * This string can be in the formats:\r\n         * - host\r\n         * - host:port\r\n         */\r\n        this._host = DEFAULT_HOST;\r\n        this._protocol = 'https';\r\n        this._appId = null;\r\n        this._deleted = false;\r\n        this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;\r\n        this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;\r\n        this._requests = new Set();\r\n        if (_url != null) {\r\n            this._bucket = Location.makeFromBucketSpec(_url, this._host);\r\n        }\r\n        else {\r\n            this._bucket = extractBucket(this._host, this.app.options);\r\n        }\r\n    }\r\n    /**\r\n     * The host string for this service, in the form of `host` or\r\n     * `host:port`.\r\n     */\r\n    get host() {\r\n        return this._host;\r\n    }\r\n    set host(host) {\r\n        this._host = host;\r\n        if (this._url != null) {\r\n            this._bucket = Location.makeFromBucketSpec(this._url, host);\r\n        }\r\n        else {\r\n            this._bucket = extractBucket(host, this.app.options);\r\n        }\r\n    }\r\n    /**\r\n     * The maximum time to retry uploads in milliseconds.\r\n     */\r\n    get maxUploadRetryTime() {\r\n        return this._maxUploadRetryTime;\r\n    }\r\n    set maxUploadRetryTime(time) {\r\n        validateNumber('time', \r\n        /* minValue=*/ 0, \r\n        /* maxValue= */ Number.POSITIVE_INFINITY, time);\r\n        this._maxUploadRetryTime = time;\r\n    }\r\n    /**\r\n     * The maximum time to retry operations other than uploads or downloads in\r\n     * milliseconds.\r\n     */\r\n    get maxOperationRetryTime() {\r\n        return this._maxOperationRetryTime;\r\n    }\r\n    set maxOperationRetryTime(time) {\r\n        validateNumber('time', \r\n        /* minValue=*/ 0, \r\n        /* maxValue= */ Number.POSITIVE_INFINITY, time);\r\n        this._maxOperationRetryTime = time;\r\n    }\r\n    async _getAuthToken() {\r\n        if (this._overrideAuthToken) {\r\n            return this._overrideAuthToken;\r\n        }\r\n        const auth = this._authProvider.getImmediate({ optional: true });\r\n        if (auth) {\r\n            const tokenData = await auth.getToken();\r\n            if (tokenData !== null) {\r\n                return tokenData.accessToken;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    async _getAppCheckToken() {\r\n        const appCheck = this._appCheckProvider.getImmediate({ optional: true });\r\n        if (appCheck) {\r\n            const result = await appCheck.getToken();\r\n            // TODO: What do we want to do if there is an error getting the token?\r\n            // Context: appCheck.getToken() will never throw even if an error happened. In the error case, a dummy token will be\r\n            // returned along with an error field describing the error. In general, we shouldn't care about the error condition and just use\r\n            // the token (actual or dummy) to send requests.\r\n            return result.token;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Stop running requests and prevent more from being created.\r\n     */\r\n    _delete() {\r\n        if (!this._deleted) {\r\n            this._deleted = true;\r\n            this._requests.forEach(request => request.cancel());\r\n            this._requests.clear();\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    /**\r\n     * Returns a new firebaseStorage.Reference object referencing this StorageService\r\n     * at the given Location.\r\n     */\r\n    _makeStorageReference(loc) {\r\n        return new Reference(this, loc);\r\n    }\r\n    /**\r\n     * @param requestInfo - HTTP RequestInfo object\r\n     * @param authToken - Firebase auth token\r\n     */\r\n    _makeRequest(requestInfo, requestFactory, authToken, appCheckToken, retry = true) {\r\n        if (!this._deleted) {\r\n            const request = makeRequest(requestInfo, this._appId, authToken, appCheckToken, requestFactory, this._firebaseVersion, retry);\r\n            this._requests.add(request);\r\n            // Request removes itself from set when complete.\r\n            request.getPromise().then(() => this._requests.delete(request), () => this._requests.delete(request));\r\n            return request;\r\n        }\r\n        else {\r\n            return new FailRequest(appDeleted());\r\n        }\r\n    }\r\n    async makeRequestWithTokens(requestInfo, requestFactory) {\r\n        const [authToken, appCheckToken] = await Promise.all([\r\n            this._getAuthToken(),\r\n            this._getAppCheckToken()\r\n        ]);\r\n        return this._makeRequest(requestInfo, requestFactory, authToken, appCheckToken).getPromise();\r\n    }\r\n}\n\nconst name = \"@firebase/storage\";\nconst version = \"0.12.4\";\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Type constant for Firebase Storage.\r\n */\r\nconst STORAGE_TYPE = 'storage';\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Downloads the data at the object's location. Returns an error if the object\r\n * is not found.\r\n *\r\n * To use this functionality, you have to whitelist your app's origin in your\r\n * Cloud Storage bucket. See also\r\n * https://cloud.google.com/storage/docs/configuring-cors\r\n *\r\n * @public\r\n * @param ref - StorageReference where data should be downloaded.\r\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\r\n * retrieve.\r\n * @returns A Promise containing the object's bytes\r\n */\r\nfunction getBytes(ref, maxDownloadSizeBytes) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\r\n    return getBytesInternal(ref, maxDownloadSizeBytes);\r\n}\r\n/**\r\n * Uploads data to this object's location.\r\n * The upload is not resumable.\r\n * @public\r\n * @param ref - {@link StorageReference} where data should be uploaded.\r\n * @param data - The data to upload.\r\n * @param metadata - Metadata for the data to upload.\r\n * @returns A Promise containing an UploadResult\r\n */\r\nfunction uploadBytes(ref, data, metadata) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\r\n    return uploadBytes$1(ref, data, metadata);\r\n}\r\n/**\r\n * Uploads a string to this object's location.\r\n * The upload is not resumable.\r\n * @public\r\n * @param ref - {@link StorageReference} where string should be uploaded.\r\n * @param value - The string to upload.\r\n * @param format - The format of the string to upload.\r\n * @param metadata - Metadata for the string to upload.\r\n * @returns A Promise containing an UploadResult\r\n */\r\nfunction uploadString(ref, value, format, metadata) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\r\n    return uploadString$1(ref, value, format, metadata);\r\n}\r\n/**\r\n * Uploads data to this object's location.\r\n * The upload can be paused and resumed, and exposes progress updates.\r\n * @public\r\n * @param ref - {@link StorageReference} where data should be uploaded.\r\n * @param data - The data to upload.\r\n * @param metadata - Metadata for the data to upload.\r\n * @returns An UploadTask\r\n */\r\nfunction uploadBytesResumable(ref, data, metadata) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\r\n    return uploadBytesResumable$1(ref, data, metadata);\r\n}\r\n/**\r\n * A `Promise` that resolves with the metadata for this object. If this\r\n * object doesn't exist or metadata cannot be retreived, the promise is\r\n * rejected.\r\n * @public\r\n * @param ref - {@link StorageReference} to get metadata from.\r\n */\r\nfunction getMetadata(ref) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\r\n    return getMetadata$1(ref);\r\n}\r\n/**\r\n * Updates the metadata for this object.\r\n * @public\r\n * @param ref - {@link StorageReference} to update metadata for.\r\n * @param metadata - The new metadata for the object.\r\n *     Only values that have been explicitly set will be changed. Explicitly\r\n *     setting a value to null will remove the metadata.\r\n * @returns A `Promise` that resolves with the new metadata for this object.\r\n */\r\nfunction updateMetadata(ref, metadata) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\r\n    return updateMetadata$1(ref, metadata);\r\n}\r\n/**\r\n * List items (files) and prefixes (folders) under this storage reference.\r\n *\r\n * List API is only available for Firebase Rules Version 2.\r\n *\r\n * GCS is a key-blob store. Firebase Storage imposes the semantic of '/'\r\n * delimited folder structure.\r\n * Refer to GCS's List API if you want to learn more.\r\n *\r\n * To adhere to Firebase Rules's Semantics, Firebase Storage does not\r\n * support objects whose paths end with \"/\" or contain two consecutive\r\n * \"/\"s. Firebase Storage List API will filter these unsupported objects.\r\n * list() may fail if there are too many unsupported objects in the bucket.\r\n * @public\r\n *\r\n * @param ref - {@link StorageReference} to get list from.\r\n * @param options - See {@link ListOptions} for details.\r\n * @returns A `Promise` that resolves with the items and prefixes.\r\n *      `prefixes` contains references to sub-folders and `items`\r\n *      contains references to objects in this folder. `nextPageToken`\r\n *      can be used to get the rest of the results.\r\n */\r\nfunction list(ref, options) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\r\n    return list$1(ref, options);\r\n}\r\n/**\r\n * List all items (files) and prefixes (folders) under this storage reference.\r\n *\r\n * This is a helper method for calling list() repeatedly until there are\r\n * no more results. The default pagination size is 1000.\r\n *\r\n * Note: The results may not be consistent if objects are changed while this\r\n * operation is running.\r\n *\r\n * Warning: `listAll` may potentially consume too many resources if there are\r\n * too many results.\r\n * @public\r\n * @param ref - {@link StorageReference} to get list from.\r\n *\r\n * @returns A `Promise` that resolves with all the items and prefixes under\r\n *      the current storage reference. `prefixes` contains references to\r\n *      sub-directories and `items` contains references to objects in this\r\n *      folder. `nextPageToken` is never returned.\r\n */\r\nfunction listAll(ref) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\r\n    return listAll$1(ref);\r\n}\r\n/**\r\n * Returns the download URL for the given {@link StorageReference}.\r\n * @public\r\n * @param ref - {@link StorageReference} to get the download URL for.\r\n * @returns A `Promise` that resolves with the download\r\n *     URL for this object.\r\n */\r\nfunction getDownloadURL(ref) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\r\n    return getDownloadURL$1(ref);\r\n}\r\n/**\r\n * Deletes the object at this location.\r\n * @public\r\n * @param ref - {@link StorageReference} for object to delete.\r\n * @returns A `Promise` that resolves if the deletion succeeds.\r\n */\r\nfunction deleteObject(ref) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\r\n    return deleteObject$1(ref);\r\n}\r\nfunction ref(serviceOrRef, pathOrUrl) {\r\n    serviceOrRef = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(serviceOrRef);\r\n    return ref$1(serviceOrRef, pathOrUrl);\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction _getChild(ref, childPath) {\r\n    return _getChild$1(ref, childPath);\r\n}\r\n/**\r\n * Gets a {@link FirebaseStorage} instance for the given Firebase app.\r\n * @public\r\n * @param app - Firebase app to get {@link FirebaseStorage} instance for.\r\n * @param bucketUrl - The gs:// url to your Firebase Storage Bucket.\r\n * If not passed, uses the app's default Storage Bucket.\r\n * @returns A {@link FirebaseStorage} instance.\r\n */\r\nfunction getStorage(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)(), bucketUrl) {\r\n    app = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(app);\r\n    const storageProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, STORAGE_TYPE);\r\n    const storageInstance = storageProvider.getImmediate({\r\n        identifier: bucketUrl\r\n    });\r\n    const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHostnameAndPort)('storage');\r\n    if (emulator) {\r\n        connectStorageEmulator(storageInstance, ...emulator);\r\n    }\r\n    return storageInstance;\r\n}\r\n/**\r\n * Modify this {@link FirebaseStorage} instance to communicate with the Cloud Storage emulator.\r\n *\r\n * @param storage - The {@link FirebaseStorage} instance\r\n * @param host - The emulator host (ex: localhost)\r\n * @param port - The emulator port (ex: 5001)\r\n * @param options - Emulator options. `options.mockUserToken` is the mock auth\r\n * token to use for unit testing Security Rules.\r\n * @public\r\n */\r\nfunction connectStorageEmulator(storage, host, port, options = {}) {\r\n    connectStorageEmulator$1(storage, host, port, options);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Downloads the data at the object's location. Returns an error if the object\r\n * is not found.\r\n *\r\n * To use this functionality, you have to whitelist your app's origin in your\r\n * Cloud Storage bucket. See also\r\n * https://cloud.google.com/storage/docs/configuring-cors\r\n *\r\n * This API is not available in Node.\r\n *\r\n * @public\r\n * @param ref - StorageReference where data should be downloaded.\r\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\r\n * retrieve.\r\n * @returns A Promise that resolves with a Blob containing the object's bytes\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nfunction getBlob(ref, maxDownloadSizeBytes) {\r\n    throw new Error('getBlob() is only available in Browser-like environments');\r\n}\r\n/**\r\n * Downloads the data at the object's location. Raises an error event if the\r\n * object is not found.\r\n *\r\n * This API is only available in Node.\r\n *\r\n * @public\r\n * @param ref - StorageReference where data should be downloaded.\r\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\r\n * retrieve.\r\n * @returns A stream with the object's data as bytes\r\n */\r\nfunction getStream(ref, maxDownloadSizeBytes) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\r\n    return getStreamInternal(ref, maxDownloadSizeBytes);\r\n}\n\n/**\r\n * Cloud Storage for Firebase\r\n *\r\n * @packageDocumentation\r\n */\r\nfunction factory(container, { instanceIdentifier: url }) {\r\n    const app = container.getProvider('app').getImmediate();\r\n    const authProvider = container.getProvider('auth-internal');\r\n    const appCheckProvider = container.getProvider('app-check-internal');\r\n    return new FirebaseStorageImpl(app, authProvider, appCheckProvider, url, _firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\r\n}\r\nfunction registerStorage() {\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Component(STORAGE_TYPE, factory, \"PUBLIC\" /* ComponentType.PUBLIC */).setMultipleInstances(true));\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version);\r\n}\r\nregisterStorage();\n\n\n//# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1RztBQUNvQjtBQUMzRTtBQUNqQjtBQUNpQjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5REFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTLEdBQUcsa0JBQWtCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCLElBQUksK0JBQStCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxvQkFBb0IsR0FBRyxRQUFRLEtBQUssYUFBYSxJQUFJLG9CQUFvQjtBQUN2SSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUJBQWlCLEdBQUcsYUFBYSxHQUFHLGlCQUFpQjtBQUNoSCxzQ0FBc0M7QUFDdEM7QUFDQSxjQUFjLDBEQUEwRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVMsY0FBYyxVQUFVO0FBQ3JGO0FBQ0E7QUFDQSxvREFBb0QsU0FBUyxjQUFjLFVBQVU7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0EsY0FBYyxTQUFTLEtBQUssT0FBTyxLQUFLLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1DQUFtQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUNBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZDQUFTO0FBQ3ZCLGNBQWMsK0NBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLHNCQUFzQixLQUFLLEdBQUcsS0FBSztBQUNuQztBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsZ0JBQWdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6Qyx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QjtBQUNsRTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0VBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0EscUNBQXFDLHVCQUF1QjtBQUM1RDtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQSwwQkFBMEIscURBQU07QUFDaEMsVUFBVSxrRUFBa0I7QUFDNUIsNEJBQTRCLDJEQUFZO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUJBQXFCLGlGQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5QkFBeUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHNEQUFXO0FBQ3hGO0FBQ0E7QUFDQSxJQUFJLGlFQUFrQixLQUFLLDBEQUFTO0FBQ3BDLElBQUksOERBQWU7QUFDbkI7QUFDQTs7QUFFcWY7QUFDcmYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFybnR1YmUtMS4wLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3Qvbm9kZS1lc20vaW5kZXgubm9kZS5lc20uanM/N2Q5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfZ2V0UHJvdmlkZXIsIGdldEFwcCwgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24sIFNES19WRVJTSU9OIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yLCBjcmVhdGVNb2NrVXNlclRva2VuLCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFRyYW5zZm9ybSwgUGFzc1Rocm91Z2ggfSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IHsgZmV0Y2ggfSBmcm9tICd1bmRpY2knO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnN0YW50cyB1c2VkIGluIHRoZSBGaXJlYmFzZSBTdG9yYWdlIGxpYnJhcnkuXHJcbiAqL1xyXG4vKipcclxuICogRG9tYWluIG5hbWUgZm9yIGZpcmViYXNlIHN0b3JhZ2UuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0hPU1QgPSAnZmlyZWJhc2VzdG9yYWdlLmdvb2dsZWFwaXMuY29tJztcclxuLyoqXHJcbiAqIFRoZSBrZXkgaW4gRmlyZWJhc2UgY29uZmlnIGpzb24gZm9yIHRoZSBzdG9yYWdlIGJ1Y2tldC5cclxuICovXHJcbmNvbnN0IENPTkZJR19TVE9SQUdFX0JVQ0tFVF9LRVkgPSAnc3RvcmFnZUJ1Y2tldCc7XHJcbi8qKlxyXG4gKiAyIG1pbnV0ZXNcclxuICpcclxuICogVGhlIHRpbWVvdXQgZm9yIGFsbCBvcGVyYXRpb25zIGV4Y2VwdCB1cGxvYWQuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX01BWF9PUEVSQVRJT05fUkVUUllfVElNRSA9IDIgKiA2MCAqIDEwMDA7XHJcbi8qKlxyXG4gKiAxMCBtaW51dGVzXHJcbiAqXHJcbiAqIFRoZSB0aW1lb3V0IGZvciB1cGxvYWQuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX01BWF9VUExPQURfUkVUUllfVElNRSA9IDEwICogNjAgKiAxMDAwO1xyXG4vKipcclxuICogMSBzZWNvbmRcclxuICovXHJcbmNvbnN0IERFRkFVTFRfTUlOX1NMRUVQX1RJTUVfTUlMTElTID0gMTAwMDtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGVycm9yIHJldHVybmVkIGJ5IHRoZSBGaXJlYmFzZSBTdG9yYWdlIFNESy5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgU3RvcmFnZUVycm9yIGV4dGVuZHMgRmlyZWJhc2VFcnJvciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb2RlIC0gQSBgU3RvcmFnZUVycm9yQ29kZWAgc3RyaW5nIHRvIGJlIHByZWZpeGVkIHdpdGggJ3N0b3JhZ2UvJyBhbmRcclxuICAgICAqICBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBtZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgIC0gRXJyb3IgbWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSBzdGF0dXNfIC0gQ29ycmVzcG9uZGluZyBIVFRQIFN0YXR1cyBDb2RlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIHN0YXR1c18gPSAwKSB7XHJcbiAgICAgICAgc3VwZXIocHJlcGVuZENvZGUoY29kZSksIGBGaXJlYmFzZSBTdG9yYWdlOiAke21lc3NhZ2V9ICgke3ByZXBlbmRDb2RlKGNvZGUpfSlgKTtcclxuICAgICAgICB0aGlzLnN0YXR1c18gPSBzdGF0dXNfO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3JlcyBjdXN0b20gZXJyb3IgZGF0YSB1bmlxdWUgdG8gdGhlIGBTdG9yYWdlRXJyb3JgLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3VzdG9tRGF0YSA9IHsgc2VydmVyUmVzcG9uc2U6IG51bGwgfTtcclxuICAgICAgICB0aGlzLl9iYXNlTWVzc2FnZSA9IHRoaXMubWVzc2FnZTtcclxuICAgICAgICAvLyBXaXRob3V0IHRoaXMsIGBpbnN0YW5jZW9mIFN0b3JhZ2VFcnJvcmAsIGluIHRlc3RzIGZvciBleGFtcGxlLFxyXG4gICAgICAgIC8vIHJldHVybnMgZmFsc2UuXHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFN0b3JhZ2VFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHN0YXR1cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXNfO1xyXG4gICAgfVxyXG4gICAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcclxuICAgICAgICB0aGlzLnN0YXR1c18gPSBzdGF0dXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIGEgYFN0b3JhZ2VFcnJvckNvZGVgIGFnYWluc3QgdGhpcyBlcnJvcidzIGNvZGUsIGZpbHRlcmluZyBvdXQgdGhlIHByZWZpeC5cclxuICAgICAqL1xyXG4gICAgX2NvZGVFcXVhbHMoY29kZSkge1xyXG4gICAgICAgIHJldHVybiBwcmVwZW5kQ29kZShjb2RlKSA9PT0gdGhpcy5jb2RlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPcHRpb25hbCByZXNwb25zZSBtZXNzYWdlIHRoYXQgd2FzIGFkZGVkIGJ5IHRoZSBzZXJ2ZXIuXHJcbiAgICAgKi9cclxuICAgIGdldCBzZXJ2ZXJSZXNwb25zZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21EYXRhLnNlcnZlclJlc3BvbnNlO1xyXG4gICAgfVxyXG4gICAgc2V0IHNlcnZlclJlc3BvbnNlKHNlcnZlclJlc3BvbnNlKSB7XHJcbiAgICAgICAgdGhpcy5jdXN0b21EYXRhLnNlcnZlclJlc3BvbnNlID0gc2VydmVyUmVzcG9uc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tRGF0YS5zZXJ2ZXJSZXNwb25zZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgJHt0aGlzLl9iYXNlTWVzc2FnZX1cXG4ke3RoaXMuY3VzdG9tRGF0YS5zZXJ2ZXJSZXNwb25zZX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5fYmFzZU1lc3NhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqIEVycm9yIGNvZGVzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGBTdG9yYWdlRXJyb3JgIG9iamVjdHMuXHJcbiAqL1xyXG52YXIgU3RvcmFnZUVycm9yQ29kZTtcclxuKGZ1bmN0aW9uIChTdG9yYWdlRXJyb3JDb2RlKSB7XHJcbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBhbGwgcGxhdGZvcm1zXHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIk9CSkVDVF9OT1RfRk9VTkRcIl0gPSBcIm9iamVjdC1ub3QtZm91bmRcIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJCVUNLRVRfTk9UX0ZPVU5EXCJdID0gXCJidWNrZXQtbm90LWZvdW5kXCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiUFJPSkVDVF9OT1RfRk9VTkRcIl0gPSBcInByb2plY3Qtbm90LWZvdW5kXCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiUVVPVEFfRVhDRUVERURcIl0gPSBcInF1b3RhLWV4Y2VlZGVkXCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiVU5BVVRIRU5USUNBVEVEXCJdID0gXCJ1bmF1dGhlbnRpY2F0ZWRcIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJVTkFVVEhPUklaRURcIl0gPSBcInVuYXV0aG9yaXplZFwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlVOQVVUSE9SSVpFRF9BUFBcIl0gPSBcInVuYXV0aG9yaXplZC1hcHBcIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJSRVRSWV9MSU1JVF9FWENFRURFRFwiXSA9IFwicmV0cnktbGltaXQtZXhjZWVkZWRcIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX0NIRUNLU1VNXCJdID0gXCJpbnZhbGlkLWNoZWNrc3VtXCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiQ0FOQ0VMRURcIl0gPSBcImNhbmNlbGVkXCI7XHJcbiAgICAvLyBKUyBzcGVjaWZpY1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfRVZFTlRfTkFNRVwiXSA9IFwiaW52YWxpZC1ldmVudC1uYW1lXCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiSU5WQUxJRF9VUkxcIl0gPSBcImludmFsaWQtdXJsXCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiSU5WQUxJRF9ERUZBVUxUX0JVQ0tFVFwiXSA9IFwiaW52YWxpZC1kZWZhdWx0LWJ1Y2tldFwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIk5PX0RFRkFVTFRfQlVDS0VUXCJdID0gXCJuby1kZWZhdWx0LWJ1Y2tldFwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIkNBTk5PVF9TTElDRV9CTE9CXCJdID0gXCJjYW5ub3Qtc2xpY2UtYmxvYlwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlNFUlZFUl9GSUxFX1dST05HX1NJWkVcIl0gPSBcInNlcnZlci1maWxlLXdyb25nLXNpemVcIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJOT19ET1dOTE9BRF9VUkxcIl0gPSBcIm5vLWRvd25sb2FkLXVybFwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfQVJHVU1FTlRcIl0gPSBcImludmFsaWQtYXJndW1lbnRcIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX0FSR1VNRU5UX0NPVU5UXCJdID0gXCJpbnZhbGlkLWFyZ3VtZW50LWNvdW50XCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiQVBQX0RFTEVURURcIl0gPSBcImFwcC1kZWxldGVkXCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiSU5WQUxJRF9ST09UX09QRVJBVElPTlwiXSA9IFwiaW52YWxpZC1yb290LW9wZXJhdGlvblwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfRk9STUFUXCJdID0gXCJpbnZhbGlkLWZvcm1hdFwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVEVSTkFMX0VSUk9SXCJdID0gXCJpbnRlcm5hbC1lcnJvclwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlVOU1VQUE9SVEVEX0VOVklST05NRU5UXCJdID0gXCJ1bnN1cHBvcnRlZC1lbnZpcm9ubWVudFwiO1xyXG59KShTdG9yYWdlRXJyb3JDb2RlIHx8IChTdG9yYWdlRXJyb3JDb2RlID0ge30pKTtcclxuZnVuY3Rpb24gcHJlcGVuZENvZGUoY29kZSkge1xyXG4gICAgcmV0dXJuICdzdG9yYWdlLycgKyBjb2RlO1xyXG59XHJcbmZ1bmN0aW9uIHVua25vd24oKSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQsIHBsZWFzZSBjaGVjayB0aGUgZXJyb3IgcGF5bG9hZCBmb3IgJyArXHJcbiAgICAgICAgJ3NlcnZlciByZXNwb25zZS4nO1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5VTktOT1dOLCBtZXNzYWdlKTtcclxufVxyXG5mdW5jdGlvbiBvYmplY3ROb3RGb3VuZChwYXRoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLk9CSkVDVF9OT1RfRk9VTkQsIFwiT2JqZWN0ICdcIiArIHBhdGggKyBcIicgZG9lcyBub3QgZXhpc3QuXCIpO1xyXG59XHJcbmZ1bmN0aW9uIHF1b3RhRXhjZWVkZWQoYnVja2V0KSB7XHJcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlFVT1RBX0VYQ0VFREVELCBcIlF1b3RhIGZvciBidWNrZXQgJ1wiICtcclxuICAgICAgICBidWNrZXQgK1xyXG4gICAgICAgIFwiJyBleGNlZWRlZCwgcGxlYXNlIHZpZXcgcXVvdGEgb24gXCIgK1xyXG4gICAgICAgICdodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vcHJpY2luZy8uJyk7XHJcbn1cclxuZnVuY3Rpb24gdW5hdXRoZW50aWNhdGVkKCkge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9ICdVc2VyIGlzIG5vdCBhdXRoZW50aWNhdGVkLCBwbGVhc2UgYXV0aGVudGljYXRlIHVzaW5nIEZpcmViYXNlICcgK1xyXG4gICAgICAgICdBdXRoZW50aWNhdGlvbiBhbmQgdHJ5IGFnYWluLic7XHJcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlVOQVVUSEVOVElDQVRFRCwgbWVzc2FnZSk7XHJcbn1cclxuZnVuY3Rpb24gdW5hdXRob3JpemVkQXBwKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5VTkFVVEhPUklaRURfQVBQLCAnVGhpcyBhcHAgZG9lcyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyBGaXJlYmFzZSBTdG9yYWdlIG9uIHRoaXMgcHJvamVjdC4nKTtcclxufVxyXG5mdW5jdGlvbiB1bmF1dGhvcml6ZWQocGF0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5VTkFVVEhPUklaRUQsIFwiVXNlciBkb2VzIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gYWNjZXNzICdcIiArIHBhdGggKyBcIicuXCIpO1xyXG59XHJcbmZ1bmN0aW9uIHJldHJ5TGltaXRFeGNlZWRlZCgpIHtcclxuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuUkVUUllfTElNSVRfRVhDRUVERUQsICdNYXggcmV0cnkgdGltZSBmb3Igb3BlcmF0aW9uIGV4Y2VlZGVkLCBwbGVhc2UgdHJ5IGFnYWluLicpO1xyXG59XHJcbmZ1bmN0aW9uIGNhbmNlbGVkKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5DQU5DRUxFRCwgJ1VzZXIgY2FuY2VsZWQgdGhlIHVwbG9hZC9kb3dubG9hZC4nKTtcclxufVxyXG5mdW5jdGlvbiBpbnZhbGlkVXJsKHVybCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5JTlZBTElEX1VSTCwgXCJJbnZhbGlkIFVSTCAnXCIgKyB1cmwgKyBcIicuXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGludmFsaWREZWZhdWx0QnVja2V0KGJ1Y2tldCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5JTlZBTElEX0RFRkFVTFRfQlVDS0VULCBcIkludmFsaWQgZGVmYXVsdCBidWNrZXQgJ1wiICsgYnVja2V0ICsgXCInLlwiKTtcclxufVxyXG5mdW5jdGlvbiBub0RlZmF1bHRCdWNrZXQoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLk5PX0RFRkFVTFRfQlVDS0VULCAnTm8gZGVmYXVsdCBidWNrZXQgJyArXHJcbiAgICAgICAgXCJmb3VuZC4gRGlkIHlvdSBzZXQgdGhlICdcIiArXHJcbiAgICAgICAgQ09ORklHX1NUT1JBR0VfQlVDS0VUX0tFWSArXHJcbiAgICAgICAgXCInIHByb3BlcnR5IHdoZW4gaW5pdGlhbGl6aW5nIHRoZSBhcHA/XCIpO1xyXG59XHJcbmZ1bmN0aW9uIGNhbm5vdFNsaWNlQmxvYigpIHtcclxuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuQ0FOTk9UX1NMSUNFX0JMT0IsICdDYW5ub3Qgc2xpY2UgYmxvYiBmb3IgdXBsb2FkLiBQbGVhc2UgcmV0cnkgdGhlIHVwbG9hZC4nKTtcclxufVxyXG5mdW5jdGlvbiBzZXJ2ZXJGaWxlV3JvbmdTaXplKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5TRVJWRVJfRklMRV9XUk9OR19TSVpFLCAnU2VydmVyIHJlY29yZGVkIGluY29ycmVjdCB1cGxvYWQgZmlsZSBzaXplLCBwbGVhc2UgcmV0cnkgdGhlIHVwbG9hZC4nKTtcclxufVxyXG5mdW5jdGlvbiBub0Rvd25sb2FkVVJMKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5OT19ET1dOTE9BRF9VUkwsICdUaGUgZ2l2ZW4gZmlsZSBkb2VzIG5vdCBoYXZlIGFueSBkb3dubG9hZCBVUkxzLicpO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGludmFsaWRBcmd1bWVudChtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLklOVkFMSURfQVJHVU1FTlQsIG1lc3NhZ2UpO1xyXG59XHJcbmZ1bmN0aW9uIGFwcERlbGV0ZWQoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLkFQUF9ERUxFVEVELCAnVGhlIEZpcmViYXNlIGFwcCB3YXMgZGVsZXRlZC4nKTtcclxufVxyXG4vKipcclxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgb3BlcmF0aW9uIHRoYXQgd2FzIGludmFsaWQuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gaW52YWxpZFJvb3RPcGVyYXRpb24obmFtZSkge1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5JTlZBTElEX1JPT1RfT1BFUkFUSU9OLCBcIlRoZSBvcGVyYXRpb24gJ1wiICtcclxuICAgICAgICBuYW1lICtcclxuICAgICAgICBcIicgY2Fubm90IGJlIHBlcmZvcm1lZCBvbiBhIHJvb3QgcmVmZXJlbmNlLCBjcmVhdGUgYSBub24tcm9vdCBcIiArXHJcbiAgICAgICAgXCJyZWZlcmVuY2UgdXNpbmcgY2hpbGQsIHN1Y2ggYXMgLmNoaWxkKCdmaWxlLnBuZycpLlwiKTtcclxufVxyXG4vKipcclxuICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgdGhhdCB3YXMgbm90IHZhbGlkLlxyXG4gKiBAcGFyYW0gbWVzc2FnZSAtIEEgbWVzc2FnZSBkZXNjcmliaW5nIHRoZSBmb3JtYXQgdmlvbGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gaW52YWxpZEZvcm1hdChmb3JtYXQsIG1lc3NhZ2UpIHtcclxuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuSU5WQUxJRF9GT1JNQVQsIFwiU3RyaW5nIGRvZXMgbm90IG1hdGNoIGZvcm1hdCAnXCIgKyBmb3JtYXQgKyBcIic6IFwiICsgbWVzc2FnZSk7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBtZXNzYWdlIC0gQSBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIGludGVybmFsIGVycm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gaW50ZXJuYWxFcnJvcihtZXNzYWdlKSB7XHJcbiAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuSU5URVJOQUxfRVJST1IsICdJbnRlcm5hbCBlcnJvcjogJyArIG1lc3NhZ2UpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBGaXJlYmFzZSBTdG9yYWdlIGxvY2F0aW9uIGRhdGEuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgTG9jYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoYnVja2V0LCBwYXRoKSB7XHJcbiAgICAgICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XHJcbiAgICAgICAgdGhpcy5wYXRoXyA9IHBhdGg7XHJcbiAgICB9XHJcbiAgICBnZXQgcGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoXztcclxuICAgIH1cclxuICAgIGdldCBpc1Jvb3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcbiAgICBmdWxsU2VydmVyVXJsKCkge1xyXG4gICAgICAgIGNvbnN0IGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcclxuICAgICAgICByZXR1cm4gJy9iLycgKyBlbmNvZGUodGhpcy5idWNrZXQpICsgJy9vLycgKyBlbmNvZGUodGhpcy5wYXRoKTtcclxuICAgIH1cclxuICAgIGJ1Y2tldE9ubHlTZXJ2ZXJVcmwoKSB7XHJcbiAgICAgICAgY29uc3QgZW5jb2RlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xyXG4gICAgICAgIHJldHVybiAnL2IvJyArIGVuY29kZSh0aGlzLmJ1Y2tldCkgKyAnL28nO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG1ha2VGcm9tQnVja2V0U3BlYyhidWNrZXRTdHJpbmcsIGhvc3QpIHtcclxuICAgICAgICBsZXQgYnVja2V0TG9jYXRpb247XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYnVja2V0TG9jYXRpb24gPSBMb2NhdGlvbi5tYWtlRnJvbVVybChidWNrZXRTdHJpbmcsIGhvc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBOb3QgdmFsaWQgVVJMLCB1c2UgYXMtaXMuIFRoaXMgbGV0cyB5b3UgcHV0IGJhcmUgYnVja2V0IG5hbWVzIGluXHJcbiAgICAgICAgICAgIC8vIGNvbmZpZy5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2NhdGlvbihidWNrZXRTdHJpbmcsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ1Y2tldExvY2F0aW9uLnBhdGggPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBidWNrZXRMb2NhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGludmFsaWREZWZhdWx0QnVja2V0KGJ1Y2tldFN0cmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIG1ha2VGcm9tVXJsKHVybCwgaG9zdCkge1xyXG4gICAgICAgIGxldCBsb2NhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgYnVja2V0RG9tYWluID0gJyhbQS1aYS16MC05LlxcXFwtX10rKSc7XHJcbiAgICAgICAgZnVuY3Rpb24gZ3NNb2RpZnkobG9jKSB7XHJcbiAgICAgICAgICAgIGlmIChsb2MucGF0aC5jaGFyQXQobG9jLnBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgbG9jLnBhdGhfID0gbG9jLnBhdGhfLnNsaWNlKDAsIC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBnc1BhdGggPSAnKC8oLiopKT8kJztcclxuICAgICAgICBjb25zdCBnc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXmdzOi8vJyArIGJ1Y2tldERvbWFpbiArIGdzUGF0aCwgJ2knKTtcclxuICAgICAgICBjb25zdCBnc0luZGljZXMgPSB7IGJ1Y2tldDogMSwgcGF0aDogMyB9O1xyXG4gICAgICAgIGZ1bmN0aW9uIGh0dHBNb2RpZnkobG9jKSB7XHJcbiAgICAgICAgICAgIGxvYy5wYXRoXyA9IGRlY29kZVVSSUNvbXBvbmVudChsb2MucGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAndltBLVphLXowLTlfXSsnO1xyXG4gICAgICAgIGNvbnN0IGZpcmViYXNlU3RvcmFnZUhvc3QgPSBob3N0LnJlcGxhY2UoL1suXS9nLCAnXFxcXC4nKTtcclxuICAgICAgICBjb25zdCBmaXJlYmFzZVN0b3JhZ2VQYXRoID0gJygvKFtePyNdKikuKik/JCc7XHJcbiAgICAgICAgY29uc3QgZmlyZWJhc2VTdG9yYWdlUmVnRXhwID0gbmV3IFJlZ0V4cChgXmh0dHBzPzovLyR7ZmlyZWJhc2VTdG9yYWdlSG9zdH0vJHt2ZXJzaW9ufS9iLyR7YnVja2V0RG9tYWlufS9vJHtmaXJlYmFzZVN0b3JhZ2VQYXRofWAsICdpJyk7XHJcbiAgICAgICAgY29uc3QgZmlyZWJhc2VTdG9yYWdlSW5kaWNlcyA9IHsgYnVja2V0OiAxLCBwYXRoOiAzIH07XHJcbiAgICAgICAgY29uc3QgY2xvdWRTdG9yYWdlSG9zdCA9IGhvc3QgPT09IERFRkFVTFRfSE9TVFxyXG4gICAgICAgICAgICA/ICcoPzpzdG9yYWdlLmdvb2dsZWFwaXMuY29tfHN0b3JhZ2UuY2xvdWQuZ29vZ2xlLmNvbSknXHJcbiAgICAgICAgICAgIDogaG9zdDtcclxuICAgICAgICBjb25zdCBjbG91ZFN0b3JhZ2VQYXRoID0gJyhbXj8jXSopJztcclxuICAgICAgICBjb25zdCBjbG91ZFN0b3JhZ2VSZWdFeHAgPSBuZXcgUmVnRXhwKGBeaHR0cHM/Oi8vJHtjbG91ZFN0b3JhZ2VIb3N0fS8ke2J1Y2tldERvbWFpbn0vJHtjbG91ZFN0b3JhZ2VQYXRofWAsICdpJyk7XHJcbiAgICAgICAgY29uc3QgY2xvdWRTdG9yYWdlSW5kaWNlcyA9IHsgYnVja2V0OiAxLCBwYXRoOiAyIH07XHJcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gW1xyXG4gICAgICAgICAgICB7IHJlZ2V4OiBnc1JlZ2V4LCBpbmRpY2VzOiBnc0luZGljZXMsIHBvc3RNb2RpZnk6IGdzTW9kaWZ5IH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlZ2V4OiBmaXJlYmFzZVN0b3JhZ2VSZWdFeHAsXHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzOiBmaXJlYmFzZVN0b3JhZ2VJbmRpY2VzLFxyXG4gICAgICAgICAgICAgICAgcG9zdE1vZGlmeTogaHR0cE1vZGlmeVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZWdleDogY2xvdWRTdG9yYWdlUmVnRXhwLFxyXG4gICAgICAgICAgICAgICAgaW5kaWNlczogY2xvdWRTdG9yYWdlSW5kaWNlcyxcclxuICAgICAgICAgICAgICAgIHBvc3RNb2RpZnk6IGh0dHBNb2RpZnlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVzID0gZ3JvdXAucmVnZXguZXhlYyh1cmwpO1xyXG4gICAgICAgICAgICBpZiAoY2FwdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1Y2tldFZhbHVlID0gY2FwdHVyZXNbZ3JvdXAuaW5kaWNlcy5idWNrZXRdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhdGhWYWx1ZSA9IGNhcHR1cmVzW2dyb3VwLmluZGljZXMucGF0aF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGhWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhWYWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSBuZXcgTG9jYXRpb24oYnVja2V0VmFsdWUsIHBhdGhWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBncm91cC5wb3N0TW9kaWZ5KGxvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IGludmFsaWRVcmwodXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBBIHJlcXVlc3Qgd2hvc2UgcHJvbWlzZSBhbHdheXMgZmFpbHMuXHJcbiAqL1xyXG5jbGFzcyBGYWlsUmVxdWVzdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xyXG4gICAgICAgIHRoaXMucHJvbWlzZV8gPSBQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldFByb21pc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZV87XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGNhbmNlbChfYXBwRGVsZXRlID0gZmFsc2UpIHsgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBY2NlcHRzIGEgY2FsbGJhY2sgZm9yIGFuIGFjdGlvbiB0byBwZXJmb3JtIChgZG9SZXF1ZXN0YCksXHJcbiAqIGFuZCB0aGVuIGEgY2FsbGJhY2sgZm9yIHdoZW4gdGhlIGJhY2tvZmYgaGFzIGNvbXBsZXRlZCAoYGJhY2tvZmZDb21wbGV0ZUNiYCkuXHJcbiAqIFRoZSBjYWxsYmFjayBzZW50IHRvIHN0YXJ0IHJlcXVpcmVzIGFuIGFyZ3VtZW50IHRvIGNhbGwgKGBvblJlcXVlc3RDb21wbGV0ZWApLlxyXG4gKiBXaGVuIGBzdGFydGAgY2FsbHMgYGRvUmVxdWVzdGAsIGl0IHBhc3NlcyBhIGNhbGxiYWNrIGZvciB3aGVuIHRoZSByZXF1ZXN0IGhhc1xyXG4gKiBjb21wbGV0ZWQsIGBvblJlcXVlc3RDb21wbGV0ZWAuIEJhc2VkIG9uIHRoaXMsIHRoZSBiYWNrb2ZmIGNvbnRpbnVlcywgd2l0aFxyXG4gKiBhbm90aGVyIGNhbGwgdG8gYGRvUmVxdWVzdGAgYW5kIHRoZSBhYm92ZSBsb29wIGNvbnRpbnVlcyB1bnRpbCB0aGUgdGltZW91dFxyXG4gKiBpcyBoaXQsIG9yIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSBvY2N1cnMuXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBAcGFyYW0gZG9SZXF1ZXN0IENhbGxiYWNrIHRvIHBlcmZvcm0gcmVxdWVzdFxyXG4gKiBAcGFyYW0gYmFja29mZkNvbXBsZXRlQ2IgQ2FsbGJhY2sgdG8gY2FsbCB3aGVuIGJhY2tvZmYgaGFzIGJlZW4gY29tcGxldGVkXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFydChkb1JlcXVlc3QsIFxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5iYWNrb2ZmQ29tcGxldGVDYiwgdGltZW91dCkge1xyXG4gICAgLy8gVE9ETyhhbmR5c290byk6IG1ha2UgdGhpcyBjb2RlIGNsZWFuZXIgKHByb2JhYmx5IHJlZmFjdG9yIGludG8gYW4gYWN0dWFsXHJcbiAgICAvLyB0eXBlIGluc3RlYWQgb2YgYSBidW5jaCBvZiBmdW5jdGlvbnMgd2l0aCBzdGF0ZSBzaGFyZWQgaW4gdGhlIGNsb3N1cmUpXHJcbiAgICBsZXQgd2FpdFNlY29uZHMgPSAxO1xyXG4gICAgLy8gV291bGQgdHlwZSB0aGlzIGFzIFwibnVtYmVyXCIgYnV0IHRoYXQgZG9lc24ndCB3b3JrIGZvciBOb2RlIHNvIMKvXFxfKOODhClfL8KvXHJcbiAgICAvLyBUT0RPOiBmaW5kIGEgd2F5IHRvIGV4Y2x1ZGUgTm9kZSB0eXBlIGRlZmluaXRpb24gZm9yIHN0b3JhZ2UgYmVjYXVzZSBzdG9yYWdlIG9ubHkgd29ya3MgaW4gYnJvd3NlclxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGxldCByZXRyeVRpbWVvdXRJZCA9IG51bGw7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgbGV0IGdsb2JhbFRpbWVvdXRJZCA9IG51bGw7XHJcbiAgICBsZXQgaGl0VGltZW91dCA9IGZhbHNlO1xyXG4gICAgbGV0IGNhbmNlbFN0YXRlID0gMDtcclxuICAgIGZ1bmN0aW9uIGNhbmNlbGVkKCkge1xyXG4gICAgICAgIHJldHVybiBjYW5jZWxTdGF0ZSA9PT0gMjtcclxuICAgIH1cclxuICAgIGxldCB0cmlnZ2VyZWRDYWxsYmFjayA9IGZhbHNlO1xyXG4gICAgZnVuY3Rpb24gdHJpZ2dlckNhbGxiYWNrKC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAoIXRyaWdnZXJlZENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJlZENhbGxiYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgYmFja29mZkNvbXBsZXRlQ2IuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2FsbFdpdGhEZWxheShtaWxsaXMpIHtcclxuICAgICAgICByZXRyeVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICByZXRyeVRpbWVvdXRJZCA9IG51bGw7XHJcbiAgICAgICAgICAgIGRvUmVxdWVzdChyZXNwb25zZUhhbmRsZXIsIGNhbmNlbGVkKCkpO1xyXG4gICAgICAgIH0sIG1pbGxpcyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjbGVhckdsb2JhbFRpbWVvdXQoKSB7XHJcbiAgICAgICAgaWYgKGdsb2JhbFRpbWVvdXRJZCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZ2xvYmFsVGltZW91dElkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXNwb25zZUhhbmRsZXIoc3VjY2VzcywgLi4uYXJncykge1xyXG4gICAgICAgIGlmICh0cmlnZ2VyZWRDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjbGVhckdsb2JhbFRpbWVvdXQoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3VjY2Vzcykge1xyXG4gICAgICAgICAgICBjbGVhckdsb2JhbFRpbWVvdXQoKTtcclxuICAgICAgICAgICAgdHJpZ2dlckNhbGxiYWNrLmNhbGwobnVsbCwgc3VjY2VzcywgLi4uYXJncyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbXVzdFN0b3AgPSBjYW5jZWxlZCgpIHx8IGhpdFRpbWVvdXQ7XHJcbiAgICAgICAgaWYgKG11c3RTdG9wKSB7XHJcbiAgICAgICAgICAgIGNsZWFyR2xvYmFsVGltZW91dCgpO1xyXG4gICAgICAgICAgICB0cmlnZ2VyQ2FsbGJhY2suY2FsbChudWxsLCBzdWNjZXNzLCAuLi5hcmdzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod2FpdFNlY29uZHMgPCA2NCkge1xyXG4gICAgICAgICAgICAvKiBUT0RPKGFuZHlzb3RvKTogZG9uJ3QgYmFjayBvZmYgc28gcXVpY2tseSBpZiB3ZSBrbm93IHdlJ3JlIG9mZmxpbmUuICovXHJcbiAgICAgICAgICAgIHdhaXRTZWNvbmRzICo9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB3YWl0TWlsbGlzO1xyXG4gICAgICAgIGlmIChjYW5jZWxTdGF0ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICBjYW5jZWxTdGF0ZSA9IDI7XHJcbiAgICAgICAgICAgIHdhaXRNaWxsaXMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2FpdE1pbGxpcyA9ICh3YWl0U2Vjb25kcyArIE1hdGgucmFuZG9tKCkpICogMTAwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FsbFdpdGhEZWxheSh3YWl0TWlsbGlzKTtcclxuICAgIH1cclxuICAgIGxldCBzdG9wcGVkID0gZmFsc2U7XHJcbiAgICBmdW5jdGlvbiBzdG9wKHdhc1RpbWVvdXQpIHtcclxuICAgICAgICBpZiAoc3RvcHBlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIGNsZWFyR2xvYmFsVGltZW91dCgpO1xyXG4gICAgICAgIGlmICh0cmlnZ2VyZWRDYWxsYmFjaykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXRyeVRpbWVvdXRJZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoIXdhc1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIGNhbmNlbFN0YXRlID0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocmV0cnlUaW1lb3V0SWQpO1xyXG4gICAgICAgICAgICBjYWxsV2l0aERlbGF5KDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCF3YXNUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxTdGF0ZSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYWxsV2l0aERlbGF5KDApO1xyXG4gICAgZ2xvYmFsVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaGl0VGltZW91dCA9IHRydWU7XHJcbiAgICAgICAgc3RvcCh0cnVlKTtcclxuICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgcmV0dXJuIHN0b3A7XHJcbn1cclxuLyoqXHJcbiAqIFN0b3BzIHRoZSByZXRyeSBsb29wIGZyb20gcmVwZWF0aW5nLlxyXG4gKiBJZiB0aGUgZnVuY3Rpb24gaXMgY3VycmVudGx5IFwiaW4gYmV0d2VlblwiIHJldHJpZXMsIGl0IGlzIGludm9rZWQgaW1tZWRpYXRlbHlcclxuICogd2l0aCB0aGUgc2Vjb25kIHBhcmFtZXRlciBhcyBcInRydWVcIi4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGludm9rZWQgb25jZSBtb3JlXHJcbiAqIGFmdGVyIHRoZSBjdXJyZW50IGludm9jYXRpb24gZmluaXNoZXMgaWZmIHRoZSBjdXJyZW50IGludm9jYXRpb24gd291bGQgaGF2ZVxyXG4gKiB0cmlnZ2VyZWQgYW5vdGhlciByZXRyeS5cclxuICovXHJcbmZ1bmN0aW9uIHN0b3AoaWQpIHtcclxuICAgIGlkKGZhbHNlKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0p1c3REZWYocCkge1xyXG4gICAgcmV0dXJuIHAgIT09IHZvaWQgMDtcclxufVxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHApIHtcclxuICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG5mdW5jdGlvbiBpc05vbkFycmF5T2JqZWN0KHApIHtcclxuICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocCk7XHJcbn1cclxuZnVuY3Rpb24gaXNTdHJpbmcocCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBwID09PSAnc3RyaW5nJyB8fCBwIGluc3RhbmNlb2YgU3RyaW5nO1xyXG59XHJcbmZ1bmN0aW9uIGlzTmF0aXZlQmxvYihwKSB7XHJcbiAgICByZXR1cm4gaXNOYXRpdmVCbG9iRGVmaW5lZCgpICYmIHAgaW5zdGFuY2VvZiBCbG9iO1xyXG59XHJcbmZ1bmN0aW9uIGlzTmF0aXZlQmxvYkRlZmluZWQoKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKGFyZ3VtZW50LCBtaW5WYWx1ZSwgbWF4VmFsdWUsIHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPCBtaW5WYWx1ZSkge1xyXG4gICAgICAgIHRocm93IGludmFsaWRBcmd1bWVudChgSW52YWxpZCB2YWx1ZSBmb3IgJyR7YXJndW1lbnR9Jy4gRXhwZWN0ZWQgJHttaW5WYWx1ZX0gb3IgZ3JlYXRlci5gKTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA+IG1heFZhbHVlKSB7XHJcbiAgICAgICAgdGhyb3cgaW52YWxpZEFyZ3VtZW50KGBJbnZhbGlkIHZhbHVlIGZvciAnJHthcmd1bWVudH0nLiBFeHBlY3RlZCAke21heFZhbHVlfSBvciBsZXNzLmApO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VVcmwodXJsUGFydCwgaG9zdCwgcHJvdG9jb2wpIHtcclxuICAgIGxldCBvcmlnaW4gPSBob3N0O1xyXG4gICAgaWYgKHByb3RvY29sID09IG51bGwpIHtcclxuICAgICAgICBvcmlnaW4gPSBgaHR0cHM6Ly8ke2hvc3R9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBgJHtwcm90b2NvbH06Ly8ke29yaWdpbn0vdjAke3VybFBhcnR9YDtcclxufVxyXG5mdW5jdGlvbiBtYWtlUXVlcnlTdHJpbmcocGFyYW1zKSB7XHJcbiAgICBjb25zdCBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XHJcbiAgICBsZXQgcXVlcnlQYXJ0ID0gJz8nO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRQYXJ0ID0gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUocGFyYW1zW2tleV0pO1xyXG4gICAgICAgICAgICBxdWVyeVBhcnQgPSBxdWVyeVBhcnQgKyBuZXh0UGFydCArICcmJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDaG9wIG9mZiB0aGUgZXh0cmEgJyYnIG9yICc/JyBvbiB0aGUgZW5kXHJcbiAgICBxdWVyeVBhcnQgPSBxdWVyeVBhcnQuc2xpY2UoMCwgLTEpO1xyXG4gICAgcmV0dXJuIHF1ZXJ5UGFydDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRXJyb3IgY29kZXMgZm9yIHJlcXVlc3RzIG1hZGUgYnkgdGhlIHRoZSBYaHJJbyB3cmFwcGVyLlxyXG4gKi9cclxudmFyIEVycm9yQ29kZTtcclxuKGZ1bmN0aW9uIChFcnJvckNvZGUpIHtcclxuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJOT19FUlJPUlwiXSA9IDBdID0gXCJOT19FUlJPUlwiO1xyXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIk5FVFdPUktfRVJST1JcIl0gPSAxXSA9IFwiTkVUV09SS19FUlJPUlwiO1xyXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkFCT1JUXCJdID0gMl0gPSBcIkFCT1JUXCI7XHJcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENoZWNrcyB0aGUgc3RhdHVzIGNvZGUgdG8gc2VlIGlmIHRoZSBhY3Rpb24gc2hvdWxkIGJlIHJldHJpZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBzdGF0dXMgQ3VycmVudCBIVFRQIHN0YXR1cyBjb2RlIHJldHVybmVkIGJ5IHNlcnZlci5cclxuICogQHBhcmFtIGFkZGl0aW9uYWxSZXRyeUNvZGVzIGFkZGl0aW9uYWwgcmV0cnkgY29kZXMgdG8gY2hlY2sgYWdhaW5zdFxyXG4gKi9cclxuZnVuY3Rpb24gaXNSZXRyeVN0YXR1c0NvZGUoc3RhdHVzLCBhZGRpdGlvbmFsUmV0cnlDb2Rlcykge1xyXG4gICAgLy8gVGhlIGNvZGVzIGZvciB3aGljaCB0byByZXRyeSBjYW1lIGZyb20gdGhpcyBwYWdlOlxyXG4gICAgLy8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3N0b3JhZ2UvZG9jcy9leHBvbmVudGlhbC1iYWNrb2ZmXHJcbiAgICBjb25zdCBpc0ZpdmVIdW5kcmVkQ29kZSA9IHN0YXR1cyA+PSA1MDAgJiYgc3RhdHVzIDwgNjAwO1xyXG4gICAgY29uc3QgZXh0cmFSZXRyeUNvZGVzID0gW1xyXG4gICAgICAgIC8vIFJlcXVlc3QgVGltZW91dDogd2ViIHNlcnZlciBkaWRuJ3QgcmVjZWl2ZSBmdWxsIHJlcXVlc3QgaW4gdGltZS5cclxuICAgICAgICA0MDgsXHJcbiAgICAgICAgLy8gVG9vIE1hbnkgUmVxdWVzdHM6IHlvdSdyZSBnZXR0aW5nIHJhdGUtbGltaXRlZCwgYmFzaWNhbGx5LlxyXG4gICAgICAgIDQyOVxyXG4gICAgXTtcclxuICAgIGNvbnN0IGlzRXh0cmFSZXRyeUNvZGUgPSBleHRyYVJldHJ5Q29kZXMuaW5kZXhPZihzdGF0dXMpICE9PSAtMTtcclxuICAgIGNvbnN0IGlzQWRkaXRpb25hbFJldHJ5Q29kZSA9IGFkZGl0aW9uYWxSZXRyeUNvZGVzLmluZGV4T2Yoc3RhdHVzKSAhPT0gLTE7XHJcbiAgICByZXR1cm4gaXNGaXZlSHVuZHJlZENvZGUgfHwgaXNFeHRyYVJldHJ5Q29kZSB8fCBpc0FkZGl0aW9uYWxSZXRyeUNvZGU7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEhhbmRsZXMgbmV0d29yayBsb2dpYyBmb3IgYWxsIFN0b3JhZ2UgUmVxdWVzdHMsIGluY2x1ZGluZyBlcnJvciByZXBvcnRpbmcgYW5kXHJcbiAqIHJldHJpZXMgd2l0aCBiYWNrb2ZmLlxyXG4gKlxyXG4gKiBAcGFyYW0gSSAtIHRoZSB0eXBlIG9mIHRoZSBiYWNrZW5kJ3MgbmV0d29yayByZXNwb25zZS5cclxuICogQHBhcmFtIC0gTyB0aGUgb3V0cHV0IHR5cGUgdXNlZCBieSB0aGUgcmVzdCBvZiB0aGUgU0RLLiBUaGUgY29udmVyc2lvblxyXG4gKiBoYXBwZW5zIGluIHRoZSBzcGVjaWZpZWQgYGNhbGxiYWNrX2AuXHJcbiAqL1xyXG5jbGFzcyBOZXR3b3JrUmVxdWVzdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1cmxfLCBtZXRob2RfLCBoZWFkZXJzXywgYm9keV8sIHN1Y2Nlc3NDb2Rlc18sIGFkZGl0aW9uYWxSZXRyeUNvZGVzXywgY2FsbGJhY2tfLCBlcnJvckNhbGxiYWNrXywgdGltZW91dF8sIHByb2dyZXNzQ2FsbGJhY2tfLCBjb25uZWN0aW9uRmFjdG9yeV8sIHJldHJ5ID0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMudXJsXyA9IHVybF87XHJcbiAgICAgICAgdGhpcy5tZXRob2RfID0gbWV0aG9kXztcclxuICAgICAgICB0aGlzLmhlYWRlcnNfID0gaGVhZGVyc187XHJcbiAgICAgICAgdGhpcy5ib2R5XyA9IGJvZHlfO1xyXG4gICAgICAgIHRoaXMuc3VjY2Vzc0NvZGVzXyA9IHN1Y2Nlc3NDb2Rlc187XHJcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsUmV0cnlDb2Rlc18gPSBhZGRpdGlvbmFsUmV0cnlDb2Rlc187XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFja187XHJcbiAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrXyA9IGVycm9yQ2FsbGJhY2tfO1xyXG4gICAgICAgIHRoaXMudGltZW91dF8gPSB0aW1lb3V0XztcclxuICAgICAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2tfID0gcHJvZ3Jlc3NDYWxsYmFja187XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRmFjdG9yeV8gPSBjb25uZWN0aW9uRmFjdG9yeV87XHJcbiAgICAgICAgdGhpcy5yZXRyeSA9IHJldHJ5O1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0Nvbm5lY3Rpb25fID0gbnVsbDtcclxuICAgICAgICB0aGlzLmJhY2tvZmZJZF8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2FuY2VsZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hcHBEZWxldGVfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlXyA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlXyA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgIHRoaXMucmVqZWN0XyA9IHJlamVjdDtcclxuICAgICAgICAgICAgdGhpcy5zdGFydF8oKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWN0dWFsbHkgc3RhcnRzIHRoZSByZXRyeSBsb29wLlxyXG4gICAgICovXHJcbiAgICBzdGFydF8oKSB7XHJcbiAgICAgICAgY29uc3QgZG9UaGVSZXF1ZXN0ID0gKGJhY2tvZmZDYWxsYmFjaywgY2FuY2VsZWQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNhbmNlbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBiYWNrb2ZmQ2FsbGJhY2soZmFsc2UsIG5ldyBSZXF1ZXN0RW5kU3RhdHVzKGZhbHNlLCBudWxsLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbkZhY3RvcnlfKCk7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0Nvbm5lY3Rpb25fID0gY29ubmVjdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3NMaXN0ZW5lciA9IHByb2dyZXNzRXZlbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZGVkID0gcHJvZ3Jlc3NFdmVudC5sb2FkZWQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbCA9IHByb2dyZXNzRXZlbnQubGVuZ3RoQ29tcHV0YWJsZSA/IHByb2dyZXNzRXZlbnQudG90YWwgOiAtMTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2dyZXNzQ2FsbGJhY2tfICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0NhbGxiYWNrXyhsb2FkZWQsIHRvdGFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvZ3Jlc3NDYWxsYmFja18gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uYWRkVXBsb2FkUHJvZ3Jlc3NMaXN0ZW5lcihwcm9ncmVzc0xpc3RlbmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb25uZWN0aW9uLnNlbmQoKSBuZXZlciByZWplY3RzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGhhdmUgYSBlcnJvciBoYW5kbGVyIG9yIHVzZSBjYXRjaCBvbiB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAuc2VuZCh0aGlzLnVybF8sIHRoaXMubWV0aG9kXywgdGhpcy5ib2R5XywgdGhpcy5oZWFkZXJzXylcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2dyZXNzQ2FsbGJhY2tfICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVVcGxvYWRQcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ29ubmVjdGlvbl8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGl0U2VydmVyID0gY29ubmVjdGlvbi5nZXRFcnJvckNvZGUoKSA9PT0gRXJyb3JDb2RlLk5PX0VSUk9SO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gY29ubmVjdGlvbi5nZXRTdGF0dXMoKTtcclxuICAgICAgICAgICAgICAgIGlmICghaGl0U2VydmVyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGlzUmV0cnlTdGF0dXNDb2RlKHN0YXR1cywgdGhpcy5hZGRpdGlvbmFsUmV0cnlDb2Rlc18pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmV0cnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FzQ2FuY2VsZWQgPSBjb25uZWN0aW9uLmdldEVycm9yQ29kZSgpID09PSBFcnJvckNvZGUuQUJPUlQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFja29mZkNhbGxiYWNrKGZhbHNlLCBuZXcgUmVxdWVzdEVuZFN0YXR1cyhmYWxzZSwgbnVsbCwgd2FzQ2FuY2VsZWQpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdWNjZXNzQ29kZSA9IHRoaXMuc3VjY2Vzc0NvZGVzXy5pbmRleE9mKHN0YXR1cykgIT09IC0xO1xyXG4gICAgICAgICAgICAgICAgYmFja29mZkNhbGxiYWNrKHRydWUsIG5ldyBSZXF1ZXN0RW5kU3RhdHVzKHN1Y2Nlc3NDb2RlLCBjb25uZWN0aW9uKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHJlcXVlc3RXZW50VGhyb3VnaCAtIFRydWUgaWYgdGhlIHJlcXVlc3QgZXZlbnR1YWxseSB3ZW50XHJcbiAgICAgICAgICogICAgIHRocm91Z2gsIGZhbHNlIGlmIGl0IGhpdCB0aGUgcmV0cnkgbGltaXQgb3Igd2FzIGNhbmNlbGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IGJhY2tvZmZEb25lID0gKHJlcXVlc3RXZW50VGhyb3VnaCwgc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSB0aGlzLnJlc29sdmVfO1xyXG4gICAgICAgICAgICBjb25zdCByZWplY3QgPSB0aGlzLnJlamVjdF87XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBzdGF0dXMuY29ubmVjdGlvbjtcclxuICAgICAgICAgICAgaWYgKHN0YXR1cy53YXNTdWNjZXNzQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNhbGxiYWNrXyhjb25uZWN0aW9uLCBjb25uZWN0aW9uLmdldFJlc3BvbnNlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0p1c3REZWYocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IHVua25vd24oKTtcclxuICAgICAgICAgICAgICAgICAgICBlcnIuc2VydmVyUmVzcG9uc2UgPSBjb25uZWN0aW9uLmdldEVycm9yVGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycm9yQ2FsbGJhY2tfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmVycm9yQ2FsbGJhY2tfKGNvbm5lY3Rpb24sIGVycikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jYW5jZWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLmFwcERlbGV0ZV8gPyBhcHBEZWxldGVkKCkgOiBjYW5jZWxlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IHJldHJ5TGltaXRFeGNlZWRlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGVkXykge1xyXG4gICAgICAgICAgICBiYWNrb2ZmRG9uZShmYWxzZSwgbmV3IFJlcXVlc3RFbmRTdGF0dXMoZmFsc2UsIG51bGwsIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja29mZklkXyA9IHN0YXJ0KGRvVGhlUmVxdWVzdCwgYmFja29mZkRvbmUsIHRoaXMudGltZW91dF8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJvbWlzZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlXztcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgY2FuY2VsKGFwcERlbGV0ZSkge1xyXG4gICAgICAgIHRoaXMuY2FuY2VsZWRfID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFwcERlbGV0ZV8gPSBhcHBEZWxldGUgfHwgZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuYmFja29mZklkXyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdG9wKHRoaXMuYmFja29mZklkXyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDb25uZWN0aW9uXyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDb25uZWN0aW9uXy5hYm9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBjb2xsZWN0aW9uIG9mIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZXN1bHQgb2YgYSBuZXR3b3JrIHJlcXVlc3QuXHJcbiAqIEBwYXJhbSBvcHRfY2FuY2VsZWQgLSBEZWZhdWx0cyB0byBmYWxzZS5cclxuICovXHJcbmNsYXNzIFJlcXVlc3RFbmRTdGF0dXMge1xyXG4gICAgY29uc3RydWN0b3Iod2FzU3VjY2Vzc0NvZGUsIGNvbm5lY3Rpb24sIGNhbmNlbGVkKSB7XHJcbiAgICAgICAgdGhpcy53YXNTdWNjZXNzQ29kZSA9IHdhc1N1Y2Nlc3NDb2RlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XHJcbiAgICAgICAgdGhpcy5jYW5jZWxlZCA9ICEhY2FuY2VsZWQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkQXV0aEhlYWRlcl8oaGVhZGVycywgYXV0aFRva2VuKSB7XHJcbiAgICBpZiAoYXV0aFRva2VuICE9PSBudWxsICYmIGF1dGhUb2tlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0ZpcmViYXNlICcgKyBhdXRoVG9rZW47XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkVmVyc2lvbkhlYWRlcl8oaGVhZGVycywgZmlyZWJhc2VWZXJzaW9uKSB7XHJcbiAgICBoZWFkZXJzWydYLUZpcmViYXNlLVN0b3JhZ2UtVmVyc2lvbiddID1cclxuICAgICAgICAnd2VianMvJyArIChmaXJlYmFzZVZlcnNpb24gIT09IG51bGwgJiYgZmlyZWJhc2VWZXJzaW9uICE9PSB2b2lkIDAgPyBmaXJlYmFzZVZlcnNpb24gOiAnQXBwTWFuYWdlcicpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZEdtcGlkSGVhZGVyXyhoZWFkZXJzLCBhcHBJZCkge1xyXG4gICAgaWYgKGFwcElkKSB7XHJcbiAgICAgICAgaGVhZGVyc1snWC1GaXJlYmFzZS1HTVBJRCddID0gYXBwSWQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkQXBwQ2hlY2tIZWFkZXJfKGhlYWRlcnMsIGFwcENoZWNrVG9rZW4pIHtcclxuICAgIGlmIChhcHBDaGVja1Rva2VuICE9PSBudWxsKSB7XHJcbiAgICAgICAgaGVhZGVyc1snWC1GaXJlYmFzZS1BcHBDaGVjayddID0gYXBwQ2hlY2tUb2tlbjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgYXBwSWQsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgcmVxdWVzdEZhY3RvcnksIGZpcmViYXNlVmVyc2lvbiwgcmV0cnkgPSB0cnVlKSB7XHJcbiAgICBjb25zdCBxdWVyeVBhcnQgPSBtYWtlUXVlcnlTdHJpbmcocmVxdWVzdEluZm8udXJsUGFyYW1zKTtcclxuICAgIGNvbnN0IHVybCA9IHJlcXVlc3RJbmZvLnVybCArIHF1ZXJ5UGFydDtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0SW5mby5oZWFkZXJzKTtcclxuICAgIGFkZEdtcGlkSGVhZGVyXyhoZWFkZXJzLCBhcHBJZCk7XHJcbiAgICBhZGRBdXRoSGVhZGVyXyhoZWFkZXJzLCBhdXRoVG9rZW4pO1xyXG4gICAgYWRkVmVyc2lvbkhlYWRlcl8oaGVhZGVycywgZmlyZWJhc2VWZXJzaW9uKTtcclxuICAgIGFkZEFwcENoZWNrSGVhZGVyXyhoZWFkZXJzLCBhcHBDaGVja1Rva2VuKTtcclxuICAgIHJldHVybiBuZXcgTmV0d29ya1JlcXVlc3QodXJsLCByZXF1ZXN0SW5mby5tZXRob2QsIGhlYWRlcnMsIHJlcXVlc3RJbmZvLmJvZHksIHJlcXVlc3RJbmZvLnN1Y2Nlc3NDb2RlcywgcmVxdWVzdEluZm8uYWRkaXRpb25hbFJldHJ5Q29kZXMsIHJlcXVlc3RJbmZvLmhhbmRsZXIsIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciwgcmVxdWVzdEluZm8udGltZW91dCwgcmVxdWVzdEluZm8ucHJvZ3Jlc3NDYWxsYmFjaywgcmVxdWVzdEZhY3RvcnksIHJldHJ5KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCbG9iQnVpbGRlcigpIHtcclxuICAgIGlmICh0eXBlb2YgQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIEJsb2JCdWlsZGVyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIFdlYktpdEJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBXZWJLaXRCbG9iQnVpbGRlcjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbmNhdGVuYXRlcyBvbmUgb3IgbW9yZSB2YWx1ZXMgdG9nZXRoZXIgYW5kIGNvbnZlcnRzIHRoZW0gdG8gYSBCbG9iLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJncyBUaGUgdmFsdWVzIHRoYXQgd2lsbCBtYWtlIHVwIHRoZSByZXN1bHRpbmcgYmxvYi5cclxuICogQHJldHVybiBUaGUgYmxvYi5cclxuICovXHJcbmZ1bmN0aW9uIGdldEJsb2IkMSguLi5hcmdzKSB7XHJcbiAgICBjb25zdCBCbG9iQnVpbGRlciA9IGdldEJsb2JCdWlsZGVyKCk7XHJcbiAgICBpZiAoQmxvYkJ1aWxkZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbnN0IGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJiLmFwcGVuZChhcmdzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJiLmdldEJsb2IoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChpc05hdGl2ZUJsb2JEZWZpbmVkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlVOU1VQUE9SVEVEX0VOVklST05NRU5ULCBcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHNlZW0gdG8gc3VwcG9ydCBjcmVhdGluZyBCbG9ic1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNsaWNlcyB0aGUgYmxvYi4gVGhlIHJldHVybmVkIGJsb2IgY29udGFpbnMgZGF0YSBmcm9tIHRoZSBzdGFydCBieXRlXHJcbiAqIChpbmNsdXNpdmUpIHRpbGwgdGhlIGVuZCBieXRlIChleGNsdXNpdmUpLiBOZWdhdGl2ZSBpbmRpY2VzIGNhbm5vdCBiZSB1c2VkLlxyXG4gKlxyXG4gKiBAcGFyYW0gYmxvYiBUaGUgYmxvYiB0byBiZSBzbGljZWQuXHJcbiAqIEBwYXJhbSBzdGFydCBJbmRleCBvZiB0aGUgc3RhcnRpbmcgYnl0ZS5cclxuICogQHBhcmFtIGVuZCBJbmRleCBvZiB0aGUgZW5kaW5nIGJ5dGUuXHJcbiAqIEByZXR1cm4gVGhlIGJsb2Igc2xpY2Ugb3IgbnVsbCBpZiBub3Qgc3VwcG9ydGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gc2xpY2VCbG9iKGJsb2IsIHN0YXJ0LCBlbmQpIHtcclxuICAgIGlmIChibG9iLndlYmtpdFNsaWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGJsb2Iud2Via2l0U2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChibG9iLm1velNsaWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGJsb2IubW96U2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChibG9iLnNsaWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGJsb2Iuc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogQ29udmVydHMgYSBCYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBiaW5hcnkgc3RyaW5nLiAqL1xyXG5mdW5jdGlvbiBkZWNvZGVCYXNlNjQoZW5jb2RlZCkge1xyXG4gICAgLy8gTm9kZSBhY3R1YWxseSBkb2Vzbid0IHZhbGlkYXRlIGJhc2U2NCBzdHJpbmdzLlxyXG4gICAgLy8gQSBxdWljayBzYW5pdHkgY2hlY2sgdGhhdCBpcyBub3QgYSBmb29sLXByb29mIHZhbGlkYXRpb25cclxuICAgIGlmICgvW14tQS1aYS16MC05Ky89XS8udGVzdChlbmNvZGVkKSkge1xyXG4gICAgICAgIHRocm93IGludmFsaWRGb3JtYXQoJ2Jhc2U2NCcsICdJbnZhbGlkIGNoYXJhY3RlciBmb3VuZCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVuY29kZWQsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5Jyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHRoZSBwb3NzaWJsZSBzdHJpbmcgZm9ybWF0cyBmb3IgdXBsb2FkLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBTdHJpbmdGb3JtYXQgPSB7XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB0aGUgc3RyaW5nIHNob3VsZCBiZSBpbnRlcnByZXRlZCBcInJhd1wiLCB0aGF0IGlzLCBhcyBub3JtYWwgdGV4dC5cclxuICAgICAqIFRoZSBzdHJpbmcgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBVVEYtMTYsIHRoZW4gdXBsb2FkZWQgYXMgYSBVVEYtOCBieXRlXHJcbiAgICAgKiBzZXF1ZW5jZS5cclxuICAgICAqIEV4YW1wbGU6IFRoZSBzdHJpbmcgJ0hlbGxvISBcXFxcdWQ4M2RcXFxcdWRlMGEnIGJlY29tZXMgdGhlIGJ5dGUgc2VxdWVuY2VcclxuICAgICAqIDQ4IDY1IDZjIDZjIDZmIDIxIDIwIGYwIDlmIDk4IDhhXHJcbiAgICAgKi9cclxuICAgIFJBVzogJ3JhdycsXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB0aGUgc3RyaW5nIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBiYXNlNjQtZW5jb2RlZCBkYXRhLlxyXG4gICAgICogUGFkZGluZyBjaGFyYWN0ZXJzICh0cmFpbGluZyAnPSdzKSBhcmUgb3B0aW9uYWwuXHJcbiAgICAgKiBFeGFtcGxlOiBUaGUgc3RyaW5nICdyV21PKytFNnQ3L3Jsdz09JyBiZWNvbWVzIHRoZSBieXRlIHNlcXVlbmNlXHJcbiAgICAgKiBhZCA2OSA4ZSBmYiBlMSAzYSBiNyBiZiBlYiA5N1xyXG4gICAgICovXHJcbiAgICBCQVNFNjQ6ICdiYXNlNjQnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIHN0cmluZyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYmFzZTY0dXJsLWVuY29kZWQgZGF0YS5cclxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyAodHJhaWxpbmcgJz0ncykgYXJlIG9wdGlvbmFsLlxyXG4gICAgICogRXhhbXBsZTogVGhlIHN0cmluZyAncldtTy0tRTZ0N19ybHc9PScgYmVjb21lcyB0aGUgYnl0ZSBzZXF1ZW5jZVxyXG4gICAgICogYWQgNjkgOGUgZmIgZTEgM2EgYjcgYmYgZWIgOTdcclxuICAgICAqL1xyXG4gICAgQkFTRTY0VVJMOiAnYmFzZTY0dXJsJyxcclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHRoZSBzdHJpbmcgaXMgYSBkYXRhIFVSTCwgc3VjaCBhcyBvbmUgb2J0YWluZWQgZnJvbVxyXG4gICAgICogY2FudmFzLnRvRGF0YVVSTCgpLlxyXG4gICAgICogRXhhbXBsZTogdGhlIHN0cmluZyAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LGFhYWEnXHJcbiAgICAgKiBiZWNvbWVzIHRoZSBieXRlIHNlcXVlbmNlXHJcbiAgICAgKiA2OSBhNiA5YVxyXG4gICAgICogKHRoZSBjb250ZW50LXR5cGUgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiBpcyBhbHNvIGFwcGxpZWQsIGJ1dCBjYW5cclxuICAgICAqIGJlIG92ZXJyaWRkZW4gaW4gdGhlIG1ldGFkYXRhIG9iamVjdCkuXHJcbiAgICAgKi9cclxuICAgIERBVEFfVVJMOiAnZGF0YV91cmwnXHJcbn07XHJcbmNsYXNzIFN0cmluZ0RhdGEge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSwgY29udGVudFR5cGUpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBjb250ZW50VHlwZSB8fCBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGRhdGFGcm9tU3RyaW5nKGZvcm1hdCwgc3RyaW5nRGF0YSkge1xyXG4gICAgc3dpdGNoIChmb3JtYXQpIHtcclxuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5SQVc6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nRGF0YSh1dGY4Qnl0ZXNfKHN0cmluZ0RhdGEpKTtcclxuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5CQVNFNjQ6XHJcbiAgICAgICAgY2FzZSBTdHJpbmdGb3JtYXQuQkFTRTY0VVJMOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0RhdGEoYmFzZTY0Qnl0ZXNfKGZvcm1hdCwgc3RyaW5nRGF0YSkpO1xyXG4gICAgICAgIGNhc2UgU3RyaW5nRm9ybWF0LkRBVEFfVVJMOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0RhdGEoZGF0YVVSTEJ5dGVzXyhzdHJpbmdEYXRhKSwgZGF0YVVSTENvbnRlbnRUeXBlXyhzdHJpbmdEYXRhKSk7XHJcbiAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgfVxyXG4gICAgLy8gYXNzZXJ0KGZhbHNlKTtcclxuICAgIHRocm93IHVua25vd24oKTtcclxufVxyXG5mdW5jdGlvbiB1dGY4Qnl0ZXNfKHZhbHVlKSB7XHJcbiAgICBjb25zdCBiID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDw9IDEyNykge1xyXG4gICAgICAgICAgICBiLnB1c2goYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoYyA8PSAyMDQ3KSB7XHJcbiAgICAgICAgICAgICAgICBiLnB1c2goMTkyIHwgKGMgPj4gNiksIDEyOCB8IChjICYgNjMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICgoYyAmIDY0NTEyKSA9PT0gNTUyOTYpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc3RhcnQgb2YgYSBzdXJyb2dhdGUgcGFpci5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IGkgPCB2YWx1ZS5sZW5ndGggLSAxICYmICh2YWx1ZS5jaGFyQ29kZUF0KGkgKyAxKSAmIDY0NTEyKSA9PT0gNTYzMjA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2Vjb25kIHN1cnJvZ2F0ZSB3YXNuJ3QgdGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgyMzksIDE5MSwgMTg5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpID0gYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG8gPSB2YWx1ZS5jaGFyQ29kZUF0KCsraSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSA2NTUzNiB8ICgoaGkgJiAxMDIzKSA8PCAxMCkgfCAobG8gJiAxMDIzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKDI0MCB8IChjID4+IDE4KSwgMTI4IHwgKChjID4+IDEyKSAmIDYzKSwgMTI4IHwgKChjID4+IDYpICYgNjMpLCAxMjggfCAoYyAmIDYzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjICYgNjQ1MTIpID09PSA1NjMyMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGxvdyBzdXJyb2dhdGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgyMzksIDE5MSwgMTg5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgyMjQgfCAoYyA+PiAxMiksIDEyOCB8ICgoYyA+PiA2KSAmIDYzKSwgMTI4IHwgKGMgJiA2MykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShiKTtcclxufVxyXG5mdW5jdGlvbiBwZXJjZW50RW5jb2RlZEJ5dGVzXyh2YWx1ZSkge1xyXG4gICAgbGV0IGRlY29kZWQ7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGRlY29kZWQgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvdyBpbnZhbGlkRm9ybWF0KFN0cmluZ0Zvcm1hdC5EQVRBX1VSTCwgJ01hbGZvcm1lZCBkYXRhIFVSTC4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1dGY4Qnl0ZXNfKGRlY29kZWQpO1xyXG59XHJcbmZ1bmN0aW9uIGJhc2U2NEJ5dGVzXyhmb3JtYXQsIHZhbHVlKSB7XHJcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xyXG4gICAgICAgIGNhc2UgU3RyaW5nRm9ybWF0LkJBU0U2NDoge1xyXG4gICAgICAgICAgICBjb25zdCBoYXNNaW51cyA9IHZhbHVlLmluZGV4T2YoJy0nKSAhPT0gLTE7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhc1VuZGVyID0gdmFsdWUuaW5kZXhPZignXycpICE9PSAtMTtcclxuICAgICAgICAgICAgaWYgKGhhc01pbnVzIHx8IGhhc1VuZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkQ2hhciA9IGhhc01pbnVzID8gJy0nIDogJ18nO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgaW52YWxpZEZvcm1hdChmb3JtYXQsIFwiSW52YWxpZCBjaGFyYWN0ZXIgJ1wiICtcclxuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkQ2hhciArXHJcbiAgICAgICAgICAgICAgICAgICAgXCInIGZvdW5kOiBpcyBpdCBiYXNlNjR1cmwgZW5jb2RlZD9cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgU3RyaW5nRm9ybWF0LkJBU0U2NFVSTDoge1xyXG4gICAgICAgICAgICBjb25zdCBoYXNQbHVzID0gdmFsdWUuaW5kZXhPZignKycpICE9PSAtMTtcclxuICAgICAgICAgICAgY29uc3QgaGFzU2xhc2ggPSB2YWx1ZS5pbmRleE9mKCcvJykgIT09IC0xO1xyXG4gICAgICAgICAgICBpZiAoaGFzUGx1cyB8fCBoYXNTbGFzaCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZENoYXIgPSBoYXNQbHVzID8gJysnIDogJy8nO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgaW52YWxpZEZvcm1hdChmb3JtYXQsIFwiSW52YWxpZCBjaGFyYWN0ZXIgJ1wiICsgaW52YWxpZENoYXIgKyBcIicgZm91bmQ6IGlzIGl0IGJhc2U2NCBlbmNvZGVkP1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICB9XHJcbiAgICBsZXQgYnl0ZXM7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGJ5dGVzID0gZGVjb2RlQmFzZTY0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcygncG9seWZpbGwnKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBpbnZhbGlkRm9ybWF0KGZvcm1hdCwgJ0ludmFsaWQgY2hhcmFjdGVyIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG59XHJcbmNsYXNzIERhdGFVUkxQYXJ0cyB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhVVJMKSB7XHJcbiAgICAgICAgdGhpcy5iYXNlNjQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gbnVsbDtcclxuICAgICAgICBjb25zdCBtYXRjaGVzID0gZGF0YVVSTC5tYXRjaCgvXmRhdGE6KFteLF0rKT8sLyk7XHJcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgaW52YWxpZEZvcm1hdChTdHJpbmdGb3JtYXQuREFUQV9VUkwsIFwiTXVzdCBiZSBmb3JtYXR0ZWQgJ2RhdGE6WzxtZWRpYXR5cGU+XVs7YmFzZTY0XSw8ZGF0YT5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1pZGRsZSA9IG1hdGNoZXNbMV0gfHwgbnVsbDtcclxuICAgICAgICBpZiAobWlkZGxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5iYXNlNjQgPSBlbmRzV2l0aChtaWRkbGUsICc7YmFzZTY0Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudFR5cGUgPSB0aGlzLmJhc2U2NFxyXG4gICAgICAgICAgICAgICAgPyBtaWRkbGUuc3Vic3RyaW5nKDAsIG1pZGRsZS5sZW5ndGggLSAnO2Jhc2U2NCcubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgOiBtaWRkbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzdCA9IGRhdGFVUkwuc3Vic3RyaW5nKGRhdGFVUkwuaW5kZXhPZignLCcpICsgMSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGF0YVVSTEJ5dGVzXyhkYXRhVXJsKSB7XHJcbiAgICBjb25zdCBwYXJ0cyA9IG5ldyBEYXRhVVJMUGFydHMoZGF0YVVybCk7XHJcbiAgICBpZiAocGFydHMuYmFzZTY0KSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2U2NEJ5dGVzXyhTdHJpbmdGb3JtYXQuQkFTRTY0LCBwYXJ0cy5yZXN0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBwZXJjZW50RW5jb2RlZEJ5dGVzXyhwYXJ0cy5yZXN0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBkYXRhVVJMQ29udGVudFR5cGVfKGRhdGFVcmwpIHtcclxuICAgIGNvbnN0IHBhcnRzID0gbmV3IERhdGFVUkxQYXJ0cyhkYXRhVXJsKTtcclxuICAgIHJldHVybiBwYXJ0cy5jb250ZW50VHlwZTtcclxufVxyXG5mdW5jdGlvbiBlbmRzV2l0aChzLCBlbmQpIHtcclxuICAgIGNvbnN0IGxvbmdFbm91Z2ggPSBzLmxlbmd0aCA+PSBlbmQubGVuZ3RoO1xyXG4gICAgaWYgKCFsb25nRW5vdWdoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHMuc3Vic3RyaW5nKHMubGVuZ3RoIC0gZW5kLmxlbmd0aCkgPT09IGVuZDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQHBhcmFtIG9wdF9lbGlkZUNvcHkgLSBJZiB0cnVlLCBkb2Vzbid0IGNvcHkgbXV0YWJsZSBpbnB1dCBkYXRhXHJcbiAqICAgICAoZS5nLiBVaW50OEFycmF5cykuIFBhc3MgdHJ1ZSBvbmx5IGlmIHlvdSBrbm93IHRoZSBvYmplY3RzIHdpbGwgbm90IGJlXHJcbiAqICAgICBtb2RpZmllZCBhZnRlciB0aGlzIGJsb2IncyBjb25zdHJ1Y3Rpb24uXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgRmJzQmxvYiB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBlbGlkZUNvcHkpIHtcclxuICAgICAgICBsZXQgc2l6ZSA9IDA7XHJcbiAgICAgICAgbGV0IGJsb2JUeXBlID0gJyc7XHJcbiAgICAgICAgaWYgKGlzTmF0aXZlQmxvYihkYXRhKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcclxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcclxuICAgICAgICAgICAgYmxvYlR5cGUgPSBkYXRhLnR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICBpZiAoZWxpZGVDb3B5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFfID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFfID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8uc2V0KG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzaXplID0gdGhpcy5kYXRhXy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICAgICAgICAgIGlmIChlbGlkZUNvcHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8gPSBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8uc2V0KGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zaXplXyA9IHNpemU7XHJcbiAgICAgICAgdGhpcy50eXBlXyA9IGJsb2JUeXBlO1xyXG4gICAgfVxyXG4gICAgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaXplXztcclxuICAgIH1cclxuICAgIHR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZV87XHJcbiAgICB9XHJcbiAgICBzbGljZShzdGFydEJ5dGUsIGVuZEJ5dGUpIHtcclxuICAgICAgICBpZiAoaXNOYXRpdmVCbG9iKHRoaXMuZGF0YV8pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWxCbG9iID0gdGhpcy5kYXRhXztcclxuICAgICAgICAgICAgY29uc3Qgc2xpY2VkID0gc2xpY2VCbG9iKHJlYWxCbG9iLCBzdGFydEJ5dGUsIGVuZEJ5dGUpO1xyXG4gICAgICAgICAgICBpZiAoc2xpY2VkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZic0Jsb2Ioc2xpY2VkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhXy5idWZmZXIsIHN0YXJ0Qnl0ZSwgZW5kQnl0ZSAtIHN0YXJ0Qnl0ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmJzQmxvYihzbGljZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEJsb2IoLi4uYXJncykge1xyXG4gICAgICAgIGlmIChpc05hdGl2ZUJsb2JEZWZpbmVkKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgYmxvYmJ5ID0gYXJncy5tYXAoKHZhbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEZic0Jsb2IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLmRhdGFfO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmJzQmxvYihnZXRCbG9iJDEuYXBwbHkobnVsbCwgYmxvYmJ5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB1aW50OEFycmF5cyA9IGFyZ3MubWFwKCh2YWwpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFGcm9tU3RyaW5nKFN0cmluZ0Zvcm1hdC5SQVcsIHZhbCkuZGF0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJsb2JzIGRvbid0IGV4aXN0LCBzbyB0aGlzIGhhcyB0byBiZSBhIFVpbnQ4QXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5kYXRhXztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxldCBmaW5hbExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHVpbnQ4QXJyYXlzLmZvckVhY2goKGFycmF5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBmaW5hbExlbmd0aCArPSBhcnJheS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IFVpbnQ4QXJyYXkoZmluYWxMZW5ndGgpO1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICB1aW50OEFycmF5cy5mb3JFYWNoKChhcnJheSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFtpbmRleCsrXSA9IGFycmF5W2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYnNCbG9iKG1lcmdlZCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBsb2FkRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhXztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgT2JqZWN0IHJlc3VsdGluZyBmcm9tIHBhcnNpbmcgdGhlIGdpdmVuIEpTT04sIG9yIG51bGwgaWYgdGhlXHJcbiAqIGdpdmVuIHN0cmluZyBkb2VzIG5vdCByZXByZXNlbnQgYSBKU09OIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGpzb25PYmplY3RPck51bGwocykge1xyXG4gICAgbGV0IG9iajtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgb2JqID0gSlNPTi5wYXJzZShzKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOb25BcnJheU9iamVjdChvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnRhaW5zIGhlbHBlciBtZXRob2RzIGZvciBtYW5pcHVsYXRpbmcgcGF0aHMuXHJcbiAqL1xyXG4vKipcclxuICogQHJldHVybiBOdWxsIGlmIHRoZSBwYXRoIGlzIGFscmVhZHkgYXQgdGhlIHJvb3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJlbnQocGF0aCkge1xyXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcclxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdQYXRoID0gcGF0aC5zbGljZSgwLCBpbmRleCk7XHJcbiAgICByZXR1cm4gbmV3UGF0aDtcclxufVxyXG5mdW5jdGlvbiBjaGlsZChwYXRoLCBjaGlsZFBhdGgpIHtcclxuICAgIGNvbnN0IGNhbm9uaWNhbENoaWxkUGF0aCA9IGNoaWxkUGF0aFxyXG4gICAgICAgIC5zcGxpdCgnLycpXHJcbiAgICAgICAgLmZpbHRlcihjb21wb25lbnQgPT4gY29tcG9uZW50Lmxlbmd0aCA+IDApXHJcbiAgICAgICAgLmpvaW4oJy8nKTtcclxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBjYW5vbmljYWxDaGlsZFBhdGg7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcGF0aCArICcvJyArIGNhbm9uaWNhbENoaWxkUGF0aDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbGFzdCBjb21wb25lbnQgb2YgYSBwYXRoLlxyXG4gKiAnL2Zvby9iYXInIC0+ICdiYXInXHJcbiAqICcvZm9vL2Jhci9iYXovJyAtPiAnYmF6LydcclxuICogJy9hJyAtPiAnYSdcclxuICovXHJcbmZ1bmN0aW9uIGxhc3RDb21wb25lbnQocGF0aCkge1xyXG4gICAgY29uc3QgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJywgcGF0aC5sZW5ndGggLSAyKTtcclxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKGluZGV4ICsgMSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbm9YZm9ybV8obWV0YWRhdGEsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuY2xhc3MgTWFwcGluZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXIsIGxvY2FsLCB3cml0YWJsZSwgeGZvcm0pIHtcclxuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcclxuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWwgfHwgc2VydmVyO1xyXG4gICAgICAgIHRoaXMud3JpdGFibGUgPSAhIXdyaXRhYmxlO1xyXG4gICAgICAgIHRoaXMueGZvcm0gPSB4Zm9ybSB8fCBub1hmb3JtXztcclxuICAgIH1cclxufVxyXG5sZXQgbWFwcGluZ3NfID0gbnVsbDtcclxuZnVuY3Rpb24geGZvcm1QYXRoKGZ1bGxQYXRoKSB7XHJcbiAgICBpZiAoIWlzU3RyaW5nKGZ1bGxQYXRoKSB8fCBmdWxsUGF0aC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bGxQYXRoO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGxhc3RDb21wb25lbnQoZnVsbFBhdGgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldE1hcHBpbmdzKCkge1xyXG4gICAgaWYgKG1hcHBpbmdzXykge1xyXG4gICAgICAgIHJldHVybiBtYXBwaW5nc187XHJcbiAgICB9XHJcbiAgICBjb25zdCBtYXBwaW5ncyA9IFtdO1xyXG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnYnVja2V0JykpO1xyXG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnZ2VuZXJhdGlvbicpKTtcclxuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ21ldGFnZW5lcmF0aW9uJykpO1xyXG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnbmFtZScsICdmdWxsUGF0aCcsIHRydWUpKTtcclxuICAgIGZ1bmN0aW9uIG1hcHBpbmdzWGZvcm1QYXRoKF9tZXRhZGF0YSwgZnVsbFBhdGgpIHtcclxuICAgICAgICByZXR1cm4geGZvcm1QYXRoKGZ1bGxQYXRoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5hbWVNYXBwaW5nID0gbmV3IE1hcHBpbmcoJ25hbWUnKTtcclxuICAgIG5hbWVNYXBwaW5nLnhmb3JtID0gbWFwcGluZ3NYZm9ybVBhdGg7XHJcbiAgICBtYXBwaW5ncy5wdXNoKG5hbWVNYXBwaW5nKTtcclxuICAgIC8qKlxyXG4gICAgICogQ29lcmNlcyB0aGUgc2Vjb25kIHBhcmFtIHRvIGEgbnVtYmVyLCBpZiBpdCBpcyBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB4Zm9ybVNpemUoX21ldGFkYXRhLCBzaXplKSB7XHJcbiAgICAgICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgc2l6ZU1hcHBpbmcgPSBuZXcgTWFwcGluZygnc2l6ZScpO1xyXG4gICAgc2l6ZU1hcHBpbmcueGZvcm0gPSB4Zm9ybVNpemU7XHJcbiAgICBtYXBwaW5ncy5wdXNoKHNpemVNYXBwaW5nKTtcclxuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ3RpbWVDcmVhdGVkJykpO1xyXG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygndXBkYXRlZCcpKTtcclxuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ21kNUhhc2gnLCBudWxsLCB0cnVlKSk7XHJcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjYWNoZUNvbnRyb2wnLCBudWxsLCB0cnVlKSk7XHJcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjb250ZW50RGlzcG9zaXRpb24nLCBudWxsLCB0cnVlKSk7XHJcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjb250ZW50RW5jb2RpbmcnLCBudWxsLCB0cnVlKSk7XHJcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjb250ZW50TGFuZ3VhZ2UnLCBudWxsLCB0cnVlKSk7XHJcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjb250ZW50VHlwZScsIG51bGwsIHRydWUpKTtcclxuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ21ldGFkYXRhJywgJ2N1c3RvbU1ldGFkYXRhJywgdHJ1ZSkpO1xyXG4gICAgbWFwcGluZ3NfID0gbWFwcGluZ3M7XHJcbiAgICByZXR1cm4gbWFwcGluZ3NfO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFJlZihtZXRhZGF0YSwgc2VydmljZSkge1xyXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVSZWYoKSB7XHJcbiAgICAgICAgY29uc3QgYnVja2V0ID0gbWV0YWRhdGFbJ2J1Y2tldCddO1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBtZXRhZGF0YVsnZnVsbFBhdGgnXTtcclxuICAgICAgICBjb25zdCBsb2MgPSBuZXcgTG9jYXRpb24oYnVja2V0LCBwYXRoKTtcclxuICAgICAgICByZXR1cm4gc2VydmljZS5fbWFrZVN0b3JhZ2VSZWZlcmVuY2UobG9jKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRhZGF0YSwgJ3JlZicsIHsgZ2V0OiBnZW5lcmF0ZVJlZiB9KTtcclxufVxyXG5mdW5jdGlvbiBmcm9tUmVzb3VyY2Uoc2VydmljZSwgcmVzb3VyY2UsIG1hcHBpbmdzKSB7XHJcbiAgICBjb25zdCBtZXRhZGF0YSA9IHt9O1xyXG4gICAgbWV0YWRhdGFbJ3R5cGUnXSA9ICdmaWxlJztcclxuICAgIGNvbnN0IGxlbiA9IG1hcHBpbmdzLmxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBjb25zdCBtYXBwaW5nID0gbWFwcGluZ3NbaV07XHJcbiAgICAgICAgbWV0YWRhdGFbbWFwcGluZy5sb2NhbF0gPSBtYXBwaW5nLnhmb3JtKG1ldGFkYXRhLCByZXNvdXJjZVttYXBwaW5nLnNlcnZlcl0pO1xyXG4gICAgfVxyXG4gICAgYWRkUmVmKG1ldGFkYXRhLCBzZXJ2aWNlKTtcclxuICAgIHJldHVybiBtZXRhZGF0YTtcclxufVxyXG5mdW5jdGlvbiBmcm9tUmVzb3VyY2VTdHJpbmcoc2VydmljZSwgcmVzb3VyY2VTdHJpbmcsIG1hcHBpbmdzKSB7XHJcbiAgICBjb25zdCBvYmogPSBqc29uT2JqZWN0T3JOdWxsKHJlc291cmNlU3RyaW5nKTtcclxuICAgIGlmIChvYmogPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc291cmNlID0gb2JqO1xyXG4gICAgcmV0dXJuIGZyb21SZXNvdXJjZShzZXJ2aWNlLCByZXNvdXJjZSwgbWFwcGluZ3MpO1xyXG59XHJcbmZ1bmN0aW9uIGRvd25sb2FkVXJsRnJvbVJlc291cmNlU3RyaW5nKG1ldGFkYXRhLCByZXNvdXJjZVN0cmluZywgaG9zdCwgcHJvdG9jb2wpIHtcclxuICAgIGNvbnN0IG9iaiA9IGpzb25PYmplY3RPck51bGwocmVzb3VyY2VTdHJpbmcpO1xyXG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1N0cmluZyhvYmpbJ2Rvd25sb2FkVG9rZW5zJ10pKSB7XHJcbiAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIG9iamVjdHMgYXJlIHVwbG9hZGVkIHRocm91Z2ggR0NTIGFuZCByZXRyaWV2ZWRcclxuICAgICAgICAvLyB0aHJvdWdoIGxpc3QsIHNvIHdlIGRvbid0IHdhbnQgdG8gdGhyb3cgYW4gRXJyb3IuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0b2tlbnMgPSBvYmpbJ2Rvd25sb2FkVG9rZW5zJ107XHJcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZW5jb2RlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xyXG4gICAgY29uc3QgdG9rZW5zTGlzdCA9IHRva2Vucy5zcGxpdCgnLCcpO1xyXG4gICAgY29uc3QgdXJscyA9IHRva2Vuc0xpc3QubWFwKCh0b2tlbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IG1ldGFkYXRhWydidWNrZXQnXTtcclxuICAgICAgICBjb25zdCBwYXRoID0gbWV0YWRhdGFbJ2Z1bGxQYXRoJ107XHJcbiAgICAgICAgY29uc3QgdXJsUGFydCA9ICcvYi8nICsgZW5jb2RlKGJ1Y2tldCkgKyAnL28vJyArIGVuY29kZShwYXRoKTtcclxuICAgICAgICBjb25zdCBiYXNlID0gbWFrZVVybCh1cmxQYXJ0LCBob3N0LCBwcm90b2NvbCk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSBtYWtlUXVlcnlTdHJpbmcoe1xyXG4gICAgICAgICAgICBhbHQ6ICdtZWRpYScsXHJcbiAgICAgICAgICAgIHRva2VuXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGJhc2UgKyBxdWVyeVN0cmluZztcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHVybHNbMF07XHJcbn1cclxuZnVuY3Rpb24gdG9SZXNvdXJjZVN0cmluZyhtZXRhZGF0YSwgbWFwcGluZ3MpIHtcclxuICAgIGNvbnN0IHJlc291cmNlID0ge307XHJcbiAgICBjb25zdCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xyXG4gICAgICAgIGlmIChtYXBwaW5nLndyaXRhYmxlKSB7XHJcbiAgICAgICAgICAgIHJlc291cmNlW21hcHBpbmcuc2VydmVyXSA9IG1ldGFkYXRhW21hcHBpbmcubG9jYWxdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXNvdXJjZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgUFJFRklYRVNfS0VZID0gJ3ByZWZpeGVzJztcclxuY29uc3QgSVRFTVNfS0VZID0gJ2l0ZW1zJztcclxuZnVuY3Rpb24gZnJvbUJhY2tlbmRSZXNwb25zZShzZXJ2aWNlLCBidWNrZXQsIHJlc291cmNlKSB7XHJcbiAgICBjb25zdCBsaXN0UmVzdWx0ID0ge1xyXG4gICAgICAgIHByZWZpeGVzOiBbXSxcclxuICAgICAgICBpdGVtczogW10sXHJcbiAgICAgICAgbmV4dFBhZ2VUb2tlbjogcmVzb3VyY2VbJ25leHRQYWdlVG9rZW4nXVxyXG4gICAgfTtcclxuICAgIGlmIChyZXNvdXJjZVtQUkVGSVhFU19LRVldKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHJlc291cmNlW1BSRUZJWEVTX0tFWV0pIHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aFdpdGhvdXRUcmFpbGluZ1NsYXNoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpO1xyXG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2UgPSBzZXJ2aWNlLl9tYWtlU3RvcmFnZVJlZmVyZW5jZShuZXcgTG9jYXRpb24oYnVja2V0LCBwYXRoV2l0aG91dFRyYWlsaW5nU2xhc2gpKTtcclxuICAgICAgICAgICAgbGlzdFJlc3VsdC5wcmVmaXhlcy5wdXNoKHJlZmVyZW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHJlc291cmNlW0lURU1TX0tFWV0pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVzb3VyY2VbSVRFTVNfS0VZXSkge1xyXG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2UgPSBzZXJ2aWNlLl9tYWtlU3RvcmFnZVJlZmVyZW5jZShuZXcgTG9jYXRpb24oYnVja2V0LCBpdGVtWyduYW1lJ10pKTtcclxuICAgICAgICAgICAgbGlzdFJlc3VsdC5pdGVtcy5wdXNoKHJlZmVyZW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxpc3RSZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVJlc3BvbnNlU3RyaW5nKHNlcnZpY2UsIGJ1Y2tldCwgcmVzb3VyY2VTdHJpbmcpIHtcclxuICAgIGNvbnN0IG9iaiA9IGpzb25PYmplY3RPck51bGwocmVzb3VyY2VTdHJpbmcpO1xyXG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzb3VyY2UgPSBvYmo7XHJcbiAgICByZXR1cm4gZnJvbUJhY2tlbmRSZXNwb25zZShzZXJ2aWNlLCBidWNrZXQsIHJlc291cmNlKTtcclxufVxuXG4vKipcclxuICogQ29udGFpbnMgYSBmdWxseSBzcGVjaWZpZWQgcmVxdWVzdC5cclxuICpcclxuICogQHBhcmFtIEkgLSB0aGUgdHlwZSBvZiB0aGUgYmFja2VuZCdzIG5ldHdvcmsgcmVzcG9uc2UuXHJcbiAqIEBwYXJhbSBPIC0gdGhlIG91dHB1dCByZXNwb25zZSB0eXBlIHVzZWQgYnkgdGhlIHJlc3Qgb2YgdGhlIFNESy5cclxuICovXHJcbmNsYXNzIFJlcXVlc3RJbmZvIHtcclxuICAgIGNvbnN0cnVjdG9yKHVybCwgbWV0aG9kLCBcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgd2l0aCB3aGljaCB0byByZXNvbHZlIHRoZSByZXF1ZXN0J3MgcHJvbWlzZS4gT25seSBjYWxsZWRcclxuICAgICAqIGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuIFRocm93IGZyb20gdGhpcyBmdW5jdGlvbiB0byByZWplY3QgdGhlXHJcbiAgICAgKiByZXR1cm5lZCBSZXF1ZXN0J3MgcHJvbWlzZSB3aXRoIHRoZSB0aHJvd24gZXJyb3IuXHJcbiAgICAgKiBOb3RlOiBUaGUgWGhySW8gcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gbWF5IGJlIHJldXNlZCBhZnRlciB0aGlzIGNhbGxiYWNrXHJcbiAgICAgKiByZXR1cm5zLiBEbyBub3Qga2VlcCBhIHJlZmVyZW5jZSB0byBpdCBpbiBhbnkgd2F5LlxyXG4gICAgICovXHJcbiAgICBoYW5kbGVyLCB0aW1lb3V0KSB7XHJcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xyXG4gICAgICAgIHRoaXMudXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbGVkIHdpdGggdGhlIGN1cnJlbnQgbnVtYmVyIG9mIGJ5dGVzIHVwbG9hZGVkIGFuZCB0b3RhbCBzaXplICgtMSBpZiBub3RcclxuICAgICAgICAgKiBjb21wdXRhYmxlKSBvZiB0aGUgcmVxdWVzdCBib2R5IChpLmUuIHVzZWQgdG8gcmVwb3J0IHVwbG9hZCBwcm9ncmVzcykuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc0NhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN1Y2Nlc3NDb2RlcyA9IFsyMDBdO1xyXG4gICAgICAgIHRoaXMuYWRkaXRpb25hbFJldHJ5Q29kZXMgPSBbXTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhyb3dzIHRoZSBVTktOT1dOIFN0b3JhZ2VFcnJvciBpZiBjbmRuIGlzIGZhbHNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaGFuZGxlckNoZWNrKGNuZG4pIHtcclxuICAgIGlmICghY25kbikge1xyXG4gICAgICAgIHRocm93IHVua25vd24oKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtZXRhZGF0YUhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpIHtcclxuICAgIGZ1bmN0aW9uIGhhbmRsZXIoeGhyLCB0ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBmcm9tUmVzb3VyY2VTdHJpbmcoc2VydmljZSwgdGV4dCwgbWFwcGluZ3MpO1xyXG4gICAgICAgIGhhbmRsZXJDaGVjayhtZXRhZGF0YSAhPT0gbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhbmRsZXI7XHJcbn1cclxuZnVuY3Rpb24gbGlzdEhhbmRsZXIoc2VydmljZSwgYnVja2V0KSB7XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhociwgdGV4dCkge1xyXG4gICAgICAgIGNvbnN0IGxpc3RSZXN1bHQgPSBmcm9tUmVzcG9uc2VTdHJpbmcoc2VydmljZSwgYnVja2V0LCB0ZXh0KTtcclxuICAgICAgICBoYW5kbGVyQ2hlY2sobGlzdFJlc3VsdCAhPT0gbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIGxpc3RSZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFuZGxlcjtcclxufVxyXG5mdW5jdGlvbiBkb3dubG9hZFVybEhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpIHtcclxuICAgIGZ1bmN0aW9uIGhhbmRsZXIoeGhyLCB0ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBmcm9tUmVzb3VyY2VTdHJpbmcoc2VydmljZSwgdGV4dCwgbWFwcGluZ3MpO1xyXG4gICAgICAgIGhhbmRsZXJDaGVjayhtZXRhZGF0YSAhPT0gbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIGRvd25sb2FkVXJsRnJvbVJlc291cmNlU3RyaW5nKG1ldGFkYXRhLCB0ZXh0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcclxuICAgIH1cclxuICAgIHJldHVybiBoYW5kbGVyO1xyXG59XHJcbmZ1bmN0aW9uIHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbikge1xyXG4gICAgZnVuY3Rpb24gZXJyb3JIYW5kbGVyKHhociwgZXJyKSB7XHJcbiAgICAgICAgbGV0IG5ld0VycjtcclxuICAgICAgICBpZiAoeGhyLmdldFN0YXR1cygpID09PSA0MDEpIHtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAvLyBUaGlzIGV4YWN0IG1lc3NhZ2Ugc3RyaW5nIGlzIHRoZSBvbmx5IGNvbnNpc3RlbnQgcGFydCBvZiB0aGVcclxuICAgICAgICAgICAgLy8gc2VydmVyJ3MgZXJyb3IgcmVzcG9uc2UgdGhhdCBpZGVudGlmaWVzIGl0IGFzIGFuIEFwcCBDaGVjayBlcnJvci5cclxuICAgICAgICAgICAgeGhyLmdldEVycm9yVGV4dCgpLmluY2x1ZGVzKCdGaXJlYmFzZSBBcHAgQ2hlY2sgdG9rZW4gaXMgaW52YWxpZCcpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdFcnIgPSB1bmF1dGhvcml6ZWRBcHAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld0VyciA9IHVuYXV0aGVudGljYXRlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoeGhyLmdldFN0YXR1cygpID09PSA0MDIpIHtcclxuICAgICAgICAgICAgICAgIG5ld0VyciA9IHF1b3RhRXhjZWVkZWQobG9jYXRpb24uYnVja2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh4aHIuZ2V0U3RhdHVzKCkgPT09IDQwMykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0VyciA9IHVuYXV0aG9yaXplZChsb2NhdGlvbi5wYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0VyciA9IGVycjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBuZXdFcnIuc3RhdHVzID0geGhyLmdldFN0YXR1cygpO1xyXG4gICAgICAgIG5ld0Vyci5zZXJ2ZXJSZXNwb25zZSA9IGVyci5zZXJ2ZXJSZXNwb25zZTtcclxuICAgICAgICByZXR1cm4gbmV3RXJyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVycm9ySGFuZGxlcjtcclxufVxyXG5mdW5jdGlvbiBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pIHtcclxuICAgIGNvbnN0IHNoYXJlZCA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XHJcbiAgICBmdW5jdGlvbiBlcnJvckhhbmRsZXIoeGhyLCBlcnIpIHtcclxuICAgICAgICBsZXQgbmV3RXJyID0gc2hhcmVkKHhociwgZXJyKTtcclxuICAgICAgICBpZiAoeGhyLmdldFN0YXR1cygpID09PSA0MDQpIHtcclxuICAgICAgICAgICAgbmV3RXJyID0gb2JqZWN0Tm90Rm91bmQobG9jYXRpb24ucGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ld0Vyci5zZXJ2ZXJSZXNwb25zZSA9IGVyci5zZXJ2ZXJSZXNwb25zZTtcclxuICAgICAgICByZXR1cm4gbmV3RXJyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVycm9ySGFuZGxlcjtcclxufVxyXG5mdW5jdGlvbiBnZXRNZXRhZGF0YSQyKHNlcnZpY2UsIGxvY2F0aW9uLCBtYXBwaW5ncykge1xyXG4gICAgY29uc3QgdXJsUGFydCA9IGxvY2F0aW9uLmZ1bGxTZXJ2ZXJVcmwoKTtcclxuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XHJcbiAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heE9wZXJhdGlvblJldHJ5VGltZTtcclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBtZXRhZGF0YUhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpLCB0aW1lb3V0KTtcclxuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IG9iamVjdEVycm9ySGFuZGxlcihsb2NhdGlvbik7XHJcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XHJcbn1cclxuZnVuY3Rpb24gbGlzdCQyKHNlcnZpY2UsIGxvY2F0aW9uLCBkZWxpbWl0ZXIsIHBhZ2VUb2tlbiwgbWF4UmVzdWx0cykge1xyXG4gICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICBpZiAobG9jYXRpb24uaXNSb290KSB7XHJcbiAgICAgICAgdXJsUGFyYW1zWydwcmVmaXgnXSA9ICcnO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdXJsUGFyYW1zWydwcmVmaXgnXSA9IGxvY2F0aW9uLnBhdGggKyAnLyc7XHJcbiAgICB9XHJcbiAgICBpZiAoZGVsaW1pdGVyICYmIGRlbGltaXRlci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdXJsUGFyYW1zWydkZWxpbWl0ZXInXSA9IGRlbGltaXRlcjtcclxuICAgIH1cclxuICAgIGlmIChwYWdlVG9rZW4pIHtcclxuICAgICAgICB1cmxQYXJhbXNbJ3BhZ2VUb2tlbiddID0gcGFnZVRva2VuO1xyXG4gICAgfVxyXG4gICAgaWYgKG1heFJlc3VsdHMpIHtcclxuICAgICAgICB1cmxQYXJhbXNbJ21heFJlc3VsdHMnXSA9IG1heFJlc3VsdHM7XHJcbiAgICB9XHJcbiAgICBjb25zdCB1cmxQYXJ0ID0gbG9jYXRpb24uYnVja2V0T25seVNlcnZlclVybCgpO1xyXG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcclxuICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xyXG4gICAgY29uc3QgdGltZW91dCA9IHNlcnZpY2UubWF4T3BlcmF0aW9uUmV0cnlUaW1lO1xyXG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIGxpc3RIYW5kbGVyKHNlcnZpY2UsIGxvY2F0aW9uLmJ1Y2tldCksIHRpbWVvdXQpO1xyXG4gICAgcmVxdWVzdEluZm8udXJsUGFyYW1zID0gdXJsUGFyYW1zO1xyXG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcclxuICAgIHJldHVybiByZXF1ZXN0SW5mbztcclxufVxyXG5mdW5jdGlvbiBnZXRCeXRlcyQxKHNlcnZpY2UsIGxvY2F0aW9uLCBtYXhEb3dubG9hZFNpemVCeXRlcykge1xyXG4gICAgY29uc3QgdXJsUGFydCA9IGxvY2F0aW9uLmZ1bGxTZXJ2ZXJVcmwoKTtcclxuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCkgKyAnP2FsdD1tZWRpYSc7XHJcbiAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heE9wZXJhdGlvblJldHJ5VGltZTtcclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCAoXywgZGF0YSkgPT4gZGF0YSwgdGltZW91dCk7XHJcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xyXG4gICAgaWYgKG1heERvd25sb2FkU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXF1ZXN0SW5mby5oZWFkZXJzWydSYW5nZSddID0gYGJ5dGVzPTAtJHttYXhEb3dubG9hZFNpemVCeXRlc31gO1xyXG4gICAgICAgIHJlcXVlc3RJbmZvLnN1Y2Nlc3NDb2RlcyA9IFsyMDAgLyogT0sgKi8sIDIwNiAvKiBQYXJ0aWFsIENvbnRlbnQgKi9dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xyXG59XHJcbmZ1bmN0aW9uIGdldERvd25sb2FkVXJsKHNlcnZpY2UsIGxvY2F0aW9uLCBtYXBwaW5ncykge1xyXG4gICAgY29uc3QgdXJsUGFydCA9IGxvY2F0aW9uLmZ1bGxTZXJ2ZXJVcmwoKTtcclxuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XHJcbiAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heE9wZXJhdGlvblJldHJ5VGltZTtcclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBkb3dubG9hZFVybEhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpLCB0aW1lb3V0KTtcclxuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IG9iamVjdEVycm9ySGFuZGxlcihsb2NhdGlvbik7XHJcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlTWV0YWRhdGEkMihzZXJ2aWNlLCBsb2NhdGlvbiwgbWV0YWRhdGEsIG1hcHBpbmdzKSB7XHJcbiAgICBjb25zdCB1cmxQYXJ0ID0gbG9jYXRpb24uZnVsbFNlcnZlclVybCgpO1xyXG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcclxuICAgIGNvbnN0IG1ldGhvZCA9ICdQQVRDSCc7XHJcbiAgICBjb25zdCBib2R5ID0gdG9SZXNvdXJjZVN0cmluZyhtZXRhZGF0YSwgbWFwcGluZ3MpO1xyXG4gICAgY29uc3QgaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04JyB9O1xyXG4gICAgY29uc3QgdGltZW91dCA9IHNlcnZpY2UubWF4T3BlcmF0aW9uUmV0cnlUaW1lO1xyXG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIG1ldGFkYXRhSGFuZGxlcihzZXJ2aWNlLCBtYXBwaW5ncyksIHRpbWVvdXQpO1xyXG4gICAgcmVxdWVzdEluZm8uaGVhZGVycyA9IGhlYWRlcnM7XHJcbiAgICByZXF1ZXN0SW5mby5ib2R5ID0gYm9keTtcclxuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IG9iamVjdEVycm9ySGFuZGxlcihsb2NhdGlvbik7XHJcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlT2JqZWN0JDIoc2VydmljZSwgbG9jYXRpb24pIHtcclxuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5mdWxsU2VydmVyVXJsKCk7XHJcbiAgICBjb25zdCB1cmwgPSBtYWtlVXJsKHVybFBhcnQsIHNlcnZpY2UuaG9zdCwgc2VydmljZS5fcHJvdG9jb2wpO1xyXG4gICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XHJcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhPcGVyYXRpb25SZXRyeVRpbWU7XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVyKF94aHIsIF90ZXh0KSB7IH1cclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBoYW5kbGVyLCB0aW1lb3V0KTtcclxuICAgIHJlcXVlc3RJbmZvLnN1Y2Nlc3NDb2RlcyA9IFsyMDAsIDIwNF07XHJcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xyXG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xyXG59XHJcbmZ1bmN0aW9uIGRldGVybWluZUNvbnRlbnRUeXBlXyhtZXRhZGF0YSwgYmxvYikge1xyXG4gICAgcmV0dXJuICgobWV0YWRhdGEgJiYgbWV0YWRhdGFbJ2NvbnRlbnRUeXBlJ10pIHx8XHJcbiAgICAgICAgKGJsb2IgJiYgYmxvYi50eXBlKCkpIHx8XHJcbiAgICAgICAgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xyXG59XHJcbmZ1bmN0aW9uIG1ldGFkYXRhRm9yVXBsb2FkXyhsb2NhdGlvbiwgYmxvYiwgbWV0YWRhdGEpIHtcclxuICAgIGNvbnN0IG1ldGFkYXRhQ2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCBtZXRhZGF0YSk7XHJcbiAgICBtZXRhZGF0YUNsb25lWydmdWxsUGF0aCddID0gbG9jYXRpb24ucGF0aDtcclxuICAgIG1ldGFkYXRhQ2xvbmVbJ3NpemUnXSA9IGJsb2Iuc2l6ZSgpO1xyXG4gICAgaWYgKCFtZXRhZGF0YUNsb25lWydjb250ZW50VHlwZSddKSB7XHJcbiAgICAgICAgbWV0YWRhdGFDbG9uZVsnY29udGVudFR5cGUnXSA9IGRldGVybWluZUNvbnRlbnRUeXBlXyhudWxsLCBibG9iKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtZXRhZGF0YUNsb25lO1xyXG59XHJcbi8qKlxyXG4gKiBQcmVwYXJlIFJlcXVlc3RJbmZvIGZvciB1cGxvYWRzIGFzIENvbnRlbnQtVHlwZTogbXVsdGlwYXJ0LlxyXG4gKi9cclxuZnVuY3Rpb24gbXVsdGlwYXJ0VXBsb2FkKHNlcnZpY2UsIGxvY2F0aW9uLCBtYXBwaW5ncywgYmxvYiwgbWV0YWRhdGEpIHtcclxuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5idWNrZXRPbmx5U2VydmVyVXJsKCk7XHJcbiAgICBjb25zdCBoZWFkZXJzID0ge1xyXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLVByb3RvY29sJzogJ211bHRpcGFydCdcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBnZW5Cb3VuZGFyeSgpIHtcclxuICAgICAgICBsZXQgc3RyID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcclxuICAgICAgICAgICAgc3RyID0gc3RyICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnNsaWNlKDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYm91bmRhcnkgPSBnZW5Cb3VuZGFyeSgpO1xyXG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnbXVsdGlwYXJ0L3JlbGF0ZWQ7IGJvdW5kYXJ5PScgKyBib3VuZGFyeTtcclxuICAgIGNvbnN0IG1ldGFkYXRhXyA9IG1ldGFkYXRhRm9yVXBsb2FkXyhsb2NhdGlvbiwgYmxvYiwgbWV0YWRhdGEpO1xyXG4gICAgY29uc3QgbWV0YWRhdGFTdHJpbmcgPSB0b1Jlc291cmNlU3RyaW5nKG1ldGFkYXRhXywgbWFwcGluZ3MpO1xyXG4gICAgY29uc3QgcHJlQmxvYlBhcnQgPSAnLS0nICtcclxuICAgICAgICBib3VuZGFyeSArXHJcbiAgICAgICAgJ1xcclxcbicgK1xyXG4gICAgICAgICdDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcXHJcXG5cXHJcXG4nICtcclxuICAgICAgICBtZXRhZGF0YVN0cmluZyArXHJcbiAgICAgICAgJ1xcclxcbi0tJyArXHJcbiAgICAgICAgYm91bmRhcnkgK1xyXG4gICAgICAgICdcXHJcXG4nICtcclxuICAgICAgICAnQ29udGVudC1UeXBlOiAnICtcclxuICAgICAgICBtZXRhZGF0YV9bJ2NvbnRlbnRUeXBlJ10gK1xyXG4gICAgICAgICdcXHJcXG5cXHJcXG4nO1xyXG4gICAgY29uc3QgcG9zdEJsb2JQYXJ0ID0gJ1xcclxcbi0tJyArIGJvdW5kYXJ5ICsgJy0tJztcclxuICAgIGNvbnN0IGJvZHkgPSBGYnNCbG9iLmdldEJsb2IocHJlQmxvYlBhcnQsIGJsb2IsIHBvc3RCbG9iUGFydCk7XHJcbiAgICBpZiAoYm9keSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IGNhbm5vdFNsaWNlQmxvYigpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdXJsUGFyYW1zID0geyBuYW1lOiBtZXRhZGF0YV9bJ2Z1bGxQYXRoJ10gfTtcclxuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XHJcbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XHJcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhVcGxvYWRSZXRyeVRpbWU7XHJcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgbWV0YWRhdGFIYW5kbGVyKHNlcnZpY2UsIG1hcHBpbmdzKSwgdGltZW91dCk7XHJcbiAgICByZXF1ZXN0SW5mby51cmxQYXJhbXMgPSB1cmxQYXJhbXM7XHJcbiAgICByZXF1ZXN0SW5mby5oZWFkZXJzID0gaGVhZGVycztcclxuICAgIHJlcXVlc3RJbmZvLmJvZHkgPSBib2R5LnVwbG9hZERhdGEoKTtcclxuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XHJcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBjdXJyZW50IFRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBoYXZlIGJlZW4gdXBsb2FkZWQgc28gZmFyLlxyXG4gKiBAcGFyYW0gdG90YWwgVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBpbiB0aGUgdXBsb2FkLlxyXG4gKiBAcGFyYW0gb3B0X2ZpbmFsaXplZCBUcnVlIGlmIHRoZSBzZXJ2ZXIgaGFzIGZpbmlzaGVkIHRoZSB1cGxvYWQuXHJcbiAqIEBwYXJhbSBvcHRfbWV0YWRhdGEgVGhlIHVwbG9hZCBtZXRhZGF0YSwgc2hvdWxkXHJcbiAqICAgICBvbmx5IGJlIHBhc3NlZCBpZiBvcHRfZmluYWxpemVkIGlzIHRydWUuXHJcbiAqL1xyXG5jbGFzcyBSZXN1bWFibGVVcGxvYWRTdGF0dXMge1xyXG4gICAgY29uc3RydWN0b3IoY3VycmVudCwgdG90YWwsIGZpbmFsaXplZCwgbWV0YWRhdGEpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xyXG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcclxuICAgICAgICB0aGlzLmZpbmFsaXplZCA9ICEhZmluYWxpemVkO1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YSB8fCBudWxsO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrUmVzdW1lSGVhZGVyXyh4aHIsIGFsbG93ZWQpIHtcclxuICAgIGxldCBzdGF0dXMgPSBudWxsO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBzdGF0dXMgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtR29vZy1VcGxvYWQtU3RhdHVzJyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGhhbmRsZXJDaGVjayhmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhbGxvd2VkU3RhdHVzID0gYWxsb3dlZCB8fCBbJ2FjdGl2ZSddO1xyXG4gICAgaGFuZGxlckNoZWNrKCEhc3RhdHVzICYmIGFsbG93ZWRTdGF0dXMuaW5kZXhPZihzdGF0dXMpICE9PSAtMSk7XHJcbiAgICByZXR1cm4gc3RhdHVzO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlc3VtYWJsZVVwbG9hZChzZXJ2aWNlLCBsb2NhdGlvbiwgbWFwcGluZ3MsIGJsb2IsIG1ldGFkYXRhKSB7XHJcbiAgICBjb25zdCB1cmxQYXJ0ID0gbG9jYXRpb24uYnVja2V0T25seVNlcnZlclVybCgpO1xyXG4gICAgY29uc3QgbWV0YWRhdGFGb3JVcGxvYWQgPSBtZXRhZGF0YUZvclVwbG9hZF8obG9jYXRpb24sIGJsb2IsIG1ldGFkYXRhKTtcclxuICAgIGNvbnN0IHVybFBhcmFtcyA9IHsgbmFtZTogbWV0YWRhdGFGb3JVcGxvYWRbJ2Z1bGxQYXRoJ10gfTtcclxuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XHJcbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XHJcbiAgICBjb25zdCBoZWFkZXJzID0ge1xyXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLVByb3RvY29sJzogJ3Jlc3VtYWJsZScsXHJcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6ICdzdGFydCcsXHJcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtSGVhZGVyLUNvbnRlbnQtTGVuZ3RoJzogYCR7YmxvYi5zaXplKCl9YCxcclxuICAgICAgICAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1UeXBlJzogbWV0YWRhdGFGb3JVcGxvYWRbJ2NvbnRlbnRUeXBlJ10sXHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04J1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGJvZHkgPSB0b1Jlc291cmNlU3RyaW5nKG1ldGFkYXRhRm9yVXBsb2FkLCBtYXBwaW5ncyk7XHJcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhVcGxvYWRSZXRyeVRpbWU7XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhocikge1xyXG4gICAgICAgIGNoZWNrUmVzdW1lSGVhZGVyXyh4aHIpO1xyXG4gICAgICAgIGxldCB1cmw7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdXJsID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLUdvb2ctVXBsb2FkLVVSTCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBoYW5kbGVyQ2hlY2soZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVyQ2hlY2soaXNTdHJpbmcodXJsKSk7XHJcbiAgICAgICAgcmV0dXJuIHVybDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBoYW5kbGVyLCB0aW1lb3V0KTtcclxuICAgIHJlcXVlc3RJbmZvLnVybFBhcmFtcyA9IHVybFBhcmFtcztcclxuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xyXG4gICAgcmVxdWVzdEluZm8uYm9keSA9IGJvZHk7XHJcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBzaGFyZWRFcnJvckhhbmRsZXIobG9jYXRpb24pO1xyXG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gdXJsIEZyb20gYSBjYWxsIHRvIGZicy5yZXF1ZXN0cy5jcmVhdGVSZXN1bWFibGVVcGxvYWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZXN1bWFibGVVcGxvYWRTdGF0dXMoc2VydmljZSwgbG9jYXRpb24sIHVybCwgYmxvYikge1xyXG4gICAgY29uc3QgaGVhZGVycyA9IHsgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6ICdxdWVyeScgfTtcclxuICAgIGZ1bmN0aW9uIGhhbmRsZXIoeGhyKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gY2hlY2tSZXN1bWVIZWFkZXJfKHhociwgWydhY3RpdmUnLCAnZmluYWwnXSk7XHJcbiAgICAgICAgbGV0IHNpemVTdHJpbmcgPSBudWxsO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHNpemVTdHJpbmcgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtR29vZy1VcGxvYWQtU2l6ZS1SZWNlaXZlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBoYW5kbGVyQ2hlY2soZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNpemVTdHJpbmcpIHtcclxuICAgICAgICAgICAgLy8gbnVsbCBvciBlbXB0eSBzdHJpbmdcclxuICAgICAgICAgICAgaGFuZGxlckNoZWNrKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE51bWJlcihzaXplU3RyaW5nKTtcclxuICAgICAgICBoYW5kbGVyQ2hlY2soIWlzTmFOKHNpemUpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cyhzaXplLCBibG9iLnNpemUoKSwgc3RhdHVzID09PSAnZmluYWwnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heFVwbG9hZFJldHJ5VGltZTtcclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBoYW5kbGVyLCB0aW1lb3V0KTtcclxuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xyXG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcclxuICAgIHJldHVybiByZXF1ZXN0SW5mbztcclxufVxyXG4vKipcclxuICogQW55IHVwbG9hZHMgdmlhIHRoZSByZXN1bWFibGUgdXBsb2FkIEFQSSBtdXN0IHRyYW5zZmVyIGEgbnVtYmVyIG9mIGJ5dGVzXHJcbiAqIHRoYXQgaXMgYSBtdWx0aXBsZSBvZiB0aGlzIG51bWJlci5cclxuICovXHJcbmNvbnN0IFJFU1VNQUJMRV9VUExPQURfQ0hVTktfU0laRSA9IDI1NiAqIDEwMjQ7XHJcbi8qKlxyXG4gKiBAcGFyYW0gdXJsIEZyb20gYSBjYWxsIHRvIGZicy5yZXF1ZXN0cy5jcmVhdGVSZXN1bWFibGVVcGxvYWQuXHJcbiAqIEBwYXJhbSBjaHVua1NpemUgTnVtYmVyIG9mIGJ5dGVzIHRvIHVwbG9hZC5cclxuICogQHBhcmFtIHN0YXR1cyBUaGUgcHJldmlvdXMgc3RhdHVzLlxyXG4gKiAgICAgSWYgbm90IHBhc3NlZCBvciBudWxsLCB3ZSBzdGFydCBmcm9tIHRoZSBiZWdpbm5pbmcuXHJcbiAqIEB0aHJvd3MgZmJzLkVycm9yIElmIHRoZSB1cGxvYWQgaXMgYWxyZWFkeSBjb21wbGV0ZSwgdGhlIHBhc3NlZCBpbiBzdGF0dXNcclxuICogICAgIGhhcyBhIGZpbmFsIHNpemUgaW5jb25zaXN0ZW50IHdpdGggdGhlIGJsb2IsIG9yIHRoZSBibG9iIGNhbm5vdCBiZSBzbGljZWRcclxuICogICAgIGZvciB1cGxvYWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb250aW51ZVJlc3VtYWJsZVVwbG9hZChsb2NhdGlvbiwgc2VydmljZSwgdXJsLCBibG9iLCBjaHVua1NpemUsIG1hcHBpbmdzLCBzdGF0dXMsIHByb2dyZXNzQ2FsbGJhY2spIHtcclxuICAgIC8vIFRPRE8oYW5keXNvdG8pOiBzdGFuZGFyZGl6ZSBvbiBpbnRlcm5hbCBhc3NlcnRzXHJcbiAgICAvLyBhc3NlcnQoIShvcHRfc3RhdHVzICYmIG9wdF9zdGF0dXMuZmluYWxpemVkKSk7XHJcbiAgICBjb25zdCBzdGF0dXNfID0gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cygwLCAwKTtcclxuICAgIGlmIChzdGF0dXMpIHtcclxuICAgICAgICBzdGF0dXNfLmN1cnJlbnQgPSBzdGF0dXMuY3VycmVudDtcclxuICAgICAgICBzdGF0dXNfLnRvdGFsID0gc3RhdHVzLnRvdGFsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3RhdHVzXy5jdXJyZW50ID0gMDtcclxuICAgICAgICBzdGF0dXNfLnRvdGFsID0gYmxvYi5zaXplKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoYmxvYi5zaXplKCkgIT09IHN0YXR1c18udG90YWwpIHtcclxuICAgICAgICB0aHJvdyBzZXJ2ZXJGaWxlV3JvbmdTaXplKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBieXRlc0xlZnQgPSBzdGF0dXNfLnRvdGFsIC0gc3RhdHVzXy5jdXJyZW50O1xyXG4gICAgbGV0IGJ5dGVzVG9VcGxvYWQgPSBieXRlc0xlZnQ7XHJcbiAgICBpZiAoY2h1bmtTaXplID4gMCkge1xyXG4gICAgICAgIGJ5dGVzVG9VcGxvYWQgPSBNYXRoLm1pbihieXRlc1RvVXBsb2FkLCBjaHVua1NpemUpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RhcnRCeXRlID0gc3RhdHVzXy5jdXJyZW50O1xyXG4gICAgY29uc3QgZW5kQnl0ZSA9IHN0YXJ0Qnl0ZSArIGJ5dGVzVG9VcGxvYWQ7XHJcbiAgICBsZXQgdXBsb2FkQ29tbWFuZCA9ICcnO1xyXG4gICAgaWYgKGJ5dGVzVG9VcGxvYWQgPT09IDApIHtcclxuICAgICAgICB1cGxvYWRDb21tYW5kID0gJ2ZpbmFsaXplJztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGJ5dGVzTGVmdCA9PT0gYnl0ZXNUb1VwbG9hZCkge1xyXG4gICAgICAgIHVwbG9hZENvbW1hbmQgPSAndXBsb2FkLCBmaW5hbGl6ZSc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBoZWFkZXJzID0ge1xyXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiB1cGxvYWRDb21tYW5kLFxyXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLU9mZnNldCc6IGAke3N0YXR1c18uY3VycmVudH1gXHJcbiAgICB9O1xyXG4gICAgY29uc3QgYm9keSA9IGJsb2Iuc2xpY2Uoc3RhcnRCeXRlLCBlbmRCeXRlKTtcclxuICAgIGlmIChib2R5ID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgY2Fubm90U2xpY2VCbG9iKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhociwgdGV4dCkge1xyXG4gICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOiBWZXJpZnkgdGhlIE1ENSBvZiBlYWNoIHVwbG9hZGVkIHJhbmdlOlxyXG4gICAgICAgIC8vIHRoZSAneC1yYW5nZS1tZDUnIGhlYWRlciBjb21lcyBiYWNrIHdpdGggc3RhdHVzIGNvZGUgMzA4IHJlc3BvbnNlcy5cclxuICAgICAgICAvLyBXZSdsbCBvbmx5IGJlIGFibGUgdG8gYmFpbCBvdXQgdGhvdWdoLCBiZWNhdXNlIHlvdSBjYW4ndCByZS11cGxvYWQgYVxyXG4gICAgICAgIC8vIHJhbmdlIHRoYXQgeW91IHByZXZpb3VzbHkgdXBsb2FkZWQuXHJcbiAgICAgICAgY29uc3QgdXBsb2FkU3RhdHVzID0gY2hlY2tSZXN1bWVIZWFkZXJfKHhociwgWydhY3RpdmUnLCAnZmluYWwnXSk7XHJcbiAgICAgICAgY29uc3QgbmV3Q3VycmVudCA9IHN0YXR1c18uY3VycmVudCArIGJ5dGVzVG9VcGxvYWQ7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGJsb2Iuc2l6ZSgpO1xyXG4gICAgICAgIGxldCBtZXRhZGF0YTtcclxuICAgICAgICBpZiAodXBsb2FkU3RhdHVzID09PSAnZmluYWwnKSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGFIYW5kbGVyKHNlcnZpY2UsIG1hcHBpbmdzKSh4aHIsIHRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWV0YWRhdGEgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cyhuZXdDdXJyZW50LCBzaXplLCB1cGxvYWRTdGF0dXMgPT09ICdmaW5hbCcsIG1ldGFkYXRhKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heFVwbG9hZFJldHJ5VGltZTtcclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBoYW5kbGVyLCB0aW1lb3V0KTtcclxuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xyXG4gICAgcmVxdWVzdEluZm8uYm9keSA9IGJvZHkudXBsb2FkRGF0YSgpO1xyXG4gICAgcmVxdWVzdEluZm8ucHJvZ3Jlc3NDYWxsYmFjayA9IHByb2dyZXNzQ2FsbGJhY2sgfHwgbnVsbDtcclxuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XHJcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGV2ZW50IHRoYXQgaXMgdHJpZ2dlcmVkIG9uIGEgdGFzay5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBUYXNrRXZlbnQgPSB7XHJcbiAgICAvKipcclxuICAgICAqIEZvciB0aGlzIGV2ZW50LFxyXG4gICAgICogPHVsPlxyXG4gICAgICogICA8bGk+VGhlIGBuZXh0YCBmdW5jdGlvbiBpcyB0cmlnZ2VyZWQgb24gcHJvZ3Jlc3MgdXBkYXRlcyBhbmQgd2hlbiB0aGVcclxuICAgICAqICAgICAgIHRhc2sgaXMgcGF1c2VkL3Jlc3VtZWQgd2l0aCBhbiBgVXBsb2FkVGFza1NuYXBzaG90YCBhcyB0aGUgZmlyc3RcclxuICAgICAqICAgICAgIGFyZ3VtZW50LjwvbGk+XHJcbiAgICAgKiAgIDxsaT5UaGUgYGVycm9yYCBmdW5jdGlvbiBpcyB0cmlnZ2VyZWQgaWYgdGhlIHVwbG9hZCBpcyBjYW5jZWxlZCBvciBmYWlsc1xyXG4gICAgICogICAgICAgZm9yIGFub3RoZXIgcmVhc29uLjwvbGk+XHJcbiAgICAgKiAgIDxsaT5UaGUgYGNvbXBsZXRlYCBmdW5jdGlvbiBpcyB0cmlnZ2VyZWQgaWYgdGhlIHVwbG9hZCBjb21wbGV0ZXNcclxuICAgICAqICAgICAgIHN1Y2Nlc3NmdWxseS48L2xpPlxyXG4gICAgICogPC91bD5cclxuICAgICAqL1xyXG4gICAgU1RBVEVfQ0hBTkdFRDogJ3N0YXRlX2NoYW5nZWQnXHJcbn07XHJcbi8vIHR5cGUga2V5cyA9IGtleW9mIFRhc2tTdGF0ZVxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgY3VycmVudCBzdGF0ZSBvZiBhIHJ1bm5pbmcgdXBsb2FkLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IFRhc2tTdGF0ZSA9IHtcclxuICAgIC8qKiBUaGUgdGFzayBpcyBjdXJyZW50bHkgdHJhbnNmZXJyaW5nIGRhdGEuICovXHJcbiAgICBSVU5OSU5HOiAncnVubmluZycsXHJcbiAgICAvKiogVGhlIHRhc2sgd2FzIHBhdXNlZCBieSB0aGUgdXNlci4gKi9cclxuICAgIFBBVVNFRDogJ3BhdXNlZCcsXHJcbiAgICAvKiogVGhlIHRhc2sgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS4gKi9cclxuICAgIFNVQ0NFU1M6ICdzdWNjZXNzJyxcclxuICAgIC8qKiBUaGUgdGFzayB3YXMgY2FuY2VsZWQuICovXHJcbiAgICBDQU5DRUxFRDogJ2NhbmNlbGVkJyxcclxuICAgIC8qKiBUaGUgdGFzayBmYWlsZWQgd2l0aCBhbiBlcnJvci4gKi9cclxuICAgIEVSUk9SOiAnZXJyb3InXHJcbn07XHJcbmZ1bmN0aW9uIHRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZShzdGF0ZSkge1xyXG4gICAgc3dpdGNoIChzdGF0ZSkge1xyXG4gICAgICAgIGNhc2UgXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLzpcclxuICAgICAgICBjYXNlIFwicGF1c2luZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgKi86XHJcbiAgICAgICAgY2FzZSBcImNhbmNlbGluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIFRhc2tTdGF0ZS5SVU5OSU5HO1xyXG4gICAgICAgIGNhc2UgXCJwYXVzZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBUYXNrU3RhdGUuUEFVU0VEO1xyXG4gICAgICAgIGNhc2UgXCJzdWNjZXNzXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuU1VDQ0VTUyAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIFRhc2tTdGF0ZS5TVUNDRVNTO1xyXG4gICAgICAgIGNhc2UgXCJjYW5jZWxlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTEVEICovOlxyXG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLkNBTkNFTEVEO1xyXG4gICAgICAgIGNhc2UgXCJlcnJvclwiIC8qIEludGVybmFsVGFza1N0YXRlLkVSUk9SICovOlxyXG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLkVSUk9SO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOiBhc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLkVSUk9SO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE9ic2VydmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcclxuICAgICAgICBjb25zdCBhc0Z1bmN0aW9ucyA9IGlzRnVuY3Rpb24obmV4dE9yT2JzZXJ2ZXIpIHx8IGVycm9yICE9IG51bGwgfHwgY29tcGxldGUgIT0gbnVsbDtcclxuICAgICAgICBpZiAoYXNGdW5jdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXh0ID0gbmV4dE9yT2JzZXJ2ZXI7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvciAhPT0gbnVsbCAmJiBlcnJvciAhPT0gdm9pZCAwID8gZXJyb3IgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSBjb21wbGV0ZSAhPT0gbnVsbCAmJiBjb21wbGV0ZSAhPT0gdm9pZCAwID8gY29tcGxldGUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xyXG4gICAgICAgICAgICB0aGlzLm5leHQgPSBvYnNlcnZlci5uZXh0O1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gb2JzZXJ2ZXIuZXJyb3I7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSBvYnNlcnZlci5jb21wbGV0ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgZiB3aXRoIGl0cyBhcmd1bWVudHMgYXN5bmNocm9ub3VzbHkgYXMgYVxyXG4gKiBtaWNyb3Rhc2ssIGkuZS4gYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBzY3JpcHQgcmV0dXJucyBiYWNrXHJcbiAqIGludG8gYnJvd3NlciBjb2RlLlxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcclxuZnVuY3Rpb24gYXN5bmMoZikge1xyXG4gICAgcmV0dXJuICguLi5hcmdzVG9Gb3J3YXJkKSA9PiB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZiguLi5hcmdzVG9Gb3J3YXJkKSk7XHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBBbiBvdmVycmlkZSBmb3IgdGhlIHRleHQtYmFzZWQgQ29ubmVjdGlvbi4gVXNlZCBpbiB0ZXN0cy4gKi9cclxubGV0IHRleHRGYWN0b3J5T3ZlcnJpZGUgPSBudWxsO1xyXG4vKipcclxuICogTmV0d29yayBsYXllciB0aGF0IHdvcmtzIGluIE5vZGUuXHJcbiAqXHJcbiAqIFRoaXMgbmV0d29yayBpbXBsZW1lbnRhdGlvbiBzaG91bGQgbm90IGJlIHVzZWQgaW4gYnJvd3NlcnMgYXMgaXQgZG9lcyBub3RcclxuICogc3VwcG9ydCBwcm9ncmVzcyB1cGRhdGVzLlxyXG4gKi9cclxuY2xhc3MgRmV0Y2hDb25uZWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZXJyb3JUZXh0XyA9ICcnO1xyXG4gICAgICAgIHRoaXMuc2VudF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZldGNoXyA9IGZldGNoO1xyXG4gICAgICAgIHRoaXMuZXJyb3JDb2RlXyA9IEVycm9yQ29kZS5OT19FUlJPUjtcclxuICAgIH1cclxuICAgIGFzeW5jIHNlbmQodXJsLCBtZXRob2QsIGJvZHksIGhlYWRlcnMpIHtcclxuICAgICAgICBpZiAodGhpcy5zZW50Xykge1xyXG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLnNlbmQoKSBtb3JlIHRoYW4gb25jZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbnRfID0gdHJ1ZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hfKHVybCwge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyB8fCB7fSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc18gPSByZXNwb25zZS5oZWFkZXJzO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGVfID0gcmVzcG9uc2Uuc3RhdHVzO1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yQ29kZV8gPSBFcnJvckNvZGUuTk9fRVJST1I7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keV8gPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yVGV4dF8gPSBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZTtcclxuICAgICAgICAgICAgLy8gZW11bGF0ZSBYSFIgd2hpY2ggc2V0cyBzdGF0dXMgdG8gMCB3aGVuIGVuY291bnRlcmluZyBhIG5ldHdvcmsgZXJyb3JcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlXyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JDb2RlXyA9IEVycm9yQ29kZS5ORVRXT1JLX0VSUk9SO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEVycm9yQ29kZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5lcnJvckNvZGVfID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgaW50ZXJuYWxFcnJvcignY2Fubm90IC5nZXRFcnJvckNvZGUoKSBiZWZvcmUgcmVjZWl2aW5nIHJlc3BvbnNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yQ29kZV87XHJcbiAgICB9XHJcbiAgICBnZXRTdGF0dXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzQ29kZV8gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLmdldFN0YXR1cygpIGJlZm9yZSByZWNlaXZpbmcgcmVzcG9uc2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzQ29kZV87XHJcbiAgICB9XHJcbiAgICBnZXRFcnJvclRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JUZXh0XztcclxuICAgIH1cclxuICAgIGFib3J0KCkge1xyXG4gICAgICAgIC8vIE5vdCBzdXBwb3J0ZWRcclxuICAgIH1cclxuICAgIGdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcikge1xyXG4gICAgICAgIGlmICghdGhpcy5oZWFkZXJzXykge1xyXG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLmdldFJlc3BvbnNlSGVhZGVyKCkgYmVmb3JlIHJlY2VpdmluZyByZXNwb25zZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzXy5nZXQoaGVhZGVyKTtcclxuICAgIH1cclxuICAgIGFkZFVwbG9hZFByb2dyZXNzTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICAvLyBOb3Qgc3VwcG9ydGVkXHJcbiAgICB9XHJcbiAgICByZW1vdmVVcGxvYWRQcm9ncmVzc0xpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgLy8gTm90IHN1cHBvcnRlZFxyXG4gICAgfVxyXG59XHJcbmNsYXNzIEZldGNoVGV4dENvbm5lY3Rpb24gZXh0ZW5kcyBGZXRjaENvbm5lY3Rpb24ge1xyXG4gICAgZ2V0UmVzcG9uc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmJvZHlfKSB7XHJcbiAgICAgICAgICAgIHRocm93IGludGVybmFsRXJyb3IoJ2Nhbm5vdCAuZ2V0UmVzcG9uc2UoKSBiZWZvcmUgcmVjZWl2aW5nIHJlc3BvbnNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmJvZHlfKS50b1N0cmluZygndXRmLTgnKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdUZXh0Q29ubmVjdGlvbigpIHtcclxuICAgIHJldHVybiB0ZXh0RmFjdG9yeU92ZXJyaWRlXHJcbiAgICAgICAgPyB0ZXh0RmFjdG9yeU92ZXJyaWRlKClcclxuICAgICAgICA6IG5ldyBGZXRjaFRleHRDb25uZWN0aW9uKCk7XHJcbn1cclxuY2xhc3MgRmV0Y2hCeXRlc0Nvbm5lY3Rpb24gZXh0ZW5kcyBGZXRjaENvbm5lY3Rpb24ge1xyXG4gICAgZ2V0UmVzcG9uc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmJvZHlfKSB7XHJcbiAgICAgICAgICAgIHRocm93IGludGVybmFsRXJyb3IoJ2Nhbm5vdCAuZ2V0UmVzcG9uc2UoKSBiZWZvcmUgc2VuZGluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5ib2R5XztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdCeXRlc0Nvbm5lY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IEZldGNoQnl0ZXNDb25uZWN0aW9uKCk7XHJcbn1cclxuY2xhc3MgRmV0Y2hTdHJlYW1Db25uZWN0aW9uIGV4dGVuZHMgRmV0Y2hDb25uZWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW1fID0gbnVsbDtcclxuICAgIH1cclxuICAgIGFzeW5jIHNlbmQodXJsLCBtZXRob2QsIGJvZHksIGhlYWRlcnMpIHtcclxuICAgICAgICBpZiAodGhpcy5zZW50Xykge1xyXG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLnNlbmQoKSBtb3JlIHRoYW4gb25jZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbnRfID0gdHJ1ZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hfKHVybCwge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyB8fCB7fSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc18gPSByZXNwb25zZS5oZWFkZXJzO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGVfID0gcmVzcG9uc2Uuc3RhdHVzO1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yQ29kZV8gPSBFcnJvckNvZGUuTk9fRVJST1I7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtXyA9IHJlc3BvbnNlLmJvZHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JUZXh0XyA9IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlO1xyXG4gICAgICAgICAgICAvLyBlbXVsYXRlIFhIUiB3aGljaCBzZXRzIHN0YXR1cyB0byAwIHdoZW4gZW5jb3VudGVyaW5nIGEgbmV0d29yayBlcnJvclxyXG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGVfID0gMDtcclxuICAgICAgICAgICAgdGhpcy5lcnJvckNvZGVfID0gRXJyb3JDb2RlLk5FVFdPUktfRVJST1I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0UmVzcG9uc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnN0cmVhbV8pIHtcclxuICAgICAgICAgICAgdGhyb3cgaW50ZXJuYWxFcnJvcignY2Fubm90IC5nZXRSZXNwb25zZSgpIGJlZm9yZSBzZW5kaW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbV87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3U3RyZWFtQ29ubmVjdGlvbigpIHtcclxuICAgIHJldHVybiBuZXcgRmV0Y2hTdHJlYW1Db25uZWN0aW9uKCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBibG9iIGJlaW5nIHVwbG9hZGVkLiBDYW4gYmUgdXNlZCB0byBwYXVzZS9yZXN1bWUvY2FuY2VsIHRoZVxyXG4gKiB1cGxvYWQgYW5kIG1hbmFnZSBjYWxsYmFja3MgZm9yIHZhcmlvdXMgZXZlbnRzLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFVwbG9hZFRhc2sge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcmVmIC0gVGhlIGZpcmViYXNlU3RvcmFnZS5SZWZlcmVuY2Ugb2JqZWN0IHRoaXMgdGFzayBjYW1lXHJcbiAgICAgKiAgICAgZnJvbSwgdW50eXBlZCB0byBhdm9pZCBjeWNsaWMgZGVwZW5kZW5jaWVzLlxyXG4gICAgICogQHBhcmFtIGJsb2IgLSBUaGUgYmxvYiB0byB1cGxvYWQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJlZiwgYmxvYiwgbWV0YWRhdGEgPSBudWxsKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTnVtYmVyIG9mIGJ5dGVzIHRyYW5zZmVycmVkIHNvIGZhci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl90cmFuc2ZlcnJlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5fbmVlZFRvRmV0Y2hTdGF0dXMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9uZWVkVG9GZXRjaE1ldGFkYXRhID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5fZXJyb3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fdXBsb2FkVXJsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fY2h1bmtNdWx0aXBsaWVyID0gMTtcclxuICAgICAgICB0aGlzLl9yZXNvbHZlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3JlamVjdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9yZWYgPSByZWY7XHJcbiAgICAgICAgdGhpcy5fYmxvYiA9IGJsb2I7XHJcbiAgICAgICAgdGhpcy5fbWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgICAgICB0aGlzLl9tYXBwaW5ncyA9IGdldE1hcHBpbmdzKCk7XHJcbiAgICAgICAgdGhpcy5fcmVzdW1hYmxlID0gdGhpcy5fc2hvdWxkRG9SZXN1bWFibGUodGhpcy5fYmxvYik7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovO1xyXG4gICAgICAgIHRoaXMuX2Vycm9ySGFuZGxlciA9IGVycm9yID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5fY2h1bmtNdWx0aXBsaWVyID0gMTtcclxuICAgICAgICAgICAgaWYgKGVycm9yLl9jb2RlRXF1YWxzKFN0b3JhZ2VFcnJvckNvZGUuQ0FOQ0VMRUQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkVG9GZXRjaFN0YXR1cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlVHJhbnNpdGlvbnNfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYWNrb2ZmRXhwaXJlZCA9IHRoaXMuaXNFeHBvbmVudGlhbEJhY2tvZmZFeHBpcmVkKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXRyeVN0YXR1c0NvZGUoZXJyb3Iuc3RhdHVzLCBbXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFja29mZkV4cGlyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSByZXRyeUxpbWl0RXhjZWVkZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2xlZXBUaW1lID0gTWF0aC5tYXgodGhpcy5zbGVlcFRpbWUgKiAyLCBERUZBVUxUX01JTl9TTEVFUF9USU1FX01JTExJUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJlcnJvclwiIC8qIEludGVybmFsVGFza1N0YXRlLkVSUk9SICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFFcnJvckhhbmRsZXIgPSBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5fY29kZUVxdWFscyhTdG9yYWdlRXJyb3JDb2RlLkNBTkNFTEVEKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJlcnJvclwiIC8qIEludGVybmFsVGFza1N0YXRlLkVSUk9SICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5zbGVlcFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMubWF4U2xlZXBUaW1lID0gdGhpcy5fcmVmLnN0b3JhZ2UubWF4VXBsb2FkUmV0cnlUaW1lO1xyXG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gUHJldmVudCB1bmNhdWdodCByZWplY3Rpb25zIG9uIHRoZSBpbnRlcm5hbCBwcm9taXNlIGZyb20gYnViYmxpbmcgb3V0XHJcbiAgICAgICAgLy8gdG8gdGhlIHRvcCBsZXZlbCB3aXRoIGEgZHVtbXkgaGFuZGxlci5cclxuICAgICAgICB0aGlzLl9wcm9taXNlLnRoZW4obnVsbCwgKCkgPT4geyB9KTtcclxuICAgIH1cclxuICAgIGlzRXhwb25lbnRpYWxCYWNrb2ZmRXhwaXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zbGVlcFRpbWUgPiB0aGlzLm1heFNsZWVwVGltZTtcclxuICAgIH1cclxuICAgIF9tYWtlUHJvZ3Jlc3NDYWxsYmFjaygpIHtcclxuICAgICAgICBjb25zdCBzaXplQmVmb3JlID0gdGhpcy5fdHJhbnNmZXJyZWQ7XHJcbiAgICAgICAgcmV0dXJuIGxvYWRlZCA9PiB0aGlzLl91cGRhdGVQcm9ncmVzcyhzaXplQmVmb3JlICsgbG9hZGVkKTtcclxuICAgIH1cclxuICAgIF9zaG91bGREb1Jlc3VtYWJsZShibG9iKSB7XHJcbiAgICAgICAgcmV0dXJuIGJsb2Iuc2l6ZSgpID4gMjU2ICogMTAyNDtcclxuICAgIH1cclxuICAgIF9zdGFydCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi8pIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHNvbWVvbmUgcGF1c2VzIHVzIGluIGEgcmVzdW1lIGNhbGxiYWNrLCBmb3IgZXhhbXBsZS5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jlc3VtYWJsZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdXBsb2FkVXJsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlc3VtYWJsZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmV0Y2hTdGF0dXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZWVkVG9GZXRjaE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhcHBlbnMgaWYgd2UgbWlzcyB0aGUgbWV0YWRhdGEgb24gdXBsb2FkIGNvbXBsZXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZldGNoTWV0YWRhdGEoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1RpbWVvdXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250aW51ZVVwbG9hZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnNsZWVwVGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9vbmVTaG90VXBsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3Jlc29sdmVUb2tlbihjYWxsYmFjaykge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgIHRoaXMuX3JlZi5zdG9yYWdlLl9nZXRBdXRoVG9rZW4oKSxcclxuICAgICAgICAgICAgdGhpcy5fcmVmLnN0b3JhZ2UuX2dldEFwcENoZWNrVG9rZW4oKVxyXG4gICAgICAgIF0pLnRoZW4oKFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dKSA9PiB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLzpcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImNhbmNlbGluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyAqLzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwiY2FuY2VsZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxFRCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicGF1c2luZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcInBhdXNlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNFRCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8oYW5keXNvdG8pOiBhc3NlcnQgZmFsc2VcclxuICAgIF9jcmVhdGVSZXN1bWFibGUoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVRva2VuKChhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEluZm8gPSBjcmVhdGVSZXN1bWFibGVVcGxvYWQodGhpcy5fcmVmLnN0b3JhZ2UsIHRoaXMuX3JlZi5fbG9jYXRpb24sIHRoaXMuX21hcHBpbmdzLCB0aGlzLl9ibG9iLCB0aGlzLl9tZXRhZGF0YSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVJlcXVlc3QgPSB0aGlzLl9yZWYuc3RvcmFnZS5fbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdDtcclxuICAgICAgICAgICAgY3JlYXRlUmVxdWVzdC5nZXRQcm9taXNlKCkudGhlbigodXJsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkVXJsID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZFRvRmV0Y2hTdGF0dXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcclxuICAgICAgICAgICAgfSwgdGhpcy5fZXJyb3JIYW5kbGVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9mZXRjaFN0YXR1cygpIHtcclxuICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogYXNzZXJ0KHRoaXMudXBsb2FkVXJsXyAhPT0gbnVsbCk7XHJcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5fdXBsb2FkVXJsO1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVUb2tlbigoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gZ2V0UmVzdW1hYmxlVXBsb2FkU3RhdHVzKHRoaXMuX3JlZi5zdG9yYWdlLCB0aGlzLl9yZWYuX2xvY2F0aW9uLCB1cmwsIHRoaXMuX2Jsb2IpO1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0dXNSZXF1ZXN0ID0gdGhpcy5fcmVmLnN0b3JhZ2UuX21ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbiwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHN0YXR1c1JlcXVlc3Q7XHJcbiAgICAgICAgICAgIHN0YXR1c1JlcXVlc3QuZ2V0UHJvbWlzZSgpLnRoZW4oc3RhdHVzID0+IHtcclxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQcm9ncmVzcyhzdGF0dXMuY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkVG9GZXRjaFN0YXR1cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZWVkVG9GZXRjaE1ldGFkYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcclxuICAgICAgICAgICAgfSwgdGhpcy5fZXJyb3JIYW5kbGVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9jb250aW51ZVVwbG9hZCgpIHtcclxuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBSRVNVTUFCTEVfVVBMT0FEX0NIVU5LX1NJWkUgKiB0aGlzLl9jaHVua011bHRpcGxpZXI7XHJcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cyh0aGlzLl90cmFuc2ZlcnJlZCwgdGhpcy5fYmxvYi5zaXplKCkpO1xyXG4gICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOiBhc3NlcnQodGhpcy51cGxvYWRVcmxfICE9PSBudWxsKTtcclxuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLl91cGxvYWRVcmw7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVRva2VuKChhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlcXVlc3RJbmZvO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdEluZm8gPSBjb250aW51ZVJlc3VtYWJsZVVwbG9hZCh0aGlzLl9yZWYuX2xvY2F0aW9uLCB0aGlzLl9yZWYuc3RvcmFnZSwgdXJsLCB0aGlzLl9ibG9iLCBjaHVua1NpemUsIHRoaXMuX21hcHBpbmdzLCBzdGF0dXMsIHRoaXMuX21ha2VQcm9ncmVzc0NhbGxiYWNrKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwiZXJyb3JcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5FUlJPUiAqLyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdXBsb2FkUmVxdWVzdCA9IHRoaXMuX3JlZi5zdG9yYWdlLl9tYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24sIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgXHJcbiAgICAgICAgICAgIC8qcmV0cnk9Ki8gZmFsc2UgLy8gVXBsb2FkIHJlcXVlc3RzIHNob3VsZCBub3QgYmUgcmV0cmllZCBhcyBlYWNoIHJldHJ5IHNob3VsZCBiZSBwcmVjZWRlZCBieSBhbm90aGVyIHF1ZXJ5IHJlcXVlc3QuIFdoaWNoIGlzIGhhbmRsZWQgaW4gdGhpcyBmaWxlLlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdXBsb2FkUmVxdWVzdDtcclxuICAgICAgICAgICAgdXBsb2FkUmVxdWVzdC5nZXRQcm9taXNlKCkudGhlbigobmV3U3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmNyZWFzZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQcm9ncmVzcyhuZXdTdGF0dXMuY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdHVzLmZpbmFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhID0gbmV3U3RhdHVzLm1ldGFkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJzdWNjZXNzXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuU1VDQ0VTUyAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlVHJhbnNpdGlvbnNfKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMuX2Vycm9ySGFuZGxlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfaW5jcmVhc2VNdWx0aXBsaWVyKCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTaXplID0gUkVTVU1BQkxFX1VQTE9BRF9DSFVOS19TSVpFICogdGhpcy5fY2h1bmtNdWx0aXBsaWVyO1xyXG4gICAgICAgIC8vIE1heCBjaHVuayBzaXplIGlzIDMyTS5cclxuICAgICAgICBpZiAoY3VycmVudFNpemUgKiAyIDwgMzIgKiAxMDI0ICogMTAyNCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jaHVua011bHRpcGxpZXIgKj0gMjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZmV0Y2hNZXRhZGF0YSgpIHtcclxuICAgICAgICB0aGlzLl9yZXNvbHZlVG9rZW4oKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGdldE1ldGFkYXRhJDIodGhpcy5fcmVmLnN0b3JhZ2UsIHRoaXMuX3JlZi5fbG9jYXRpb24sIHRoaXMuX21hcHBpbmdzKTtcclxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFSZXF1ZXN0ID0gdGhpcy5fcmVmLnN0b3JhZ2UuX21ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbiwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IG1ldGFkYXRhUmVxdWVzdDtcclxuICAgICAgICAgICAgbWV0YWRhdGFSZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcInN1Y2Nlc3NcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5TVUNDRVNTICovKTtcclxuICAgICAgICAgICAgfSwgdGhpcy5fbWV0YWRhdGFFcnJvckhhbmRsZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX29uZVNob3RVcGxvYWQoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVRva2VuKChhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEluZm8gPSBtdWx0aXBhcnRVcGxvYWQodGhpcy5fcmVmLnN0b3JhZ2UsIHRoaXMuX3JlZi5fbG9jYXRpb24sIHRoaXMuX21hcHBpbmdzLCB0aGlzLl9ibG9iLCB0aGlzLl9tZXRhZGF0YSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG11bHRpcGFydFJlcXVlc3QgPSB0aGlzLl9yZWYuc3RvcmFnZS5fbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbXVsdGlwYXJ0UmVxdWVzdDtcclxuICAgICAgICAgICAgbXVsdGlwYXJ0UmVxdWVzdC5nZXRQcm9taXNlKCkudGhlbihtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByb2dyZXNzKHRoaXMuX2Jsb2Iuc2l6ZSgpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJzdWNjZXNzXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuU1VDQ0VTUyAqLyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMuX2Vycm9ySGFuZGxlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlUHJvZ3Jlc3ModHJhbnNmZXJyZWQpIHtcclxuICAgICAgICBjb25zdCBvbGQgPSB0aGlzLl90cmFuc2ZlcnJlZDtcclxuICAgICAgICB0aGlzLl90cmFuc2ZlcnJlZCA9IHRyYW5zZmVycmVkO1xyXG4gICAgICAgIC8vIEEgcHJvZ3Jlc3MgdXBkYXRlIGNhbiBtYWtlIHRoZSBcInRyYW5zZmVycmVkXCIgdmFsdWUgc21hbGxlciAoZS5nLiBhXHJcbiAgICAgICAgLy8gcGFydGlhbCB1cGxvYWQgbm90IGNvbXBsZXRlZCBieSBzZXJ2ZXIsIGFmdGVyIHdoaWNoIHRoZSBcInRyYW5zZmVycmVkXCJcclxuICAgICAgICAvLyB2YWx1ZSBtYXkgcmVzZXQgdG8gdGhlIHZhbHVlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlcXVlc3QpLlxyXG4gICAgICAgIGlmICh0aGlzLl90cmFuc2ZlcnJlZCAhPT0gb2xkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeU9ic2VydmVycygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF90cmFuc2l0aW9uKHN0YXRlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBzdGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcImNhbmNlbGluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyAqLzpcclxuICAgICAgICAgICAgY2FzZSBcInBhdXNpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HICovOlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6XHJcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgfHxcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QuY2FuY2VsKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlbmRpbmdUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGVuZGluZ1RpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1RpbWVvdXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLzpcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxyXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgfHxcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3YXNQYXVzZWQgPSB0aGlzLl9zdGF0ZSA9PT0gXCJwYXVzZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgKi87XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdhc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vdGlmeU9ic2VydmVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInBhdXNlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNFRCAqLzpcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxyXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcnMoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiY2FuY2VsZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxFRCAqLzpcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxyXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgfHxcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMSU5HKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gY2FuY2VsZWQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcnMoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5FUlJPUiAqLzpcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxyXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HIHx8XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgfHxcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMSU5HKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcnMoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiIC8qIEludGVybmFsVGFza1N0YXRlLlNVQ0NFU1MgKi86XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcclxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyB8fFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HIHx8XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2JzZXJ2ZXJzKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb21wbGV0ZVRyYW5zaXRpb25zXygpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwYXVzaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyAqLzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJwYXVzZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgKi8pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcgKi86XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwiY2FuY2VsZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxFRCAqLyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCB0YXNrIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBnZXQgc25hcHNob3QoKSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxTdGF0ZSA9IHRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZSh0aGlzLl9zdGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYnl0ZXNUcmFuc2ZlcnJlZDogdGhpcy5fdHJhbnNmZXJyZWQsXHJcbiAgICAgICAgICAgIHRvdGFsQnl0ZXM6IHRoaXMuX2Jsb2Iuc2l6ZSgpLFxyXG4gICAgICAgICAgICBzdGF0ZTogZXh0ZXJuYWxTdGF0ZSxcclxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMuX21ldGFkYXRhLFxyXG4gICAgICAgICAgICB0YXNrOiB0aGlzLFxyXG4gICAgICAgICAgICByZWY6IHRoaXMuX3JlZlxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBjYWxsYmFjayBmb3IgYW4gZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIGV2ZW50IHRvIGxpc3RlbiBmb3IuXHJcbiAgICAgKiBAcGFyYW0gbmV4dE9yT2JzZXJ2ZXIgLVxyXG4gICAgICogICAgIFRoZSBgbmV4dGAgZnVuY3Rpb24sIHdoaWNoIGdldHMgY2FsbGVkIGZvciBlYWNoIGl0ZW0gaW5cclxuICAgICAqICAgICB0aGUgZXZlbnQgc3RyZWFtLCBvciBhbiBvYnNlcnZlciBvYmplY3Qgd2l0aCBzb21lIG9yIGFsbCBvZiB0aGVzZSB0aHJlZVxyXG4gICAgICogICAgIHByb3BlcnRpZXMgKGBuZXh0YCwgYGVycm9yYCwgYGNvbXBsZXRlYCkuXHJcbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2l0aCBhIGBTdG9yYWdlRXJyb3JgXHJcbiAgICAgKiAgICAgaWYgdGhlIGV2ZW50IHN0cmVhbSBlbmRzIGR1ZSB0byBhbiBlcnJvci5cclxuICAgICAqIEBwYXJhbSBjb21wbGV0ZWQgLSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgaWYgdGhlXHJcbiAgICAgKiAgICAgZXZlbnQgc3RyZWFtIGVuZHMgbm9ybWFsbHkuXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICogICAgIElmIG9ubHkgdGhlIGV2ZW50IGFyZ3VtZW50IGlzIHBhc3NlZCwgcmV0dXJucyBhIGZ1bmN0aW9uIHlvdSBjYW4gdXNlIHRvXHJcbiAgICAgKiAgICAgYWRkIGNhbGxiYWNrcyAoc2VlIHRoZSBleGFtcGxlcyBhYm92ZSkuIElmIG1vcmUgdGhhbiBqdXN0IHRoZSBldmVudFxyXG4gICAgICogICAgIGFyZ3VtZW50IGlzIHBhc3NlZCwgcmV0dXJucyBhIGZ1bmN0aW9uIHlvdSBjYW4gY2FsbCB0byB1bnJlZ2lzdGVyIHRoZVxyXG4gICAgICogICAgIGNhbGxiYWNrcy5cclxuICAgICAqL1xyXG4gICAgb24odHlwZSwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpIHtcclxuICAgICAgICAvLyBOb3RlOiBgdHlwZWAgaXNuJ3QgYmVpbmcgdXNlZC4gSXRzIHR5cGUgaXMgYWxzbyBpbmNvcnJlY3QuIFRhc2tFdmVudCBzaG91bGQgbm90IGJlIGEgc3RyaW5nLlxyXG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE9ic2VydmVyKG5leHRPck9ic2VydmVyIHx8IHVuZGVmaW5lZCwgZXJyb3IgfHwgdW5kZWZpbmVkLCBjb21wbGV0ZWQgfHwgdW5kZWZpbmVkKTtcclxuICAgICAgICB0aGlzLl9hZGRPYnNlcnZlcihvYnNlcnZlcik7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgb2JqZWN0IGJlaGF2ZXMgbGlrZSBhIFByb21pc2UsIGFuZCByZXNvbHZlcyB3aXRoIGl0cyBzbmFwc2hvdCBkYXRhXHJcbiAgICAgKiB3aGVuIHRoZSB1cGxvYWQgY29tcGxldGVzLlxyXG4gICAgICogQHBhcmFtIG9uRnVsZmlsbGVkIC0gVGhlIGZ1bGZpbGxtZW50IGNhbGxiYWNrLiBQcm9taXNlIGNoYWluaW5nIHdvcmtzIGFzIG5vcm1hbC5cclxuICAgICAqIEBwYXJhbSBvblJlamVjdGVkIC0gVGhlIHJlamVjdGlvbiBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xyXG4gICAgICAgIC8vIFRoZXNlIGNhc3RzIGFyZSBuZWVkZWQgc28gdGhhdCBUeXBlU2NyaXB0IGNhbiBpbmZlciB0aGUgdHlwZXMgb2YgdGhlXHJcbiAgICAgICAgLy8gcmVzdWx0aW5nIFByb21pc2UuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2UudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBgdGhlbihudWxsLCBvblJlamVjdGVkKWAuXHJcbiAgICAgKi9cclxuICAgIGNhdGNoKG9uUmVqZWN0ZWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiBvYnNlcnZlci5cclxuICAgICAqL1xyXG4gICAgX2FkZE9ic2VydmVyKG9ic2VydmVyKSB7XHJcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgICAgIHRoaXMuX25vdGlmeU9ic2VydmVyKG9ic2VydmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gb2JzZXJ2ZXIuXHJcbiAgICAgKi9cclxuICAgIF9yZW1vdmVPYnNlcnZlcihvYnNlcnZlcikge1xyXG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9vYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XHJcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX25vdGlmeU9ic2VydmVycygpIHtcclxuICAgICAgICB0aGlzLl9maW5pc2hQcm9taXNlKCk7XHJcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXJzID0gdGhpcy5fb2JzZXJ2ZXJzLnNsaWNlKCk7XHJcbiAgICAgICAgb2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcihvYnNlcnZlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfZmluaXNoUHJvbWlzZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxldCB0cmlnZ2VyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZSh0aGlzLl9zdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLlNVQ0NFU1M6XHJcbiAgICAgICAgICAgICAgICAgICAgYXN5bmModGhpcy5fcmVzb2x2ZS5iaW5kKG51bGwsIHRoaXMuc25hcHNob3QpKSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuQ0FOQ0VMRUQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5FUlJPUjpcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b0NhbGwgPSB0aGlzLl9yZWplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgYXN5bmModG9DYWxsLmJpbmQobnVsbCwgdGhpcy5fZXJyb3IpKSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHJpZ2dlcmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX25vdGlmeU9ic2VydmVyKG9ic2VydmVyKSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxTdGF0ZSA9IHRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZSh0aGlzLl9zdGF0ZSk7XHJcbiAgICAgICAgc3dpdGNoIChleHRlcm5hbFN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLlJVTk5JTkc6XHJcbiAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLlBBVVNFRDpcclxuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMob2JzZXJ2ZXIubmV4dC5iaW5kKG9ic2VydmVyLCB0aGlzLnNuYXBzaG90KSkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5TVUNDRVNTOlxyXG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMob2JzZXJ2ZXIuY29tcGxldGUuYmluZChvYnNlcnZlcikpKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuQ0FOQ0VMRUQ6XHJcbiAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLkVSUk9SOlxyXG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMob2JzZXJ2ZXIuZXJyb3IuYmluZChvYnNlcnZlciwgdGhpcy5fZXJyb3IpKSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogYXNzZXJ0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKG9ic2VydmVyLmVycm9yLmJpbmQob2JzZXJ2ZXIsIHRoaXMuX2Vycm9yKSkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc3VtZXMgYSBwYXVzZWQgdGFzay4gSGFzIG5vIGVmZmVjdCBvbiBhIGN1cnJlbnRseSBydW5uaW5nIG9yIGZhaWxlZCB0YXNrLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIHRvb2sgZWZmZWN0LCBmYWxzZSBpZiBpZ25vcmVkLlxyXG4gICAgICovXHJcbiAgICByZXN1bWUoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLl9zdGF0ZSA9PT0gXCJwYXVzZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgKi8gfHxcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPT09IFwicGF1c2luZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgKi87XHJcbiAgICAgICAgaWYgKHZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWxpZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGF1c2VzIGEgY3VycmVudGx5IHJ1bm5pbmcgdGFzay4gSGFzIG5vIGVmZmVjdCBvbiBhIHBhdXNlZCBvciBmYWlsZWQgdGFzay5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG9wZXJhdGlvbiB0b29rIGVmZmVjdCwgZmFsc2UgaWYgaWdub3JlZC5cclxuICAgICAqL1xyXG4gICAgcGF1c2UoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLl9zdGF0ZSA9PT0gXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLztcclxuICAgICAgICBpZiAodmFsaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcInBhdXNpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW5jZWxzIGEgY3VycmVudGx5IHJ1bm5pbmcgb3IgcGF1c2VkIHRhc2suIEhhcyBubyBlZmZlY3Qgb24gYSBjb21wbGV0ZSBvclxyXG4gICAgICogZmFpbGVkIHRhc2suXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBvcGVyYXRpb24gdG9vayBlZmZlY3QsIGZhbHNlIGlmIGlnbm9yZWQuXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMuX3N0YXRlID09PSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovIHx8XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID09PSBcInBhdXNpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HICovO1xyXG4gICAgICAgIGlmICh2YWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwiY2FuY2VsaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMSU5HICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBtZXRob2RzIHRvIGludGVyYWN0IHdpdGggYSBidWNrZXQgaW4gdGhlIEZpcmViYXNlIFN0b3JhZ2Ugc2VydmljZS5cclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSBfbG9jYXRpb24gLSBBbiBmYnMubG9jYXRpb24sIG9yIHRoZSBVUkwgYXRcclxuICogICAgIHdoaWNoIHRvIGJhc2UgdGhpcyBvYmplY3QsIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1zOlxyXG4gKiAgICAgICAgIGdzOi8vPGJ1Y2tldD4vPG9iamVjdC1wYXRoPlxyXG4gKiAgICAgICAgIGh0dHBbc106Ly9maXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vXHJcbiAqICAgICAgICAgICAgICAgICAgICAgPGFwaS12ZXJzaW9uPi9iLzxidWNrZXQ+L28vPG9iamVjdC1wYXRoPlxyXG4gKiAgICAgQW55IHF1ZXJ5IG9yIGZyYWdtZW50IHN0cmluZ3Mgd2lsbCBiZSBpZ25vcmVkIGluIHRoZSBodHRwW3NdXHJcbiAqICAgICBmb3JtYXQuIElmIG5vIHZhbHVlIGlzIHBhc3NlZCwgdGhlIHN0b3JhZ2Ugb2JqZWN0IHdpbGwgdXNlIGEgVVJMIGJhc2VkIG9uXHJcbiAqICAgICB0aGUgcHJvamVjdCBJRCBvZiB0aGUgYmFzZSBmaXJlYmFzZS5BcHAgaW5zdGFuY2UuXHJcbiAqL1xyXG5jbGFzcyBSZWZlcmVuY2Uge1xyXG4gICAgY29uc3RydWN0b3IoX3NlcnZpY2UsIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fc2VydmljZSA9IF9zZXJ2aWNlO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbiBpbnN0YW5jZW9mIExvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IExvY2F0aW9uLm1ha2VGcm9tVXJsKGxvY2F0aW9uLCBfc2VydmljZS5ob3N0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFVSTCBmb3IgdGhlIGJ1Y2tldCBhbmQgcGF0aCB0aGlzIG9iamVjdCByZWZlcmVuY2VzLFxyXG4gICAgICogICAgIGluIHRoZSBmb3JtIGdzOi8vPGJ1Y2tldD4vPG9iamVjdC1wYXRoPlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnZ3M6Ly8nICsgdGhpcy5fbG9jYXRpb24uYnVja2V0ICsgJy8nICsgdGhpcy5fbG9jYXRpb24ucGF0aDtcclxuICAgIH1cclxuICAgIF9uZXdSZWYoc2VydmljZSwgbG9jYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZShzZXJ2aWNlLCBsb2NhdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSByb290IG9mIHRoaXMgb2JqZWN0J3MgYnVja2V0LlxyXG4gICAgICovXHJcbiAgICBnZXQgcm9vdCgpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG5ldyBMb2NhdGlvbih0aGlzLl9sb2NhdGlvbi5idWNrZXQsICcnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmV3UmVmKHRoaXMuX3NlcnZpY2UsIGxvY2F0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGJ1Y2tldCBjb250YWluaW5nIHRoaXMgcmVmZXJlbmNlJ3Mgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBnZXQgYnVja2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbi5idWNrZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmdWxsIHBhdGggb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGdldCBmdWxsUGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb24ucGF0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNob3J0IG5hbWUgb2YgdGhpcyBvYmplY3QsIHdoaWNoIGlzIHRoZSBsYXN0IGNvbXBvbmVudCBvZiB0aGUgZnVsbCBwYXRoLlxyXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIGZ1bGxQYXRoIGlzICdmdWxsL3BhdGgvaW1hZ2UucG5nJywgbmFtZSBpcyAnaW1hZ2UucG5nJy5cclxuICAgICAqL1xyXG4gICAgZ2V0IG5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGxhc3RDb21wb25lbnQodGhpcy5fbG9jYXRpb24ucGF0aCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgU3RvcmFnZVNlcnZpY2VgIGluc3RhbmNlIHRoaXMgYFN0b3JhZ2VSZWZlcmVuY2VgIGlzIGFzc29jaWF0ZWQgd2l0aC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHN0b3JhZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZpY2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgYFN0b3JhZ2VSZWZlcmVuY2VgIHBvaW50aW5nIHRvIHRoZSBwYXJlbnQgbG9jYXRpb24gb2YgdGhpcyBgU3RvcmFnZVJlZmVyZW5jZWAsIG9yIG51bGwgaWZcclxuICAgICAqIHRoaXMgcmVmZXJlbmNlIGlzIHRoZSByb290LlxyXG4gICAgICovXHJcbiAgICBnZXQgcGFyZW50KCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1BhdGggPSBwYXJlbnQodGhpcy5fbG9jYXRpb24ucGF0aCk7XHJcbiAgICAgICAgaWYgKG5ld1BhdGggPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gbmV3IExvY2F0aW9uKHRoaXMuX2xvY2F0aW9uLmJ1Y2tldCwgbmV3UGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWZlcmVuY2UodGhpcy5fc2VydmljZSwgbG9jYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIHRocm93IGFuIGVycm9yIGluIG1ldGhvZHMgdGhhdCBkbyBub3QgYWNjZXB0IGEgcm9vdCByZWZlcmVuY2UuXHJcbiAgICAgKi9cclxuICAgIF90aHJvd0lmUm9vdChuYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvY2F0aW9uLnBhdGggPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IGludmFsaWRSb290T3BlcmF0aW9uKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogRG93bmxvYWQgdGhlIGJ5dGVzIGF0IHRoZSBvYmplY3QncyBsb2NhdGlvbi5cclxuICogQHJldHVybnMgQSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIGRvd25sb2FkZWQgYnl0ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCeXRlc0ludGVybmFsKHJlZiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpIHtcclxuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ2dldEJ5dGVzJyk7XHJcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGdldEJ5dGVzJDEocmVmLnN0b3JhZ2UsIHJlZi5fbG9jYXRpb24sIG1heERvd25sb2FkU2l6ZUJ5dGVzKTtcclxuICAgIHJldHVybiByZWYuc3RvcmFnZVxyXG4gICAgICAgIC5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld0J5dGVzQ29ubmVjdGlvbilcclxuICAgICAgICAudGhlbihieXRlcyA9PiBtYXhEb3dubG9hZFNpemVCeXRlcyAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgPyAvLyBHQ1MgbWF5IG5vdCBob25vciB0aGUgUmFuZ2UgaGVhZGVyIGZvciBzbWFsbCBmaWxlc1xyXG4gICAgICAgICAgICBieXRlcy5zbGljZSgwLCBtYXhEb3dubG9hZFNpemVCeXRlcylcclxuICAgICAgICA6IGJ5dGVzKTtcclxufVxyXG4vKiogU3RyZWFtIHRoZSBieXRlcyBhdCB0aGUgb2JqZWN0J3MgbG9jYXRpb24uICovXHJcbmZ1bmN0aW9uIGdldFN0cmVhbUludGVybmFsKHJlZiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpIHtcclxuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ2dldFN0cmVhbScpO1xyXG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBnZXRCeXRlcyQxKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBtYXhEb3dubG9hZFNpemVCeXRlcyk7XHJcbiAgICAvKiogQSB0cmFuc2Zvcm1lciB0aGF0IHBhc3NlcyB0aHJvdWdoIHRoZSBmaXJzdCBuIGJ5dGVzLiAqL1xyXG4gICAgY29uc3QgbmV3TWF4U2l6ZVRyYW5zZm9ybSA9IG4gPT4ge1xyXG4gICAgICAgIGxldCBtaXNzaW5nQnl0ZXMgPSBuO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBHQ1MgbWF5IG5vdCBob25vciB0aGUgUmFuZ2UgaGVhZGVyIGZvciBzbWFsbCBmaWxlc1xyXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLmxlbmd0aCA8IG1pc3NpbmdCeXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaChjaHVuayk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZ0J5dGVzIC09IGNodW5rLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaChjaHVuay5zbGljZSgwLCBtaXNzaW5nQnl0ZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2VuZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzdWx0ID0gbWF4RG93bmxvYWRTaXplQnl0ZXMgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gbmV3IFRyYW5zZm9ybShuZXdNYXhTaXplVHJhbnNmb3JtKG1heERvd25sb2FkU2l6ZUJ5dGVzKSlcclxuICAgICAgICA6IG5ldyBQYXNzVGhyb3VnaCgpO1xyXG4gICAgcmVmLnN0b3JhZ2VcclxuICAgICAgICAubWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCBuZXdTdHJlYW1Db25uZWN0aW9uKVxyXG4gICAgICAgIC50aGVuKHN0cmVhbSA9PiBzdHJlYW0ucGlwZShyZXN1bHQpKVxyXG4gICAgICAgIC5jYXRjaChlID0+IHJlc3VsdC5kZXN0cm95KGUpKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIFVwbG9hZHMgZGF0YSB0byB0aGlzIG9iamVjdCdzIGxvY2F0aW9uLlxyXG4gKiBUaGUgdXBsb2FkIGlzIG5vdCByZXN1bWFibGUuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHdoZXJlIGRhdGEgc2hvdWxkIGJlIHVwbG9hZGVkLlxyXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVwbG9hZC5cclxuICogQHBhcmFtIG1ldGFkYXRhIC0gTWV0YWRhdGEgZm9yIHRoZSBuZXdseSB1cGxvYWRlZCBkYXRhLlxyXG4gKiBAcmV0dXJucyBBIFByb21pc2UgY29udGFpbmluZyBhbiBVcGxvYWRSZXN1bHRcclxuICovXHJcbmZ1bmN0aW9uIHVwbG9hZEJ5dGVzJDEocmVmLCBkYXRhLCBtZXRhZGF0YSkge1xyXG4gICAgcmVmLl90aHJvd0lmUm9vdCgndXBsb2FkQnl0ZXMnKTtcclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbXVsdGlwYXJ0VXBsb2FkKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBnZXRNYXBwaW5ncygpLCBuZXcgRmJzQmxvYihkYXRhLCB0cnVlKSwgbWV0YWRhdGEpO1xyXG4gICAgcmV0dXJuIHJlZi5zdG9yYWdlXHJcbiAgICAgICAgLm1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24pXHJcbiAgICAgICAgLnRoZW4oZmluYWxNZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWV0YWRhdGE6IGZpbmFsTWV0YWRhdGEsXHJcbiAgICAgICAgICAgIHJlZlxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogVXBsb2FkcyBkYXRhIHRvIHRoaXMgb2JqZWN0J3MgbG9jYXRpb24uXHJcbiAqIFRoZSB1cGxvYWQgY2FuIGJlIHBhdXNlZCBhbmQgcmVzdW1lZCwgYW5kIGV4cG9zZXMgcHJvZ3Jlc3MgdXBkYXRlcy5cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB3aGVyZSBkYXRhIHNob3VsZCBiZSB1cGxvYWRlZC5cclxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1cGxvYWQuXHJcbiAqIEBwYXJhbSBtZXRhZGF0YSAtIE1ldGFkYXRhIGZvciB0aGUgbmV3bHkgdXBsb2FkZWQgZGF0YS5cclxuICogQHJldHVybnMgQW4gVXBsb2FkVGFza1xyXG4gKi9cclxuZnVuY3Rpb24gdXBsb2FkQnl0ZXNSZXN1bWFibGUkMShyZWYsIGRhdGEsIG1ldGFkYXRhKSB7XHJcbiAgICByZWYuX3Rocm93SWZSb290KCd1cGxvYWRCeXRlc1Jlc3VtYWJsZScpO1xyXG4gICAgcmV0dXJuIG5ldyBVcGxvYWRUYXNrKHJlZiwgbmV3IEZic0Jsb2IoZGF0YSksIG1ldGFkYXRhKTtcclxufVxyXG4vKipcclxuICogVXBsb2FkcyBhIHN0cmluZyB0byB0aGlzIG9iamVjdCdzIGxvY2F0aW9uLlxyXG4gKiBUaGUgdXBsb2FkIGlzIG5vdCByZXN1bWFibGUuXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2Ugd2hlcmUgc3RyaW5nIHNob3VsZCBiZSB1cGxvYWRlZC5cclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byB1cGxvYWQuXHJcbiAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IG9mIHRoZSBzdHJpbmcgdG8gdXBsb2FkLlxyXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSBmb3IgdGhlIG5ld2x5IHVwbG9hZGVkIHN0cmluZy5cclxuICogQHJldHVybnMgQSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gVXBsb2FkUmVzdWx0XHJcbiAqL1xyXG5mdW5jdGlvbiB1cGxvYWRTdHJpbmckMShyZWYsIHZhbHVlLCBmb3JtYXQgPSBTdHJpbmdGb3JtYXQuUkFXLCBtZXRhZGF0YSkge1xyXG4gICAgcmVmLl90aHJvd0lmUm9vdCgndXBsb2FkU3RyaW5nJyk7XHJcbiAgICBjb25zdCBkYXRhID0gZGF0YUZyb21TdHJpbmcoZm9ybWF0LCB2YWx1ZSk7XHJcbiAgICBjb25zdCBtZXRhZGF0YUNsb25lID0gT2JqZWN0LmFzc2lnbih7fSwgbWV0YWRhdGEpO1xyXG4gICAgaWYgKG1ldGFkYXRhQ2xvbmVbJ2NvbnRlbnRUeXBlJ10gPT0gbnVsbCAmJiBkYXRhLmNvbnRlbnRUeXBlICE9IG51bGwpIHtcclxuICAgICAgICBtZXRhZGF0YUNsb25lWydjb250ZW50VHlwZSddID0gZGF0YS5jb250ZW50VHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiB1cGxvYWRCeXRlcyQxKHJlZiwgZGF0YS5kYXRhLCBtZXRhZGF0YUNsb25lKTtcclxufVxyXG4vKipcclxuICogTGlzdCBhbGwgaXRlbXMgKGZpbGVzKSBhbmQgcHJlZml4ZXMgKGZvbGRlcnMpIHVuZGVyIHRoaXMgc3RvcmFnZSByZWZlcmVuY2UuXHJcbiAqXHJcbiAqIFRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kIGZvciBjYWxsaW5nIGxpc3QoKSByZXBlYXRlZGx5IHVudGlsIHRoZXJlIGFyZVxyXG4gKiBubyBtb3JlIHJlc3VsdHMuIFRoZSBkZWZhdWx0IHBhZ2luYXRpb24gc2l6ZSBpcyAxMDAwLlxyXG4gKlxyXG4gKiBOb3RlOiBUaGUgcmVzdWx0cyBtYXkgbm90IGJlIGNvbnNpc3RlbnQgaWYgb2JqZWN0cyBhcmUgY2hhbmdlZCB3aGlsZSB0aGlzXHJcbiAqIG9wZXJhdGlvbiBpcyBydW5uaW5nLlxyXG4gKlxyXG4gKiBXYXJuaW5nOiBsaXN0QWxsIG1heSBwb3RlbnRpYWxseSBjb25zdW1lIHRvbyBtYW55IHJlc291cmNlcyBpZiB0aGVyZSBhcmVcclxuICogdG9vIG1hbnkgcmVzdWx0cy5cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB0byBnZXQgbGlzdCBmcm9tLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFsbCB0aGUgaXRlbXMgYW5kIHByZWZpeGVzIHVuZGVyXHJcbiAqICAgICAgdGhlIGN1cnJlbnQgc3RvcmFnZSByZWZlcmVuY2UuIGBwcmVmaXhlc2AgY29udGFpbnMgcmVmZXJlbmNlcyB0b1xyXG4gKiAgICAgIHN1Yi1kaXJlY3RvcmllcyBhbmQgYGl0ZW1zYCBjb250YWlucyByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gdGhpc1xyXG4gKiAgICAgIGZvbGRlci4gYG5leHRQYWdlVG9rZW5gIGlzIG5ldmVyIHJldHVybmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gbGlzdEFsbCQxKHJlZikge1xyXG4gICAgY29uc3QgYWNjdW11bGF0b3IgPSB7XHJcbiAgICAgICAgcHJlZml4ZXM6IFtdLFxyXG4gICAgICAgIGl0ZW1zOiBbXVxyXG4gICAgfTtcclxuICAgIHJldHVybiBsaXN0QWxsSGVscGVyKHJlZiwgYWNjdW11bGF0b3IpLnRoZW4oKCkgPT4gYWNjdW11bGF0b3IpO1xyXG59XHJcbi8qKlxyXG4gKiBTZXBhcmF0ZWQgZnJvbSBsaXN0QWxsIGJlY2F1c2UgYXN5bmMgZnVuY3Rpb25zIGNhbid0IHVzZSBcImFyZ3VtZW50c1wiLlxyXG4gKiBAcGFyYW0gcmVmXHJcbiAqIEBwYXJhbSBhY2N1bXVsYXRvclxyXG4gKiBAcGFyYW0gcGFnZVRva2VuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBsaXN0QWxsSGVscGVyKHJlZiwgYWNjdW11bGF0b3IsIHBhZ2VUb2tlbikge1xyXG4gICAgY29uc3Qgb3B0ID0ge1xyXG4gICAgICAgIC8vIG1heFJlc3VsdHMgaXMgMTAwMCBieSBkZWZhdWx0LlxyXG4gICAgICAgIHBhZ2VUb2tlblxyXG4gICAgfTtcclxuICAgIGNvbnN0IG5leHRQYWdlID0gYXdhaXQgbGlzdCQxKHJlZiwgb3B0KTtcclxuICAgIGFjY3VtdWxhdG9yLnByZWZpeGVzLnB1c2goLi4ubmV4dFBhZ2UucHJlZml4ZXMpO1xyXG4gICAgYWNjdW11bGF0b3IuaXRlbXMucHVzaCguLi5uZXh0UGFnZS5pdGVtcyk7XHJcbiAgICBpZiAobmV4dFBhZ2UubmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XHJcbiAgICAgICAgYXdhaXQgbGlzdEFsbEhlbHBlcihyZWYsIGFjY3VtdWxhdG9yLCBuZXh0UGFnZS5uZXh0UGFnZVRva2VuKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTGlzdCBpdGVtcyAoZmlsZXMpIGFuZCBwcmVmaXhlcyAoZm9sZGVycykgdW5kZXIgdGhpcyBzdG9yYWdlIHJlZmVyZW5jZS5cclxuICpcclxuICogTGlzdCBBUEkgaXMgb25seSBhdmFpbGFibGUgZm9yIEZpcmViYXNlIFJ1bGVzIFZlcnNpb24gMi5cclxuICpcclxuICogR0NTIGlzIGEga2V5LWJsb2Igc3RvcmUuIEZpcmViYXNlIFN0b3JhZ2UgaW1wb3NlcyB0aGUgc2VtYW50aWMgb2YgJy8nXHJcbiAqIGRlbGltaXRlZCBmb2xkZXIgc3RydWN0dXJlLlxyXG4gKiBSZWZlciB0byBHQ1MncyBMaXN0IEFQSSBpZiB5b3Ugd2FudCB0byBsZWFybiBtb3JlLlxyXG4gKlxyXG4gKiBUbyBhZGhlcmUgdG8gRmlyZWJhc2UgUnVsZXMncyBTZW1hbnRpY3MsIEZpcmViYXNlIFN0b3JhZ2UgZG9lcyBub3RcclxuICogc3VwcG9ydCBvYmplY3RzIHdob3NlIHBhdGhzIGVuZCB3aXRoIFwiL1wiIG9yIGNvbnRhaW4gdHdvIGNvbnNlY3V0aXZlXHJcbiAqIFwiL1wicy4gRmlyZWJhc2UgU3RvcmFnZSBMaXN0IEFQSSB3aWxsIGZpbHRlciB0aGVzZSB1bnN1cHBvcnRlZCBvYmplY3RzLlxyXG4gKiBsaXN0KCkgbWF5IGZhaWwgaWYgdGhlcmUgYXJlIHRvbyBtYW55IHVuc3VwcG9ydGVkIG9iamVjdHMgaW4gdGhlIGJ1Y2tldC5cclxuICogQHB1YmxpY1xyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB0byBnZXQgbGlzdCBmcm9tLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFNlZSBMaXN0T3B0aW9ucyBmb3IgZGV0YWlscy5cclxuICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgaXRlbXMgYW5kIHByZWZpeGVzLlxyXG4gKiAgICAgIGBwcmVmaXhlc2AgY29udGFpbnMgcmVmZXJlbmNlcyB0byBzdWItZm9sZGVycyBhbmQgYGl0ZW1zYFxyXG4gKiAgICAgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyBpbiB0aGlzIGZvbGRlci4gYG5leHRQYWdlVG9rZW5gXHJcbiAqICAgICAgY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSByZXN0IG9mIHRoZSByZXN1bHRzLlxyXG4gKi9cclxuZnVuY3Rpb24gbGlzdCQxKHJlZiwgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXhSZXN1bHRzID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZU51bWJlcignb3B0aW9ucy5tYXhSZXN1bHRzJywgXHJcbiAgICAgICAgICAgIC8qIG1pblZhbHVlPSAqLyAxLCBcclxuICAgICAgICAgICAgLyogbWF4VmFsdWU9ICovIDEwMDAsIG9wdGlvbnMubWF4UmVzdWx0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgb3AgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBsaXN0JDIocmVmLnN0b3JhZ2UsIHJlZi5fbG9jYXRpb24sIFxyXG4gICAgLypkZWxpbWl0ZXI9ICovICcvJywgb3AucGFnZVRva2VuLCBvcC5tYXhSZXN1bHRzKTtcclxuICAgIHJldHVybiByZWYuc3RvcmFnZS5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uKTtcclxufVxyXG4vKipcclxuICogQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBtZXRhZGF0YSBmb3IgdGhpcyBvYmplY3QuIElmIHRoaXNcclxuICogb2JqZWN0IGRvZXNuJ3QgZXhpc3Qgb3IgbWV0YWRhdGEgY2Fubm90IGJlIHJldHJlaXZlZCwgdGhlIHByb21pc2UgaXNcclxuICogcmVqZWN0ZWQuXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2UgdG8gZ2V0IG1ldGFkYXRhIGZyb20uXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNZXRhZGF0YSQxKHJlZikge1xyXG4gICAgcmVmLl90aHJvd0lmUm9vdCgnZ2V0TWV0YWRhdGEnKTtcclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gZ2V0TWV0YWRhdGEkMihyZWYuc3RvcmFnZSwgcmVmLl9sb2NhdGlvbiwgZ2V0TWFwcGluZ3MoKSk7XHJcbiAgICByZXR1cm4gcmVmLnN0b3JhZ2UubWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbik7XHJcbn1cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIG1ldGFkYXRhIGZvciB0aGlzIG9iamVjdC5cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB0byB1cGRhdGUgbWV0YWRhdGEgZm9yLlxyXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBUaGUgbmV3IG1ldGFkYXRhIGZvciB0aGUgb2JqZWN0LlxyXG4gKiAgICAgT25seSB2YWx1ZXMgdGhhdCBoYXZlIGJlZW4gZXhwbGljaXRseSBzZXQgd2lsbCBiZSBjaGFuZ2VkLiBFeHBsaWNpdGx5XHJcbiAqICAgICBzZXR0aW5nIGEgdmFsdWUgdG8gbnVsbCB3aWxsIHJlbW92ZSB0aGUgbWV0YWRhdGEuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXNcclxuICogICAgIHdpdGggdGhlIG5ldyBtZXRhZGF0YSBmb3IgdGhpcyBvYmplY3QuXHJcbiAqICAgICBTZWUgYGZpcmViYXNlU3RvcmFnZS5SZWZlcmVuY2UucHJvdG90eXBlLmdldE1ldGFkYXRhYFxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlTWV0YWRhdGEkMShyZWYsIG1ldGFkYXRhKSB7XHJcbiAgICByZWYuX3Rocm93SWZSb290KCd1cGRhdGVNZXRhZGF0YScpO1xyXG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSB1cGRhdGVNZXRhZGF0YSQyKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBtZXRhZGF0YSwgZ2V0TWFwcGluZ3MoKSk7XHJcbiAgICByZXR1cm4gcmVmLnN0b3JhZ2UubWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbik7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRvd25sb2FkIFVSTCBmb3IgdGhlIGdpdmVuIFJlZmVyZW5jZS5cclxuICogQHB1YmxpY1xyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGRvd25sb2FkXHJcbiAqICAgICBVUkwgZm9yIHRoaXMgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RG93bmxvYWRVUkwkMShyZWYpIHtcclxuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ2dldERvd25sb2FkVVJMJyk7XHJcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGdldERvd25sb2FkVXJsKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBnZXRNYXBwaW5ncygpKTtcclxuICAgIHJldHVybiByZWYuc3RvcmFnZVxyXG4gICAgICAgIC5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uKVxyXG4gICAgICAgIC50aGVuKHVybCA9PiB7XHJcbiAgICAgICAgaWYgKHVybCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBub0Rvd25sb2FkVVJMKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogRGVsZXRlcyB0aGUgb2JqZWN0IGF0IHRoaXMgbG9jYXRpb24uXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2UgZm9yIG9iamVjdCB0byBkZWxldGUuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgaWYgdGhlIGRlbGV0aW9uIHN1Y2NlZWRzLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVsZXRlT2JqZWN0JDEocmVmKSB7XHJcbiAgICByZWYuX3Rocm93SWZSb290KCdkZWxldGVPYmplY3QnKTtcclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gZGVsZXRlT2JqZWN0JDIocmVmLnN0b3JhZ2UsIHJlZi5fbG9jYXRpb24pO1xyXG4gICAgcmV0dXJuIHJlZi5zdG9yYWdlLm1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHJlZmVyZW5jZSBmb3Igb2JqZWN0IG9idGFpbmVkIGJ5IGFwcGVuZGluZyBgY2hpbGRQYXRoYCB0byBgcmVmYC5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2UgdG8gZ2V0IGNoaWxkIG9mLlxyXG4gKiBAcGFyYW0gY2hpbGRQYXRoIC0gQ2hpbGQgcGF0aCBmcm9tIHByb3ZpZGVkIHJlZi5cclxuICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhlIG9iamVjdCBvYnRhaW5lZCBieVxyXG4gKiBhcHBlbmRpbmcgY2hpbGRQYXRoLCByZW1vdmluZyBhbnkgZHVwbGljYXRlLCBiZWdpbm5pbmcsIG9yIHRyYWlsaW5nXHJcbiAqIHNsYXNoZXMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0Q2hpbGQkMShyZWYsIGNoaWxkUGF0aCkge1xyXG4gICAgY29uc3QgbmV3UGF0aCA9IGNoaWxkKHJlZi5fbG9jYXRpb24ucGF0aCwgY2hpbGRQYXRoKTtcclxuICAgIGNvbnN0IGxvY2F0aW9uID0gbmV3IExvY2F0aW9uKHJlZi5fbG9jYXRpb24uYnVja2V0LCBuZXdQYXRoKTtcclxuICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHJlZi5zdG9yYWdlLCBsb2NhdGlvbik7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNVcmwocGF0aCkge1xyXG4gICAgcmV0dXJuIC9eW0EtWmEtel0rOlxcL1xcLy8udGVzdChwYXRoKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGZpcmViYXNlU3RvcmFnZS5SZWZlcmVuY2UgZm9yIHRoZSBnaXZlbiB1cmwuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWZGcm9tVVJMKHNlcnZpY2UsIHVybCkge1xyXG4gICAgcmV0dXJuIG5ldyBSZWZlcmVuY2Uoc2VydmljZSwgdXJsKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGZpcmViYXNlU3RvcmFnZS5SZWZlcmVuY2UgZm9yIHRoZSBnaXZlbiBwYXRoIGluIHRoZSBkZWZhdWx0XHJcbiAqIGJ1Y2tldC5cclxuICovXHJcbmZ1bmN0aW9uIHJlZkZyb21QYXRoKHJlZiwgcGF0aCkge1xyXG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIEZpcmViYXNlU3RvcmFnZUltcGwpIHtcclxuICAgICAgICBjb25zdCBzZXJ2aWNlID0gcmVmO1xyXG4gICAgICAgIGlmIChzZXJ2aWNlLl9idWNrZXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBub0RlZmF1bHRCdWNrZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gbmV3IFJlZmVyZW5jZShzZXJ2aWNlLCBzZXJ2aWNlLl9idWNrZXQpO1xyXG4gICAgICAgIGlmIChwYXRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZkZyb21QYXRoKHJlZmVyZW5jZSwgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVmZXJlbmNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHJlZiBpcyBhIFJlZmVyZW5jZVxyXG4gICAgICAgIGlmIChwYXRoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9nZXRDaGlsZCQxKHJlZiwgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVmO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZWYkMShzZXJ2aWNlT3JSZWYsIHBhdGhPclVybCkge1xyXG4gICAgaWYgKHBhdGhPclVybCAmJiBpc1VybChwYXRoT3JVcmwpKSB7XHJcbiAgICAgICAgaWYgKHNlcnZpY2VPclJlZiBpbnN0YW5jZW9mIEZpcmViYXNlU3RvcmFnZUltcGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZkZyb21VUkwoc2VydmljZU9yUmVmLCBwYXRoT3JVcmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgaW52YWxpZEFyZ3VtZW50KCdUbyB1c2UgcmVmKHNlcnZpY2UsIHVybCksIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgU3RvcmFnZSBpbnN0YW5jZS4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcmVmRnJvbVBhdGgoc2VydmljZU9yUmVmLCBwYXRoT3JVcmwpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RCdWNrZXQoaG9zdCwgY29uZmlnKSB7XHJcbiAgICBjb25zdCBidWNrZXRTdHJpbmcgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWdbQ09ORklHX1NUT1JBR0VfQlVDS0VUX0tFWV07XHJcbiAgICBpZiAoYnVja2V0U3RyaW5nID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBMb2NhdGlvbi5tYWtlRnJvbUJ1Y2tldFNwZWMoYnVja2V0U3RyaW5nLCBob3N0KTtcclxufVxyXG5mdW5jdGlvbiBjb25uZWN0U3RvcmFnZUVtdWxhdG9yJDEoc3RvcmFnZSwgaG9zdCwgcG9ydCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdG9yYWdlLmhvc3QgPSBgJHtob3N0fToke3BvcnR9YDtcclxuICAgIHN0b3JhZ2UuX3Byb3RvY29sID0gJ2h0dHAnO1xyXG4gICAgY29uc3QgeyBtb2NrVXNlclRva2VuIH0gPSBvcHRpb25zO1xyXG4gICAgaWYgKG1vY2tVc2VyVG9rZW4pIHtcclxuICAgICAgICBzdG9yYWdlLl9vdmVycmlkZUF1dGhUb2tlbiA9XHJcbiAgICAgICAgICAgIHR5cGVvZiBtb2NrVXNlclRva2VuID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAgICAgPyBtb2NrVXNlclRva2VuXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZU1vY2tVc2VyVG9rZW4obW9ja1VzZXJUb2tlbiwgc3RvcmFnZS5hcHAub3B0aW9ucy5wcm9qZWN0SWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIHNlcnZpY2UgdGhhdCBwcm92aWRlcyBGaXJlYmFzZSBTdG9yYWdlIFJlZmVyZW5jZSBpbnN0YW5jZXMuXHJcbiAqIEBwYXJhbSBvcHRfdXJsIC0gZ3M6Ly8gdXJsIHRvIGEgY3VzdG9tIFN0b3JhZ2UgQnVja2V0XHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgRmlyZWJhc2VTdG9yYWdlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogRmlyZWJhc2VBcHAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgU3RvcmFnZVNlcnZpY2UgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGFwcCwgX2F1dGhQcm92aWRlciwgXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfYXBwQ2hlY2tQcm92aWRlciwgXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfdXJsLCBfZmlyZWJhc2VWZXJzaW9uKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5fYXV0aFByb3ZpZGVyID0gX2F1dGhQcm92aWRlcjtcclxuICAgICAgICB0aGlzLl9hcHBDaGVja1Byb3ZpZGVyID0gX2FwcENoZWNrUHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5fdXJsID0gX3VybDtcclxuICAgICAgICB0aGlzLl9maXJlYmFzZVZlcnNpb24gPSBfZmlyZWJhc2VWZXJzaW9uO1xyXG4gICAgICAgIHRoaXMuX2J1Y2tldCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBzdHJpbmcgY2FuIGJlIGluIHRoZSBmb3JtYXRzOlxyXG4gICAgICAgICAqIC0gaG9zdFxyXG4gICAgICAgICAqIC0gaG9zdDpwb3J0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faG9zdCA9IERFRkFVTFRfSE9TVDtcclxuICAgICAgICB0aGlzLl9wcm90b2NvbCA9ICdodHRwcyc7XHJcbiAgICAgICAgdGhpcy5fYXBwSWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2RlbGV0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9tYXhPcGVyYXRpb25SZXRyeVRpbWUgPSBERUZBVUxUX01BWF9PUEVSQVRJT05fUkVUUllfVElNRTtcclxuICAgICAgICB0aGlzLl9tYXhVcGxvYWRSZXRyeVRpbWUgPSBERUZBVUxUX01BWF9VUExPQURfUkVUUllfVElNRTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0cyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBpZiAoX3VybCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1Y2tldCA9IExvY2F0aW9uLm1ha2VGcm9tQnVja2V0U3BlYyhfdXJsLCB0aGlzLl9ob3N0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1Y2tldCA9IGV4dHJhY3RCdWNrZXQodGhpcy5faG9zdCwgdGhpcy5hcHAub3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaG9zdCBzdHJpbmcgZm9yIHRoaXMgc2VydmljZSwgaW4gdGhlIGZvcm0gb2YgYGhvc3RgIG9yXHJcbiAgICAgKiBgaG9zdDpwb3J0YC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGhvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvc3Q7XHJcbiAgICB9XHJcbiAgICBzZXQgaG9zdChob3N0KSB7XHJcbiAgICAgICAgdGhpcy5faG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgaWYgKHRoaXMuX3VybCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1Y2tldCA9IExvY2F0aW9uLm1ha2VGcm9tQnVja2V0U3BlYyh0aGlzLl91cmwsIGhvc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fYnVja2V0ID0gZXh0cmFjdEJ1Y2tldChob3N0LCB0aGlzLmFwcC5vcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXhpbXVtIHRpbWUgdG8gcmV0cnkgdXBsb2FkcyBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIGdldCBtYXhVcGxvYWRSZXRyeVRpbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heFVwbG9hZFJldHJ5VGltZTtcclxuICAgIH1cclxuICAgIHNldCBtYXhVcGxvYWRSZXRyeVRpbWUodGltZSkge1xyXG4gICAgICAgIHZhbGlkYXRlTnVtYmVyKCd0aW1lJywgXHJcbiAgICAgICAgLyogbWluVmFsdWU9Ki8gMCwgXHJcbiAgICAgICAgLyogbWF4VmFsdWU9ICovIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdGltZSk7XHJcbiAgICAgICAgdGhpcy5fbWF4VXBsb2FkUmV0cnlUaW1lID0gdGltZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gdGltZSB0byByZXRyeSBvcGVyYXRpb25zIG90aGVyIHRoYW4gdXBsb2FkcyBvciBkb3dubG9hZHMgaW5cclxuICAgICAqIG1pbGxpc2Vjb25kcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IG1heE9wZXJhdGlvblJldHJ5VGltZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWF4T3BlcmF0aW9uUmV0cnlUaW1lO1xyXG4gICAgfVxyXG4gICAgc2V0IG1heE9wZXJhdGlvblJldHJ5VGltZSh0aW1lKSB7XHJcbiAgICAgICAgdmFsaWRhdGVOdW1iZXIoJ3RpbWUnLCBcclxuICAgICAgICAvKiBtaW5WYWx1ZT0qLyAwLCBcclxuICAgICAgICAvKiBtYXhWYWx1ZT0gKi8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0aW1lKTtcclxuICAgICAgICB0aGlzLl9tYXhPcGVyYXRpb25SZXRyeVRpbWUgPSB0aW1lO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX2dldEF1dGhUb2tlbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fb3ZlcnJpZGVBdXRoVG9rZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJyaWRlQXV0aFRva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhdXRoID0gdGhpcy5fYXV0aFByb3ZpZGVyLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xyXG4gICAgICAgIGlmIChhdXRoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuRGF0YSA9IGF3YWl0IGF1dGguZ2V0VG9rZW4oKTtcclxuICAgICAgICAgICAgaWYgKHRva2VuRGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuRGF0YS5hY2Nlc3NUb2tlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGFzeW5jIF9nZXRBcHBDaGVja1Rva2VuKCkge1xyXG4gICAgICAgIGNvbnN0IGFwcENoZWNrID0gdGhpcy5fYXBwQ2hlY2tQcm92aWRlci5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcclxuICAgICAgICBpZiAoYXBwQ2hlY2spIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXBwQ2hlY2suZ2V0VG9rZW4oKTtcclxuICAgICAgICAgICAgLy8gVE9ETzogV2hhdCBkbyB3ZSB3YW50IHRvIGRvIGlmIHRoZXJlIGlzIGFuIGVycm9yIGdldHRpbmcgdGhlIHRva2VuP1xyXG4gICAgICAgICAgICAvLyBDb250ZXh0OiBhcHBDaGVjay5nZXRUb2tlbigpIHdpbGwgbmV2ZXIgdGhyb3cgZXZlbiBpZiBhbiBlcnJvciBoYXBwZW5lZC4gSW4gdGhlIGVycm9yIGNhc2UsIGEgZHVtbXkgdG9rZW4gd2lsbCBiZVxyXG4gICAgICAgICAgICAvLyByZXR1cm5lZCBhbG9uZyB3aXRoIGFuIGVycm9yIGZpZWxkIGRlc2NyaWJpbmcgdGhlIGVycm9yLiBJbiBnZW5lcmFsLCB3ZSBzaG91bGRuJ3QgY2FyZSBhYm91dCB0aGUgZXJyb3IgY29uZGl0aW9uIGFuZCBqdXN0IHVzZVxyXG4gICAgICAgICAgICAvLyB0aGUgdG9rZW4gKGFjdHVhbCBvciBkdW1teSkgdG8gc2VuZCByZXF1ZXN0cy5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3AgcnVubmluZyByZXF1ZXN0cyBhbmQgcHJldmVudCBtb3JlIGZyb20gYmVpbmcgY3JlYXRlZC5cclxuICAgICAqL1xyXG4gICAgX2RlbGV0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVsZXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLmZvckVhY2gocmVxdWVzdCA9PiByZXF1ZXN0LmNhbmNlbCgpKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHMuY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGZpcmViYXNlU3RvcmFnZS5SZWZlcmVuY2Ugb2JqZWN0IHJlZmVyZW5jaW5nIHRoaXMgU3RvcmFnZVNlcnZpY2VcclxuICAgICAqIGF0IHRoZSBnaXZlbiBMb2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgX21ha2VTdG9yYWdlUmVmZXJlbmNlKGxvYykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHRoaXMsIGxvYyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0SW5mbyAtIEhUVFAgUmVxdWVzdEluZm8gb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gYXV0aFRva2VuIC0gRmlyZWJhc2UgYXV0aCB0b2tlblxyXG4gICAgICovXHJcbiAgICBfbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIHJlcXVlc3RGYWN0b3J5LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHJldHJ5ID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZGVsZXRlZCkge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIHRoaXMuX2FwcElkLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHJlcXVlc3RGYWN0b3J5LCB0aGlzLl9maXJlYmFzZVZlcnNpb24sIHJldHJ5KTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHMuYWRkKHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAvLyBSZXF1ZXN0IHJlbW92ZXMgaXRzZWxmIGZyb20gc2V0IHdoZW4gY29tcGxldGUuXHJcbiAgICAgICAgICAgIHJlcXVlc3QuZ2V0UHJvbWlzZSgpLnRoZW4oKCkgPT4gdGhpcy5fcmVxdWVzdHMuZGVsZXRlKHJlcXVlc3QpLCAoKSA9PiB0aGlzLl9yZXF1ZXN0cy5kZWxldGUocmVxdWVzdCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFpbFJlcXVlc3QoYXBwRGVsZXRlZCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBtYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIHJlcXVlc3RGYWN0b3J5KSB7XHJcbiAgICAgICAgY29uc3QgW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgIHRoaXMuX2dldEF1dGhUb2tlbigpLFxyXG4gICAgICAgICAgICB0aGlzLl9nZXRBcHBDaGVja1Rva2VuKClcclxuICAgICAgICBdKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIHJlcXVlc3RGYWN0b3J5LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pLmdldFByb21pc2UoKTtcclxuICAgIH1cclxufVxuXG5jb25zdCBuYW1lID0gXCJAZmlyZWJhc2Uvc3RvcmFnZVwiO1xuY29uc3QgdmVyc2lvbiA9IFwiMC4xMi40XCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUeXBlIGNvbnN0YW50IGZvciBGaXJlYmFzZSBTdG9yYWdlLlxyXG4gKi9cclxuY29uc3QgU1RPUkFHRV9UWVBFID0gJ3N0b3JhZ2UnO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG93bmxvYWRzIHRoZSBkYXRhIGF0IHRoZSBvYmplY3QncyBsb2NhdGlvbi4gUmV0dXJucyBhbiBlcnJvciBpZiB0aGUgb2JqZWN0XHJcbiAqIGlzIG5vdCBmb3VuZC5cclxuICpcclxuICogVG8gdXNlIHRoaXMgZnVuY3Rpb25hbGl0eSwgeW91IGhhdmUgdG8gd2hpdGVsaXN0IHlvdXIgYXBwJ3Mgb3JpZ2luIGluIHlvdXJcclxuICogQ2xvdWQgU3RvcmFnZSBidWNrZXQuIFNlZSBhbHNvXHJcbiAqIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9zdG9yYWdlL2RvY3MvY29uZmlndXJpbmctY29yc1xyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHdoZXJlIGRhdGEgc2hvdWxkIGJlIGRvd25sb2FkZWQuXHJcbiAqIEBwYXJhbSBtYXhEb3dubG9hZFNpemVCeXRlcyAtIElmIHNldCwgdGhlIG1heGltdW0gYWxsb3dlZCBzaXplIGluIGJ5dGVzIHRvXHJcbiAqIHJldHJpZXZlLlxyXG4gKiBAcmV0dXJucyBBIFByb21pc2UgY29udGFpbmluZyB0aGUgb2JqZWN0J3MgYnl0ZXNcclxuICovXHJcbmZ1bmN0aW9uIGdldEJ5dGVzKHJlZiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgcmV0dXJuIGdldEJ5dGVzSW50ZXJuYWwocmVmLCBtYXhEb3dubG9hZFNpemVCeXRlcyk7XHJcbn1cclxuLyoqXHJcbiAqIFVwbG9hZHMgZGF0YSB0byB0aGlzIG9iamVjdCdzIGxvY2F0aW9uLlxyXG4gKiBUaGUgdXBsb2FkIGlzIG5vdCByZXN1bWFibGUuXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHJlZiAtIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfSB3aGVyZSBkYXRhIHNob3VsZCBiZSB1cGxvYWRlZC5cclxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1cGxvYWQuXHJcbiAqIEBwYXJhbSBtZXRhZGF0YSAtIE1ldGFkYXRhIGZvciB0aGUgZGF0YSB0byB1cGxvYWQuXHJcbiAqIEByZXR1cm5zIEEgUHJvbWlzZSBjb250YWluaW5nIGFuIFVwbG9hZFJlc3VsdFxyXG4gKi9cclxuZnVuY3Rpb24gdXBsb2FkQnl0ZXMocmVmLCBkYXRhLCBtZXRhZGF0YSkge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICByZXR1cm4gdXBsb2FkQnl0ZXMkMShyZWYsIGRhdGEsIG1ldGFkYXRhKTtcclxufVxyXG4vKipcclxuICogVXBsb2FkcyBhIHN0cmluZyB0byB0aGlzIG9iamVjdCdzIGxvY2F0aW9uLlxyXG4gKiBUaGUgdXBsb2FkIGlzIG5vdCByZXN1bWFibGUuXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHJlZiAtIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfSB3aGVyZSBzdHJpbmcgc2hvdWxkIGJlIHVwbG9hZGVkLlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIHVwbG9hZC5cclxuICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIHN0cmluZyB0byB1cGxvYWQuXHJcbiAqIEBwYXJhbSBtZXRhZGF0YSAtIE1ldGFkYXRhIGZvciB0aGUgc3RyaW5nIHRvIHVwbG9hZC5cclxuICogQHJldHVybnMgQSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gVXBsb2FkUmVzdWx0XHJcbiAqL1xyXG5mdW5jdGlvbiB1cGxvYWRTdHJpbmcocmVmLCB2YWx1ZSwgZm9ybWF0LCBtZXRhZGF0YSkge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICByZXR1cm4gdXBsb2FkU3RyaW5nJDEocmVmLCB2YWx1ZSwgZm9ybWF0LCBtZXRhZGF0YSk7XHJcbn1cclxuLyoqXHJcbiAqIFVwbG9hZHMgZGF0YSB0byB0aGlzIG9iamVjdCdzIGxvY2F0aW9uLlxyXG4gKiBUaGUgdXBsb2FkIGNhbiBiZSBwYXVzZWQgYW5kIHJlc3VtZWQsIGFuZCBleHBvc2VzIHByb2dyZXNzIHVwZGF0ZXMuXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHJlZiAtIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfSB3aGVyZSBkYXRhIHNob3VsZCBiZSB1cGxvYWRlZC5cclxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1cGxvYWQuXHJcbiAqIEBwYXJhbSBtZXRhZGF0YSAtIE1ldGFkYXRhIGZvciB0aGUgZGF0YSB0byB1cGxvYWQuXHJcbiAqIEByZXR1cm5zIEFuIFVwbG9hZFRhc2tcclxuICovXHJcbmZ1bmN0aW9uIHVwbG9hZEJ5dGVzUmVzdW1hYmxlKHJlZiwgZGF0YSwgbWV0YWRhdGEpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgcmV0dXJuIHVwbG9hZEJ5dGVzUmVzdW1hYmxlJDEocmVmLCBkYXRhLCBtZXRhZGF0YSk7XHJcbn1cclxuLyoqXHJcbiAqIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LiBJZiB0aGlzXHJcbiAqIG9iamVjdCBkb2Vzbid0IGV4aXN0IG9yIG1ldGFkYXRhIGNhbm5vdCBiZSByZXRyZWl2ZWQsIHRoZSBwcm9taXNlIGlzXHJcbiAqIHJlamVjdGVkLlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gdG8gZ2V0IG1ldGFkYXRhIGZyb20uXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNZXRhZGF0YShyZWYpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgcmV0dXJuIGdldE1ldGFkYXRhJDEocmVmKTtcclxufVxyXG4vKipcclxuICogVXBkYXRlcyB0aGUgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gdG8gdXBkYXRlIG1ldGFkYXRhIGZvci5cclxuICogQHBhcmFtIG1ldGFkYXRhIC0gVGhlIG5ldyBtZXRhZGF0YSBmb3IgdGhlIG9iamVjdC5cclxuICogICAgIE9ubHkgdmFsdWVzIHRoYXQgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgc2V0IHdpbGwgYmUgY2hhbmdlZC4gRXhwbGljaXRseVxyXG4gKiAgICAgc2V0dGluZyBhIHZhbHVlIHRvIG51bGwgd2lsbCByZW1vdmUgdGhlIG1ldGFkYXRhLlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG5ldyBtZXRhZGF0YSBmb3IgdGhpcyBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVNZXRhZGF0YShyZWYsIG1ldGFkYXRhKSB7XHJcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcclxuICAgIHJldHVybiB1cGRhdGVNZXRhZGF0YSQxKHJlZiwgbWV0YWRhdGEpO1xyXG59XHJcbi8qKlxyXG4gKiBMaXN0IGl0ZW1zIChmaWxlcykgYW5kIHByZWZpeGVzIChmb2xkZXJzKSB1bmRlciB0aGlzIHN0b3JhZ2UgcmVmZXJlbmNlLlxyXG4gKlxyXG4gKiBMaXN0IEFQSSBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgRmlyZWJhc2UgUnVsZXMgVmVyc2lvbiAyLlxyXG4gKlxyXG4gKiBHQ1MgaXMgYSBrZXktYmxvYiBzdG9yZS4gRmlyZWJhc2UgU3RvcmFnZSBpbXBvc2VzIHRoZSBzZW1hbnRpYyBvZiAnLydcclxuICogZGVsaW1pdGVkIGZvbGRlciBzdHJ1Y3R1cmUuXHJcbiAqIFJlZmVyIHRvIEdDUydzIExpc3QgQVBJIGlmIHlvdSB3YW50IHRvIGxlYXJuIG1vcmUuXHJcbiAqXHJcbiAqIFRvIGFkaGVyZSB0byBGaXJlYmFzZSBSdWxlcydzIFNlbWFudGljcywgRmlyZWJhc2UgU3RvcmFnZSBkb2VzIG5vdFxyXG4gKiBzdXBwb3J0IG9iamVjdHMgd2hvc2UgcGF0aHMgZW5kIHdpdGggXCIvXCIgb3IgY29udGFpbiB0d28gY29uc2VjdXRpdmVcclxuICogXCIvXCJzLiBGaXJlYmFzZSBTdG9yYWdlIExpc3QgQVBJIHdpbGwgZmlsdGVyIHRoZXNlIHVuc3VwcG9ydGVkIG9iamVjdHMuXHJcbiAqIGxpc3QoKSBtYXkgZmFpbCBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgdW5zdXBwb3J0ZWQgb2JqZWN0cyBpbiB0aGUgYnVja2V0LlxyXG4gKiBAcHVibGljXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gdG8gZ2V0IGxpc3QgZnJvbS5cclxuICogQHBhcmFtIG9wdGlvbnMgLSBTZWUge0BsaW5rIExpc3RPcHRpb25zfSBmb3IgZGV0YWlscy5cclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBpdGVtcyBhbmQgcHJlZml4ZXMuXHJcbiAqICAgICAgYHByZWZpeGVzYCBjb250YWlucyByZWZlcmVuY2VzIHRvIHN1Yi1mb2xkZXJzIGFuZCBgaXRlbXNgXHJcbiAqICAgICAgY29udGFpbnMgcmVmZXJlbmNlcyB0byBvYmplY3RzIGluIHRoaXMgZm9sZGVyLiBgbmV4dFBhZ2VUb2tlbmBcclxuICogICAgICBjYW4gYmUgdXNlZCB0byBnZXQgdGhlIHJlc3Qgb2YgdGhlIHJlc3VsdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBsaXN0KHJlZiwgb3B0aW9ucykge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICByZXR1cm4gbGlzdCQxKHJlZiwgb3B0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIExpc3QgYWxsIGl0ZW1zIChmaWxlcykgYW5kIHByZWZpeGVzIChmb2xkZXJzKSB1bmRlciB0aGlzIHN0b3JhZ2UgcmVmZXJlbmNlLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGEgaGVscGVyIG1ldGhvZCBmb3IgY2FsbGluZyBsaXN0KCkgcmVwZWF0ZWRseSB1bnRpbCB0aGVyZSBhcmVcclxuICogbm8gbW9yZSByZXN1bHRzLiBUaGUgZGVmYXVsdCBwYWdpbmF0aW9uIHNpemUgaXMgMTAwMC5cclxuICpcclxuICogTm90ZTogVGhlIHJlc3VsdHMgbWF5IG5vdCBiZSBjb25zaXN0ZW50IGlmIG9iamVjdHMgYXJlIGNoYW5nZWQgd2hpbGUgdGhpc1xyXG4gKiBvcGVyYXRpb24gaXMgcnVubmluZy5cclxuICpcclxuICogV2FybmluZzogYGxpc3RBbGxgIG1heSBwb3RlbnRpYWxseSBjb25zdW1lIHRvbyBtYW55IHJlc291cmNlcyBpZiB0aGVyZSBhcmVcclxuICogdG9vIG1hbnkgcmVzdWx0cy5cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IHRvIGdldCBsaXN0IGZyb20uXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbGwgdGhlIGl0ZW1zIGFuZCBwcmVmaXhlcyB1bmRlclxyXG4gKiAgICAgIHRoZSBjdXJyZW50IHN0b3JhZ2UgcmVmZXJlbmNlLiBgcHJlZml4ZXNgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG9cclxuICogICAgICBzdWItZGlyZWN0b3JpZXMgYW5kIGBpdGVtc2AgY29udGFpbnMgcmVmZXJlbmNlcyB0byBvYmplY3RzIGluIHRoaXNcclxuICogICAgICBmb2xkZXIuIGBuZXh0UGFnZVRva2VuYCBpcyBuZXZlciByZXR1cm5lZC5cclxuICovXHJcbmZ1bmN0aW9uIGxpc3RBbGwocmVmKSB7XHJcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcclxuICAgIHJldHVybiBsaXN0QWxsJDEocmVmKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZG93bmxvYWQgVVJMIGZvciB0aGUgZ2l2ZW4ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9LlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gdG8gZ2V0IHRoZSBkb3dubG9hZCBVUkwgZm9yLlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGRvd25sb2FkXHJcbiAqICAgICBVUkwgZm9yIHRoaXMgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RG93bmxvYWRVUkwocmVmKSB7XHJcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcclxuICAgIHJldHVybiBnZXREb3dubG9hZFVSTCQxKHJlZik7XHJcbn1cclxuLyoqXHJcbiAqIERlbGV0ZXMgdGhlIG9iamVjdCBhdCB0aGlzIGxvY2F0aW9uLlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gZm9yIG9iamVjdCB0byBkZWxldGUuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgaWYgdGhlIGRlbGV0aW9uIHN1Y2NlZWRzLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVsZXRlT2JqZWN0KHJlZikge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICByZXR1cm4gZGVsZXRlT2JqZWN0JDEocmVmKTtcclxufVxyXG5mdW5jdGlvbiByZWYoc2VydmljZU9yUmVmLCBwYXRoT3JVcmwpIHtcclxuICAgIHNlcnZpY2VPclJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShzZXJ2aWNlT3JSZWYpO1xyXG4gICAgcmV0dXJuIHJlZiQxKHNlcnZpY2VPclJlZiwgcGF0aE9yVXJsKTtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0Q2hpbGQocmVmLCBjaGlsZFBhdGgpIHtcclxuICAgIHJldHVybiBfZ2V0Q2hpbGQkMShyZWYsIGNoaWxkUGF0aCk7XHJcbn1cclxuLyoqXHJcbiAqIEdldHMgYSB7QGxpbmsgRmlyZWJhc2VTdG9yYWdlfSBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIEZpcmViYXNlIGFwcC5cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gYXBwIC0gRmlyZWJhc2UgYXBwIHRvIGdldCB7QGxpbmsgRmlyZWJhc2VTdG9yYWdlfSBpbnN0YW5jZSBmb3IuXHJcbiAqIEBwYXJhbSBidWNrZXRVcmwgLSBUaGUgZ3M6Ly8gdXJsIHRvIHlvdXIgRmlyZWJhc2UgU3RvcmFnZSBCdWNrZXQuXHJcbiAqIElmIG5vdCBwYXNzZWQsIHVzZXMgdGhlIGFwcCdzIGRlZmF1bHQgU3RvcmFnZSBCdWNrZXQuXHJcbiAqIEByZXR1cm5zIEEge0BsaW5rIEZpcmViYXNlU3RvcmFnZX0gaW5zdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdG9yYWdlKGFwcCA9IGdldEFwcCgpLCBidWNrZXRVcmwpIHtcclxuICAgIGFwcCA9IGdldE1vZHVsYXJJbnN0YW5jZShhcHApO1xyXG4gICAgY29uc3Qgc3RvcmFnZVByb3ZpZGVyID0gX2dldFByb3ZpZGVyKGFwcCwgU1RPUkFHRV9UWVBFKTtcclxuICAgIGNvbnN0IHN0b3JhZ2VJbnN0YW5jZSA9IHN0b3JhZ2VQcm92aWRlci5nZXRJbW1lZGlhdGUoe1xyXG4gICAgICAgIGlkZW50aWZpZXI6IGJ1Y2tldFVybFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBlbXVsYXRvciA9IGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCgnc3RvcmFnZScpO1xyXG4gICAgaWYgKGVtdWxhdG9yKSB7XHJcbiAgICAgICAgY29ubmVjdFN0b3JhZ2VFbXVsYXRvcihzdG9yYWdlSW5zdGFuY2UsIC4uLmVtdWxhdG9yKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdG9yYWdlSW5zdGFuY2U7XHJcbn1cclxuLyoqXHJcbiAqIE1vZGlmeSB0aGlzIHtAbGluayBGaXJlYmFzZVN0b3JhZ2V9IGluc3RhbmNlIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIENsb3VkIFN0b3JhZ2UgZW11bGF0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBzdG9yYWdlIC0gVGhlIHtAbGluayBGaXJlYmFzZVN0b3JhZ2V9IGluc3RhbmNlXHJcbiAqIEBwYXJhbSBob3N0IC0gVGhlIGVtdWxhdG9yIGhvc3QgKGV4OiBsb2NhbGhvc3QpXHJcbiAqIEBwYXJhbSBwb3J0IC0gVGhlIGVtdWxhdG9yIHBvcnQgKGV4OiA1MDAxKVxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVtdWxhdG9yIG9wdGlvbnMuIGBvcHRpb25zLm1vY2tVc2VyVG9rZW5gIGlzIHRoZSBtb2NrIGF1dGhcclxuICogdG9rZW4gdG8gdXNlIGZvciB1bml0IHRlc3RpbmcgU2VjdXJpdHkgUnVsZXMuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGNvbm5lY3RTdG9yYWdlRW11bGF0b3Ioc3RvcmFnZSwgaG9zdCwgcG9ydCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25uZWN0U3RvcmFnZUVtdWxhdG9yJDEoc3RvcmFnZSwgaG9zdCwgcG9ydCwgb3B0aW9ucyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERvd25sb2FkcyB0aGUgZGF0YSBhdCB0aGUgb2JqZWN0J3MgbG9jYXRpb24uIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIG9iamVjdFxyXG4gKiBpcyBub3QgZm91bmQuXHJcbiAqXHJcbiAqIFRvIHVzZSB0aGlzIGZ1bmN0aW9uYWxpdHksIHlvdSBoYXZlIHRvIHdoaXRlbGlzdCB5b3VyIGFwcCdzIG9yaWdpbiBpbiB5b3VyXHJcbiAqIENsb3VkIFN0b3JhZ2UgYnVja2V0LiBTZWUgYWxzb1xyXG4gKiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vc3RvcmFnZS9kb2NzL2NvbmZpZ3VyaW5nLWNvcnNcclxuICpcclxuICogVGhpcyBBUEkgaXMgbm90IGF2YWlsYWJsZSBpbiBOb2RlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHdoZXJlIGRhdGEgc2hvdWxkIGJlIGRvd25sb2FkZWQuXHJcbiAqIEBwYXJhbSBtYXhEb3dubG9hZFNpemVCeXRlcyAtIElmIHNldCwgdGhlIG1heGltdW0gYWxsb3dlZCBzaXplIGluIGJ5dGVzIHRvXHJcbiAqIHJldHJpZXZlLlxyXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgQmxvYiBjb250YWluaW5nIHRoZSBvYmplY3QncyBieXRlc1xyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG5mdW5jdGlvbiBnZXRCbG9iKHJlZiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignZ2V0QmxvYigpIGlzIG9ubHkgYXZhaWxhYmxlIGluIEJyb3dzZXItbGlrZSBlbnZpcm9ubWVudHMnKTtcclxufVxyXG4vKipcclxuICogRG93bmxvYWRzIHRoZSBkYXRhIGF0IHRoZSBvYmplY3QncyBsb2NhdGlvbi4gUmFpc2VzIGFuIGVycm9yIGV2ZW50IGlmIHRoZVxyXG4gKiBvYmplY3QgaXMgbm90IGZvdW5kLlxyXG4gKlxyXG4gKiBUaGlzIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBOb2RlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHdoZXJlIGRhdGEgc2hvdWxkIGJlIGRvd25sb2FkZWQuXHJcbiAqIEBwYXJhbSBtYXhEb3dubG9hZFNpemVCeXRlcyAtIElmIHNldCwgdGhlIG1heGltdW0gYWxsb3dlZCBzaXplIGluIGJ5dGVzIHRvXHJcbiAqIHJldHJpZXZlLlxyXG4gKiBAcmV0dXJucyBBIHN0cmVhbSB3aXRoIHRoZSBvYmplY3QncyBkYXRhIGFzIGJ5dGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdHJlYW0ocmVmLCBtYXhEb3dubG9hZFNpemVCeXRlcykge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICByZXR1cm4gZ2V0U3RyZWFtSW50ZXJuYWwocmVmLCBtYXhEb3dubG9hZFNpemVCeXRlcyk7XHJcbn1cblxuLyoqXHJcbiAqIENsb3VkIFN0b3JhZ2UgZm9yIEZpcmViYXNlXHJcbiAqXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gZmFjdG9yeShjb250YWluZXIsIHsgaW5zdGFuY2VJZGVudGlmaWVyOiB1cmwgfSkge1xyXG4gICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgIGNvbnN0IGF1dGhQcm92aWRlciA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXV0aC1pbnRlcm5hbCcpO1xyXG4gICAgY29uc3QgYXBwQ2hlY2tQcm92aWRlciA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwLWNoZWNrLWludGVybmFsJyk7XHJcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUltcGwoYXBwLCBhdXRoUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIsIHVybCwgU0RLX1ZFUlNJT04pO1xyXG59XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyU3RvcmFnZSgpIHtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KFNUT1JBR0VfVFlQRSwgZmFjdG9yeSwgXCJQVUJMSUNcIiAvKiBDb21wb25lbnRUeXBlLlBVQkxJQyAqLykuc2V0TXVsdGlwbGVJbnN0YW5jZXModHJ1ZSkpO1xyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24pO1xyXG59XHJcbnJlZ2lzdGVyU3RvcmFnZSgpO1xuXG5leHBvcnQgeyBTdG9yYWdlRXJyb3IsIFN0b3JhZ2VFcnJvckNvZGUsIFN0cmluZ0Zvcm1hdCwgRmJzQmxvYiBhcyBfRmJzQmxvYiwgTG9jYXRpb24gYXMgX0xvY2F0aW9uLCBUYXNrRXZlbnQgYXMgX1Rhc2tFdmVudCwgVGFza1N0YXRlIGFzIF9UYXNrU3RhdGUsIFVwbG9hZFRhc2sgYXMgX1VwbG9hZFRhc2ssIGRhdGFGcm9tU3RyaW5nIGFzIF9kYXRhRnJvbVN0cmluZywgX2dldENoaWxkLCBpbnZhbGlkQXJndW1lbnQgYXMgX2ludmFsaWRBcmd1bWVudCwgaW52YWxpZFJvb3RPcGVyYXRpb24gYXMgX2ludmFsaWRSb290T3BlcmF0aW9uLCBjb25uZWN0U3RvcmFnZUVtdWxhdG9yLCBkZWxldGVPYmplY3QsIGdldEJsb2IsIGdldEJ5dGVzLCBnZXREb3dubG9hZFVSTCwgZ2V0TWV0YWRhdGEsIGdldFN0b3JhZ2UsIGdldFN0cmVhbSwgbGlzdCwgbGlzdEFsbCwgcmVmLCB1cGRhdGVNZXRhZGF0YSwgdXBsb2FkQnl0ZXMsIHVwbG9hZEJ5dGVzUmVzdW1hYmxlLCB1cGxvYWRTdHJpbmcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/storage/dist/node-esm/index.node.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@firebase/util/dist/node-esm/index.node.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: () => (/* binding */ CONSTANTS),\n/* harmony export */   DecodeBase64StringError: () => (/* binding */ DecodeBase64StringError),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ErrorFactory: () => (/* binding */ ErrorFactory),\n/* harmony export */   FirebaseError: () => (/* binding */ FirebaseError),\n/* harmony export */   MAX_VALUE_MILLIS: () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   RANDOM_FACTOR: () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   Sha1: () => (/* binding */ Sha1),\n/* harmony export */   areCookiesEnabled: () => (/* binding */ areCookiesEnabled),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertionError: () => (/* binding */ assertionError),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64urlEncodeWithoutPadding: () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   calculateBackoffMillis: () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createMockUserToken: () => (/* binding */ createMockUserToken),\n/* harmony export */   createSubscribe: () => (/* binding */ createSubscribe),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   errorPrefix: () => (/* binding */ errorPrefix),\n/* harmony export */   extractQuerystring: () => (/* binding */ extractQuerystring),\n/* harmony export */   getDefaultAppConfig: () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   getDefaultEmulatorHost: () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   getDefaultEmulatorHostnameAndPort: () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getExperimentalSetting: () => (/* binding */ getExperimentalSetting),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getModularInstance: () => (/* binding */ getModularInstance),\n/* harmony export */   getUA: () => (/* binding */ getUA),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBrowserExtension: () => (/* binding */ isBrowserExtension),\n/* harmony export */   isElectron: () => (/* binding */ isElectron),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isIE: () => (/* binding */ isIE),\n/* harmony export */   isIndexedDBAvailable: () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   isMobileCordova: () => (/* binding */ isMobileCordova),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNodeSdk: () => (/* binding */ isNodeSdk),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isUWP: () => (/* binding */ isUWP),\n/* harmony export */   isValidFormat: () => (/* binding */ isValidFormat),\n/* harmony export */   isValidTimestamp: () => (/* binding */ isValidTimestamp),\n/* harmony export */   issuedAtTime: () => (/* binding */ issuedAtTime),\n/* harmony export */   jsonEval: () => (/* binding */ jsonEval),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   ordinal: () => (/* binding */ ordinal),\n/* harmony export */   promiseWithTimeout: () => (/* binding */ promiseWithTimeout),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   querystringDecode: () => (/* binding */ querystringDecode),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   stringLength: () => (/* binding */ stringLength),\n/* harmony export */   stringToByteArray: () => (/* binding */ stringToByteArray),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4),\n/* harmony export */   validateArgCount: () => (/* binding */ validateArgCount),\n/* harmony export */   validateCallback: () => (/* binding */ validateCallback),\n/* harmony export */   validateContextObject: () => (/* binding */ validateContextObject),\n/* harmony export */   validateIndexedDBOpenable: () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   validateNamespace: () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\r\n */\r\nconst CONSTANTS = {\r\n    /**\r\n     * @define {boolean} Whether this is the client Node.js SDK.\r\n     */\r\n    NODE_CLIENT: false,\r\n    /**\r\n     * @define {boolean} Whether this is the Admin Node.js SDK.\r\n     */\r\n    NODE_ADMIN: false,\r\n    /**\r\n     * Firebase SDK Version\r\n     */\r\n    SDK_VERSION: '${JSCORE_VERSION}'\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Throws an error if the provided assertion is falsy\r\n */\r\nconst assert = function (assertion, message) {\r\n    if (!assertion) {\r\n        throw assertionError(message);\r\n    }\r\n};\r\n/**\r\n * Returns an Error object suitable for throwing.\r\n */\r\nconst assertionError = function (message) {\r\n    return new Error('Firebase Database (' +\r\n        CONSTANTS.SDK_VERSION +\r\n        ') INTERNAL ASSERT FAILED: ' +\r\n        message);\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst stringToByteArray$1 = function (str) {\r\n    // TODO(user): Use native implementations if/when available\r\n    const out = [];\r\n    let p = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        let c = str.charCodeAt(i);\r\n        if (c < 128) {\r\n            out[p++] = c;\r\n        }\r\n        else if (c < 2048) {\r\n            out[p++] = (c >> 6) | 192;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else if ((c & 0xfc00) === 0xd800 &&\r\n            i + 1 < str.length &&\r\n            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\r\n            // Surrogate Pair\r\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\r\n            out[p++] = (c >> 18) | 240;\r\n            out[p++] = ((c >> 12) & 63) | 128;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else {\r\n            out[p++] = (c >> 12) | 224;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n    }\r\n    return out;\r\n};\r\n/**\r\n * Turns an array of numbers into the string given by the concatenation of the\r\n * characters to which the numbers correspond.\r\n * @param bytes Array of numbers representing characters.\r\n * @return Stringification of the array.\r\n */\r\nconst byteArrayToString = function (bytes) {\r\n    // TODO(user): Use native implementations if/when available\r\n    const out = [];\r\n    let pos = 0, c = 0;\r\n    while (pos < bytes.length) {\r\n        const c1 = bytes[pos++];\r\n        if (c1 < 128) {\r\n            out[c++] = String.fromCharCode(c1);\r\n        }\r\n        else if (c1 > 191 && c1 < 224) {\r\n            const c2 = bytes[pos++];\r\n            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));\r\n        }\r\n        else if (c1 > 239 && c1 < 365) {\r\n            // Surrogate Pair\r\n            const c2 = bytes[pos++];\r\n            const c3 = bytes[pos++];\r\n            const c4 = bytes[pos++];\r\n            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -\r\n                0x10000;\r\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\r\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\r\n        }\r\n        else {\r\n            const c2 = bytes[pos++];\r\n            const c3 = bytes[pos++];\r\n            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\r\n        }\r\n    }\r\n    return out.join('');\r\n};\r\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\r\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\r\n// Static lookup maps, lazily populated by init_()\r\nconst base64 = {\r\n    /**\r\n     * Maps bytes to characters.\r\n     */\r\n    byteToCharMap_: null,\r\n    /**\r\n     * Maps characters to bytes.\r\n     */\r\n    charToByteMap_: null,\r\n    /**\r\n     * Maps bytes to websafe characters.\r\n     * @private\r\n     */\r\n    byteToCharMapWebSafe_: null,\r\n    /**\r\n     * Maps websafe characters to bytes.\r\n     * @private\r\n     */\r\n    charToByteMapWebSafe_: null,\r\n    /**\r\n     * Our default alphabet, shared between\r\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\r\n     */\r\n    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\r\n    /**\r\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\r\n     */\r\n    get ENCODED_VALS() {\r\n        return this.ENCODED_VALS_BASE + '+/=';\r\n    },\r\n    /**\r\n     * Our websafe alphabet.\r\n     */\r\n    get ENCODED_VALS_WEBSAFE() {\r\n        return this.ENCODED_VALS_BASE + '-_.';\r\n    },\r\n    /**\r\n     * Whether this browser supports the atob and btoa functions. This extension\r\n     * started at Mozilla but is now implemented by many browsers. We use the\r\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\r\n     * but still allowing the standard per-browser compilations.\r\n     *\r\n     */\r\n    HAS_NATIVE_SUPPORT: typeof atob === 'function',\r\n    /**\r\n     * Base64-encode an array of bytes.\r\n     *\r\n     * @param input An array of bytes (numbers with\r\n     *     value in [0, 255]) to encode.\r\n     * @param webSafe Boolean indicating we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */\r\n    encodeByteArray(input, webSafe) {\r\n        if (!Array.isArray(input)) {\r\n            throw Error('encodeByteArray takes an array as a parameter');\r\n        }\r\n        this.init_();\r\n        const byteToCharMap = webSafe\r\n            ? this.byteToCharMapWebSafe_\r\n            : this.byteToCharMap_;\r\n        const output = [];\r\n        for (let i = 0; i < input.length; i += 3) {\r\n            const byte1 = input[i];\r\n            const haveByte2 = i + 1 < input.length;\r\n            const byte2 = haveByte2 ? input[i + 1] : 0;\r\n            const haveByte3 = i + 2 < input.length;\r\n            const byte3 = haveByte3 ? input[i + 2] : 0;\r\n            const outByte1 = byte1 >> 2;\r\n            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\r\n            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\r\n            let outByte4 = byte3 & 0x3f;\r\n            if (!haveByte3) {\r\n                outByte4 = 64;\r\n                if (!haveByte2) {\r\n                    outByte3 = 64;\r\n                }\r\n            }\r\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\r\n        }\r\n        return output.join('');\r\n    },\r\n    /**\r\n     * Base64-encode a string.\r\n     *\r\n     * @param input A string to encode.\r\n     * @param webSafe If true, we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */\r\n    encodeString(input, webSafe) {\r\n        // Shortcut for Mozilla browsers that implement\r\n        // a native base64 encoder in the form of \"btoa/atob\"\r\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\r\n            return btoa(input);\r\n        }\r\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\r\n    },\r\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * @param input to decode.\r\n     * @param webSafe True if we should use the\r\n     *     alternative alphabet.\r\n     * @return string representing the decoded value.\r\n     */\r\n    decodeString(input, webSafe) {\r\n        // Shortcut for Mozilla browsers that implement\r\n        // a native base64 encoder in the form of \"btoa/atob\"\r\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\r\n            return atob(input);\r\n        }\r\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\r\n    },\r\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * In base-64 decoding, groups of four characters are converted into three\r\n     * bytes.  If the encoder did not apply padding, the input length may not\r\n     * be a multiple of 4.\r\n     *\r\n     * In this case, the last group will have fewer than 4 characters, and\r\n     * padding will be inferred.  If the group has one or two characters, it decodes\r\n     * to one byte.  If the group has three characters, it decodes to two bytes.\r\n     *\r\n     * @param input Input to decode.\r\n     * @param webSafe True if we should use the web-safe alphabet.\r\n     * @return bytes representing the decoded value.\r\n     */\r\n    decodeStringToByteArray(input, webSafe) {\r\n        this.init_();\r\n        const charToByteMap = webSafe\r\n            ? this.charToByteMapWebSafe_\r\n            : this.charToByteMap_;\r\n        const output = [];\r\n        for (let i = 0; i < input.length;) {\r\n            const byte1 = charToByteMap[input.charAt(i++)];\r\n            const haveByte2 = i < input.length;\r\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\r\n            ++i;\r\n            const haveByte3 = i < input.length;\r\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\r\n            ++i;\r\n            const haveByte4 = i < input.length;\r\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\r\n            ++i;\r\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\r\n                throw new DecodeBase64StringError();\r\n            }\r\n            const outByte1 = (byte1 << 2) | (byte2 >> 4);\r\n            output.push(outByte1);\r\n            if (byte3 !== 64) {\r\n                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\r\n                output.push(outByte2);\r\n                if (byte4 !== 64) {\r\n                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;\r\n                    output.push(outByte3);\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    },\r\n    /**\r\n     * Lazy static initialization function. Called before\r\n     * accessing any of the static map variables.\r\n     * @private\r\n     */\r\n    init_() {\r\n        if (!this.byteToCharMap_) {\r\n            this.byteToCharMap_ = {};\r\n            this.charToByteMap_ = {};\r\n            this.byteToCharMapWebSafe_ = {};\r\n            this.charToByteMapWebSafe_ = {};\r\n            // We want quick mappings back and forth, so we precompute two maps.\r\n            for (let i = 0; i < this.ENCODED_VALS.length; i++) {\r\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\r\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\r\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\r\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\r\n                // Be forgiving when decoding and correctly decode both encodings.\r\n                if (i >= this.ENCODED_VALS_BASE.length) {\r\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\r\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n/**\r\n * An error encountered while decoding base64 string.\r\n */\r\nclass DecodeBase64StringError extends Error {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = 'DecodeBase64StringError';\r\n    }\r\n}\r\n/**\r\n * URL-safe base64 encoding\r\n */\r\nconst base64Encode = function (str) {\r\n    const utf8Bytes = stringToByteArray$1(str);\r\n    return base64.encodeByteArray(utf8Bytes, true);\r\n};\r\n/**\r\n * URL-safe base64 encoding (without \".\" padding in the end).\r\n * e.g. Used in JSON Web Token (JWT) parts.\r\n */\r\nconst base64urlEncodeWithoutPadding = function (str) {\r\n    // Use base64url encoding and remove padding in the end (dot characters).\r\n    return base64Encode(str).replace(/\\./g, '');\r\n};\r\n/**\r\n * URL-safe base64 decoding\r\n *\r\n * NOTE: DO NOT use the global atob() function - it does NOT support the\r\n * base64Url variant encoding.\r\n *\r\n * @param str To be decoded\r\n * @return Decoded result, if possible\r\n */\r\nconst base64Decode = function (str) {\r\n    try {\r\n        return base64.decodeString(str, true);\r\n    }\r\n    catch (e) {\r\n        console.error('base64Decode failed: ', e);\r\n    }\r\n    return null;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Do a deep-copy of basic JavaScript Objects or Arrays.\r\n */\r\nfunction deepCopy(value) {\r\n    return deepExtend(undefined, value);\r\n}\r\n/**\r\n * Copy properties from source to target (recursively allows extension\r\n * of Objects and Arrays).  Scalar values in the target are over-written.\r\n * If target is undefined, an object of the appropriate type will be created\r\n * (and returned).\r\n *\r\n * We recursively copy all child properties of plain Objects in the source- so\r\n * that namespace- like dictionaries are merged.\r\n *\r\n * Note that the target can be a function, in which case the properties in\r\n * the source Object are copied onto it as static properties of the Function.\r\n *\r\n * Note: we don't merge __proto__ to prevent prototype pollution\r\n */\r\nfunction deepExtend(target, source) {\r\n    if (!(source instanceof Object)) {\r\n        return source;\r\n    }\r\n    switch (source.constructor) {\r\n        case Date:\r\n            // Treat Dates like scalars; if the target date object had any child\r\n            // properties - they will be lost!\r\n            const dateValue = source;\r\n            return new Date(dateValue.getTime());\r\n        case Object:\r\n            if (target === undefined) {\r\n                target = {};\r\n            }\r\n            break;\r\n        case Array:\r\n            // Always copy the array source and overwrite the target.\r\n            target = [];\r\n            break;\r\n        default:\r\n            // Not a plain Object - treat it as a scalar.\r\n            return source;\r\n    }\r\n    for (const prop in source) {\r\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\r\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\r\n            continue;\r\n        }\r\n        target[prop] = deepExtend(target[prop], source[prop]);\r\n    }\r\n    return target;\r\n}\r\nfunction isValidKey(key) {\r\n    return key !== '__proto__';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Polyfill for `globalThis` object.\r\n * @returns the `globalThis` object for the given environment.\r\n * @public\r\n */\r\nfunction getGlobal() {\r\n    if (typeof self !== 'undefined') {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined') {\r\n        return window;\r\n    }\r\n    if (typeof global !== 'undefined') {\r\n        return global;\r\n    }\r\n    throw new Error('Unable to locate global object.');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;\r\n/**\r\n * Attempt to read defaults from a JSON string provided to\r\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\r\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\r\n * The dots are in parens because certain compilers (Vite?) cannot\r\n * handle seeing that variable in comments.\r\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\r\n */\r\nconst getDefaultsFromEnvVariable = () => {\r\n    if (typeof process === 'undefined' || typeof process.env === 'undefined') {\r\n        return;\r\n    }\r\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\r\n    if (defaultsJsonString) {\r\n        return JSON.parse(defaultsJsonString);\r\n    }\r\n};\r\nconst getDefaultsFromCookie = () => {\r\n    if (typeof document === 'undefined') {\r\n        return;\r\n    }\r\n    let match;\r\n    try {\r\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\r\n    }\r\n    catch (e) {\r\n        // Some environments such as Angular Universal SSR have a\r\n        // `document` object but error on accessing `document.cookie`.\r\n        return;\r\n    }\r\n    const decoded = match && base64Decode(match[1]);\r\n    return decoded && JSON.parse(decoded);\r\n};\r\n/**\r\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\r\n * (1) if such an object exists as a property of `globalThis`\r\n * (2) if such an object was provided on a shell environment variable\r\n * (3) if such an object exists in a cookie\r\n * @public\r\n */\r\nconst getDefaults = () => {\r\n    try {\r\n        return (getDefaultsFromGlobal() ||\r\n            getDefaultsFromEnvVariable() ||\r\n            getDefaultsFromCookie());\r\n    }\r\n    catch (e) {\r\n        /**\r\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\r\n         * to any environment case we have not accounted for. Log to\r\n         * info instead of swallowing so we can find these unknown cases\r\n         * and add paths for them if needed.\r\n         */\r\n        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\r\n        return;\r\n    }\r\n};\r\n/**\r\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\r\n * @public\r\n */\r\nconst getDefaultEmulatorHost = (productName) => { var _a, _b; return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName]; };\r\n/**\r\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\r\n * @public\r\n */\r\nconst getDefaultEmulatorHostnameAndPort = (productName) => {\r\n    const host = getDefaultEmulatorHost(productName);\r\n    if (!host) {\r\n        return undefined;\r\n    }\r\n    const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.\r\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\r\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\r\n    }\r\n    // eslint-disable-next-line no-restricted-globals\r\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\r\n    if (host[0] === '[') {\r\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\r\n        return [host.substring(1, separatorIndex - 1), port];\r\n    }\r\n    else {\r\n        return [host.substring(0, separatorIndex), port];\r\n    }\r\n};\r\n/**\r\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\r\n * @public\r\n */\r\nconst getDefaultAppConfig = () => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };\r\n/**\r\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\r\n * prefixed by \"_\")\r\n * @public\r\n */\r\nconst getExperimentalSetting = (name) => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`]; };\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Deferred {\r\n    constructor() {\r\n        this.reject = () => { };\r\n        this.resolve = () => { };\r\n        this.promise = new Promise((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n    }\r\n    /**\r\n     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\r\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\r\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\r\n     */\r\n    wrapCallback(callback) {\r\n        return (error, value) => {\r\n            if (error) {\r\n                this.reject(error);\r\n            }\r\n            else {\r\n                this.resolve(value);\r\n            }\r\n            if (typeof callback === 'function') {\r\n                // Attaching noop handler just in case developer wasn't expecting\r\n                // promises\r\n                this.promise.catch(() => { });\r\n                // Some of our callbacks don't expect a value and our own tests\r\n                // assert that the parameter length is 1\r\n                if (callback.length === 1) {\r\n                    callback(error);\r\n                }\r\n                else {\r\n                    callback(error, value);\r\n                }\r\n            }\r\n        };\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction createMockUserToken(token, projectId) {\r\n    if (token.uid) {\r\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\r\n    }\r\n    // Unsecured JWTs use \"none\" as the algorithm.\r\n    const header = {\r\n        alg: 'none',\r\n        type: 'JWT'\r\n    };\r\n    const project = projectId || 'demo-project';\r\n    const iat = token.iat || 0;\r\n    const sub = token.sub || token.user_id;\r\n    if (!sub) {\r\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\r\n    }\r\n    const payload = Object.assign({ \r\n        // Set all required fields to decent defaults\r\n        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {\r\n            sign_in_provider: 'custom',\r\n            identities: {}\r\n        } }, token);\r\n    // Unsecured JWTs use the empty string as a signature.\r\n    const signature = '';\r\n    return [\r\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\r\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\r\n        signature\r\n    ].join('.');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns navigator.userAgent string or '' if it's not defined.\r\n * @return user agent string\r\n */\r\nfunction getUA() {\r\n    if (typeof navigator !== 'undefined' &&\r\n        typeof navigator['userAgent'] === 'string') {\r\n        return navigator['userAgent'];\r\n    }\r\n    else {\r\n        return '';\r\n    }\r\n}\r\n/**\r\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\r\n *\r\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\r\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\r\n * wait for a callback.\r\n */\r\nfunction isMobileCordova() {\r\n    return (typeof window !== 'undefined' &&\r\n        // @ts-ignore Setting up an broadly applicable index signature for Window\r\n        // just to deal with this case would probably be a bad idea.\r\n        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&\r\n        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));\r\n}\r\n/**\r\n * Detect Node.js.\r\n *\r\n * @return true if Node.js environment is detected or specified.\r\n */\r\n// Node detection logic from: https://github.com/iliakan/detect-node/\r\nfunction isNode() {\r\n    var _a;\r\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\r\n    if (forceEnvironment === 'node') {\r\n        return true;\r\n    }\r\n    else if (forceEnvironment === 'browser') {\r\n        return false;\r\n    }\r\n    try {\r\n        return (Object.prototype.toString.call(global.process) === '[object process]');\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Detect Browser Environment\r\n */\r\nfunction isBrowser() {\r\n    return typeof self === 'object' && self.self === self;\r\n}\r\nfunction isBrowserExtension() {\r\n    const runtime = typeof chrome === 'object'\r\n        ? chrome.runtime\r\n        : typeof browser === 'object'\r\n            ? browser.runtime\r\n            : undefined;\r\n    return typeof runtime === 'object' && runtime.id !== undefined;\r\n}\r\n/**\r\n * Detect React Native.\r\n *\r\n * @return true if ReactNative environment is detected.\r\n */\r\nfunction isReactNative() {\r\n    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');\r\n}\r\n/** Detects Electron apps. */\r\nfunction isElectron() {\r\n    return getUA().indexOf('Electron/') >= 0;\r\n}\r\n/** Detects Internet Explorer. */\r\nfunction isIE() {\r\n    const ua = getUA();\r\n    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\r\n}\r\n/** Detects Universal Windows Platform apps. */\r\nfunction isUWP() {\r\n    return getUA().indexOf('MSAppHost/') >= 0;\r\n}\r\n/**\r\n * Detect whether the current SDK build is the Node version.\r\n *\r\n * @return true if it's the Node SDK build.\r\n */\r\nfunction isNodeSdk() {\r\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\r\n}\r\n/** Returns true if we are running in Safari. */\r\nfunction isSafari() {\r\n    return (!isNode() &&\r\n        !!navigator.userAgent &&\r\n        navigator.userAgent.includes('Safari') &&\r\n        !navigator.userAgent.includes('Chrome'));\r\n}\r\n/**\r\n * This method checks if indexedDB is supported by current browser/service worker context\r\n * @return true if indexedDB is supported by current browser/service worker context\r\n */\r\nfunction isIndexedDBAvailable() {\r\n    try {\r\n        return typeof indexedDB === 'object';\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\r\n * if errors occur during the database open operation.\r\n *\r\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\r\n * private browsing)\r\n */\r\nfunction validateIndexedDBOpenable() {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            let preExist = true;\r\n            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';\r\n            const request = self.indexedDB.open(DB_CHECK_NAME);\r\n            request.onsuccess = () => {\r\n                request.result.close();\r\n                // delete database only when it doesn't pre-exist\r\n                if (!preExist) {\r\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\r\n                }\r\n                resolve(true);\r\n            };\r\n            request.onupgradeneeded = () => {\r\n                preExist = false;\r\n            };\r\n            request.onerror = () => {\r\n                var _a;\r\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');\r\n            };\r\n        }\r\n        catch (error) {\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n/**\r\n *\r\n * This method checks whether cookie is enabled within current browser\r\n * @return true if cookie is enabled within current browser\r\n */\r\nfunction areCookiesEnabled() {\r\n    if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview Standardized Firebase Error.\r\n *\r\n * Usage:\r\n *\r\n *   // Typescript string literals for type-safe codes\r\n *   type Err =\r\n *     'unknown' |\r\n *     'object-not-found'\r\n *     ;\r\n *\r\n *   // Closure enum for type-safe error codes\r\n *   // at-enum {string}\r\n *   var Err = {\r\n *     UNKNOWN: 'unknown',\r\n *     OBJECT_NOT_FOUND: 'object-not-found',\r\n *   }\r\n *\r\n *   let errors: Map<Err, string> = {\r\n *     'generic-error': \"Unknown error\",\r\n *     'file-not-found': \"Could not find file: {$file}\",\r\n *   };\r\n *\r\n *   // Type-safe function - must pass a valid error code as param.\r\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\r\n *\r\n *   ...\r\n *   throw error.create(Err.GENERIC);\r\n *   ...\r\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\r\n *   ...\r\n *   // Service: Could not file file: foo.txt (service/file-not-found).\r\n *\r\n *   catch (e) {\r\n *     assert(e.message === \"Could not find file: foo.txt.\");\r\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\r\n *       console.log(\"Could not read file: \" + e['file']);\r\n *     }\r\n *   }\r\n */\r\nconst ERROR_NAME = 'FirebaseError';\r\n// Based on code from:\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\r\nclass FirebaseError extends Error {\r\n    constructor(\r\n    /** The error code for this error. */\r\n    code, message, \r\n    /** Custom data for this error. */\r\n    customData) {\r\n        super(message);\r\n        this.code = code;\r\n        this.customData = customData;\r\n        /** The custom name for all FirebaseErrors. */\r\n        this.name = ERROR_NAME;\r\n        // Fix For ES5\r\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, FirebaseError.prototype);\r\n        // Maintains proper stack trace for where our error was thrown.\r\n        // Only available on V8.\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\r\n        }\r\n    }\r\n}\r\nclass ErrorFactory {\r\n    constructor(service, serviceName, errors) {\r\n        this.service = service;\r\n        this.serviceName = serviceName;\r\n        this.errors = errors;\r\n    }\r\n    create(code, ...data) {\r\n        const customData = data[0] || {};\r\n        const fullCode = `${this.service}/${code}`;\r\n        const template = this.errors[code];\r\n        const message = template ? replaceTemplate(template, customData) : 'Error';\r\n        // Service Name: Error message (service/code).\r\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\r\n        const error = new FirebaseError(fullCode, fullMessage, customData);\r\n        return error;\r\n    }\r\n}\r\nfunction replaceTemplate(template, data) {\r\n    return template.replace(PATTERN, (_, key) => {\r\n        const value = data[key];\r\n        return value != null ? String(value) : `<${key}?>`;\r\n    });\r\n}\r\nconst PATTERN = /\\{\\$([^}]+)}/g;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Evaluates a JSON string into a javascript object.\r\n *\r\n * @param {string} str A string containing JSON.\r\n * @return {*} The javascript object representing the specified JSON.\r\n */\r\nfunction jsonEval(str) {\r\n    return JSON.parse(str);\r\n}\r\n/**\r\n * Returns JSON representing a javascript object.\r\n * @param {*} data Javascript object to be stringified.\r\n * @return {string} The JSON contents of the object.\r\n */\r\nfunction stringify(data) {\r\n    return JSON.stringify(data);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Decodes a Firebase auth. token into constituent parts.\r\n *\r\n * Notes:\r\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst decode = function (token) {\r\n    let header = {}, claims = {}, data = {}, signature = '';\r\n    try {\r\n        const parts = token.split('.');\r\n        header = jsonEval(base64Decode(parts[0]) || '');\r\n        claims = jsonEval(base64Decode(parts[1]) || '');\r\n        signature = parts[2];\r\n        data = claims['d'] || {};\r\n        delete claims['d'];\r\n    }\r\n    catch (e) { }\r\n    return {\r\n        header,\r\n        claims,\r\n        data,\r\n        signature\r\n    };\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\r\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst isValidTimestamp = function (token) {\r\n    const claims = decode(token).claims;\r\n    const now = Math.floor(new Date().getTime() / 1000);\r\n    let validSince = 0, validUntil = 0;\r\n    if (typeof claims === 'object') {\r\n        if (claims.hasOwnProperty('nbf')) {\r\n            validSince = claims['nbf'];\r\n        }\r\n        else if (claims.hasOwnProperty('iat')) {\r\n            validSince = claims['iat'];\r\n        }\r\n        if (claims.hasOwnProperty('exp')) {\r\n            validUntil = claims['exp'];\r\n        }\r\n        else {\r\n            // token will expire after 24h by default\r\n            validUntil = validSince + 86400;\r\n        }\r\n    }\r\n    return (!!now &&\r\n        !!validSince &&\r\n        !!validUntil &&\r\n        now >= validSince &&\r\n        now <= validUntil);\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\r\n *\r\n * Notes:\r\n * - May return null if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst issuedAtTime = function (token) {\r\n    const claims = decode(token).claims;\r\n    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\r\n        return claims['iat'];\r\n    }\r\n    return null;\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst isValidFormat = function (token) {\r\n    const decoded = decode(token), claims = decoded.claims;\r\n    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\r\n};\r\n/**\r\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst isAdmin = function (token) {\r\n    const claims = decode(token).claims;\r\n    return typeof claims === 'object' && claims['admin'] === true;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction contains(obj, key) {\r\n    return Object.prototype.hasOwnProperty.call(obj, key);\r\n}\r\nfunction safeGet(obj, key) {\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n        return obj[key];\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nfunction isEmpty(obj) {\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction map(obj, fn, contextObj) {\r\n    const res = {};\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            res[key] = fn.call(contextObj, obj[key], key, obj);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n/**\r\n * Deep equal two objects. Support Arrays and Objects.\r\n */\r\nfunction deepEqual(a, b) {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    const aKeys = Object.keys(a);\r\n    const bKeys = Object.keys(b);\r\n    for (const k of aKeys) {\r\n        if (!bKeys.includes(k)) {\r\n            return false;\r\n        }\r\n        const aProp = a[k];\r\n        const bProp = b[k];\r\n        if (isObject(aProp) && isObject(bProp)) {\r\n            if (!deepEqual(aProp, bProp)) {\r\n                return false;\r\n            }\r\n        }\r\n        else if (aProp !== bProp) {\r\n            return false;\r\n        }\r\n    }\r\n    for (const k of bKeys) {\r\n        if (!aKeys.includes(k)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isObject(thing) {\r\n    return thing !== null && typeof thing === 'object';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\r\n * @internal\r\n */\r\nfunction promiseWithTimeout(promise, timeInMS = 2000) {\r\n    const deferredPromise = new Deferred();\r\n    setTimeout(() => deferredPromise.reject('timeout!'), timeInMS);\r\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\r\n    return deferredPromise.promise;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\r\n * params object (e.g. {arg: 'val', arg2: 'val2'})\r\n * Note: You must prepend it with ? when adding it to a URL.\r\n */\r\nfunction querystring(querystringParams) {\r\n    const params = [];\r\n    for (const [key, value] of Object.entries(querystringParams)) {\r\n        if (Array.isArray(value)) {\r\n            value.forEach(arrayVal => {\r\n                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));\r\n            });\r\n        }\r\n        else {\r\n            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\r\n        }\r\n    }\r\n    return params.length ? '&' + params.join('&') : '';\r\n}\r\n/**\r\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\r\n * (e.g. {arg: 'val', arg2: 'val2'})\r\n */\r\nfunction querystringDecode(querystring) {\r\n    const obj = {};\r\n    const tokens = querystring.replace(/^\\?/, '').split('&');\r\n    tokens.forEach(token => {\r\n        if (token) {\r\n            const [key, value] = token.split('=');\r\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\r\n        }\r\n    });\r\n    return obj;\r\n}\r\n/**\r\n * Extract the query string part of a URL, including the leading question mark (if present).\r\n */\r\nfunction extractQuerystring(url) {\r\n    const queryStart = url.indexOf('?');\r\n    if (!queryStart) {\r\n        return '';\r\n    }\r\n    const fragmentStart = url.indexOf('#', queryStart);\r\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview SHA-1 cryptographic hash.\r\n * Variable names follow the notation in FIPS PUB 180-3:\r\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\r\n *\r\n * Usage:\r\n *   var sha1 = new sha1();\r\n *   sha1.update(bytes);\r\n *   var hash = sha1.digest();\r\n *\r\n * Performance:\r\n *   Chrome 23:   ~400 Mbit/s\r\n *   Firefox 16:  ~250 Mbit/s\r\n *\r\n */\r\n/**\r\n * SHA-1 cryptographic hash constructor.\r\n *\r\n * The properties declared here are discussed in the above algorithm document.\r\n * @constructor\r\n * @final\r\n * @struct\r\n */\r\nclass Sha1 {\r\n    constructor() {\r\n        /**\r\n         * Holds the previous values of accumulated variables a-e in the compress_\r\n         * function.\r\n         * @private\r\n         */\r\n        this.chain_ = [];\r\n        /**\r\n         * A buffer holding the partially computed hash result.\r\n         * @private\r\n         */\r\n        this.buf_ = [];\r\n        /**\r\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\r\n         * as the message schedule in the docs.\r\n         * @private\r\n         */\r\n        this.W_ = [];\r\n        /**\r\n         * Contains data needed to pad messages less than 64 bytes.\r\n         * @private\r\n         */\r\n        this.pad_ = [];\r\n        /**\r\n         * @private {number}\r\n         */\r\n        this.inbuf_ = 0;\r\n        /**\r\n         * @private {number}\r\n         */\r\n        this.total_ = 0;\r\n        this.blockSize = 512 / 8;\r\n        this.pad_[0] = 128;\r\n        for (let i = 1; i < this.blockSize; ++i) {\r\n            this.pad_[i] = 0;\r\n        }\r\n        this.reset();\r\n    }\r\n    reset() {\r\n        this.chain_[0] = 0x67452301;\r\n        this.chain_[1] = 0xefcdab89;\r\n        this.chain_[2] = 0x98badcfe;\r\n        this.chain_[3] = 0x10325476;\r\n        this.chain_[4] = 0xc3d2e1f0;\r\n        this.inbuf_ = 0;\r\n        this.total_ = 0;\r\n    }\r\n    /**\r\n     * Internal compress helper function.\r\n     * @param buf Block to compress.\r\n     * @param offset Offset of the block in the buffer.\r\n     * @private\r\n     */\r\n    compress_(buf, offset) {\r\n        if (!offset) {\r\n            offset = 0;\r\n        }\r\n        const W = this.W_;\r\n        // get 16 big endian words\r\n        if (typeof buf === 'string') {\r\n            for (let i = 0; i < 16; i++) {\r\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\r\n                // have a bug that turns the post-increment ++ operator into pre-increment\r\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\r\n                // correctness and which is affected by this bug, so I've removed all uses\r\n                // of post-increment ++ in which the result value is used.  We can revert\r\n                // this change once the Safari bug\r\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\r\n                // most clients have been updated.\r\n                W[i] =\r\n                    (buf.charCodeAt(offset) << 24) |\r\n                        (buf.charCodeAt(offset + 1) << 16) |\r\n                        (buf.charCodeAt(offset + 2) << 8) |\r\n                        buf.charCodeAt(offset + 3);\r\n                offset += 4;\r\n            }\r\n        }\r\n        else {\r\n            for (let i = 0; i < 16; i++) {\r\n                W[i] =\r\n                    (buf[offset] << 24) |\r\n                        (buf[offset + 1] << 16) |\r\n                        (buf[offset + 2] << 8) |\r\n                        buf[offset + 3];\r\n                offset += 4;\r\n            }\r\n        }\r\n        // expand to 80 words\r\n        for (let i = 16; i < 80; i++) {\r\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\r\n            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;\r\n        }\r\n        let a = this.chain_[0];\r\n        let b = this.chain_[1];\r\n        let c = this.chain_[2];\r\n        let d = this.chain_[3];\r\n        let e = this.chain_[4];\r\n        let f, k;\r\n        // TODO(user): Try to unroll this loop to speed up the computation.\r\n        for (let i = 0; i < 80; i++) {\r\n            if (i < 40) {\r\n                if (i < 20) {\r\n                    f = d ^ (b & (c ^ d));\r\n                    k = 0x5a827999;\r\n                }\r\n                else {\r\n                    f = b ^ c ^ d;\r\n                    k = 0x6ed9eba1;\r\n                }\r\n            }\r\n            else {\r\n                if (i < 60) {\r\n                    f = (b & c) | (d & (b | c));\r\n                    k = 0x8f1bbcdc;\r\n                }\r\n                else {\r\n                    f = b ^ c ^ d;\r\n                    k = 0xca62c1d6;\r\n                }\r\n            }\r\n            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;\r\n            e = d;\r\n            d = c;\r\n            c = ((b << 30) | (b >>> 2)) & 0xffffffff;\r\n            b = a;\r\n            a = t;\r\n        }\r\n        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;\r\n        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;\r\n        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;\r\n        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;\r\n        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;\r\n    }\r\n    update(bytes, length) {\r\n        // TODO(johnlenz): tighten the function signature and remove this check\r\n        if (bytes == null) {\r\n            return;\r\n        }\r\n        if (length === undefined) {\r\n            length = bytes.length;\r\n        }\r\n        const lengthMinusBlock = length - this.blockSize;\r\n        let n = 0;\r\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\r\n        const buf = this.buf_;\r\n        let inbuf = this.inbuf_;\r\n        // The outer while loop should execute at most twice.\r\n        while (n < length) {\r\n            // When we have no data in the block to top up, we can directly process the\r\n            // input buffer (assuming it contains sufficient data). This gives ~25%\r\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\r\n            // the data is provided in large chunks (or in multiples of 64 bytes).\r\n            if (inbuf === 0) {\r\n                while (n <= lengthMinusBlock) {\r\n                    this.compress_(bytes, n);\r\n                    n += this.blockSize;\r\n                }\r\n            }\r\n            if (typeof bytes === 'string') {\r\n                while (n < length) {\r\n                    buf[inbuf] = bytes.charCodeAt(n);\r\n                    ++inbuf;\r\n                    ++n;\r\n                    if (inbuf === this.blockSize) {\r\n                        this.compress_(buf);\r\n                        inbuf = 0;\r\n                        // Jump to the outer loop so we use the full-block optimization.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                while (n < length) {\r\n                    buf[inbuf] = bytes[n];\r\n                    ++inbuf;\r\n                    ++n;\r\n                    if (inbuf === this.blockSize) {\r\n                        this.compress_(buf);\r\n                        inbuf = 0;\r\n                        // Jump to the outer loop so we use the full-block optimization.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.inbuf_ = inbuf;\r\n        this.total_ += length;\r\n    }\r\n    /** @override */\r\n    digest() {\r\n        const digest = [];\r\n        let totalBits = this.total_ * 8;\r\n        // Add pad 0x80 0x00*.\r\n        if (this.inbuf_ < 56) {\r\n            this.update(this.pad_, 56 - this.inbuf_);\r\n        }\r\n        else {\r\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\r\n        }\r\n        // Add # bits.\r\n        for (let i = this.blockSize - 1; i >= 56; i--) {\r\n            this.buf_[i] = totalBits & 255;\r\n            totalBits /= 256; // Don't use bit-shifting here!\r\n        }\r\n        this.compress_(this.buf_);\r\n        let n = 0;\r\n        for (let i = 0; i < 5; i++) {\r\n            for (let j = 24; j >= 0; j -= 8) {\r\n                digest[n] = (this.chain_[i] >> j) & 255;\r\n                ++n;\r\n            }\r\n        }\r\n        return digest;\r\n    }\r\n}\n\n/**\r\n * Helper to make a Subscribe function (just like Promise helps make a\r\n * Thenable).\r\n *\r\n * @param executor Function which can make calls to a single Observer\r\n *     as a proxy.\r\n * @param onNoObservers Callback when count of Observers goes to zero.\r\n */\r\nfunction createSubscribe(executor, onNoObservers) {\r\n    const proxy = new ObserverProxy(executor, onNoObservers);\r\n    return proxy.subscribe.bind(proxy);\r\n}\r\n/**\r\n * Implement fan-out for any number of Observers attached via a subscribe\r\n * function.\r\n */\r\nclass ObserverProxy {\r\n    /**\r\n     * @param executor Function which can make calls to a single Observer\r\n     *     as a proxy.\r\n     * @param onNoObservers Callback when count of Observers goes to zero.\r\n     */\r\n    constructor(executor, onNoObservers) {\r\n        this.observers = [];\r\n        this.unsubscribes = [];\r\n        this.observerCount = 0;\r\n        // Micro-task scheduling by calling task.then().\r\n        this.task = Promise.resolve();\r\n        this.finalized = false;\r\n        this.onNoObservers = onNoObservers;\r\n        // Call the executor asynchronously so subscribers that are called\r\n        // synchronously after the creation of the subscribe function\r\n        // can still receive the very first value generated in the executor.\r\n        this.task\r\n            .then(() => {\r\n            executor(this);\r\n        })\r\n            .catch(e => {\r\n            this.error(e);\r\n        });\r\n    }\r\n    next(value) {\r\n        this.forEachObserver((observer) => {\r\n            observer.next(value);\r\n        });\r\n    }\r\n    error(error) {\r\n        this.forEachObserver((observer) => {\r\n            observer.error(error);\r\n        });\r\n        this.close(error);\r\n    }\r\n    complete() {\r\n        this.forEachObserver((observer) => {\r\n            observer.complete();\r\n        });\r\n        this.close();\r\n    }\r\n    /**\r\n     * Subscribe function that can be used to add an Observer to the fan-out list.\r\n     *\r\n     * - We require that no event is sent to a subscriber sychronously to their\r\n     *   call to subscribe().\r\n     */\r\n    subscribe(nextOrObserver, error, complete) {\r\n        let observer;\r\n        if (nextOrObserver === undefined &&\r\n            error === undefined &&\r\n            complete === undefined) {\r\n            throw new Error('Missing Observer.');\r\n        }\r\n        // Assemble an Observer object when passed as callback functions.\r\n        if (implementsAnyMethods(nextOrObserver, [\r\n            'next',\r\n            'error',\r\n            'complete'\r\n        ])) {\r\n            observer = nextOrObserver;\r\n        }\r\n        else {\r\n            observer = {\r\n                next: nextOrObserver,\r\n                error,\r\n                complete\r\n            };\r\n        }\r\n        if (observer.next === undefined) {\r\n            observer.next = noop;\r\n        }\r\n        if (observer.error === undefined) {\r\n            observer.error = noop;\r\n        }\r\n        if (observer.complete === undefined) {\r\n            observer.complete = noop;\r\n        }\r\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\r\n        // Attempt to subscribe to a terminated Observable - we\r\n        // just respond to the Observer with the final error or complete\r\n        // event.\r\n        if (this.finalized) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this.task.then(() => {\r\n                try {\r\n                    if (this.finalError) {\r\n                        observer.error(this.finalError);\r\n                    }\r\n                    else {\r\n                        observer.complete();\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // nothing\r\n                }\r\n                return;\r\n            });\r\n        }\r\n        this.observers.push(observer);\r\n        return unsub;\r\n    }\r\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\r\n    // any unsubscribed Observer.\r\n    unsubscribeOne(i) {\r\n        if (this.observers === undefined || this.observers[i] === undefined) {\r\n            return;\r\n        }\r\n        delete this.observers[i];\r\n        this.observerCount -= 1;\r\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\r\n            this.onNoObservers(this);\r\n        }\r\n    }\r\n    forEachObserver(fn) {\r\n        if (this.finalized) {\r\n            // Already closed by previous event....just eat the additional values.\r\n            return;\r\n        }\r\n        // Since sendOne calls asynchronously - there is no chance that\r\n        // this.observers will become undefined.\r\n        for (let i = 0; i < this.observers.length; i++) {\r\n            this.sendOne(i, fn);\r\n        }\r\n    }\r\n    // Call the Observer via one of it's callback function. We are careful to\r\n    // confirm that the observe has not been unsubscribed since this asynchronous\r\n    // function had been queued.\r\n    sendOne(i, fn) {\r\n        // Execute the callback asynchronously\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.task.then(() => {\r\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\r\n                try {\r\n                    fn(this.observers[i]);\r\n                }\r\n                catch (e) {\r\n                    // Ignore exceptions raised in Observers or missing methods of an\r\n                    // Observer.\r\n                    // Log error to console. b/31404806\r\n                    if (typeof console !== 'undefined' && console.error) {\r\n                        console.error(e);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    close(err) {\r\n        if (this.finalized) {\r\n            return;\r\n        }\r\n        this.finalized = true;\r\n        if (err !== undefined) {\r\n            this.finalError = err;\r\n        }\r\n        // Proxy is no longer needed - garbage collect references\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.task.then(() => {\r\n            this.observers = undefined;\r\n            this.onNoObservers = undefined;\r\n        });\r\n    }\r\n}\r\n/** Turn synchronous function into one called asynchronously. */\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction async(fn, onError) {\r\n    return (...args) => {\r\n        Promise.resolve(true)\r\n            .then(() => {\r\n            fn(...args);\r\n        })\r\n            .catch((error) => {\r\n            if (onError) {\r\n                onError(error);\r\n            }\r\n        });\r\n    };\r\n}\r\n/**\r\n * Return true if the object passed in implements any of the named methods.\r\n */\r\nfunction implementsAnyMethods(obj, methods) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return false;\r\n    }\r\n    for (const method of methods) {\r\n        if (method in obj && typeof obj[method] === 'function') {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction noop() {\r\n    // do nothing\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Check to make sure the appropriate number of arguments are provided for a public function.\r\n * Throws an error if it fails.\r\n *\r\n * @param fnName The function name\r\n * @param minCount The minimum number of arguments to allow for the function call\r\n * @param maxCount The maximum number of argument to allow for the function call\r\n * @param argCount The actual number of arguments provided.\r\n */\r\nconst validateArgCount = function (fnName, minCount, maxCount, argCount) {\r\n    let argError;\r\n    if (argCount < minCount) {\r\n        argError = 'at least ' + minCount;\r\n    }\r\n    else if (argCount > maxCount) {\r\n        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\r\n    }\r\n    if (argError) {\r\n        const error = fnName +\r\n            ' failed: Was called with ' +\r\n            argCount +\r\n            (argCount === 1 ? ' argument.' : ' arguments.') +\r\n            ' Expects ' +\r\n            argError +\r\n            '.';\r\n        throw new Error(error);\r\n    }\r\n};\r\n/**\r\n * Generates a string to prefix an error message about failed argument validation\r\n *\r\n * @param fnName The function name\r\n * @param argName The name of the argument\r\n * @return The prefix to add to the error thrown for validation.\r\n */\r\nfunction errorPrefix(fnName, argName) {\r\n    return `${fnName} failed: ${argName} argument `;\r\n}\r\n/**\r\n * @param fnName\r\n * @param argumentNumber\r\n * @param namespace\r\n * @param optional\r\n */\r\nfunction validateNamespace(fnName, namespace, optional) {\r\n    if (optional && !namespace) {\r\n        return;\r\n    }\r\n    if (typeof namespace !== 'string') {\r\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\r\n        throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');\r\n    }\r\n}\r\nfunction validateCallback(fnName, argumentName, \r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\ncallback, optional) {\r\n    if (optional && !callback) {\r\n        return;\r\n    }\r\n    if (typeof callback !== 'function') {\r\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');\r\n    }\r\n}\r\nfunction validateContextObject(fnName, argumentName, context, optional) {\r\n    if (optional && !context) {\r\n        return;\r\n    }\r\n    if (typeof context !== 'object' || context === null) {\r\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\r\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\r\n// so it's been modified.\r\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\r\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\r\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\r\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\r\n// pair).\r\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\r\n/**\r\n * @param {string} str\r\n * @return {Array}\r\n */\r\nconst stringToByteArray = function (str) {\r\n    const out = [];\r\n    let p = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        let c = str.charCodeAt(i);\r\n        // Is this the lead surrogate in a surrogate pair?\r\n        if (c >= 0xd800 && c <= 0xdbff) {\r\n            const high = c - 0xd800; // the high 10 bits.\r\n            i++;\r\n            assert(i < str.length, 'Surrogate pair missing trail surrogate.');\r\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\r\n            c = 0x10000 + (high << 10) + low;\r\n        }\r\n        if (c < 128) {\r\n            out[p++] = c;\r\n        }\r\n        else if (c < 2048) {\r\n            out[p++] = (c >> 6) | 192;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else if (c < 65536) {\r\n            out[p++] = (c >> 12) | 224;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else {\r\n            out[p++] = (c >> 18) | 240;\r\n            out[p++] = ((c >> 12) & 63) | 128;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n    }\r\n    return out;\r\n};\r\n/**\r\n * Calculate length without actually converting; useful for doing cheaper validation.\r\n * @param {string} str\r\n * @return {number}\r\n */\r\nconst stringLength = function (str) {\r\n    let p = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        const c = str.charCodeAt(i);\r\n        if (c < 128) {\r\n            p++;\r\n        }\r\n        else if (c < 2048) {\r\n            p += 2;\r\n        }\r\n        else if (c >= 0xd800 && c <= 0xdbff) {\r\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\r\n            p += 4;\r\n            i++; // skip trail surrogate.\r\n        }\r\n        else {\r\n            p += 3;\r\n        }\r\n    }\r\n    return p;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n * Generates a new uuid.\r\n * @public\r\n */\r\nconst uuidv4 = function () {\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\r\n        const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n        return v.toString(16);\r\n    });\r\n};\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The amount of milliseconds to exponentially increase.\r\n */\r\nconst DEFAULT_INTERVAL_MILLIS = 1000;\r\n/**\r\n * The factor to backoff by.\r\n * Should be a number greater than 1.\r\n */\r\nconst DEFAULT_BACKOFF_FACTOR = 2;\r\n/**\r\n * The maximum milliseconds to increase to.\r\n *\r\n * <p>Visible for testing\r\n */\r\nconst MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\r\n/**\r\n * The percentage of backoff time to randomize by.\r\n * See\r\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\r\n * for context.\r\n *\r\n * <p>Visible for testing\r\n */\r\nconst RANDOM_FACTOR = 0.5;\r\n/**\r\n * Based on the backoff method from\r\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\r\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\r\n */\r\nfunction calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\r\n    // Calculates an exponentially increasing value.\r\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\r\n    // and count to restore state.\r\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\r\n    // A random \"fuzz\" to avoid waves of retries.\r\n    // Deviation: randomFactor is required.\r\n    const randomWait = Math.round(\r\n    // A fraction of the backoff value to add/subtract.\r\n    // Deviation: changes multiplication order to improve readability.\r\n    RANDOM_FACTOR *\r\n        currBaseValue *\r\n        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\r\n        // if we add or subtract.\r\n        (Math.random() - 0.5) *\r\n        2);\r\n    // Limits backoff to max to avoid effectively permanent backoff.\r\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provide English ordinal letters after a number\r\n */\r\nfunction ordinal(i) {\r\n    if (!Number.isFinite(i)) {\r\n        return `${i}`;\r\n    }\r\n    return i + indicator(i);\r\n}\r\nfunction indicator(i) {\r\n    i = Math.abs(i);\r\n    const cent = i % 100;\r\n    if (cent >= 10 && cent <= 20) {\r\n        return 'th';\r\n    }\r\n    const dec = i % 10;\r\n    if (dec === 1) {\r\n        return 'st';\r\n    }\r\n    if (dec === 2) {\r\n        return 'nd';\r\n    }\r\n    if (dec === 3) {\r\n        return 'rd';\r\n    }\r\n    return 'th';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getModularInstance(service) {\r\n    if (service && service._delegate) {\r\n        return service._delegate;\r\n    }\r\n    else {\r\n        return service;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Overriding the constant (we should be the only ones doing this)\r\nCONSTANTS.NODE_CLIENT = true;\n\n\n//# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsRUFBRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLHdFQUF3RSxLQUFLOztBQUVoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWEsR0FBRyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUIsSUFBSSxTQUFTLEdBQUcsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJO0FBQ3ZELEtBQUs7QUFDTDtBQUNBLG1CQUFtQixNQUFNLElBQUk7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksR0FBRztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYSxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQiw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVEsVUFBVSxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTQ5QjtBQUM1OUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFybnR1YmUtMS4wLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3Qvbm9kZS1lc20vaW5kZXgubm9kZS5lc20uanM/Y2ZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBGaXJlYmFzZSBjb25zdGFudHMuICBTb21lIG9mIHRoZXNlIChAZGVmaW5lcykgY2FuIGJlIG92ZXJyaWRkZW4gYXQgY29tcGlsZS10aW1lLlxyXG4gKi9cclxuY29uc3QgQ09OU1RBTlRTID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIGNsaWVudCBOb2RlLmpzIFNESy5cclxuICAgICAqL1xyXG4gICAgTk9ERV9DTElFTlQ6IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIEFkbWluIE5vZGUuanMgU0RLLlxyXG4gICAgICovXHJcbiAgICBOT0RFX0FETUlOOiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogRmlyZWJhc2UgU0RLIFZlcnNpb25cclxuICAgICAqL1xyXG4gICAgU0RLX1ZFUlNJT046ICcke0pTQ09SRV9WRVJTSU9OfSdcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgYXNzZXJ0aW9uIGlzIGZhbHN5XHJcbiAqL1xyXG5jb25zdCBhc3NlcnQgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIWFzc2VydGlvbikge1xyXG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBhbiBFcnJvciBvYmplY3Qgc3VpdGFibGUgZm9yIHRocm93aW5nLlxyXG4gKi9cclxuY29uc3QgYXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIG5ldyBFcnJvcignRmlyZWJhc2UgRGF0YWJhc2UgKCcgK1xyXG4gICAgICAgIENPTlNUQU5UUy5TREtfVkVSU0lPTiArXHJcbiAgICAgICAgJykgSU5URVJOQUwgQVNTRVJUIEZBSUxFRDogJyArXHJcbiAgICAgICAgbWVzc2FnZSk7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5JDEgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxyXG4gICAgICAgICAgICBpICsgMSA8IHN0ci5sZW5ndGggJiZcclxuICAgICAgICAgICAgKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xyXG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxyXG4gICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDAzZmYpO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTIpIHwgMjI0O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICogVHVybnMgYW4gYXJyYXkgb2YgbnVtYmVycyBpbnRvIHRoZSBzdHJpbmcgZ2l2ZW4gYnkgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlXHJcbiAqIGNoYXJhY3RlcnMgdG8gd2hpY2ggdGhlIG51bWJlcnMgY29ycmVzcG9uZC5cclxuICogQHBhcmFtIGJ5dGVzIEFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGNoYXJhY3RlcnMuXHJcbiAqIEByZXR1cm4gU3RyaW5naWZpY2F0aW9uIG9mIHRoZSBhcnJheS5cclxuICovXHJcbmNvbnN0IGJ5dGVBcnJheVRvU3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XHJcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcG9zID0gMCwgYyA9IDA7XHJcbiAgICB3aGlsZSAocG9zIDwgYnl0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgYzEgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMxID4gMTkxICYmIGMxIDwgMjI0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDMxKSA8PCA2KSB8IChjMiAmIDYzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMxID4gMjM5ICYmIGMxIDwgMzY1KSB7XHJcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgY29uc3QgYzQgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IHUgPSAoKChjMSAmIDcpIDw8IDE4KSB8ICgoYzIgJiA2MykgPDwgMTIpIHwgKChjMyAmIDYzKSA8PCA2KSB8IChjNCAmIDYzKSkgLVxyXG4gICAgICAgICAgICAgICAgMHgxMDAwMDtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgwMCArICh1ID4+IDEwKSk7XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGRjMDAgKyAodSAmIDEwMjMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYzEgJiAxNSkgPDwgMTIpIHwgKChjMiAmIDYzKSA8PCA2KSB8IChjMyAmIDYzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcclxufTtcclxuLy8gV2UgZGVmaW5lIGl0IGFzIGFuIG9iamVjdCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjbGFzcyBiZWNhdXNlIGEgY2xhc3MgY29tcGlsZWQgZG93biB0byBlczUgY2FuJ3RcclxuLy8gYmUgdHJlZXNoYWtlZC4gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE2OTFcclxuLy8gU3RhdGljIGxvb2t1cCBtYXBzLCBsYXppbHkgcG9wdWxhdGVkIGJ5IGluaXRfKClcclxuY29uc3QgYmFzZTY0ID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIGNoYXJhY3RlcnMuXHJcbiAgICAgKi9cclxuICAgIGJ5dGVUb0NoYXJNYXBfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGNoYXJUb0J5dGVNYXBfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIHdlYnNhZmUgY2hhcmFjdGVycy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJ5dGVUb0NoYXJNYXBXZWJTYWZlXzogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyB3ZWJzYWZlIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjaGFyVG9CeXRlTWFwV2ViU2FmZV86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LCBzaGFyZWQgYmV0d2VlblxyXG4gICAgICogRU5DT0RFRF9WQUxTIGFuZCBFTkNPREVEX1ZBTFNfV0VCU0FGRVxyXG4gICAgICovXHJcbiAgICBFTkNPREVEX1ZBTFNfQkFTRTogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJyArICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicgKyAnMDEyMzQ1Njc4OScsXHJcbiAgICAvKipcclxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LiBWYWx1ZSA2NCAoPSkgaXMgc3BlY2lhbDsgaXQgbWVhbnMgXCJub3RoaW5nLlwiXHJcbiAgICAgKi9cclxuICAgIGdldCBFTkNPREVEX1ZBTFMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnKy89JztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIE91ciB3ZWJzYWZlIGFscGhhYmV0LlxyXG4gICAgICovXHJcbiAgICBnZXQgRU5DT0RFRF9WQUxTX1dFQlNBRkUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnLV8uJztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoZSBhdG9iIGFuZCBidG9hIGZ1bmN0aW9ucy4gVGhpcyBleHRlbnNpb25cclxuICAgICAqIHN0YXJ0ZWQgYXQgTW96aWxsYSBidXQgaXMgbm93IGltcGxlbWVudGVkIGJ5IG1hbnkgYnJvd3NlcnMuIFdlIHVzZSB0aGVcclxuICAgICAqIEFTU1VNRV8qIHZhcmlhYmxlcyB0byBhdm9pZCBwdWxsaW5nIGluIHRoZSBmdWxsIHVzZXJhZ2VudCBkZXRlY3Rpb24gbGlicmFyeVxyXG4gICAgICogYnV0IHN0aWxsIGFsbG93aW5nIHRoZSBzdGFuZGFyZCBwZXItYnJvd3NlciBjb21waWxhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBIQVNfTkFUSVZFX1NVUFBPUlQ6IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGFuIGFycmF5IG9mIGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCBBbiBhcnJheSBvZiBieXRlcyAobnVtYmVycyB3aXRoXHJcbiAgICAgKiAgICAgdmFsdWUgaW4gWzAsIDI1NV0pIHRvIGVuY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIEJvb2xlYW4gaW5kaWNhdGluZyB3ZSBzaG91bGQgdXNlIHRoZVxyXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxyXG4gICAgICogQHJldHVybiBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVCeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0XygpO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVUb0NoYXJNYXAgPSB3ZWJTYWZlXHJcbiAgICAgICAgICAgID8gdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9cclxuICAgICAgICAgICAgOiB0aGlzLmJ5dGVUb0NoYXJNYXBfO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBpbnB1dFtpXTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSArIDEgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gaGF2ZUJ5dGUyID8gaW5wdXRbaSArIDFdIDogMDtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSArIDIgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gaW5wdXRbaSArIDJdIDogMDtcclxuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTEgPSBieXRlMSA+PiAyO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMiA9ICgoYnl0ZTEgJiAweDAzKSA8PCA0KSB8IChieXRlMiA+PiA0KTtcclxuICAgICAgICAgICAgbGV0IG91dEJ5dGUzID0gKChieXRlMiAmIDB4MGYpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xyXG4gICAgICAgICAgICBsZXQgb3V0Qnl0ZTQgPSBieXRlMyAmIDB4M2Y7XHJcbiAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRCeXRlNCA9IDY0O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRCeXRlMyA9IDY0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTFdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUyXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlM10sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1lbmNvZGUgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IEEgc3RyaW5nIHRvIGVuY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIElmIHRydWUsIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XHJcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxyXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYnRvYShpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZUJ5dGVBcnJheShzdHJpbmdUb0J5dGVBcnJheSQxKGlucHV0KSwgd2ViU2FmZSk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCB0byBkZWNvZGUuXHJcbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGRlY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XHJcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxyXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXRvYihpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBieXRlQXJyYXlUb1N0cmluZyh0aGlzLmRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEluIGJhc2UtNjQgZGVjb2RpbmcsIGdyb3VwcyBvZiBmb3VyIGNoYXJhY3RlcnMgYXJlIGNvbnZlcnRlZCBpbnRvIHRocmVlXHJcbiAgICAgKiBieXRlcy4gIElmIHRoZSBlbmNvZGVyIGRpZCBub3QgYXBwbHkgcGFkZGluZywgdGhlIGlucHV0IGxlbmd0aCBtYXkgbm90XHJcbiAgICAgKiBiZSBhIG11bHRpcGxlIG9mIDQuXHJcbiAgICAgKlxyXG4gICAgICogSW4gdGhpcyBjYXNlLCB0aGUgbGFzdCBncm91cCB3aWxsIGhhdmUgZmV3ZXIgdGhhbiA0IGNoYXJhY3RlcnMsIGFuZFxyXG4gICAgICogcGFkZGluZyB3aWxsIGJlIGluZmVycmVkLiAgSWYgdGhlIGdyb3VwIGhhcyBvbmUgb3IgdHdvIGNoYXJhY3RlcnMsIGl0IGRlY29kZXNcclxuICAgICAqIHRvIG9uZSBieXRlLiAgSWYgdGhlIGdyb3VwIGhhcyB0aHJlZSBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzIHRvIHR3byBieXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgSW5wdXQgdG8gZGVjb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZSB3ZWItc2FmZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBkZWNvZGVTdHJpbmdUb0J5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIHRoaXMuaW5pdF8oKTtcclxuICAgICAgICBjb25zdCBjaGFyVG9CeXRlTWFwID0gd2ViU2FmZVxyXG4gICAgICAgICAgICA/IHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfXHJcbiAgICAgICAgICAgIDogdGhpcy5jaGFyVG9CeXRlTWFwXztcclxuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDspIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKyspXTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiAwO1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMyA9IGkgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGU0ID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTQgPSBoYXZlQnl0ZTQgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBpZiAoYnl0ZTEgPT0gbnVsbCB8fCBieXRlMiA9PSBudWxsIHx8IGJ5dGUzID09IG51bGwgfHwgYnl0ZTQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlY29kZUJhc2U2NFN0cmluZ0Vycm9yKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTEgPSAoYnl0ZTEgPDwgMikgfCAoYnl0ZTIgPj4gNCk7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUxKTtcclxuICAgICAgICAgICAgaWYgKGJ5dGUzICE9PSA2NCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTIgPSAoKGJ5dGUyIDw8IDQpICYgMHhmMCkgfCAoYnl0ZTMgPj4gMik7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMik7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZTQgIT09IDY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTMgPSAoKGJ5dGUzIDw8IDYpICYgMHhjMCkgfCBieXRlNDtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIExhenkgc3RhdGljIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBDYWxsZWQgYmVmb3JlXHJcbiAgICAgKiBhY2Nlc3NpbmcgYW55IG9mIHRoZSBzdGF0aWMgbWFwIHZhcmlhYmxlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGluaXRfKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5ieXRlVG9DaGFyTWFwXykge1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV8gPSB7fTtcclxuICAgICAgICAgICAgLy8gV2Ugd2FudCBxdWljayBtYXBwaW5ncyBiYWNrIGFuZCBmb3J0aCwgc28gd2UgcHJlY29tcHV0ZSB0d28gbWFwcy5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVOQ09ERURfVkFMUy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5ieXRlVG9DaGFyTWFwX1tpXV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV0gPSB0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldXSA9IGk7XHJcbiAgICAgICAgICAgICAgICAvLyBCZSBmb3JnaXZpbmcgd2hlbiBkZWNvZGluZyBhbmQgY29ycmVjdGx5IGRlY29kZSBib3RoIGVuY29kaW5ncy5cclxuICAgICAgICAgICAgICAgIGlmIChpID49IHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQW4gZXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgZGVjb2RpbmcgYmFzZTY0IHN0cmluZy5cclxuICovXHJcbmNsYXNzIERlY29kZUJhc2U2NFN0cmluZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3InO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmdcclxuICovXHJcbmNvbnN0IGJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGNvbnN0IHV0ZjhCeXRlcyA9IHN0cmluZ1RvQnl0ZUFycmF5JDEoc3RyKTtcclxuICAgIHJldHVybiBiYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHV0ZjhCeXRlcywgdHJ1ZSk7XHJcbn07XHJcbi8qKlxyXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmcgKHdpdGhvdXQgXCIuXCIgcGFkZGluZyBpbiB0aGUgZW5kKS5cclxuICogZS5nLiBVc2VkIGluIEpTT04gV2ViIFRva2VuIChKV1QpIHBhcnRzLlxyXG4gKi9cclxuY29uc3QgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAvLyBVc2UgYmFzZTY0dXJsIGVuY29kaW5nIGFuZCByZW1vdmUgcGFkZGluZyBpbiB0aGUgZW5kIChkb3QgY2hhcmFjdGVycykuXHJcbiAgICByZXR1cm4gYmFzZTY0RW5jb2RlKHN0cikucmVwbGFjZSgvXFwuL2csICcnKTtcclxufTtcclxuLyoqXHJcbiAqIFVSTC1zYWZlIGJhc2U2NCBkZWNvZGluZ1xyXG4gKlxyXG4gKiBOT1RFOiBETyBOT1QgdXNlIHRoZSBnbG9iYWwgYXRvYigpIGZ1bmN0aW9uIC0gaXQgZG9lcyBOT1Qgc3VwcG9ydCB0aGVcclxuICogYmFzZTY0VXJsIHZhcmlhbnQgZW5jb2RpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBzdHIgVG8gYmUgZGVjb2RlZFxyXG4gKiBAcmV0dXJuIERlY29kZWQgcmVzdWx0LCBpZiBwb3NzaWJsZVxyXG4gKi9cclxuY29uc3QgYmFzZTY0RGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gYmFzZTY0LmRlY29kZVN0cmluZyhzdHIsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdiYXNlNjREZWNvZGUgZmFpbGVkOiAnLCBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG8gYSBkZWVwLWNvcHkgb2YgYmFzaWMgSmF2YVNjcmlwdCBPYmplY3RzIG9yIEFycmF5cy5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBDb3B5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gZGVlcEV4dGVuZCh1bmRlZmluZWQsIHZhbHVlKTtcclxufVxyXG4vKipcclxuICogQ29weSBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIHRhcmdldCAocmVjdXJzaXZlbHkgYWxsb3dzIGV4dGVuc2lvblxyXG4gKiBvZiBPYmplY3RzIGFuZCBBcnJheXMpLiAgU2NhbGFyIHZhbHVlcyBpbiB0aGUgdGFyZ2V0IGFyZSBvdmVyLXdyaXR0ZW4uXHJcbiAqIElmIHRhcmdldCBpcyB1bmRlZmluZWQsIGFuIG9iamVjdCBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZSB3aWxsIGJlIGNyZWF0ZWRcclxuICogKGFuZCByZXR1cm5lZCkuXHJcbiAqXHJcbiAqIFdlIHJlY3Vyc2l2ZWx5IGNvcHkgYWxsIGNoaWxkIHByb3BlcnRpZXMgb2YgcGxhaW4gT2JqZWN0cyBpbiB0aGUgc291cmNlLSBzb1xyXG4gKiB0aGF0IG5hbWVzcGFjZS0gbGlrZSBkaWN0aW9uYXJpZXMgYXJlIG1lcmdlZC5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSB0YXJnZXQgY2FuIGJlIGEgZnVuY3Rpb24sIGluIHdoaWNoIGNhc2UgdGhlIHByb3BlcnRpZXMgaW5cclxuICogdGhlIHNvdXJjZSBPYmplY3QgYXJlIGNvcGllZCBvbnRvIGl0IGFzIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbi5cclxuICpcclxuICogTm90ZTogd2UgZG9uJ3QgbWVyZ2UgX19wcm90b19fIHRvIHByZXZlbnQgcHJvdG90eXBlIHBvbGx1dGlvblxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xyXG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKHNvdXJjZS5jb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIGNhc2UgRGF0ZTpcclxuICAgICAgICAgICAgLy8gVHJlYXQgRGF0ZXMgbGlrZSBzY2FsYXJzOyBpZiB0aGUgdGFyZ2V0IGRhdGUgb2JqZWN0IGhhZCBhbnkgY2hpbGRcclxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyAtIHRoZXkgd2lsbCBiZSBsb3N0IVxyXG4gICAgICAgICAgICBjb25zdCBkYXRlVmFsdWUgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlVmFsdWUuZ2V0VGltZSgpKTtcclxuICAgICAgICBjYXNlIE9iamVjdDpcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEFycmF5OlxyXG4gICAgICAgICAgICAvLyBBbHdheXMgY29weSB0aGUgYXJyYXkgc291cmNlIGFuZCBvdmVyd3JpdGUgdGhlIHRhcmdldC5cclxuICAgICAgICAgICAgdGFyZ2V0ID0gW107XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIC8vIE5vdCBhIHBsYWluIE9iamVjdCAtIHRyZWF0IGl0IGFzIGEgc2NhbGFyLlxyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xyXG4gICAgICAgIC8vIHVzZSBpc1ZhbGlkS2V5IHRvIGd1YXJkIGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvbi4gU2VlIGh0dHBzOi8vc255ay5pby92dWxuL1NOWUstSlMtTE9EQVNILTQ1MDIwMlxyXG4gICAgICAgIGlmICghc291cmNlLmhhc093blByb3BlcnR5KHByb3ApIHx8ICFpc1ZhbGlkS2V5KHByb3ApKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBkZWVwRXh0ZW5kKHRhcmdldFtwcm9wXSwgc291cmNlW3Byb3BdKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcclxuICAgIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQb2x5ZmlsbCBmb3IgYGdsb2JhbFRoaXNgIG9iamVjdC5cclxuICogQHJldHVybnMgdGhlIGBnbG9iYWxUaGlzYCBvYmplY3QgZm9yIHRoZSBnaXZlbiBlbnZpcm9ubWVudC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdC4nKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0c0Zyb21HbG9iYWwgPSAoKSA9PiBnZXRHbG9iYWwoKS5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XHJcbi8qKlxyXG4gKiBBdHRlbXB0IHRvIHJlYWQgZGVmYXVsdHMgZnJvbSBhIEpTT04gc3RyaW5nIHByb3ZpZGVkIHRvXHJcbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb3IgYSBKU09OIGZpbGUgd2hvc2UgcGF0aCBpcyBpblxyXG4gKiBwcm9jZXNzKC4pZW52KC4pX19GSVJFQkFTRV9ERUZBVUxUU19QQVRIX19cclxuICogVGhlIGRvdHMgYXJlIGluIHBhcmVucyBiZWNhdXNlIGNlcnRhaW4gY29tcGlsZXJzIChWaXRlPykgY2Fubm90XHJcbiAqIGhhbmRsZSBzZWVpbmcgdGhhdCB2YXJpYWJsZSBpbiBjb21tZW50cy5cclxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvaXNzdWVzLzY4MzhcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRzRnJvbUVudlZhcmlhYmxlID0gKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcHJvY2Vzcy5lbnYgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVmYXVsdHNKc29uU3RyaW5nID0gcHJvY2Vzcy5lbnYuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xyXG4gICAgaWYgKGRlZmF1bHRzSnNvblN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRlZmF1bHRzSnNvblN0cmluZyk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGdldERlZmF1bHRzRnJvbUNvb2tpZSA9ICgpID0+IHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IG1hdGNoO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaCgvX19GSVJFQkFTRV9ERUZBVUxUU19fPShbXjtdKykvKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gU29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBBbmd1bGFyIFVuaXZlcnNhbCBTU1IgaGF2ZSBhXHJcbiAgICAgICAgLy8gYGRvY3VtZW50YCBvYmplY3QgYnV0IGVycm9yIG9uIGFjY2Vzc2luZyBgZG9jdW1lbnQuY29va2llYC5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWNvZGVkID0gbWF0Y2ggJiYgYmFzZTY0RGVjb2RlKG1hdGNoWzFdKTtcclxuICAgIHJldHVybiBkZWNvZGVkICYmIEpTT04ucGFyc2UoZGVjb2RlZCk7XHJcbn07XHJcbi8qKlxyXG4gKiBHZXQgdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuIEl0IGNoZWNrcyBpbiBvcmRlcjpcclxuICogKDEpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBhcyBhIHByb3BlcnR5IG9mIGBnbG9iYWxUaGlzYFxyXG4gKiAoMikgaWYgc3VjaCBhbiBvYmplY3Qgd2FzIHByb3ZpZGVkIG9uIGEgc2hlbGwgZW52aXJvbm1lbnQgdmFyaWFibGVcclxuICogKDMpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBpbiBhIGNvb2tpZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0cyA9ICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChnZXREZWZhdWx0c0Zyb21HbG9iYWwoKSB8fFxyXG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSgpIHx8XHJcbiAgICAgICAgICAgIGdldERlZmF1bHRzRnJvbUNvb2tpZSgpKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2F0Y2gtYWxsIGZvciBiZWluZyB1bmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWVcclxuICAgICAgICAgKiB0byBhbnkgZW52aXJvbm1lbnQgY2FzZSB3ZSBoYXZlIG5vdCBhY2NvdW50ZWQgZm9yLiBMb2cgdG9cclxuICAgICAgICAgKiBpbmZvIGluc3RlYWQgb2Ygc3dhbGxvd2luZyBzbyB3ZSBjYW4gZmluZCB0aGVzZSB1bmtub3duIGNhc2VzXHJcbiAgICAgICAgICogYW5kIGFkZCBwYXRocyBmb3IgdGhlbSBpZiBuZWVkZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBVbmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWUgdG86ICR7ZX1gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3Qgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XHJcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cclxuICogQHJldHVybnMgYSBVUkwgaG9zdCBmb3JtYXR0ZWQgbGlrZSBgMTI3LjAuMC4xOjk5OTlgIG9yIGBbOjoxXTo0MDAwYCBpZiBhdmFpbGFibGVcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCA9IChwcm9kdWN0TmFtZSkgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtdWxhdG9ySG9zdHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltwcm9kdWN0TmFtZV07IH07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3RuYW1lIGFuZCBwb3J0IHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdFxyXG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXHJcbiAqIEByZXR1cm5zIGEgcGFpciBvZiBob3N0bmFtZSBhbmQgcG9ydCBsaWtlIGBbXCI6OjFcIiwgNDAwMF1gIGlmIGF2YWlsYWJsZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQgPSAocHJvZHVjdE5hbWUpID0+IHtcclxuICAgIGNvbnN0IGhvc3QgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0KHByb2R1Y3ROYW1lKTtcclxuICAgIGlmICghaG9zdCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXBhcmF0b3JJbmRleCA9IGhvc3QubGFzdEluZGV4T2YoJzonKTsgLy8gRmluZGluZyB0aGUgbGFzdCBzaW5jZSBJUHY2IGFkZHIgYWxzbyBoYXMgY29sb25zLlxyXG4gICAgaWYgKHNlcGFyYXRvckluZGV4IDw9IDAgfHwgc2VwYXJhdG9ySW5kZXggKyAxID09PSBob3N0Lmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3N0ICR7aG9zdH0gd2l0aCBubyBzZXBhcmF0ZSBob3N0bmFtZSBhbmQgcG9ydCFgKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcclxuICAgIGNvbnN0IHBvcnQgPSBwYXJzZUludChob3N0LnN1YnN0cmluZyhzZXBhcmF0b3JJbmRleCArIDEpLCAxMCk7XHJcbiAgICBpZiAoaG9zdFswXSA9PT0gJ1snKSB7XHJcbiAgICAgICAgLy8gQnJhY2tldC1xdW90ZWQgYFtpcHY2YWRkcl06cG9ydGAgPT4gcmV0dXJuIFwiaXB2NmFkZHJcIiAod2l0aG91dCBicmFja2V0cykuXHJcbiAgICAgICAgcmV0dXJuIFtob3N0LnN1YnN0cmluZygxLCBzZXBhcmF0b3JJbmRleCAtIDEpLCBwb3J0XTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMCwgc2VwYXJhdG9ySW5kZXgpLCBwb3J0XTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgRmlyZWJhc2UgYXBwIGNvbmZpZyBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRBcHBDb25maWcgPSAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25maWc7IH07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGV4cGVyaW1lbnRhbCBzZXR0aW5nIG9uIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0IChwcm9wZXJ0aWVzXHJcbiAqIHByZWZpeGVkIGJ5IFwiX1wiKVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXRFeHBlcmltZW50YWxTZXR0aW5nID0gKG5hbWUpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2BfJHtuYW1lfWBdOyB9O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBEZWZlcnJlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnJlamVjdCA9ICgpID0+IHsgfTtcclxuICAgICAgICB0aGlzLnJlc29sdmUgPSAoKSA9PiB7IH07XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3VyIEFQSSBpbnRlcm5hbHMgYXJlIG5vdCBwcm9taXNlaWZpZWQgYW5kIGNhbm5vdCBiZWNhdXNlIG91ciBjYWxsYmFjayBBUElzIGhhdmUgc3VidGxlIGV4cGVjdGF0aW9ucyBhcm91bmRcclxuICAgICAqIGludm9raW5nIHByb21pc2VzIGlubGluZSwgd2hpY2ggUHJvbWlzZXMgYXJlIGZvcmJpZGRlbiB0byBkby4gVGhpcyBtZXRob2QgYWNjZXB0cyBhbiBvcHRpb25hbCBub2RlLXN0eWxlIGNhbGxiYWNrXHJcbiAgICAgKiBhbmQgcmV0dXJucyBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgd2hpY2ggd2lsbCByZXNvbHZlIG9yIHJlamVjdCB0aGUgRGVmZXJyZWQncyBwcm9taXNlLlxyXG4gICAgICovXHJcbiAgICB3cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gKGVycm9yLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gQXR0YWNoaW5nIG5vb3AgaGFuZGxlciBqdXN0IGluIGNhc2UgZGV2ZWxvcGVyIHdhc24ndCBleHBlY3RpbmdcclxuICAgICAgICAgICAgICAgIC8vIHByb21pc2VzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2UuY2F0Y2goKCkgPT4geyB9KTtcclxuICAgICAgICAgICAgICAgIC8vIFNvbWUgb2Ygb3VyIGNhbGxiYWNrcyBkb24ndCBleHBlY3QgYSB2YWx1ZSBhbmQgb3VyIG93biB0ZXN0c1xyXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0IHRoYXQgdGhlIHBhcmFtZXRlciBsZW5ndGggaXMgMVxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZU1vY2tVc2VyVG9rZW4odG9rZW4sIHByb2plY3RJZCkge1xyXG4gICAgaWYgKHRva2VuLnVpZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwidWlkXCIgZmllbGQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBieSBtb2NrVXNlclRva2VuLiBQbGVhc2UgdXNlIFwic3ViXCIgaW5zdGVhZCBmb3IgRmlyZWJhc2UgQXV0aCBVc2VyIElELicpO1xyXG4gICAgfVxyXG4gICAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIFwibm9uZVwiIGFzIHRoZSBhbGdvcml0aG0uXHJcbiAgICBjb25zdCBoZWFkZXIgPSB7XHJcbiAgICAgICAgYWxnOiAnbm9uZScsXHJcbiAgICAgICAgdHlwZTogJ0pXVCdcclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9qZWN0ID0gcHJvamVjdElkIHx8ICdkZW1vLXByb2plY3QnO1xyXG4gICAgY29uc3QgaWF0ID0gdG9rZW4uaWF0IHx8IDA7XHJcbiAgICBjb25zdCBzdWIgPSB0b2tlbi5zdWIgfHwgdG9rZW4udXNlcl9pZDtcclxuICAgIGlmICghc3ViKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9ja1VzZXJUb2tlbiBtdXN0IGNvbnRhaW4gJ3N1Yicgb3IgJ3VzZXJfaWQnIGZpZWxkIVwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHsgXHJcbiAgICAgICAgLy8gU2V0IGFsbCByZXF1aXJlZCBmaWVsZHMgdG8gZGVjZW50IGRlZmF1bHRzXHJcbiAgICAgICAgaXNzOiBgaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGUuY29tLyR7cHJvamVjdH1gLCBhdWQ6IHByb2plY3QsIGlhdCwgZXhwOiBpYXQgKyAzNjAwLCBhdXRoX3RpbWU6IGlhdCwgc3ViLCB1c2VyX2lkOiBzdWIsIGZpcmViYXNlOiB7XHJcbiAgICAgICAgICAgIHNpZ25faW5fcHJvdmlkZXI6ICdjdXN0b20nLFxyXG4gICAgICAgICAgICBpZGVudGl0aWVzOiB7fVxyXG4gICAgICAgIH0gfSwgdG9rZW4pO1xyXG4gICAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIHRoZSBlbXB0eSBzdHJpbmcgYXMgYSBzaWduYXR1cmUuXHJcbiAgICBjb25zdCBzaWduYXR1cmUgPSAnJztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSksXHJcbiAgICAgICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpLFxyXG4gICAgICAgIHNpZ25hdHVyZVxyXG4gICAgXS5qb2luKCcuJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgbmF2aWdhdG9yLnVzZXJBZ2VudCBzdHJpbmcgb3IgJycgaWYgaXQncyBub3QgZGVmaW5lZC5cclxuICogQHJldHVybiB1c2VyIGFnZW50IHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VUEoKSB7XHJcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yWyd1c2VyQWdlbnQnXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gbmF2aWdhdG9yWyd1c2VyQWdlbnQnXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGV0ZWN0IENvcmRvdmEgLyBQaG9uZUdhcCAvIElvbmljIGZyYW1ld29ya3Mgb24gYSBtb2JpbGUgZGV2aWNlLlxyXG4gKlxyXG4gKiBEZWxpYmVyYXRlbHkgZG9lcyBub3QgcmVseSBvbiBjaGVja2luZyBgZmlsZTovL2AgVVJMcyAoYXMgdGhpcyBmYWlscyBQaG9uZUdhcFxyXG4gKiBpbiB0aGUgUmlwcGxlIGVtdWxhdG9yKSBub3IgQ29yZG92YSBgb25EZXZpY2VSZWFkeWAsIHdoaWNoIHdvdWxkIG5vcm1hbGx5XHJcbiAqIHdhaXQgZm9yIGEgY2FsbGJhY2suXHJcbiAqL1xyXG5mdW5jdGlvbiBpc01vYmlsZUNvcmRvdmEoKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBTZXR0aW5nIHVwIGFuIGJyb2FkbHkgYXBwbGljYWJsZSBpbmRleCBzaWduYXR1cmUgZm9yIFdpbmRvd1xyXG4gICAgICAgIC8vIGp1c3QgdG8gZGVhbCB3aXRoIHRoaXMgY2FzZSB3b3VsZCBwcm9iYWJseSBiZSBhIGJhZCBpZGVhLlxyXG4gICAgICAgICEhKHdpbmRvd1snY29yZG92YSddIHx8IHdpbmRvd1sncGhvbmVnYXAnXSB8fCB3aW5kb3dbJ1Bob25lR2FwJ10pICYmXHJcbiAgICAgICAgL2lvc3xpcGhvbmV8aXBvZHxpcGFkfGFuZHJvaWR8YmxhY2tiZXJyeXxpZW1vYmlsZS9pLnRlc3QoZ2V0VUEoKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgTm9kZS5qcy5cclxuICpcclxuICogQHJldHVybiB0cnVlIGlmIE5vZGUuanMgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQgb3Igc3BlY2lmaWVkLlxyXG4gKi9cclxuLy8gTm9kZSBkZXRlY3Rpb24gbG9naWMgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2lsaWFrYW4vZGV0ZWN0LW5vZGUvXHJcbmZ1bmN0aW9uIGlzTm9kZSgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IGZvcmNlRW52aXJvbm1lbnQgPSAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yY2VFbnZpcm9ubWVudDtcclxuICAgIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnbm9kZScpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZvcmNlRW52aXJvbm1lbnQgPT09ICdicm93c2VyJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBCcm93c2VyIEVudmlyb25tZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZjtcclxufVxyXG5mdW5jdGlvbiBpc0Jyb3dzZXJFeHRlbnNpb24oKSB7XHJcbiAgICBjb25zdCBydW50aW1lID0gdHlwZW9mIGNocm9tZSA9PT0gJ29iamVjdCdcclxuICAgICAgICA/IGNocm9tZS5ydW50aW1lXHJcbiAgICAgICAgOiB0eXBlb2YgYnJvd3NlciA9PT0gJ29iamVjdCdcclxuICAgICAgICAgICAgPyBicm93c2VyLnJ1bnRpbWVcclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdHlwZW9mIHJ1bnRpbWUgPT09ICdvYmplY3QnICYmIHJ1bnRpbWUuaWQgIT09IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IFJlYWN0IE5hdGl2ZS5cclxuICpcclxuICogQHJldHVybiB0cnVlIGlmIFJlYWN0TmF0aXZlIGVudmlyb25tZW50IGlzIGRldGVjdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpIHtcclxuICAgIHJldHVybiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yWydwcm9kdWN0J10gPT09ICdSZWFjdE5hdGl2ZScpO1xyXG59XHJcbi8qKiBEZXRlY3RzIEVsZWN0cm9uIGFwcHMuICovXHJcbmZ1bmN0aW9uIGlzRWxlY3Ryb24oKSB7XHJcbiAgICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdFbGVjdHJvbi8nKSA+PSAwO1xyXG59XHJcbi8qKiBEZXRlY3RzIEludGVybmV0IEV4cGxvcmVyLiAqL1xyXG5mdW5jdGlvbiBpc0lFKCkge1xyXG4gICAgY29uc3QgdWEgPSBnZXRVQSgpO1xyXG4gICAgcmV0dXJuIHVhLmluZGV4T2YoJ01TSUUgJykgPj0gMCB8fCB1YS5pbmRleE9mKCdUcmlkZW50LycpID49IDA7XHJcbn1cclxuLyoqIERldGVjdHMgVW5pdmVyc2FsIFdpbmRvd3MgUGxhdGZvcm0gYXBwcy4gKi9cclxuZnVuY3Rpb24gaXNVV1AoKSB7XHJcbiAgICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdNU0FwcEhvc3QvJykgPj0gMDtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgU0RLIGJ1aWxkIGlzIHRoZSBOb2RlIHZlcnNpb24uXHJcbiAqXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpdCdzIHRoZSBOb2RlIFNESyBidWlsZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzTm9kZVNkaygpIHtcclxuICAgIHJldHVybiBDT05TVEFOVFMuTk9ERV9DTElFTlQgPT09IHRydWUgfHwgQ09OU1RBTlRTLk5PREVfQURNSU4gPT09IHRydWU7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgcnVubmluZyBpbiBTYWZhcmkuICovXHJcbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xyXG4gICAgcmV0dXJuICghaXNOb2RlKCkgJiZcclxuICAgICAgICAhIW5hdmlnYXRvci51c2VyQWdlbnQgJiZcclxuICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdTYWZhcmknKSAmJlxyXG4gICAgICAgICFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdDaHJvbWUnKSk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0luZGV4ZWREQkF2YWlsYWJsZSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbmRleGVkREIgPT09ICdvYmplY3QnO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHZhbGlkYXRlcyBicm93c2VyL3N3IGNvbnRleHQgZm9yIGluZGV4ZWREQiBieSBvcGVuaW5nIGEgZHVtbXkgaW5kZXhlZERCIGRhdGFiYXNlIGFuZCByZWplY3RcclxuICogaWYgZXJyb3JzIG9jY3VyIGR1cmluZyB0aGUgZGF0YWJhc2Ugb3BlbiBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIEB0aHJvd3MgZXhjZXB0aW9uIGlmIGN1cnJlbnQgYnJvd3Nlci9zdyBjb250ZXh0IGNhbid0IHJ1biBpZGIub3BlbiAoZXg6IFNhZmFyaSBpZnJhbWUsIEZpcmVmb3hcclxuICogcHJpdmF0ZSBicm93c2luZylcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBwcmVFeGlzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IERCX0NIRUNLX05BTUUgPSAndmFsaWRhdGUtYnJvd3Nlci1jb250ZXh0LWZvci1pbmRleGVkZGItYW5hbHl0aWNzLW1vZHVsZSc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzZWxmLmluZGV4ZWREQi5vcGVuKERCX0NIRUNLX05BTUUpO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdWx0LmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgZGF0YWJhc2Ugb25seSB3aGVuIGl0IGRvZXNuJ3QgcHJlLWV4aXN0XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByZUV4aXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoREJfQ0hFQ0tfTkFNRSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHByZUV4aXN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHJlamVjdCgoKF9hID0gcmVxdWVzdC5lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2UpIHx8ICcnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIGNvb2tpZSBpcyBlbmFibGVkIHdpdGhpbiBjdXJyZW50IGJyb3dzZXJcclxuICogQHJldHVybiB0cnVlIGlmIGNvb2tpZSBpcyBlbmFibGVkIHdpdGhpbiBjdXJyZW50IGJyb3dzZXJcclxuICovXHJcbmZ1bmN0aW9uIGFyZUNvb2tpZXNFbmFibGVkKCkge1xyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IuY29va2llRW5hYmxlZCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IFN0YW5kYXJkaXplZCBGaXJlYmFzZSBFcnJvci5cclxuICpcclxuICogVXNhZ2U6XHJcbiAqXHJcbiAqICAgLy8gVHlwZXNjcmlwdCBzdHJpbmcgbGl0ZXJhbHMgZm9yIHR5cGUtc2FmZSBjb2Rlc1xyXG4gKiAgIHR5cGUgRXJyID1cclxuICogICAgICd1bmtub3duJyB8XHJcbiAqICAgICAnb2JqZWN0LW5vdC1mb3VuZCdcclxuICogICAgIDtcclxuICpcclxuICogICAvLyBDbG9zdXJlIGVudW0gZm9yIHR5cGUtc2FmZSBlcnJvciBjb2Rlc1xyXG4gKiAgIC8vIGF0LWVudW0ge3N0cmluZ31cclxuICogICB2YXIgRXJyID0ge1xyXG4gKiAgICAgVU5LTk9XTjogJ3Vua25vd24nLFxyXG4gKiAgICAgT0JKRUNUX05PVF9GT1VORDogJ29iamVjdC1ub3QtZm91bmQnLFxyXG4gKiAgIH1cclxuICpcclxuICogICBsZXQgZXJyb3JzOiBNYXA8RXJyLCBzdHJpbmc+ID0ge1xyXG4gKiAgICAgJ2dlbmVyaWMtZXJyb3InOiBcIlVua25vd24gZXJyb3JcIixcclxuICogICAgICdmaWxlLW5vdC1mb3VuZCc6IFwiQ291bGQgbm90IGZpbmQgZmlsZTogeyRmaWxlfVwiLFxyXG4gKiAgIH07XHJcbiAqXHJcbiAqICAgLy8gVHlwZS1zYWZlIGZ1bmN0aW9uIC0gbXVzdCBwYXNzIGEgdmFsaWQgZXJyb3IgY29kZSBhcyBwYXJhbS5cclxuICogICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JGYWN0b3J5PEVycj4oJ3NlcnZpY2UnLCAnU2VydmljZScsIGVycm9ycyk7XHJcbiAqXHJcbiAqICAgLi4uXHJcbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5HRU5FUklDKTtcclxuICogICAuLi5cclxuICogICB0aHJvdyBlcnJvci5jcmVhdGUoRXJyLkZJTEVfTk9UX0ZPVU5ELCB7J2ZpbGUnOiBmaWxlTmFtZX0pO1xyXG4gKiAgIC4uLlxyXG4gKiAgIC8vIFNlcnZpY2U6IENvdWxkIG5vdCBmaWxlIGZpbGU6IGZvby50eHQgKHNlcnZpY2UvZmlsZS1ub3QtZm91bmQpLlxyXG4gKlxyXG4gKiAgIGNhdGNoIChlKSB7XHJcbiAqICAgICBhc3NlcnQoZS5tZXNzYWdlID09PSBcIkNvdWxkIG5vdCBmaW5kIGZpbGU6IGZvby50eHQuXCIpO1xyXG4gKiAgICAgaWYgKChlIGFzIEZpcmViYXNlRXJyb3IpPy5jb2RlID09PSAnc2VydmljZS9maWxlLW5vdC1mb3VuZCcpIHtcclxuICogICAgICAgY29uc29sZS5sb2coXCJDb3VsZCBub3QgcmVhZCBmaWxlOiBcIiArIGVbJ2ZpbGUnXSk7XHJcbiAqICAgICB9XHJcbiAqICAgfVxyXG4gKi9cclxuY29uc3QgRVJST1JfTkFNRSA9ICdGaXJlYmFzZUVycm9yJztcclxuLy8gQmFzZWQgb24gY29kZSBmcm9tOlxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNDdXN0b21fRXJyb3JfVHlwZXNcclxuY2xhc3MgRmlyZWJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSBlcnJvciBjb2RlIGZvciB0aGlzIGVycm9yLiAqL1xyXG4gICAgY29kZSwgbWVzc2FnZSwgXHJcbiAgICAvKiogQ3VzdG9tIGRhdGEgZm9yIHRoaXMgZXJyb3IuICovXHJcbiAgICBjdXN0b21EYXRhKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLmN1c3RvbURhdGEgPSBjdXN0b21EYXRhO1xyXG4gICAgICAgIC8qKiBUaGUgY3VzdG9tIG5hbWUgZm9yIGFsbCBGaXJlYmFzZUVycm9ycy4gKi9cclxuICAgICAgICB0aGlzLm5hbWUgPSBFUlJPUl9OQU1FO1xyXG4gICAgICAgIC8vIEZpeCBGb3IgRVM1XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0LXdpa2kvYmxvYi9tYXN0ZXIvQnJlYWtpbmctQ2hhbmdlcy5tZCNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRmlyZWJhc2VFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duLlxyXG4gICAgICAgIC8vIE9ubHkgYXZhaWxhYmxlIG9uIFY4LlxyXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFcnJvckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIEVycm9yRmFjdG9yeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlLCBzZXJ2aWNlTmFtZSwgZXJyb3JzKSB7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcclxuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICB9XHJcbiAgICBjcmVhdGUoY29kZSwgLi4uZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGN1c3RvbURhdGEgPSBkYXRhWzBdIHx8IHt9O1xyXG4gICAgICAgIGNvbnN0IGZ1bGxDb2RlID0gYCR7dGhpcy5zZXJ2aWNlfS8ke2NvZGV9YDtcclxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuZXJyb3JzW2NvZGVdO1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0ZW1wbGF0ZSA/IHJlcGxhY2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgY3VzdG9tRGF0YSkgOiAnRXJyb3InO1xyXG4gICAgICAgIC8vIFNlcnZpY2UgTmFtZTogRXJyb3IgbWVzc2FnZSAoc2VydmljZS9jb2RlKS5cclxuICAgICAgICBjb25zdCBmdWxsTWVzc2FnZSA9IGAke3RoaXMuc2VydmljZU5hbWV9OiAke21lc3NhZ2V9ICgke2Z1bGxDb2RlfSkuYDtcclxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBGaXJlYmFzZUVycm9yKGZ1bGxDb2RlLCBmdWxsTWVzc2FnZSwgY3VzdG9tRGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcGxhY2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgZGF0YSkge1xyXG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoUEFUVEVSTiwgKF8sIGtleSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gU3RyaW5nKHZhbHVlKSA6IGA8JHtrZXl9Pz5gO1xyXG4gICAgfSk7XHJcbn1cclxuY29uc3QgUEFUVEVSTiA9IC9cXHtcXCQoW159XSspfS9nO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRXZhbHVhdGVzIGEgSlNPTiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGNvbnRhaW5pbmcgSlNPTi5cclxuICogQHJldHVybiB7Kn0gVGhlIGphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIEpTT04uXHJcbiAqL1xyXG5mdW5jdGlvbiBqc29uRXZhbChzdHIpIHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cik7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgSlNPTiByZXByZXNlbnRpbmcgYSBqYXZhc2NyaXB0IG9iamVjdC5cclxuICogQHBhcmFtIHsqfSBkYXRhIEphdmFzY3JpcHQgb2JqZWN0IHRvIGJlIHN0cmluZ2lmaWVkLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBKU09OIGNvbnRlbnRzIG9mIHRoZSBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gaW50byBjb25zdGl0dWVudCBwYXJ0cy5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiB3aXRoIGludmFsaWQgLyBpbmNvbXBsZXRlIGNsYWltcyBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGRlY29kZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgbGV0IGhlYWRlciA9IHt9LCBjbGFpbXMgPSB7fSwgZGF0YSA9IHt9LCBzaWduYXR1cmUgPSAnJztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xyXG4gICAgICAgIGhlYWRlciA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1swXSkgfHwgJycpO1xyXG4gICAgICAgIGNsYWltcyA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1sxXSkgfHwgJycpO1xyXG4gICAgICAgIHNpZ25hdHVyZSA9IHBhcnRzWzJdO1xyXG4gICAgICAgIGRhdGEgPSBjbGFpbXNbJ2QnXSB8fCB7fTtcclxuICAgICAgICBkZWxldGUgY2xhaW1zWydkJ107XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhlYWRlcixcclxuICAgICAgICBjbGFpbXMsXHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgICBzaWduYXR1cmVcclxuICAgIH07XHJcbn07XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIHRpbWUtYmFzZWQgY2xhaW1zLiBXaWxsIHJldHVybiB0cnVlIGlmIHRoZVxyXG4gKiB0b2tlbiBpcyB3aXRoaW4gdGhlIHRpbWUgd2luZG93IGF1dGhvcml6ZWQgYnkgdGhlICduYmYnIChub3QtYmVmb3JlKSBhbmQgJ2lhdCcgKGlzc3VlZC1hdCkgY2xhaW1zLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc1ZhbGlkVGltZXN0YW1wID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcclxuICAgIGNvbnN0IG5vdyA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcclxuICAgIGxldCB2YWxpZFNpbmNlID0gMCwgdmFsaWRVbnRpbCA9IDA7XHJcbiAgICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCduYmYnKSkge1xyXG4gICAgICAgICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWyduYmYnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSkge1xyXG4gICAgICAgICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWydpYXQnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnZXhwJykpIHtcclxuICAgICAgICAgICAgdmFsaWRVbnRpbCA9IGNsYWltc1snZXhwJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0b2tlbiB3aWxsIGV4cGlyZSBhZnRlciAyNGggYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICB2YWxpZFVudGlsID0gdmFsaWRTaW5jZSArIDg2NDAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAoISFub3cgJiZcclxuICAgICAgICAhIXZhbGlkU2luY2UgJiZcclxuICAgICAgICAhIXZhbGlkVW50aWwgJiZcclxuICAgICAgICBub3cgPj0gdmFsaWRTaW5jZSAmJlxyXG4gICAgICAgIG5vdyA8PSB2YWxpZFVudGlsKTtcclxufTtcclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgcmV0dXJucyBpdHMgaXNzdWVkIGF0IHRpbWUgaWYgdmFsaWQsIG51bGwgb3RoZXJ3aXNlLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIG51bGwgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc3N1ZWRBdFRpbWUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xyXG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcclxuICAgICAgICByZXR1cm4gY2xhaW1zWydpYXQnXTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyBmb3JtYXQuIEV4cGVjdHMgYSB2YWxpZCBpc3N1ZWQtYXQgdGltZS5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNWYWxpZEZvcm1hdCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZSh0b2tlbiksIGNsYWltcyA9IGRlY29kZWQuY2xhaW1zO1xyXG4gICAgcmV0dXJuICEhY2xhaW1zICYmIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0Jyk7XHJcbn07XHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBwZWVyIGludG8gYW4gYXV0aCB0b2tlbiBhbmQgZGV0ZXJtaW5lIGlmIGl0J3MgYW4gYWRtaW4gYXV0aCB0b2tlbiBieSBsb29raW5nIGF0IHRoZSBjbGFpbXMgcG9ydGlvbi5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNBZG1pbiA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XHJcbiAgICByZXR1cm4gdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zWydhZG1pbiddID09PSB0cnVlO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb250YWlucyhvYmosIGtleSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XHJcbn1cclxuZnVuY3Rpb24gc2FmZUdldChvYmosIGtleSkge1xyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICByZXR1cm4gb2JqW2tleV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gbWFwKG9iaiwgZm4sIGNvbnRleHRPYmopIHtcclxuICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgcmVzW2tleV0gPSBmbi5jYWxsKGNvbnRleHRPYmosIG9ialtrZXldLCBrZXksIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vKipcclxuICogRGVlcCBlcXVhbCB0d28gb2JqZWN0cy4gU3VwcG9ydCBBcnJheXMgYW5kIE9iamVjdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XHJcbiAgICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xyXG4gICAgZm9yIChjb25zdCBrIG9mIGFLZXlzKSB7XHJcbiAgICAgICAgaWYgKCFiS2V5cy5pbmNsdWRlcyhrKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFQcm9wID0gYVtrXTtcclxuICAgICAgICBjb25zdCBiUHJvcCA9IGJba107XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KGFQcm9wKSAmJiBpc09iamVjdChiUHJvcCkpIHtcclxuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVByb3AsIGJQcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFQcm9wICE9PSBiUHJvcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrIG9mIGJLZXlzKSB7XHJcbiAgICAgICAgaWYgKCFhS2V5cy5pbmNsdWRlcyhrKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcclxuICAgIHJldHVybiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZWplY3RzIGlmIHRoZSBnaXZlbiBwcm9taXNlIGRvZXNuJ3QgcmVzb2x2ZSBpbiB0aW1lSW5NUyBtaWxsaXNlY29uZHMuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gcHJvbWlzZVdpdGhUaW1lb3V0KHByb21pc2UsIHRpbWVJbk1TID0gMjAwMCkge1xyXG4gICAgY29uc3QgZGVmZXJyZWRQcm9taXNlID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IGRlZmVycmVkUHJvbWlzZS5yZWplY3QoJ3RpbWVvdXQhJyksIHRpbWVJbk1TKTtcclxuICAgIHByb21pc2UudGhlbihkZWZlcnJlZFByb21pc2UucmVzb2x2ZSwgZGVmZXJyZWRQcm9taXNlLnJlamVjdCk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWRQcm9taXNlLnByb21pc2U7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYSBxdWVyeXN0cmluZy1mb3JtYXR0ZWQgc3RyaW5nIChlLmcuICZhcmc9dmFsJmFyZzI9dmFsMikgZnJvbSBhXHJcbiAqIHBhcmFtcyBvYmplY3QgKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXHJcbiAqIE5vdGU6IFlvdSBtdXN0IHByZXBlbmQgaXQgd2l0aCA/IHdoZW4gYWRkaW5nIGl0IHRvIGEgVVJMLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnlzdHJpbmdQYXJhbXMpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnlzdHJpbmdQYXJhbXMpKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goYXJyYXlWYWwgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJyYXlWYWwpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXJhbXMubGVuZ3RoID8gJyYnICsgcGFyYW1zLmpvaW4oJyYnKSA6ICcnO1xyXG59XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgcXVlcnlzdHJpbmcgKGUuZy4gP2FyZz12YWwmYXJnMj12YWwyKSBpbnRvIGEgcGFyYW1zIG9iamVjdFxyXG4gKiAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nRGVjb2RlKHF1ZXJ5c3RyaW5nKSB7XHJcbiAgICBjb25zdCBvYmogPSB7fTtcclxuICAgIGNvbnN0IHRva2VucyA9IHF1ZXJ5c3RyaW5nLnJlcGxhY2UoL15cXD8vLCAnJykuc3BsaXQoJyYnKTtcclxuICAgIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcclxuICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gdG9rZW4uc3BsaXQoJz0nKTtcclxuICAgICAgICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChrZXkpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0IHRoZSBxdWVyeSBzdHJpbmcgcGFydCBvZiBhIFVSTCwgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIHF1ZXN0aW9uIG1hcmsgKGlmIHByZXNlbnQpLlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdFF1ZXJ5c3RyaW5nKHVybCkge1xyXG4gICAgY29uc3QgcXVlcnlTdGFydCA9IHVybC5pbmRleE9mKCc/Jyk7XHJcbiAgICBpZiAoIXF1ZXJ5U3RhcnQpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0ID0gdXJsLmluZGV4T2YoJyMnLCBxdWVyeVN0YXJ0KTtcclxuICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKHF1ZXJ5U3RhcnQsIGZyYWdtZW50U3RhcnQgPiAwID8gZnJhZ21lbnRTdGFydCA6IHVuZGVmaW5lZCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoLlxyXG4gKiBWYXJpYWJsZSBuYW1lcyBmb2xsb3cgdGhlIG5vdGF0aW9uIGluIEZJUFMgUFVCIDE4MC0zOlxyXG4gKiBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTMvZmlwczE4MC0zX2ZpbmFsLnBkZi5cclxuICpcclxuICogVXNhZ2U6XHJcbiAqICAgdmFyIHNoYTEgPSBuZXcgc2hhMSgpO1xyXG4gKiAgIHNoYTEudXBkYXRlKGJ5dGVzKTtcclxuICogICB2YXIgaGFzaCA9IHNoYTEuZGlnZXN0KCk7XHJcbiAqXHJcbiAqIFBlcmZvcm1hbmNlOlxyXG4gKiAgIENocm9tZSAyMzogICB+NDAwIE1iaXQvc1xyXG4gKiAgIEZpcmVmb3ggMTY6ICB+MjUwIE1iaXQvc1xyXG4gKlxyXG4gKi9cclxuLyoqXHJcbiAqIFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaCBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogVGhlIHByb3BlcnRpZXMgZGVjbGFyZWQgaGVyZSBhcmUgZGlzY3Vzc2VkIGluIHRoZSBhYm92ZSBhbGdvcml0aG0gZG9jdW1lbnQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZmluYWxcclxuICogQHN0cnVjdFxyXG4gKi9cclxuY2xhc3MgU2hhMSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb2xkcyB0aGUgcHJldmlvdXMgdmFsdWVzIG9mIGFjY3VtdWxhdGVkIHZhcmlhYmxlcyBhLWUgaW4gdGhlIGNvbXByZXNzX1xyXG4gICAgICAgICAqIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGFpbl8gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGJ1ZmZlciBob2xkaW5nIHRoZSBwYXJ0aWFsbHkgY29tcHV0ZWQgaGFzaCByZXN1bHQuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJ1Zl8gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBhcnJheSBvZiA4MCBieXRlcywgZWFjaCBhIHBhcnQgb2YgdGhlIG1lc3NhZ2UgdG8gYmUgaGFzaGVkLiAgUmVmZXJyZWQgdG9cclxuICAgICAgICAgKiBhcyB0aGUgbWVzc2FnZSBzY2hlZHVsZSBpbiB0aGUgZG9jcy5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuV18gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb250YWlucyBkYXRhIG5lZWRlZCB0byBwYWQgbWVzc2FnZXMgbGVzcyB0aGFuIDY0IGJ5dGVzLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYWRfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmluYnVmXyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRvdGFsXyA9IDA7XHJcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSA1MTIgLyA4O1xyXG4gICAgICAgIHRoaXMucGFkX1swXSA9IDEyODtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuYmxvY2tTaXplOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5wYWRfW2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAweDY3NDUyMzAxO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gMHhlZmNkYWI4OTtcclxuICAgICAgICB0aGlzLmNoYWluX1syXSA9IDB4OThiYWRjZmU7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAweDEwMzI1NDc2O1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gMHhjM2QyZTFmMDtcclxuICAgICAgICB0aGlzLmluYnVmXyA9IDA7XHJcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBjb21wcmVzcyBoZWxwZXIgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gYnVmIEJsb2NrIHRvIGNvbXByZXNzLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPZmZzZXQgb2YgdGhlIGJsb2NrIGluIHRoZSBidWZmZXIuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjb21wcmVzc18oYnVmLCBvZmZzZXQpIHtcclxuICAgICAgICBpZiAoIW9mZnNldCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBXID0gdGhpcy5XXztcclxuICAgICAgICAvLyBnZXQgMTYgYmlnIGVuZGlhbiB3b3Jkc1xyXG4gICAgICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8odXNlcik6IFtidWcgODE0MDEyMl0gUmVjZW50IHZlcnNpb25zIG9mIFNhZmFyaSBmb3IgTWFjIE9TIGFuZCBpT1NcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgYSBidWcgdGhhdCB0dXJucyB0aGUgcG9zdC1pbmNyZW1lbnQgKysgb3BlcmF0b3IgaW50byBwcmUtaW5jcmVtZW50XHJcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgSklUIGNvbXBpbGF0aW9uLiAgV2UgaGF2ZSBjb2RlIHRoYXQgZGVwZW5kcyBoZWF2aWx5IG9uIFNIQS0xIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdG5lc3MgYW5kIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IHRoaXMgYnVnLCBzbyBJJ3ZlIHJlbW92ZWQgYWxsIHVzZXNcclxuICAgICAgICAgICAgICAgIC8vIG9mIHBvc3QtaW5jcmVtZW50ICsrIGluIHdoaWNoIHRoZSByZXN1bHQgdmFsdWUgaXMgdXNlZC4gIFdlIGNhbiByZXZlcnRcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2hhbmdlIG9uY2UgdGhlIFNhZmFyaSBidWdcclxuICAgICAgICAgICAgICAgIC8vIChodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA5MDM2KSBoYXMgYmVlbiBmaXhlZCBhbmRcclxuICAgICAgICAgICAgICAgIC8vIG1vc3QgY2xpZW50cyBoYXZlIGJlZW4gdXBkYXRlZC5cclxuICAgICAgICAgICAgICAgIFdbaV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA8PCAxNikgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWYuY2hhckNvZGVBdChvZmZzZXQgKyAzKTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIFdbaV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0XSA8PCAyNCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDFdIDw8IDE2KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0ICsgMl0gPDwgOCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZbb2Zmc2V0ICsgM107XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBleHBhbmQgdG8gODAgd29yZHNcclxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xyXG4gICAgICAgICAgICBXW2ldID0gKCh0IDw8IDEpIHwgKHQgPj4+IDMxKSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYSA9IHRoaXMuY2hhaW5fWzBdO1xyXG4gICAgICAgIGxldCBiID0gdGhpcy5jaGFpbl9bMV07XHJcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNoYWluX1syXTtcclxuICAgICAgICBsZXQgZCA9IHRoaXMuY2hhaW5fWzNdO1xyXG4gICAgICAgIGxldCBlID0gdGhpcy5jaGFpbl9bNF07XHJcbiAgICAgICAgbGV0IGYsIGs7XHJcbiAgICAgICAgLy8gVE9ETyh1c2VyKTogVHJ5IHRvIHVucm9sbCB0aGlzIGxvb3AgdG8gc3BlZWQgdXAgdGhlIGNvbXB1dGF0aW9uLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA8IDQwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDIwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDVhODI3OTk5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHg2ZWQ5ZWJhMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgNjApIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gKGIgJiBjKSB8IChkICYgKGIgfCBjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4OGYxYmJjZGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gYiBeIGMgXiBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweGNhNjJjMWQ2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSAoKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIGsgKyBXW2ldKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgICAgIGUgPSBkO1xyXG4gICAgICAgICAgICBkID0gYztcclxuICAgICAgICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICAgICAgYiA9IGE7XHJcbiAgICAgICAgICAgIGEgPSB0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoYWluX1swXSA9ICh0aGlzLmNoYWluX1swXSArIGEpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1sxXSA9ICh0aGlzLmNoYWluX1sxXSArIGIpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1syXSA9ICh0aGlzLmNoYWluX1syXSArIGMpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1szXSA9ICh0aGlzLmNoYWluX1szXSArIGQpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1s0XSA9ICh0aGlzLmNoYWluX1s0XSArIGUpICYgMHhmZmZmZmZmZjtcclxuICAgIH1cclxuICAgIHVwZGF0ZShieXRlcywgbGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gVE9ETyhqb2hubGVueik6IHRpZ2h0ZW4gdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBhbmQgcmVtb3ZlIHRoaXMgY2hlY2tcclxuICAgICAgICBpZiAoYnl0ZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZW5ndGggPSBieXRlcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlbmd0aE1pbnVzQmxvY2sgPSBsZW5ndGggLSB0aGlzLmJsb2NrU2l6ZTtcclxuICAgICAgICBsZXQgbiA9IDA7XHJcbiAgICAgICAgLy8gVXNpbmcgbG9jYWwgaW5zdGVhZCBvZiBtZW1iZXIgdmFyaWFibGVzIGdpdmVzIH41JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYuXHJcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5idWZfO1xyXG4gICAgICAgIGxldCBpbmJ1ZiA9IHRoaXMuaW5idWZfO1xyXG4gICAgICAgIC8vIFRoZSBvdXRlciB3aGlsZSBsb29wIHNob3VsZCBleGVjdXRlIGF0IG1vc3QgdHdpY2UuXHJcbiAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBoYXZlIG5vIGRhdGEgaW4gdGhlIGJsb2NrIHRvIHRvcCB1cCwgd2UgY2FuIGRpcmVjdGx5IHByb2Nlc3MgdGhlXHJcbiAgICAgICAgICAgIC8vIGlucHV0IGJ1ZmZlciAoYXNzdW1pbmcgaXQgY29udGFpbnMgc3VmZmljaWVudCBkYXRhKS4gVGhpcyBnaXZlcyB+MjUlXHJcbiAgICAgICAgICAgIC8vIHNwZWVkdXAgb24gQ2hyb21lIDIzIGFuZCB+MTUlIHNwZWVkdXAgb24gRmlyZWZveCAxNiwgYnV0IHJlcXVpcmVzIHRoYXRcclxuICAgICAgICAgICAgLy8gdGhlIGRhdGEgaXMgcHJvdmlkZWQgaW4gbGFyZ2UgY2h1bmtzIChvciBpbiBtdWx0aXBsZXMgb2YgNjQgYnl0ZXMpLlxyXG4gICAgICAgICAgICBpZiAoaW5idWYgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuIDw9IGxlbmd0aE1pbnVzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhieXRlcywgbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbiArPSB0aGlzLmJsb2NrU2l6ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXMuY2hhckNvZGVBdChuKTtcclxuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xyXG4gICAgICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZltpbmJ1Zl0gPSBieXRlc1tuXTtcclxuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xyXG4gICAgICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSBpbmJ1ZjtcclxuICAgICAgICB0aGlzLnRvdGFsXyArPSBsZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKiogQG92ZXJyaWRlICovXHJcbiAgICBkaWdlc3QoKSB7XHJcbiAgICAgICAgY29uc3QgZGlnZXN0ID0gW107XHJcbiAgICAgICAgbGV0IHRvdGFsQml0cyA9IHRoaXMudG90YWxfICogODtcclxuICAgICAgICAvLyBBZGQgcGFkIDB4ODAgMHgwMCouXHJcbiAgICAgICAgaWYgKHRoaXMuaW5idWZfIDwgNTYpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCA1NiAtIHRoaXMuaW5idWZfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgdGhpcy5ibG9ja1NpemUgLSAodGhpcy5pbmJ1Zl8gLSA1NikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgIyBiaXRzLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmJsb2NrU2l6ZSAtIDE7IGkgPj0gNTY7IGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1Zl9baV0gPSB0b3RhbEJpdHMgJiAyNTU7XHJcbiAgICAgICAgICAgIHRvdGFsQml0cyAvPSAyNTY7IC8vIERvbid0IHVzZSBiaXQtc2hpZnRpbmcgaGVyZSFcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21wcmVzc18odGhpcy5idWZfKTtcclxuICAgICAgICBsZXQgbiA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xyXG4gICAgICAgICAgICAgICAgZGlnZXN0W25dID0gKHRoaXMuY2hhaW5fW2ldID4+IGopICYgMjU1O1xyXG4gICAgICAgICAgICAgICAgKytuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaWdlc3Q7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEhlbHBlciB0byBtYWtlIGEgU3Vic2NyaWJlIGZ1bmN0aW9uIChqdXN0IGxpa2UgUHJvbWlzZSBoZWxwcyBtYWtlIGFcclxuICogVGhlbmFibGUpLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcclxuICogICAgIGFzIGEgcHJveHkuXHJcbiAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmliZShleGVjdXRvciwgb25Ob09ic2VydmVycykge1xyXG4gICAgY29uc3QgcHJveHkgPSBuZXcgT2JzZXJ2ZXJQcm94eShleGVjdXRvciwgb25Ob09ic2VydmVycyk7XHJcbiAgICByZXR1cm4gcHJveHkuc3Vic2NyaWJlLmJpbmQocHJveHkpO1xyXG59XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnQgZmFuLW91dCBmb3IgYW55IG51bWJlciBvZiBPYnNlcnZlcnMgYXR0YWNoZWQgdmlhIGEgc3Vic2NyaWJlXHJcbiAqIGZ1bmN0aW9uLlxyXG4gKi9cclxuY2xhc3MgT2JzZXJ2ZXJQcm94eSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxyXG4gICAgICogICAgIGFzIGEgcHJveHkuXHJcbiAgICAgKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKSB7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCA9IDA7XHJcbiAgICAgICAgLy8gTWljcm8tdGFzayBzY2hlZHVsaW5nIGJ5IGNhbGxpbmcgdGFzay50aGVuKCkuXHJcbiAgICAgICAgdGhpcy50YXNrID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSBvbk5vT2JzZXJ2ZXJzO1xyXG4gICAgICAgIC8vIENhbGwgdGhlIGV4ZWN1dG9yIGFzeW5jaHJvbm91c2x5IHNvIHN1YnNjcmliZXJzIHRoYXQgYXJlIGNhbGxlZFxyXG4gICAgICAgIC8vIHN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIGNyZWF0aW9uIG9mIHRoZSBzdWJzY3JpYmUgZnVuY3Rpb25cclxuICAgICAgICAvLyBjYW4gc3RpbGwgcmVjZWl2ZSB0aGUgdmVyeSBmaXJzdCB2YWx1ZSBnZW5lcmF0ZWQgaW4gdGhlIGV4ZWN1dG9yLlxyXG4gICAgICAgIHRoaXMudGFza1xyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGV4ZWN1dG9yKHRoaXMpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG5leHQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlcnJvcihlcnJvcikge1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jbG9zZShlcnJvcik7XHJcbiAgICB9XHJcbiAgICBjb21wbGV0ZSgpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBhbiBPYnNlcnZlciB0byB0aGUgZmFuLW91dCBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIC0gV2UgcmVxdWlyZSB0aGF0IG5vIGV2ZW50IGlzIHNlbnQgdG8gYSBzdWJzY3JpYmVyIHN5Y2hyb25vdXNseSB0byB0aGVpclxyXG4gICAgICogICBjYWxsIHRvIHN1YnNjcmliZSgpLlxyXG4gICAgICovXHJcbiAgICBzdWJzY3JpYmUobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xyXG4gICAgICAgIGxldCBvYnNlcnZlcjtcclxuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBlcnJvciA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIGNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE9ic2VydmVyLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBc3NlbWJsZSBhbiBPYnNlcnZlciBvYmplY3Qgd2hlbiBwYXNzZWQgYXMgY2FsbGJhY2sgZnVuY3Rpb25zLlxyXG4gICAgICAgIGlmIChpbXBsZW1lbnRzQW55TWV0aG9kcyhuZXh0T3JPYnNlcnZlciwgW1xyXG4gICAgICAgICAgICAnbmV4dCcsXHJcbiAgICAgICAgICAgICdlcnJvcicsXHJcbiAgICAgICAgICAgICdjb21wbGV0ZSdcclxuICAgICAgICBdKSkge1xyXG4gICAgICAgICAgICBvYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0OiBuZXh0T3JPYnNlcnZlcixcclxuICAgICAgICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgY29tcGxldGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLm5leHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLmVycm9yID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JzZXJ2ZXIuY29tcGxldGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSA9IG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVuc3ViID0gdGhpcy51bnN1YnNjcmliZU9uZS5iaW5kKHRoaXMsIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCk7XHJcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzdWJzY3JpYmUgdG8gYSB0ZXJtaW5hdGVkIE9ic2VydmFibGUgLSB3ZVxyXG4gICAgICAgIC8vIGp1c3QgcmVzcG9uZCB0byB0aGUgT2JzZXJ2ZXIgd2l0aCB0aGUgZmluYWwgZXJyb3Igb3IgY29tcGxldGVcclxuICAgICAgICAvLyBldmVudC5cclxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IodGhpcy5maW5hbEVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICByZXR1cm4gdW5zdWI7XHJcbiAgICB9XHJcbiAgICAvLyBVbnN1YnNjcmliZSBpcyBzeW5jaHJvbm91cyAtIHdlIGd1YXJhbnRlZSB0aGF0IG5vIGV2ZW50cyBhcmUgc2VudCB0b1xyXG4gICAgLy8gYW55IHVuc3Vic2NyaWJlZCBPYnNlcnZlci5cclxuICAgIHVuc3Vic2NyaWJlT25lKGkpIHtcclxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9ic2VydmVyc1tpXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJzW2ldO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCAtPSAxO1xyXG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyQ291bnQgPT09IDAgJiYgdGhpcy5vbk5vT2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvckVhY2hPYnNlcnZlcihmbikge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xyXG4gICAgICAgICAgICAvLyBBbHJlYWR5IGNsb3NlZCBieSBwcmV2aW91cyBldmVudC4uLi5qdXN0IGVhdCB0aGUgYWRkaXRpb25hbCB2YWx1ZXMuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2luY2Ugc2VuZE9uZSBjYWxscyBhc3luY2hyb25vdXNseSAtIHRoZXJlIGlzIG5vIGNoYW5jZSB0aGF0XHJcbiAgICAgICAgLy8gdGhpcy5vYnNlcnZlcnMgd2lsbCBiZWNvbWUgdW5kZWZpbmVkLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kT25lKGksIGZuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDYWxsIHRoZSBPYnNlcnZlciB2aWEgb25lIG9mIGl0J3MgY2FsbGJhY2sgZnVuY3Rpb24uIFdlIGFyZSBjYXJlZnVsIHRvXHJcbiAgICAvLyBjb25maXJtIHRoYXQgdGhlIG9ic2VydmUgaGFzIG5vdCBiZWVuIHVuc3Vic2NyaWJlZCBzaW5jZSB0aGlzIGFzeW5jaHJvbm91c1xyXG4gICAgLy8gZnVuY3Rpb24gaGFkIGJlZW4gcXVldWVkLlxyXG4gICAgc2VuZE9uZShpLCBmbikge1xyXG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vYnNlcnZlcnNbaV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBmbih0aGlzLm9ic2VydmVyc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIHJhaXNlZCBpbiBPYnNlcnZlcnMgb3IgbWlzc2luZyBtZXRob2RzIG9mIGFuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT2JzZXJ2ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIHRvIGNvbnNvbGUuIGIvMzE0MDQ4MDZcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNsb3NlKGVycikge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5maW5hbEVycm9yID0gZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm94eSBpcyBubyBsb25nZXIgbmVlZGVkIC0gZ2FyYmFnZSBjb2xsZWN0IHJlZmVyZW5jZXNcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKiBUdXJuIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gb25lIGNhbGxlZCBhc3luY2hyb25vdXNseS4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcclxuZnVuY3Rpb24gYXN5bmMoZm4sIG9uRXJyb3IpIHtcclxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh0cnVlKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGZuKC4uLmFyZ3MpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpbXBsZW1lbnRzIGFueSBvZiB0aGUgbmFtZWQgbWV0aG9kcy5cclxuICovXHJcbmZ1bmN0aW9uIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgbWV0aG9kcykge1xyXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcclxuICAgICAgICBpZiAobWV0aG9kIGluIG9iaiAmJiB0eXBlb2Ygb2JqW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG5vb3AoKSB7XHJcbiAgICAvLyBkbyBub3RoaW5nXHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgZm9yIGEgcHVibGljIGZ1bmN0aW9uLlxyXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcclxuICogQHBhcmFtIG1pbkNvdW50IFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXHJcbiAqIEBwYXJhbSBtYXhDb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnQgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXHJcbiAqIEBwYXJhbSBhcmdDb3VudCBUaGUgYWN0dWFsIG51bWJlciBvZiBhcmd1bWVudHMgcHJvdmlkZWQuXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUFyZ0NvdW50ID0gZnVuY3Rpb24gKGZuTmFtZSwgbWluQ291bnQsIG1heENvdW50LCBhcmdDb3VudCkge1xyXG4gICAgbGV0IGFyZ0Vycm9yO1xyXG4gICAgaWYgKGFyZ0NvdW50IDwgbWluQ291bnQpIHtcclxuICAgICAgICBhcmdFcnJvciA9ICdhdCBsZWFzdCAnICsgbWluQ291bnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhcmdDb3VudCA+IG1heENvdW50KSB7XHJcbiAgICAgICAgYXJnRXJyb3IgPSBtYXhDb3VudCA9PT0gMCA/ICdub25lJyA6ICdubyBtb3JlIHRoYW4gJyArIG1heENvdW50O1xyXG4gICAgfVxyXG4gICAgaWYgKGFyZ0Vycm9yKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBmbk5hbWUgK1xyXG4gICAgICAgICAgICAnIGZhaWxlZDogV2FzIGNhbGxlZCB3aXRoICcgK1xyXG4gICAgICAgICAgICBhcmdDb3VudCArXHJcbiAgICAgICAgICAgIChhcmdDb3VudCA9PT0gMSA/ICcgYXJndW1lbnQuJyA6ICcgYXJndW1lbnRzLicpICtcclxuICAgICAgICAgICAgJyBFeHBlY3RzICcgK1xyXG4gICAgICAgICAgICBhcmdFcnJvciArXHJcbiAgICAgICAgICAgICcuJztcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHRvIHByZWZpeCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IGZhaWxlZCBhcmd1bWVudCB2YWxpZGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcclxuICogQHBhcmFtIGFyZ05hbWUgVGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50XHJcbiAqIEByZXR1cm4gVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIHRocm93biBmb3IgdmFsaWRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGVycm9yUHJlZml4KGZuTmFtZSwgYXJnTmFtZSkge1xyXG4gICAgcmV0dXJuIGAke2ZuTmFtZX0gZmFpbGVkOiAke2FyZ05hbWV9IGFyZ3VtZW50IGA7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBmbk5hbWVcclxuICogQHBhcmFtIGFyZ3VtZW50TnVtYmVyXHJcbiAqIEBwYXJhbSBuYW1lc3BhY2VcclxuICogQHBhcmFtIG9wdGlvbmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWVzcGFjZShmbk5hbWUsIG5hbWVzcGFjZSwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiAhbmFtZXNwYWNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy9UT0RPOiBJIHNob3VsZCBkbyBtb3JlIHZhbGlkYXRpb24gaGVyZS4gV2Ugb25seSBhbGxvdyBjZXJ0YWluIGNoYXJzIGluIG5hbWVzcGFjZXMuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ25hbWVzcGFjZScpICsgJ211c3QgYmUgYSB2YWxpZCBmaXJlYmFzZSBuYW1lc3BhY2UuJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVDYWxsYmFjayhmbk5hbWUsIGFyZ3VtZW50TmFtZSwgXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcbmNhbGxiYWNrLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmICFjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBmdW5jdGlvbi4nKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnRleHRPYmplY3QoZm5OYW1lLCBhcmd1bWVudE5hbWUsIGNvbnRleHQsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgIWNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnIHx8IGNvbnRleHQgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC4nKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBDb2RlIG9yaWdpbmFsbHkgY2FtZSBmcm9tIGdvb2cuY3J5cHQuc3RyaW5nVG9VdGY4Qnl0ZUFycmF5LCBidXQgZm9yIHNvbWUgcmVhc29uIHRoZXlcclxuLy8gYXV0b21hdGljYWxseSByZXBsYWNlZCAnXFxyXFxuJyB3aXRoICdcXG4nLCBhbmQgdGhleSBkaWRuJ3QgaGFuZGxlIHN1cnJvZ2F0ZSBwYWlycyxcclxuLy8gc28gaXQncyBiZWVuIG1vZGlmaWVkLlxyXG4vLyBOb3RlIHRoYXQgbm90IGFsbCBVbmljb2RlIGNoYXJhY3RlcnMgYXBwZWFyIGFzIHNpbmdsZSBjaGFyYWN0ZXJzIGluIEphdmFTY3JpcHQgc3RyaW5ncy5cclxuLy8gZnJvbUNoYXJDb2RlIHJldHVybnMgdGhlIFVURi0xNiBlbmNvZGluZyBvZiBhIGNoYXJhY3RlciAtIHNvIHNvbWUgVW5pY29kZSBjaGFyYWN0ZXJzXHJcbi8vIHVzZSAyIGNoYXJhY3RlcnMgaW4gSmF2YXNjcmlwdC4gIEFsbCA0LWJ5dGUgVVRGLTggY2hhcmFjdGVycyBiZWdpbiB3aXRoIGEgZmlyc3RcclxuLy8gY2hhcmFjdGVyIGluIHRoZSByYW5nZSAweEQ4MDAgLSAweERCRkYgKHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzby1jYWxsZWQgc3Vycm9nYXRlXHJcbi8vIHBhaXIpLlxyXG4vLyBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTE1LjEuM1xyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgLy8gSXMgdGhpcyB0aGUgbGVhZCBzdXJyb2dhdGUgaW4gYSBzdXJyb2dhdGUgcGFpcj9cclxuICAgICAgICBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcclxuICAgICAgICAgICAgY29uc3QgaGlnaCA9IGMgLSAweGQ4MDA7IC8vIHRoZSBoaWdoIDEwIGJpdHMuXHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgYXNzZXJ0KGkgPCBzdHIubGVuZ3RoLCAnU3Vycm9nYXRlIHBhaXIgbWlzc2luZyB0cmFpbCBzdXJyb2dhdGUuJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gMHhkYzAwOyAvLyB0aGUgbG93IDEwIGJpdHMuXHJcbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKGhpZ2ggPDwgMTApICsgbG93O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCA2NTUzNikge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICogQ2FsY3VsYXRlIGxlbmd0aCB3aXRob3V0IGFjdHVhbGx5IGNvbnZlcnRpbmc7IHVzZWZ1bCBmb3IgZG9pbmcgY2hlYXBlciB2YWxpZGF0aW9uLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICovXHJcbmNvbnN0IHN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGxldCBwID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIHArKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcclxuICAgICAgICAgICAgcCArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xyXG4gICAgICAgICAgICAvLyBMZWFkIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLiAgVGhlIHBhaXIgdG9nZXRoZXIgd2lsbCB0YWtlIDQgYnl0ZXMgdG8gcmVwcmVzZW50LlxyXG4gICAgICAgICAgICBwICs9IDQ7XHJcbiAgICAgICAgICAgIGkrKzsgLy8gc2tpcCB0cmFpbCBzdXJyb2dhdGUuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwICs9IDM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHA7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDb3BpZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjExNzUyM1xyXG4gKiBHZW5lcmF0ZXMgYSBuZXcgdXVpZC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgdXVpZHY0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgYyA9PiB7XHJcbiAgICAgICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDg7XHJcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xyXG4gICAgfSk7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBleHBvbmVudGlhbGx5IGluY3JlYXNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMgPSAxMDAwO1xyXG4vKipcclxuICogVGhlIGZhY3RvciB0byBiYWNrb2ZmIGJ5LlxyXG4gKiBTaG91bGQgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDEuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SID0gMjtcclxuLyoqXHJcbiAqIFRoZSBtYXhpbXVtIG1pbGxpc2Vjb25kcyB0byBpbmNyZWFzZSB0by5cclxuICpcclxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xyXG4gKi9cclxuY29uc3QgTUFYX1ZBTFVFX01JTExJUyA9IDQgKiA2MCAqIDYwICogMTAwMDsgLy8gRm91ciBob3VycywgbGlrZSBpT1MgYW5kIEFuZHJvaWQuXHJcbi8qKlxyXG4gKiBUaGUgcGVyY2VudGFnZSBvZiBiYWNrb2ZmIHRpbWUgdG8gcmFuZG9taXplIGJ5LlxyXG4gKiBTZWVcclxuICogaHR0cDovL2dvL3NhZmUtY2xpZW50LWJlaGF2aW9yI3N0ZXAtMS1kZXRlcm1pbmUtdGhlLWFwcHJvcHJpYXRlLXJldHJ5LWludGVydmFsLXRvLWhhbmRsZS1zcGlrZS10cmFmZmljXHJcbiAqIGZvciBjb250ZXh0LlxyXG4gKlxyXG4gKiA8cD5WaXNpYmxlIGZvciB0ZXN0aW5nXHJcbiAqL1xyXG5jb25zdCBSQU5ET01fRkFDVE9SID0gMC41O1xyXG4vKipcclxuICogQmFzZWQgb24gdGhlIGJhY2tvZmYgbWV0aG9kIGZyb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL21hdGgvZXhwb25lbnRpYWxiYWNrb2ZmLmpzLlxyXG4gKiBFeHRyYWN0ZWQgaGVyZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHBhc3MgbWV0YWRhdGEgYW5kIGEgc3RhdGVmdWwgRXhwb25lbnRpYWxCYWNrb2ZmIG9iamVjdCBhcm91bmQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzKGJhY2tvZmZDb3VudCwgaW50ZXJ2YWxNaWxsaXMgPSBERUZBVUxUX0lOVEVSVkFMX01JTExJUywgYmFja29mZkZhY3RvciA9IERFRkFVTFRfQkFDS09GRl9GQUNUT1IpIHtcclxuICAgIC8vIENhbGN1bGF0ZXMgYW4gZXhwb25lbnRpYWxseSBpbmNyZWFzaW5nIHZhbHVlLlxyXG4gICAgLy8gRGV2aWF0aW9uOiBjYWxjdWxhdGVzIHZhbHVlIGZyb20gY291bnQgYW5kIGEgY29uc3RhbnQgaW50ZXJ2YWwsIHNvIHdlIG9ubHkgbmVlZCB0byBzYXZlIHZhbHVlXHJcbiAgICAvLyBhbmQgY291bnQgdG8gcmVzdG9yZSBzdGF0ZS5cclxuICAgIGNvbnN0IGN1cnJCYXNlVmFsdWUgPSBpbnRlcnZhbE1pbGxpcyAqIE1hdGgucG93KGJhY2tvZmZGYWN0b3IsIGJhY2tvZmZDb3VudCk7XHJcbiAgICAvLyBBIHJhbmRvbSBcImZ1enpcIiB0byBhdm9pZCB3YXZlcyBvZiByZXRyaWVzLlxyXG4gICAgLy8gRGV2aWF0aW9uOiByYW5kb21GYWN0b3IgaXMgcmVxdWlyZWQuXHJcbiAgICBjb25zdCByYW5kb21XYWl0ID0gTWF0aC5yb3VuZChcclxuICAgIC8vIEEgZnJhY3Rpb24gb2YgdGhlIGJhY2tvZmYgdmFsdWUgdG8gYWRkL3N1YnRyYWN0LlxyXG4gICAgLy8gRGV2aWF0aW9uOiBjaGFuZ2VzIG11bHRpcGxpY2F0aW9uIG9yZGVyIHRvIGltcHJvdmUgcmVhZGFiaWxpdHkuXHJcbiAgICBSQU5ET01fRkFDVE9SICpcclxuICAgICAgICBjdXJyQmFzZVZhbHVlICpcclxuICAgICAgICAvLyBBIHJhbmRvbSBmbG9hdCAocm91bmRlZCB0byBpbnQgYnkgTWF0aC5yb3VuZCBhYm92ZSkgaW4gdGhlIHJhbmdlIFstMSwgMV0uIERldGVybWluZXNcclxuICAgICAgICAvLyBpZiB3ZSBhZGQgb3Igc3VidHJhY3QuXHJcbiAgICAgICAgKE1hdGgucmFuZG9tKCkgLSAwLjUpICpcclxuICAgICAgICAyKTtcclxuICAgIC8vIExpbWl0cyBiYWNrb2ZmIHRvIG1heCB0byBhdm9pZCBlZmZlY3RpdmVseSBwZXJtYW5lbnQgYmFja29mZi5cclxuICAgIHJldHVybiBNYXRoLm1pbihNQVhfVkFMVUVfTUlMTElTLCBjdXJyQmFzZVZhbHVlICsgcmFuZG9tV2FpdCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGUgRW5nbGlzaCBvcmRpbmFsIGxldHRlcnMgYWZ0ZXIgYSBudW1iZXJcclxuICovXHJcbmZ1bmN0aW9uIG9yZGluYWwoaSkge1xyXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaSkpIHtcclxuICAgICAgICByZXR1cm4gYCR7aX1gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGkgKyBpbmRpY2F0b3IoaSk7XHJcbn1cclxuZnVuY3Rpb24gaW5kaWNhdG9yKGkpIHtcclxuICAgIGkgPSBNYXRoLmFicyhpKTtcclxuICAgIGNvbnN0IGNlbnQgPSBpICUgMTAwO1xyXG4gICAgaWYgKGNlbnQgPj0gMTAgJiYgY2VudCA8PSAyMCkge1xyXG4gICAgICAgIHJldHVybiAndGgnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVjID0gaSAlIDEwO1xyXG4gICAgaWYgKGRlYyA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiAnc3QnO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlYyA9PT0gMikge1xyXG4gICAgICAgIHJldHVybiAnbmQnO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlYyA9PT0gMykge1xyXG4gICAgICAgIHJldHVybiAncmQnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICd0aCc7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TW9kdWxhckluc3RhbmNlKHNlcnZpY2UpIHtcclxuICAgIGlmIChzZXJ2aWNlICYmIHNlcnZpY2UuX2RlbGVnYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2UuX2RlbGVnYXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2U7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gT3ZlcnJpZGluZyB0aGUgY29uc3RhbnQgKHdlIHNob3VsZCBiZSB0aGUgb25seSBvbmVzIGRvaW5nIHRoaXMpXHJcbkNPTlNUQU5UUy5OT0RFX0NMSUVOVCA9IHRydWU7XG5cbmV4cG9ydCB7IENPTlNUQU5UUywgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IsIERlZmVycmVkLCBFcnJvckZhY3RvcnksIEZpcmViYXNlRXJyb3IsIE1BWF9WQUxVRV9NSUxMSVMsIFJBTkRPTV9GQUNUT1IsIFNoYTEsIGFyZUNvb2tpZXNFbmFibGVkLCBhc3NlcnQsIGFzc2VydGlvbkVycm9yLCBhc3luYywgYmFzZTY0LCBiYXNlNjREZWNvZGUsIGJhc2U2NEVuY29kZSwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMsIGNvbnRhaW5zLCBjcmVhdGVNb2NrVXNlclRva2VuLCBjcmVhdGVTdWJzY3JpYmUsIGRlY29kZSwgZGVlcENvcHksIGRlZXBFcXVhbCwgZGVlcEV4dGVuZCwgZXJyb3JQcmVmaXgsIGV4dHJhY3RRdWVyeXN0cmluZywgZ2V0RGVmYXVsdEFwcENvbmZpZywgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCwgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0LCBnZXREZWZhdWx0cywgZ2V0RXhwZXJpbWVudGFsU2V0dGluZywgZ2V0R2xvYmFsLCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldFVBLCBpc0FkbWluLCBpc0Jyb3dzZXIsIGlzQnJvd3NlckV4dGVuc2lvbiwgaXNFbGVjdHJvbiwgaXNFbXB0eSwgaXNJRSwgaXNJbmRleGVkREJBdmFpbGFibGUsIGlzTW9iaWxlQ29yZG92YSwgaXNOb2RlLCBpc05vZGVTZGssIGlzUmVhY3ROYXRpdmUsIGlzU2FmYXJpLCBpc1VXUCwgaXNWYWxpZEZvcm1hdCwgaXNWYWxpZFRpbWVzdGFtcCwgaXNzdWVkQXRUaW1lLCBqc29uRXZhbCwgbWFwLCBvcmRpbmFsLCBwcm9taXNlV2l0aFRpbWVvdXQsIHF1ZXJ5c3RyaW5nLCBxdWVyeXN0cmluZ0RlY29kZSwgc2FmZUdldCwgc3RyaW5nTGVuZ3RoLCBzdHJpbmdUb0J5dGVBcnJheSwgc3RyaW5naWZ5LCB1dWlkdjQsIHZhbGlkYXRlQXJnQ291bnQsIHZhbGlkYXRlQ2FsbGJhY2ssIHZhbGlkYXRlQ29udGV4dE9iamVjdCwgdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSwgdmFsaWRhdGVOYW1lc3BhY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\n");

/***/ })

};
;